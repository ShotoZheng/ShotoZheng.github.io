<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0"><link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.4.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.4.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="1. 通道的概念通道（Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。"><meta name="keywords" content="Java"><meta property="og:type" content="article"><meta property="og:title" content="（二）NIO - Channel"><meta property="og:url" content="https://ShotoZheng.github.io/2020/01/05/（二）NIO-Channel/index.html"><meta property="og:site_name" content="鱼肚白不是鱼"><meta property="og:description" content="1. 通道的概念通道（Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://shotozheng.github.io/2020/01/05/（二）NIO-Channel/2019033120483691.png"><meta property="og:image" content="https://shotozheng.github.io/2020/01/05/（二）NIO-Channel/2019033120524676.png"><meta property="og:image" content="https://shotozheng.github.io/2020/01/05/（二）NIO-Channel/2019033120534588.png"><meta property="og:updated_time" content="2020-01-05T01:17:01.982Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="（二）NIO - Channel"><meta name="twitter:description" content="1. 通道的概念通道（Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。"><meta name="twitter:image" content="https://shotozheng.github.io/2020/01/05/（二）NIO-Channel/2019033120483691.png"><link rel="canonical" href="https://ShotoZheng.github.io/2020/01/05/（二）NIO-Channel/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-postbottom{cursor:pointer;height:26px;margin-top:10px;position:relative}#needsharebutton-postbottom .btn{border:1px solid $btn-default-border-color;border-radius:3px;display:initial;padding:1px 4px}</style><title>（二）NIO - Channel | 鱼肚白不是鱼</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">鱼肚白不是鱼</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">笨鸟先飞</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-随笔"><a href="/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>随笔</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://ShotoZheng.github.io/2020/01/05/（二）NIO-Channel/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="郑松涛"><meta itemprop="description" content="积跬步，至千里"><meta itemprop="image" content="/images/kanieki.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鱼肚白不是鱼"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">（二）NIO - Channel</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-05 09:14:42 / 修改时间：09:17:01" itemprop="dateCreated datePublished" datetime="2020-01-05T09:14:42+08:00">2020-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/NIO/" itemprop="url" rel="index"><span itemprop="name">NIO</span></a></span> </span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2020/01/05/（二）NIO-Channel/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/01/05/（二）NIO-Channel/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.1k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="1-通道的概念"><a href="#1-通道的概念" class="headerlink" title="1. 通道的概念"></a>1. 通道的概念</h3><p>通道（Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。</p><a id="more"></a><h3 id="2-主要实现类"><a href="#2-主要实现类" class="headerlink" title="2. 主要实现类"></a>2. 主要实现类</h3><p>Java 为 Channel 接口提供的最主要实现类如下：</p><ul><li><strong>FileChannel</strong>：用于读取、写入、映射和操作文件的通道。</li><li><strong>DatagramChannel</strong>：通过 UDP 读写网络中的数据通道。</li><li><strong>SocketChannel</strong>：通过 TCP 读写网络中的数据。</li><li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3 id="3-获取通道"><a href="#3-获取通道" class="headerlink" title="3. 获取通道"></a>3. 获取通道</h3><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><p>FileInputStream、FileOutputStream、RandomAccessFile、DatagramSocket、Socket 和 ServerSocket。</p><p>获取通道的其他方式是使用 Files 类的静态方法 <strong>newByteChannel()</strong> 获取字节通道。或者通过通道的静态方法 <strong>open()</strong> 打开并返回指定通道。</p><h3 id="4-FileChannel-通道的数据传输"><a href="#4-FileChannel-通道的数据传输" class="headerlink" title="4. FileChannel 通道的数据传输"></a>4. FileChannel 通道的数据传输</h3><p>下图所示的是FileChannel类的一些常用方法：<br><img src="/2020/01/05/（二）NIO-Channel/2019033120483691.png" alt="在这里插入图片描述"></p><h4 id="4-1-文件复制"><a href="#4-1-文件复制" class="headerlink" title="4.1 文件复制"></a>4.1 文件复制</h4><p>示例一：下面演示一下使用通道和<strong>非直接缓冲区</strong>实现文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 获取通道</span></span><br><span class="line">            inChannel = fis.getChannel();</span><br><span class="line">            outChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 分配指定大小的缓冲区</span></span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 读取通道中的数据并写入缓冲区中，position后移</span></span><br><span class="line">            <span class="keyword">while</span> (inChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将缓冲区切换读取数据的模式，position为0，limit改变</span></span><br><span class="line">                buf.flip();</span><br><span class="line">                <span class="comment">// 4. 读取缓冲区中的数据并写入通道中</span></span><br><span class="line">                outChannel.write(buf);</span><br><span class="line">                buf.clear();<span class="comment">// 清空缓冲区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                outChannel.close();</span><br><span class="line">            <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>)</span><br><span class="line">                inChannel.close();</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>)</span><br><span class="line">                fos.close();</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例二：下面演示一下使用通道和<strong>直接缓冲区</strong>实现文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopyDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立文件读取通道。StandardOpenOption.READ指明了以读取的方式打开文件</span></span><br><span class="line">            inChannel = FileChannel.open(Paths.get(<span class="string">"1.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="comment">//建立文件输出通道。StandardOpenOption.CREATE表明如果文件不存在则创建</span></span><br><span class="line">            outChannel = FileChannel.open(Paths.get(<span class="string">"3.txt"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ,</span><br><span class="line">                    StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//使用内存映射文件</span></span><br><span class="line">            <span class="comment">//第一个参数执行映射时的模式，分别有只读和读写等模式</span></span><br><span class="line">            <span class="comment">//第二个和第三个参数用于控制将Channel指定范围的数据映射成ByteBuffer</span></span><br><span class="line">            MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">            MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line">            <span class="comment">//直接对缓冲区进行数据的读写操作</span></span><br><span class="line">            <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</span><br><span class="line">            <span class="comment">//将缓冲区的数据存储进数组中</span></span><br><span class="line">            inMappedBuf.get(dst);</span><br><span class="line">            <span class="comment">//将数组中的数据存储进缓冲区中</span></span><br><span class="line">            outMappedBuf.put(dst);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>)</span><br><span class="line">                inChannel.close();</span><br><span class="line">            <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                outChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例三：下面演示一下使用通道之间的数据传输来实现文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopyDirect2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立文件读取通道。StandardOpenOption.READ指明了以读取的方式打开文件</span></span><br><span class="line">            inChannel = FileChannel.open(Paths.get(<span class="string">"1.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="comment">// 建立文件输出通道。StandardOpenOption.CREATE表明如果文件不存在则创建</span></span><br><span class="line">            outChannel = FileChannel.open(Paths.get(<span class="string">"5.txt"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ,</span><br><span class="line">                    StandardOpenOption.CREATE);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//将inChannel通道指定范围大小的数据传输到outChannel中</span></span><br><span class="line"><span class="comment">//				inChannel.transferTo(0, inChannel.size(), outChannel);</span></span><br><span class="line">            <span class="comment">//从通道inChannel中以指定范围大小的数据传输到outChannel</span></span><br><span class="line">            outChannel.transferFrom(inChannel, <span class="number">0</span>, inChannel.size());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inChannel.close();</span><br><span class="line">            outChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-分散-Scatter-和聚集-Gather"><a href="#4-2-分散-Scatter-和聚集-Gather" class="headerlink" title="4.2 分散(Scatter)和聚集(Gather)"></a>4.2 分散(Scatter)和聚集(Gather)</h4><p>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中。需要按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。而聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。如下图示：<br><img src="/2020/01/05/（二）NIO-Channel/2019033120524676.png" alt="在这里插入图片描述"> <img src="/2020/01/05/（二）NIO-Channel/2019033120534588.png" alt="在这里插入图片描述"></p><p>下面演示<strong>分散读取和聚集写入</strong>的示例，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ScatteringRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        RandomAccessFile raf2 = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">            <span class="comment">//获取通道</span></span><br><span class="line">            channel = raf.getChannel();</span><br><span class="line">            <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">            ByteBuffer buf1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            ByteBuffer buf2 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//分散读取</span></span><br><span class="line">            ByteBuffer[] bufs = &#123;buf1, buf2&#125;;</span><br><span class="line">            channel.read(bufs);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;</span><br><span class="line">                <span class="comment">//因为channel.read(bufs);执行时会将数据写入缓冲区中，即position已经改变，需flip</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">0</span>].array(), <span class="number">0</span>, bufs[<span class="number">0</span>].limit()));</span><br><span class="line">            System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">1</span>].array(), <span class="number">0</span>, bufs[<span class="number">1</span>].limit()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//聚集写入</span></span><br><span class="line">            raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">"2.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">            channel2 = raf2.getChannel();</span><br><span class="line">            channel2.write(bufs);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>)</span><br><span class="line">                channel.close();</span><br><span class="line">            <span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">                raf.close();</span><br><span class="line">            <span class="keyword">if</span> (channel2 != <span class="keyword">null</span>)</span><br><span class="line">                channel2.close();</span><br><span class="line">            <span class="keyword">if</span> (raf2 != <span class="keyword">null</span>)</span><br><span class="line">                raf2.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asfasfasfa</span><br><span class="line">----------------</span><br><span class="line">sf‘sa</span><br><span class="line">阿是大师大师的</span><br><span class="line">啊实打实的看见爱好</span><br></pre></td></tr></table></figure><p>文件 2.txt保存有文件1.txt中的如下数据，同时也是从多个缓冲区中读到的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asfasfasfa</span><br><span class="line">sf‘sa</span><br><span class="line">阿是大师大师的</span><br><span class="line">啊实打实的看见爱好</span><br></pre></td></tr></table></figure><h3 id="5-字符集-Charset"><a href="#5-字符集-Charset" class="headerlink" title="5. 字符集 Charset"></a>5. 字符集 Charset</h3><p>Charset类提供了一个availableCharsets静态方法来获取当前JDK所支持的所有字符集。下面代码用于获取输出该JDK所支持的所有字符集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCharsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SortedMap&lt;String,Charset&gt; map = Charset.availableCharsets();</span><br><span class="line">    </span><br><span class="line">    Set&lt;Entry&lt;String,Charset&gt;&gt; set = map.entrySet();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Charset&gt; entry : set) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Big5=Big5</span><br><span class="line">Big5-HKSCS=Big5-HKSCS</span><br><span class="line">CESU-<span class="number">8</span>=CESU-<span class="number">8</span></span><br><span class="line">EUC-JP=EUC-JP</span><br><span class="line">EUC-KR=EUC-KR</span><br><span class="line">GB18030=GB18030</span><br><span class="line">GB2312=GB2312</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面演示一下对缓冲区的数据进行指定编码和解码的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncoding</span><span class="params">()</span> <span class="keyword">throws</span> CharacterCodingException </span>&#123;</span><br><span class="line">    Charset cs = Charset.forName(<span class="string">"GBK"</span>);</span><br><span class="line">    <span class="comment">//获取编码器</span></span><br><span class="line">    CharsetEncoder encoder = cs.newEncoder();</span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    CharsetDecoder decoder = cs.newDecoder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向字符缓冲区添加数据</span></span><br><span class="line">    CharBuffer cBuf = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    cBuf.put(<span class="string">"你好"</span>);</span><br><span class="line">    cBuf.flip();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对缓冲区的数据进行编码,encode会改变cBuf的position位置</span></span><br><span class="line">    ByteBuffer bBuf = encoder.encode(cBuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出-60-29-70-61</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bBuf.limit(); i++) &#123;</span><br><span class="line">        System.out.print(bBuf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对缓冲区的数据进行解码</span></span><br><span class="line">    bBuf.flip();</span><br><span class="line">    <span class="comment">//decode会改变缓冲区中position的位置</span></span><br><span class="line">    CharBuffer cBuf2 = decoder.decode(bBuf);</span><br><span class="line">    System.out.println(cBuf2.toString());<span class="comment">//你好</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用其他解码器进行解码，会导致乱码</span></span><br><span class="line">    bBuf.flip();</span><br><span class="line">    Charset csUTF8 = Charset.forName(<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">    CharsetDecoder decoderUTF8 = csUTF8.newDecoder();</span><br><span class="line">    CharBuffer cBufUTF8 = decoderUTF8.decode(bBuf);</span><br><span class="line">    System.out.println(cBufUTF8.toString());<span class="comment">//ÄãºÃ</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：要时刻注意缓冲区中position的位置！无论是get方法、put方法还是encode方法和decode方法都会改变缓冲区中的position位置。</p><p>对于 DatagramChannel、SocketChannel 和 ServerSocketChannel 这三个通道类将放于下一篇博客讲。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:24px">------ 本文结束------</div></div></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2020/01/05/（一）NIO-Buffer/" rel="next" title="（一）NIO - Buffer"><i class="fa fa-chevron-left"></i> （一）NIO - Buffer</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2020/01/05/（三）NIO-非阻塞式网络通信/" rel="prev" title="（三）NIO - 非阻塞式网络通信">（三）NIO - 非阻塞式网络通信 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-通道的概念"><span class="nav-text">1. 通道的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-主要实现类"><span class="nav-text">2. 主要实现类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-获取通道"><span class="nav-text">3. 获取通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-FileChannel-通道的数据传输"><span class="nav-text">4. FileChannel 通道的数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-文件复制"><span class="nav-text">4.1 文件复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-分散-Scatter-和聚集-Gather"><span class="nav-text">4.2 分散(Scatter)和聚集(Gather)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-字符集-Charset"><span class="nav-text">5. 字符集 Charset</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/kanieki.png" alt="郑松涛"><p class="site-author-name" itemprop="name">郑松涛</p><div class="site-description" itemprop="description">积跬步，至千里</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">284</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ShotoZheng" title="GitHub &rarr; https://github.com/ShotoZheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:shotozheng@163.com" title="E-Mail &rarr; mailto:shotozheng@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">郑松涛</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.6m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">24:18</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div><div class="busuanzi-count"><script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/pjax/pjax.min.js?v=0.2.8"></script><script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.js"></script><script src="//lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script><script src="/js/schemes/pisces.js?v=7.4.0"></script><script src="/js/next-boot.js?v=7.4.0"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js?v=7.4.0"></script><script pjax>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><div id="pjax"><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Wechat,QQZone,Weibo,Douban,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'd6TU9yIpopEhNQKUras2D3Nr-gzGzoHsz',
    appKey: 'CJpUierMSXBHmTo6mJ8G1KO1',
    placeholder: 'Just go go',
    avatar: 'monsterid',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);</script></div></body></html><script type="text/javascript" src="/js/clicklove.js"></script><script src="/live2d-widget/autoload.js"></script>