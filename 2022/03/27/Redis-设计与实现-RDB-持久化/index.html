<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0"><link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.4.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.4.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="本文首先介绍Redis服务器保存和载人RDB文件的方法,重点说明 SAVE 命令和 BGSAVE 命令的实现方式。之后,本章会继续介绍Redis服务器自动保存功能的实现原理。 在介绍完关于保存和载入RDB文件方面的内容之后,我们会详细分析RDB文件中的各个组成部分,并说明这些部分的结构和含义。"><meta name="keywords" content="缓存"><meta property="og:type" content="article"><meta property="og:title" content="Redis 设计与实现-RDB 持久化"><meta property="og:url" content="https://ShotoZheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/index.html"><meta property="og:site_name" content="鱼肚白不是鱼"><meta property="og:description" content="本文首先介绍Redis服务器保存和载人RDB文件的方法,重点说明 SAVE 命令和 BGSAVE 命令的实现方式。之后,本章会继续介绍Redis服务器自动保存功能的实现原理。 在介绍完关于保存和载入RDB文件方面的内容之后,我们会详细分析RDB文件中的各个组成部分,并说明这些部分的结构和含义。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416170306995.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416171801168.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416171942980.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416172023899.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416172234637.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416172432276.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203146378.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203218284.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203531076.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203639861.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204045796.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204242643.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204414997.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416210641240.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416210746060.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416210805453.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204744316.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204833435.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205057819.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205155469.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205354228.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205434452.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205518627.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205636669.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205749843.png"><meta property="og:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205818915.png"><meta property="og:updated_time" content="2022-04-16T13:10:28.095Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Redis 设计与实现-RDB 持久化"><meta name="twitter:description" content="本文首先介绍Redis服务器保存和载人RDB文件的方法,重点说明 SAVE 命令和 BGSAVE 命令的实现方式。之后,本章会继续介绍Redis服务器自动保存功能的实现原理。 在介绍完关于保存和载入RDB文件方面的内容之后,我们会详细分析RDB文件中的各个组成部分,并说明这些部分的结构和含义。"><meta name="twitter:image" content="https://shotozheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416170306995.png"><link rel="canonical" href="https://ShotoZheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-postbottom{cursor:pointer;height:26px;margin-top:10px;position:relative}#needsharebutton-postbottom .btn{border:1px solid $btn-default-border-color;border-radius:3px;display:initial;padding:1px 4px}</style><title>Redis 设计与实现-RDB 持久化 | 鱼肚白不是鱼</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">鱼肚白不是鱼</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">笨鸟先飞</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-随笔"><a href="/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>随笔</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://ShotoZheng.github.io/2022/03/27/Redis-设计与实现-RDB-持久化/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="郑松涛"><meta itemprop="description" content="积跬步，至千里"><meta itemprop="image" content="/images/kanieki.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鱼肚白不是鱼"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis 设计与实现-RDB 持久化</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-03-27 16:50:47" itemprop="dateCreated datePublished" datetime="2022-03-27T16:50:47+08:00">2022-03-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-04-16 21:10:28" itemprop="dateModified" datetime="2022-04-16T21:10:28+08:00">2022-04-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/缓存/" itemprop="url" rel="index"><span itemprop="name">缓存</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/缓存/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a></span> </span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/03/27/Redis-设计与实现-RDB-持久化/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/03/27/Redis-设计与实现-RDB-持久化/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>7.2k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>7 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>本文首先介绍Redis服务器保存和载人RDB文件的方法,重点说明 SAVE 命令和 BGSAVE 命令的实现方式。之后,本章会继续介绍Redis服务器自动保存功能的实现原理。</p><p>在介绍完关于保存和载入RDB文件方面的内容之后,我们会详细分析RDB文件中的各个组成部分,并说明这些部分的结构和含义。<a id="more"></a></p><h2 id="1-RDB-文件的创建与载入"><a href="#1-RDB-文件的创建与载入" class="headerlink" title="1. RDB 文件的创建与载入"></a>1. RDB 文件的创建与载入</h2><p>有两个Redis命令可以用于生成RDB文件,一个是SAVE ,另一个是 BGSAVE 。SAVE 命令会阻塞Redis服务器进程,直到RDB文件创建完毕为止,在服务器进程阻塞期间,服务器不能处理任何命令请求。和BGSAVE 命令直接阻塞服务器进程的做法不同,BGSAVE 命令会派生出一个子进程,然后由子进程负责创建RDB文件,服务器进程(父进程)继续处理命令请求。</p><p>和使用SAVE 命令或者BGSAVE 命令创建RDB文件不同,RDB文件的载人工作是在服务器启动时自动执行的,所以Redis并没有专门用于载人RDB文件的命令,只要Redis服务器在启动时检测到RDB文件存在,它就会自动载人RDB文件。</p><p>另外值得一提的是,因为AOF文件的更新频率通常比RDB文件的更新频率高,所以:</p><ul><li><p>如果服务器开启了AOF持久化功能,那么服务器会优先使用AOF文件来还原数据库状态。</p></li><li><p>只有在AOF持久化功能处于关闭状态时,服务器才会使用RDB文件来还原数据库状态。</p></li></ul><p>服务器判断该用哪个文件来还原数据库状态的流程如图10-4所示</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416170306995.png" alt></p><h3 id="1-1-SAVE-命令执行时的服务器状态"><a href="#1-1-SAVE-命令执行时的服务器状态" class="headerlink" title="1.1 SAVE 命令执行时的服务器状态"></a>1.1 SAVE 命令执行时的服务器状态</h3><p>前面提到过,当SAVE 命令执行时,Redis服务器会被阻塞,所以当SAVE 命令正在执行时、客户端发送的所有命令请求都会被拒绝。</p><p>只有在服务器执行完SAVE 命令、重新开始接受命令请求之后,客户端发送的命令才会被处理。</p><h3 id="1-2-BGSAVE-命令执行时的服务器状态"><a href="#1-2-BGSAVE-命令执行时的服务器状态" class="headerlink" title="1.2 BGSAVE  命令执行时的服务器状态"></a>1.2 BGSAVE 命令执行时的服务器状态</h3><p>因为 BGSAVE 命令的保存工作是由子进程执行的,所以在子进程创建RDB文件的过程中,Redis服务器仍然可以继续处理客户端的命令请求,但是,在BGSAVE 命令执行期间,服务器处理SAVE、BGSAVE、BGREWRITEAOF 三个命令的方式会和平时有所不同。首先,在BGSAVE 命令执行期间,客户端发送的SAVE命令会被服务器拒绝,服务器禁止SAVE命令和BGSAVE 命令同时执行是为了避免父进程(服务器进程)和子进程同时执行两个 rdbSave 同步命令调用,防止产生竞争条件。其次,在BGSAVE命令执行期间,客户端发送的BGSAVE命令会被服务器拒绝,因为同时执行两个BGSAVE命令也会产生竞争条件。</p><p>最后,BGREWRITEAOF 和BGSAVE两个命令不能同时执行:</p><ul><li>如果BGSAVE命令正在执行,那么客户端发送的BGREWRITEAOF 命令会被延迟到 BGSAVE 命令执行完毕之后执行。</li><li>如果BGREWRITEAOF 和令正在执行,那么客户端发送的BGSAVE 命令会被服务器拒绝。</li></ul><p>因为BGREWRITEAOF 和BGSAVE 两个命令的实际工作都由子进程执行,所以这两个命令在操作方面并没有什么冲突的地方,不能同时执行它们只是一个性能方面的考虑一一并发出两个子进程,并且这两个子进程都同时执行大量的磁盘写人操作,这怎么想都不会是一个好主意。</p><h3 id="1-3-RDB文件载入时的服务器状态"><a href="#1-3-RDB文件载入时的服务器状态" class="headerlink" title="1.3 RDB文件载入时的服务器状态"></a>1.3 RDB文件载入时的服务器状态</h3><p>服务器在载人RDB文件期间,会一直处于阻塞状态,直到载人工作完成为止。</p><h2 id="2-自动间隔性保存"><a href="#2-自动间隔性保存" class="headerlink" title="2. 自动间隔性保存"></a>2. 自动间隔性保存</h2><p>BGSAVE命令可以在不阻塞服务器进程的情况下执行,所以Redis允许用户通过设置服务器配置的save选项,让服务器每隔一段时间自动执行一次BGSAVE命令。</p><p>用户可以通过save选项设置多个保存条件,但只要其中任意一个条件被满足,服务器就会执行BGSAVE命令。</p><p>举个例子,如果我们向服务器提供以下配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>那么只要满足以下三个条件中的任意一个,BGSAVE命令就会被执行:</p><ul><li>服务器在900秒之内,对数据库进行了至少1次修改。</li><li>服务器在300秒之内,对数据库进行了至少10次修改。</li><li>服务器在60秒之内,对数据库进行了至少10000次修改。</li></ul><h3 id="2-1-设置保存条件"><a href="#2-1-设置保存条件" class="headerlink" title="2.1 设置保存条件"></a>2.1 设置保存条件</h3><p>服务器程序会根据save选项所设置的保存条件,设置服务器状态redisServer结构的saveparams属性:</p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416171801168.png" style="margin:0"><p>saveparams 属性是一个数组,数组中的每一个元素都是一个saveparam结构，每个saveparam结构都保存了一个save选项设置的保存条件:</p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416171942980.png" style="margin:0"><p>那么服务器状态中的saveparams数组将会是图10-6所示的样子。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416172023899.png" alt></p><h3 id="2-2-dirty-计数器和-lastsave-属性"><a href="#2-2-dirty-计数器和-lastsave-属性" class="headerlink" title="2.2 dirty 计数器和 lastsave 属性"></a>2.2 dirty 计数器和 lastsave 属性</h3><p>除了 saveparams 数组之外,服务器状态还维持着一个dirty计数器,以及一个 lastsave 属性：</p><ul><li>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE 命令之后,服务器对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写入、删除、更<br>新等操作)。</li><li>lastsave属性是一个UNIX时间戳,记录了服务器上一次成功执行SAVE命令或者BGSAVE 命令的时间。</li></ul><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416172234637.png" style="margin:0"><h3 id="2-3-检查保存条件是否满足"><a href="#2-3-检查保存条件是否满足" class="headerlink" title="2.3 检查保存条件是否满足"></a>2.3 检查保存条件是否满足</h3><p>Redis的服务器周期性操作函数 serverCron 默认每隔100毫秒就会执行一次,该函数用于对正在运行的服务器进行维护,它的其中一项工作就是检查save选项所设置的保存条件是否已经满足,如果满足的话,就执行 BGSAVE 命令。</p><h2 id="3-RDB-文件结构"><a href="#3-RDB-文件结构" class="headerlink" title="3. RDB 文件结构"></a>3. RDB 文件结构</h2><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416172432276.png" alt></p><p>RDB文件的最开头是RRDIS部分,这个部分的长度为5字节,保存着“REDIS“五个字符。通过这五个字符,程序可以在载入文件时,快速检查所载人的文件是否RDB文件。</p><p>adb_version长度为4字节,它的值是一个字符串表示的整数,这个整数记录了RDB 文件的版本号,比如“0006“就代表RDB文件的版本为第六版。</p><p>databases部分包含着零个或任意多个数据库,以及各个数据库中的键值对数据:</p><ul><li><p>如果服务器的数据库状态为空(所有数据库都是空的),那么这个部分也为空,长度为0字节。</p></li><li><p>如果服务器的数据库状态为非空(有至少一个数据库非空),那么这个部分也为非空,根据数据库所保存键值对的数量、类型和内容不同,这个部分的长度也会有所不同。</p></li></ul><p>EOF常量的长度为1字节,这个常量标志着RDB文件正文内容的结束,当读入程序遇到这个值的时候,它知道所有数据库的所有键值对都已经载人完毕了。</p><p>check_sum是一个8字节长的无符号整数,保存着一个校验和,这个校验和是程序通过对REDIS、db_version、adatabases、EOF四个部分的内容进行计算得出的。服务器在载入RDB文件时,会将载入数据所计算出的校验和与check_sum所记录的校验和进行对比,以此来检查RDB文件是否有出错或者损坏的情况出现。</p><h3 id="3-1-database-部分"><a href="#3-1-database-部分" class="headerlink" title="3.1 database 部分"></a>3.1 database 部分</h3><p>一个RDB文件的databases部分可以保存任意多个非空数据库。</p><p>例如,如果服务器的0号数据库和3号数据库非空,那么服务器将创建一个如图10-12所示的RDB文件, 图中的daatabase 0代表0号数据库中的所有键值对数据,而database 3则代表3号数据库中的所有键值对数据。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203146378.png" alt></p><p>每个非空数据库在RDB文件中都可以保存为SELECTDB、db_number、keyValue_Pairs三个部分,如图10-13所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203218284.png" alt></p><p>SELECTDB 常量的长度为1字节,当读人程序遇到这个值的时候,它知道接下来要读人的将是一个数据库导码。</p><p>db_numbeI 保存着一个数据库号码,根据号码的大小不同，这个部分的长度可以是 1 字节、2字节或者5字节。当程序读人db_number部分之后,服务器会调用SELECT命令,根据读入的数据库号码进行数据库切换,使得之后读入的键值对可以载人到正确的数据库中。</p><p>key_value_pairs 部分保存了数据库中的所有键值对数据,如果键值对带有过期时间,那么过期时间也会和键值对保存在一起。根据键值对的数量、类型、内容以及是否有过期时间等条件的不同,key_value_pairs部分的长度也会有所不同。另外,图10-15则展示了一个完整的RDB文件,文件中包含了0号数据库和3号数据库。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203531076.png" alt></p><h3 id="3-2-key-value-pairs-部分"><a href="#3-2-key-value-pairs-部分" class="headerlink" title="3.2 key_value_pairs 部分"></a>3.2 key_value_pairs 部分</h3><p>RDB文件中的每个key_value_pairs部分都保存了一个或以上数量的键值对,如果键值对带有过期时间的话,那么键值对的过期时间也会被保存在内。不带过期时间的键值对在RDB文件中由TYPE、key、value三部分组成,如图10-16所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416203639861.png" alt></p><p>TYPE记录了value的类型,长度为1字节,值可以是以下常量的其中一个:</p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204045796.png" style="margin:0"><p>以上列出的每个TYPE常量都代表了一种对象类型或者底层编码,当服务器读入RDB文件中的键值对数据时,程序会根据TYPE的值来决定如何读人和解释value的数据。key和value分别保存了键值对的键对象和值对象:</p><ul><li>其中key总是一个字符串对象,它的编码方式和REDIS_RDB_TYPE_STRING类型的value一样。根据内容长度的不同,key的长度也会有所不同。</li><li>根据TYPE类型的不同,以及保存内容长度的不同,保存value的结构和长度也会有所不同,稍后会详细说明每种TYPE类型的value结构保存方式。</li></ul><p>带有过期时间的键值对在RDB文件中的结构如图10-17所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204242643.png" alt></p><p>带有过期时间的键值对中的TYPE、key、value三个部分的意义,和前面介绍的不带过期时间的键值对的TYPE、key、value三个部分的意义完全相同,至于新增的EXPIRETIME_MS和ms,它们的意义如下:</p><ul><li>EXPIRETIME_MS常量的长度为1字节,它告知读入程序,接下来要读人的将是一个以毫秒为单位的过期时间。</li><li>ms是一个8字节长的带符号整数,记录着一个以毫秒为单位的UNIX时间戳,这个时间戳就是键值对的过期时间。</li></ul><p>图10-19展示了一个带有过期时间的集合键值对、其中键的过期时间为1388556000000(2014年1月1日零时)</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204414997.png" alt></p><h3 id="3-3-value-编码"><a href="#3-3-value-编码" class="headerlink" title="3.3 value 编码"></a>3.3 value 编码</h3><p>RDB文件中的每个value部分都保存了一个值对象,每个值对象的类型都由与之对应的 TYPE 记录,根据类型的不同,value部分的结构、长度也会有所不同。</p><h4 id="3-3-1-字符串对象"><a href="#3-3-1-字符串对象" class="headerlink" title="3.3.1 字符串对象"></a>3.3.1 字符串对象</h4><p>如果TYPE的值为REDIS_RDB_TYPE_STRING,那么value保存的就是一个字符串对象,字符串对象的编码可以是RERDIS_ENCODING_INT或者REDIS_ENCODING_RRW。</p><p>如果字符串对象的编码为RERDIS_ENCODING_INT,那么说明对象中保存的是长度不超过32位的整数,这种编码的对象将以图10-20所示的结构保存。</p><p>其中,ENCODING 的值可以是REDIS_RDB_ENC_INT8、REDIS_RDB_ENC_INT16或者REDIS_RDB_ENC_INT32三个常量的其中一个,它们分别代表RDB文件使用8位(bit)、16位或者32位来保存整数值integer。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416210641240.png" alt></p><p>如果字符串对象的编码为RERDIS_ENCODING_RAW,那么说明对象所保存的是一个字符串值,根据字符串长度的不同,有压缩和不压缩两种方法来保存这个字符串:</p><ul><li><p>如果字符串的长度小于等于20字节,那么这个字符串会直接被原样保存。</p></li><li><p>如果字符串的长度大于20字节,那么这个字符串会被压缩之后再保存。</p></li></ul><p>对于没有被压缩的字符串,RDB程序会以图10-22所示的结构来保存该字符串。其中,string部分保存了字符串值本身,而len保存了字符串值的长度。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416210746060.png" alt></p><p>对于压缩后的字符串,RDB程序会以图10-23所示的结构来保存该字符串。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416210805453.png" alt></p><p>其中,REDIS_RDB_ENC_LZF常量标志着字符串已经被LZF算法压缩过了,读入程序在碰到这个常量时,会根据之后的compressed_len、origin_len和compressed_string三部分,对字符串进行解压缩:其中compressed_len记录的是字符串被压缩之后的长度,而origin_len记录的是字符串原来的长度,compressed_string记录的则是被压缩之后的字符串。</p><h4 id="3-3-2-列表对象"><a href="#3-3-2-列表对象" class="headerlink" title="3.3.2 列表对象"></a>3.3.2 列表对象</h4><p>如果TYPF的值为REDIS_RDB_TYPE5_LIST,那么value保存的就是一个REDIS_ENCODING_LINKEDLIST编码的列表对象,RDB文件保存这种对象的结构如图10-26所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204744316.png" alt></p><p>list_length 记录了列表的长度,它记录列表保存了多少个项(item),读入程序可以通过这个长度知道自己应该读人多少个列表项。图中以item开头的部分代表列表的项,因为每个列表项都是一个字符串对象,所以程序会以处理字符串对象的方式来保存和读人列表项。作为示例,图10-27展示了一个包含三个元素的列表。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416204833435.png" alt></p><p>结构中的第一个数字3是列表的长度,之后跟着的分别是第一个列表项、第二个列表项和第三个列表项,其中:</p><ul><li><p>第一个列表项的长度为5,内容为字符串“hello“。</p></li><li><p>第二个列表项的长度也为5,内容为字符串“world“。</p></li><li><p>第三个列表项的长度为1,内容为字符串“!“。</p></li></ul><h4 id="3-3-3-集合对象"><a href="#3-3-3-集合对象" class="headerlink" title="3.3.3 集合对象"></a>3.3.3 集合对象</h4><p>如果TYPF的值为REDIS_RDB_TYPE_SET,那么value保存的就是一个REBDIS_ENCODING_HT编码的集合对象,RDB文件保存这种对象的结构如图10-28所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205057819.png" alt></p><p>其中,set_size是集合的大小,它记录集合保存了多少个元素,读人程序可以通过这个大小知道自己应该读入多少个集合元素。图中以elem开头的部分代表集合的元素,因为每个集合元素都是一个字符串对象,所以程序会以处理字符串对象的方式来保存和读人集合元素。作为示例,图10-29展示了一个包含四个元素的集合。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205155469.png" alt></p><p>结构中的第一个数字4记录了集合的大小,之后跟着的是集合的四个元素:</p><ul><li><p>第一个元素的长度为5,值为“apple“。</p></li><li><p>第二个元素的长度为6,值为“banana“。</p></li><li><p>第三个元素的长度为3,值为“cat“。</p></li><li><p>第四个元素的长度为3,值为“dog“。</p></li></ul><h4 id="3-3-4-哈希表对象"><a href="#3-3-4-哈希表对象" class="headerlink" title="3.3.4 哈希表对象"></a>3.3.4 哈希表对象</h4><p>如果TYPE的值为REDIS_RDB_TYPE_HASH,那么value保存的就是一个RERDIS_ENCODING_HT编码的集合对象,RDB文件保存这种对象的结构如图10-30所示:</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205354228.png" alt></p><ul><li>hash_size记录了哈希表的大小,也即是这个哈希表保存了多少键值对,读入程序可以通过这个大小知道自己应该读人多少个键值对。</li><li>以key_value_pair开头的部分代表哈希表中的键值对,键值对的键和值都是字符串对象,所以程序会以处理字符串对象的方式来保存和读入键值对。</li></ul><p>结构中的每个键值对都以键紧挨着值的方式排列在一起,如图10-31所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205434452.png" alt></p><p>作为示例,图10-33展示了一个包含两个键值对的哈希表。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205518627.png" alt></p><h4 id="3-3-5-有序集合对象"><a href="#3-3-5-有序集合对象" class="headerlink" title="3.3.5 有序集合对象"></a>3.3.5 有序集合对象</h4><p>如 TYPE 的值为REDIS_RDB_TYPE_ZSET,那么value保存的就是一个REDIS_ENCODING_SKIPLTIST编码的有序集合对象,RDB文件保存这种对象的结构如图10-34所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205636669.png" alt></p><p>sorted_set_size记录了有序集合的大小,也即是这个有序集合保存了多少元素,读人程序需要根据这个值来决定应该读人多少有序集合元素。以element开头的部分代表有序集合中的元素,每个元素又分为成员(member)和分值(score)两部分,成员是一个字符串对象,分值则是一个double类型的浮点数,程序在保存RDB文件时会先将分值转换成字符串对象,然后再用保存字符串对象的方法将分值保存起来。</p><p>有序集合中的每个元素都以成员紧挨着分值的方式排列,如图10-35所示。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205749843.png" alt></p><p>作为示例,图10-37展示了一个带有两个元素的有序集合。</p><p><img src="/2022/03/27/Redis-设计与实现-RDB-持久化/image-20220416205818915.png" alt></p><h4 id="3-3-6-INTSET-编码的集合"><a href="#3-3-6-INTSET-编码的集合" class="headerlink" title="3.3.6 INTSET 编码的集合"></a>3.3.6 INTSET 编码的集合</h4><p>如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET,那么value保存的就是一个整数集合对象,RDB文件保存这种对象的方法是,先将整数集合转换为字符串对象,然后将这个字符串对象保存到RDB文件里面。如果程序在读入RDB文件的过程中,碰到由整数集合对象转换成的字符串对象,那么程序会根据TYPE值的指示,先读人字符串对象,再将这个字符串对象转换成原来的整数集合对象。</p><h4 id="3-3-7-ZIPLIST-编码的列表、哈希表或者有序集合"><a href="#3-3-7-ZIPLIST-编码的列表、哈希表或者有序集合" class="headerlink" title="3.3.7 ZIPLIST 编码的列表、哈希表或者有序集合"></a>3.3.7 ZIPLIST 编码的列表、哈希表或者有序集合</h4><p>如果TYPF的值为RRDIS_RDR_TYPE_LIST_ZIPLIST、RRDIS_RDR_TYPE_HASH_ZIPLIST或者RRDIS_RDR_TYPE_ZST_ZIPLIST,那么value保存的就是一个压缩列表对象,RDB文件保存这种对象的方法是:</p><ul><li><p>将压缩列表转换成一个字符串对象。</p></li><li><p>将转换所得的字符串对象保存到RDB文件。</p></li></ul><p>如果程序在读人RDB文件的过程中,碰到由压缩列表对象转换成的字符串对象,那么程序会根据7YPEF值的指示,执行以下操作:</p><ul><li>读人字符串对象,并将它转换成原来的压缩列表对象。</li><li>根据7YPE的值,设置压缩列表对象的类型:如果TYPE的值为REDIS_RDB_TYPE_LIST_ZIPLIST,那么压缩列表对象的类型为列表;如果TYXPE的值为REDIS_RDB_TYPE_HASH_ZIPLIST,那么压缩列表对象的类型为哈希表;如果TYPE的值为RRDIS_RDR_TYPE_ZST_ZIPLIST,那么压缩列表对象的类型为有序集合。</li></ul><p>从步骤2可以看出,由于TYPE的存在,即使列表、哈希表和有序集合三种类型都使用压缩列表来保存,RDB读入程序也总可以将读人并转换之后得出的压缩列表设置成原来的类型。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:24px">------ 本文结束------</div></div></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/缓存/" rel="tag"><i class="fa fa-tag"></i> 缓存</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2022/03/27/Redis-设计与实现-数据库/" rel="next" title="Redis 设计与实现-数据库"><i class="fa fa-chevron-left"></i> Redis 设计与实现-数据库</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2022/03/27/Redis-设计与实现-AOF-持久化/" rel="prev" title="Redis 设计与实现-AOF 持久化">Redis 设计与实现-AOF 持久化 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-RDB-文件的创建与载入"><span class="nav-text">1. RDB 文件的创建与载入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-SAVE-命令执行时的服务器状态"><span class="nav-text">1.1 SAVE 命令执行时的服务器状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-BGSAVE-命令执行时的服务器状态"><span class="nav-text">1.2 BGSAVE 命令执行时的服务器状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-RDB文件载入时的服务器状态"><span class="nav-text">1.3 RDB文件载入时的服务器状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-自动间隔性保存"><span class="nav-text">2. 自动间隔性保存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-设置保存条件"><span class="nav-text">2.1 设置保存条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-dirty-计数器和-lastsave-属性"><span class="nav-text">2.2 dirty 计数器和 lastsave 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-检查保存条件是否满足"><span class="nav-text">2.3 检查保存条件是否满足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-RDB-文件结构"><span class="nav-text">3. RDB 文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-database-部分"><span class="nav-text">3.1 database 部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-key-value-pairs-部分"><span class="nav-text">3.2 key_value_pairs 部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-value-编码"><span class="nav-text">3.3 value 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-字符串对象"><span class="nav-text">3.3.1 字符串对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-列表对象"><span class="nav-text">3.3.2 列表对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-集合对象"><span class="nav-text">3.3.3 集合对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-哈希表对象"><span class="nav-text">3.3.4 哈希表对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-有序集合对象"><span class="nav-text">3.3.5 有序集合对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-6-INTSET-编码的集合"><span class="nav-text">3.3.6 INTSET 编码的集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-7-ZIPLIST-编码的列表、哈希表或者有序集合"><span class="nav-text">3.3.7 ZIPLIST 编码的列表、哈希表或者有序集合</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/kanieki.png" alt="郑松涛"><p class="site-author-name" itemprop="name">郑松涛</p><div class="site-description" itemprop="description">积跬步，至千里</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">287</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ShotoZheng" title="GitHub &rarr; https://github.com/ShotoZheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:shotozheng@163.com" title="E-Mail &rarr; mailto:shotozheng@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">郑松涛</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.6m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">24:39</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div><div class="busuanzi-count"><script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/pjax/pjax.min.js?v=0.2.8"></script><script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.js"></script><script src="//lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script><script src="/js/schemes/pisces.js?v=7.4.0"></script><script src="/js/next-boot.js?v=7.4.0"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js?v=7.4.0"></script><script pjax>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><div id="pjax"><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Wechat,QQZone,Weibo,Douban,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'd6TU9yIpopEhNQKUras2D3Nr-gzGzoHsz',
    appKey: 'CJpUierMSXBHmTo6mJ8G1KO1',
    placeholder: 'Just go go',
    avatar: 'monsterid',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);</script></div></body></html><script type="text/javascript" src="/js/clicklove.js"></script><script src="/live2d-widget/autoload.js"></script>