<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0"><link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.4.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.4.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="〇、对数器对数器的作用是在没有Online Judge的情况下，我们自己实现的测试代码的工具。比如现在我们有一个要测试的方法a，我们需要：  实现一个绝对正确但是复杂度可以不好的方法b 实现一个随机样本产生器 实现比对的方法，即用来对比方法a与方法b产生的结果的比对方法 把方法a和方法b比对很多次来验证方法a是否正确 如果有一个样本使得比对出错， 打印样本分析是哪个方法出错 当样本数量很多时比对测"><meta name="keywords" content="数据结构与算法"><meta property="og:type" content="article"><meta property="og:title" content="排序算法"><meta property="og:url" content="https://ShotoZheng.github.io/2019/09/06/2019-9-6-排序算法/index.html"><meta property="og:site_name" content="鱼肚白不是鱼"><meta property="og:description" content="〇、对数器对数器的作用是在没有Online Judge的情况下，我们自己实现的测试代码的工具。比如现在我们有一个要测试的方法a，我们需要：  实现一个绝对正确但是复杂度可以不好的方法b 实现一个随机样本产生器 实现比对的方法，即用来对比方法a与方法b产生的结果的比对方法 把方法a和方法b比对很多次来验证方法a是否正确 如果有一个样本使得比对出错， 打印样本分析是哪个方法出错 当样本数量很多时比对测"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710073.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710076.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710077.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710078.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710079.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710080.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710081.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710111.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710112.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710113.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710114.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710116.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710117.png"><meta property="og:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710118.png"><meta property="og:updated_time" content="2020-01-01T12:09:28.576Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="排序算法"><meta name="twitter:description" content="〇、对数器对数器的作用是在没有Online Judge的情况下，我们自己实现的测试代码的工具。比如现在我们有一个要测试的方法a，我们需要：  实现一个绝对正确但是复杂度可以不好的方法b 实现一个随机样本产生器 实现比对的方法，即用来对比方法a与方法b产生的结果的比对方法 把方法a和方法b比对很多次来验证方法a是否正确 如果有一个样本使得比对出错， 打印样本分析是哪个方法出错 当样本数量很多时比对测"><meta name="twitter:image" content="https://shotozheng.github.io/2019/09/06/2019-9-6-排序算法/1567745710073.png"><link rel="canonical" href="https://ShotoZheng.github.io/2019/09/06/2019-9-6-排序算法/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-postbottom{cursor:pointer;height:26px;margin-top:10px;position:relative}#needsharebutton-postbottom .btn{border:1px solid $btn-default-border-color;border-radius:3px;display:initial;padding:1px 4px}</style><title>排序算法 | 鱼肚白不是鱼</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">鱼肚白不是鱼</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">笨鸟先飞</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-随笔"><a href="/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>随笔</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://ShotoZheng.github.io/2019/09/06/2019-9-6-排序算法/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="郑松涛"><meta itemprop="description" content="积跬步，至千里"><meta itemprop="image" content="/images/kanieki.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鱼肚白不是鱼"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">排序算法</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-09-06 00:00:00" itemprop="dateCreated datePublished" datetime="2019-09-06T00:00:00+08:00">2019-09-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-01-01 20:09:28" itemprop="dateModified" datetime="2020-01-01T20:09:28+08:00">2020-01-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/排序/" itemprop="url" rel="index"><span itemprop="name">排序</span></a></span> </span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2019/09/06/2019-9-6-排序算法/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2019/09/06/2019-9-6-排序算法/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>18k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>16 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="〇、对数器"><a href="#〇、对数器" class="headerlink" title="〇、对数器"></a>〇、对数器</h2><p>对数器的作用是在没有<code>Online Judge</code>的情况下，我们自己实现的测试代码的工具。比如现在我们有一个要测试的方法a，我们需要：</p><ol><li>实现一个<strong>绝对正确</strong>但是复杂度可以不好的方法b</li><li>实现一个随机样本产生器</li><li>实现比对的方法，即用来对比方法a与方法b产生的结果的比对方法</li><li>把方法a和方法b比对很多次来验证方法a是否正确</li><li>如果有一个样本使得比对出错， 打印样本分析是哪个方法出错</li><li>当样本数量很多时比对测试依然正确， 可以确定方法a已经正确<a id="more"></a></li></ol><p>下面是用于测试数据结构为数组的排序算法的对数器代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTestUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机样本产生器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">        <span class="comment">//生成一个随机长度的数组，长度位于[0 - maxSize]之间</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="comment">//为数组元素赋随机值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个时间复杂度可以差但是绝对正确的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">comparator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比对方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr1 == <span class="keyword">null</span> &amp;&amp; arr2 != <span class="keyword">null</span>) || (arr1 != <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1.length != arr2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上述对数器的使用，可以参见下面冒泡排序的部分。</p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><p>思想：从左到右不断交换相邻<strong>逆序</strong>的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。<br>举例：<br>比如现在有数组[3,5,2,4,1]。开始时有指针j和j+1指向元素3和5，发现3小于5，那么不交换元素位置。指针j加1，此时j和j+1分别指向5和2，因为5大于2，所以交换元素位置。以此类推，当j指向最后第二个元素并交换元素位置之后，数组变为[3,2,4,1,5]，此时元素5已经排好序了。现在j重新指向0号位置，重新进行如上过程。因为最后一个元素5已经排好序了，所以指针j只需走到最后第三个元素即可停止。当第二大元素排好序后，第三次循环同理。</p><p>冒泡排序的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">            <span class="comment">//变量j向右走最远的坐标为 arr.length - 2</span></span><br><span class="line">            <span class="comment">//变量e走到坐标1即可停止</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; e; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用对数器来验证如上冒泡排序算法的正确性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[] testArr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = SortTestUtil.generateRandomArray(maxSize, maxValue);</span><br><span class="line">        testArr = SortTestUtil.copyArray(arr1);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = SortTestUtil.copyArray(arr1);</span><br><span class="line">        BubbleSort.bubbleSort(arr1);</span><br><span class="line">        SortTestUtil.comparator(arr2);</span><br><span class="line">        <span class="keyword">if</span> (!SortTestUtil.isEqual(arr1, arr2)) &#123;</span><br><span class="line">            succeed = <span class="keyword">false</span>;</span><br><span class="line">            SortTestUtil.printArray(testArr);</span><br><span class="line">            SortTestUtil.printArray(arr1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(succeed ? <span class="string">"Nice!"</span> : <span class="string">"Fucking fucked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的时间复杂度O(N^2)， 额外空间复杂度O(1)。</p><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><p>思想：从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。<br>举例：<br>现在有一数组[3,5,2,4,1]。开始时有两个指针minIndex和j分别指向3和5，然后j依次往后遍历，并分别与指针minIndex所指向的元素3进行对比，如果j所指向的元素小于minIndex所指向的元素，那么将minIndex设置为j，当j遍历完之后就得到了数组中最小元素的下标minIndex，此时将minIndex与0号元素交换位置，那么0号位置的元素就排好序了。下一次循环开始，minIndex指向1号位置元素，j指向2号位置元素，重复上述过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序的时间复杂度O(N^2)， 额外空间复杂度O(1)</p><h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><p>思想：每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。<br>举例：<br>现在有一数组[3,5,2,4,1]。开始时指针j指向1号元素5，将1号元素与0号元素进行对比，如果1号元素小于0号元素那么就交换位置。因为5大于3，所以不交换位置。下一次循环j指向2号元素，同样与前一个元素进行对比，因为2小于5所以交换位置，此时数组变为[3,2,5,4,1]。j减1指向1号元素2，同样的与前一个元素进行对比，因为2小于3所以交换元素位置，此时数组变为[2,3,5,4,1]。下一次循环j指向3号元素，然后进行上述过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>])</span><br><span class="line">                    swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序的时间复杂度O(N^2)， 额外空间复杂度O(1)</p><h2 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h2><p>希尔排序是希尔（Donald Shell） 于 1959 年提出的一种排序算法。 希尔排序也是一种<strong>插入排序</strong>， 它是简单插入排序经过改进之后的一个更高效的版本， 也称为<strong>缩小增量排序</strong>。</p><p>思想：希尔排序是把记录按下标的一定增量分组， 对每组使用直接插入排序算法排序； 随着增量逐渐减少， 每组包含的关键词越来越多， 当增量减至 1 时， 整个文件恰被分成一组， 算法便终止。</p><p>上面的算法思想阐述得可能不是很明了，下面就一个例子来讲解该算法的排序过程：</p><p>观察如下数组，<strong>以下数据元素颜色相同为一组</strong>：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710073.png" alt><br>初始增量gap = length / 2 = 5，意味着整个数组被分为5组：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710076.png" alt><br>对这5组分别进行直接插入排序，结果如下。可以看到，像3，5，6，0这些小元素都被调到前面了。</p><p>然后缩小增量 gap = 5 / 2 = 2，数组被分为2组，如下所示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710077.png" alt><br>对以上2组再分别进行直接插入排序，结果如下。可以看到，此时整个数组的有序程度更近了一步。</p><p>再缩小增量gap = 2 / 2 = 1，此时，整个数组为1组，如下：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710078.png" alt><br>此时，仅仅需要对以上数组进行最后一次直接插入排序，即可完成整个数组的排序：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710079.png" alt></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                    swap(arr, j, j - gap);</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// for</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h2><p>思想：归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。<br>举例：<br>有一数组[3,5,2,4,1]，其归并排序中将数组以递归地方式分成两部分的过程如下图所示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710080.png" alt="递归拆分过程"><br>上图中仅涉及数组的拆分过程，并未涉及数组元素的排序和归并过程。观察上图左下角部分，数组[3,5]被拆分为子数组[3]和子数组[5]，此时我们需要将两个子数组进行排序然后并归并到原数组中的对应位置上(这里是0号和1号元素位置)。排序和归并的过程以下图的排序状态为例：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710081.png" alt><br>假设现在有一个指针i指向前半部分的首个元素位置，j指针指向后半部分的第一个元素位置。比较i和j所指向的元素，并将较小值拷贝到一个临时数组中，较小值所对应的指针往后移动一位，另一个指针不变。比如上图，j所指向的元素2小于i所指向的元素3,那么元素2会拷贝到临时数组中，指针j往后移动，如果元素2后还有一个元素4，那么显然i所指向的元素3会被拷贝到临时数组，i然后向后移动一位。进行上述过程中，i和j会向后移动，当其中一个指针数组越界后，即可结束上述过程。<br>如上图，j指针会先数组越界，那么将i指针及其后的所有元素拷贝进临时数组中。如果i先越界也同理。<br>以上过程即完成了数组元素的排序过程，然后将临时数组中排好序的元素拷贝回原数组中的对应位置中，便完成了归并过程。即在完成了上述步骤后，原数组变为[2,3,5,4,1]。<br>当递归完数组的后半部分[4,1]后，原数组会变为[2,3,5,1,4]。最后进行前后各半部分的排序和归并过程便得出最后的排序数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        mergeSortCore(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 相比于(L + R) / 2，下面的更快且避免整型溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSortCore(arr, L, mid);</span><br><span class="line">        mergeSortCore(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        merge(arr, L, R, mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// 指向数组help的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = L;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R)</span><br><span class="line">            help[k++] = arr[j] &lt;= arr[i] ? arr[j++] : arr[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">            help[k++] = arr[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= R)</span><br><span class="line">            help[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; help.length; u++)</span><br><span class="line">            arr[L + u] = help[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的时间复杂度O(N*logN)， 额外空间复杂度O(N)</p><p>【补充】：<br>递归行为和递归行为时间复杂度的估算遵循如下master公式：<br><strong>T(N) = a*T(N/b) + O(N^d)</strong></p><p>1) log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))<br>2) log(b,a) = d -&gt; 复杂度为O(N^d * logN)<br>3) log(b,a) &lt; d -&gt; 复杂度为O(N^d)</p><p>对于归并排序，长度为N的数组分为两次的T(N/2)时间复杂度的排序和O(N)的归并过程，所以a = b = 2，d = 1，即符合第2点log(b,a) = d，故时间复杂度为O(N*logN)。因为总的情况下需要长度为N的临时数组空间，故额外空间复杂度为O(N)。</p><h2 id="六、随机快速排序"><a href="#六、随机快速排序" class="headerlink" title="六、随机快速排序"></a>六、随机快速排序</h2><p>在讲随机快速排序前，有必要了解一下两个问题：</p><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>给定一个数组arr， 和一个数num， 请把小于等于num的数放在数组的左边， 大于num的数放在数组的右边。要求额外空间复杂度O(1)， 时间复杂度O(N)</p><p>分析：假设现在有一数组[4,5,1,2,9]。我们可以使用指针less指向数组的-1处，然后指针i从0号位往后遍历数组。如果i指向的元素大于num，那么i向右移动一位。如果小于等于num那么将i指向的元素与less + 1位置的元素交换位置，然后less和i向右移动一位。<br>由此less其左边的小于num的区域逐渐向右扩张，从而就把小于等于num的数放在数组的左边， 大于num的数放在数组的右边。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftSmallNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftSmallNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= num)</span><br><span class="line">                swap(arr, ++less, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> less, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[less];</span><br><span class="line">        arr[less] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>荷兰国旗问题：给定一个数组arr， 和一个数num， 请把小于num的数放在数组的左边， 等于num的数放在数组的中间， 大于num的数放在数组的右边。要求额外空间复杂度O(1)， 时间复杂度O(N)</p><p>与问题一类似，假设现在需要将小于2的数放在数组的左边，大于2的数放在数组的右边，等于2的数放在数组中间。<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710111.png" alt><br>初始时有指针less指向-1，more指向arr.length。如果当前指针i所指向的元素大于num，那么与more - 1的元素交换位置，more向左移动一位，i指针不移动并继续判断。如果当前指针i所指向的元素小于num，那么与less + 1的元素交换位置，less向右移动一位，i指针也向右移动一位。如果当前指针i所指向的元素等于num，i指针向右移动一位。当i大于等于more时，即可结束上述过程。</p><p>下面代码，实现了自定义边界L和R，而不再是简单的指向-1和数组的长度arr.length。其能够实现指定范围内的荷兰国旗问题的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetherLandsFlag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值为数组中等于num的左右边界（包含）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherLandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = L;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &gt; num)</span><br><span class="line">                swap(arr, cur, --more);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &lt; num)</span><br><span class="line">                swap(arr, cur++, ++less);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more - <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用荷兰国旗问题来改进快速排序。由于荷兰国旗问题实现了数组中等于num的元素的上下边界值，然后我们通过上下边界值可以递归地实现数组前半部分和后半部分，最后实现了数组的整体有序。需要注意的是：不同于荷兰国旗问题中num的值是自己给定的，随机快速排序算法中的num值是当前数组的最后一个元素。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>我们看一下随机排序算法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="comment">// 随机将数组L ~ R - 1内的某个元素与R位置的元素交换位置</span></span><br><span class="line">            swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br><span class="line">            <span class="keyword">int</span>[] p = partition(arr, L, R, arr[R]);</span><br><span class="line">            quickSort(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);<span class="comment">//前半部分</span></span><br><span class="line">            quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, R);<span class="comment">//后半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R;<span class="comment">// more指向R</span></span><br><span class="line">        <span class="keyword">int</span> cur = L;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &gt; num)</span><br><span class="line">                swap(arr, cur, --more);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &lt; num)</span><br><span class="line">                swap(arr, cur++, ++less);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, R);<span class="comment">//交换元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机将数组L ~ R - 1内的某个元素与R位置的元素交换位置</span></span><br><span class="line">swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br></pre></td></tr></table></figure><p>为什么要<strong>随机</strong>从数组中选取一个元素然后与R位置的元素交换位置，然后将其作为num呢？我们下面来分析一下为什么需要随机的选择。</p><p>假设现在有一个数组[5,4,3,2,1]。如果我们不随机选择，而是每次将最右边的元素（第一次递归时是元素1）作为num，那么我们会发现大于1的元素占了4个，快速排序算法最终会退化为时间复杂度为O（n * n）的算法。如果是随机选择的，那么在期望上随机选择排序的时间复杂度是O(N * logN)。</p><p>随机快速排序的时间复杂度是O(N*logN)， 额外空间复杂度是O(logN)。</p><h2 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h2><p>堆即为完全二叉树。下面我们使用数组来实现大根堆，所谓大根堆就是符合树中的所有子树的根大于其所有子节点的完全二叉树。比如下面即为一个大根堆：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710112.png" alt="大根堆"><br>其物理存储结构为数组，如下所示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710113.png" alt="物理数组结构"><br>我们可以通过如下公式来求得当前节点的左孩子、右孩子和父节点的位置，假设节点的位置为index：</p><ol><li>左孩子：2 * index + 1</li><li>右孩子：2 * index + 2</li><li>父节点：(index - 1) / 2</li></ol><h3 id="heapInsert"><a href="#heapInsert" class="headerlink" title="heapInsert"></a>heapInsert</h3><p>当一个元素加入大根堆时，可以使用heapInsert方法对该元素进行调整，即若该元素大于其父节点的值，那么就往上浮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大值往上浮</span></span><br><span class="line"><span class="comment">//index为该元素在数组中的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>当大根堆中的顶部某元素的值变小了，就比如当元素5变为0时，即：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710114.png" alt><br>为了符合大根堆的特性，我们需调整大根堆，将0往下沉，最后符合如下图示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710116.png" alt><br>上述过程的代码具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小值往下沉</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// arr[parent]往下沉的过程</span></span><br><span class="line">        <span class="keyword">int</span> left = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 假设left为最大值</span></span><br><span class="line">        <span class="keyword">int</span> largest = left;</span><br><span class="line">        <span class="comment">// left &lt; size说明左孩子存在</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 在右孩子存在的情况下，将左右孩子较大者的下标赋给largest，其中left + 1为右孩子</span></span><br><span class="line">            largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">// 左右孩子较大者与父节点比较，将较大者赋给largest</span></span><br><span class="line">            largest = arr[largest] &gt; arr[parent] ? largest : parent;</span><br><span class="line">            <span class="comment">// 如果父节点最大，则说明不再需要进行下沉过程</span></span><br><span class="line">            <span class="keyword">if</span> (largest == parent)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 父节点下沉</span></span><br><span class="line">            swap(arr, parent, largest);</span><br><span class="line">            parent = largest;</span><br><span class="line">            left = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>理解了上述两个方法后，我们就可以使用如下方法完成堆排序的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="comment">//构建大根堆，即往大根堆插入数据的过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    <span class="comment">//从大根堆中删除元素，并达到排序效果</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 堆顶最大元素移动数组最后位置</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 逻辑上删除堆的最后一个元素</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序的时间复杂度O(N*logN)， 额外空间复杂度O(1)</p><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><p>计数排序属于桶排序的一种，是非基于比较的排序， 与被排序的样本的实际数据状况很有关系， 所以实际中并不经常使用。</p><p>为什么说计数排序与被排序的样本的实际数据状况很有关系呢？先看下面的例子，我们可以实现对以下数组进行排序，另外假设数组中的元素大小需满足[0 ~ length] 。<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710117.png" alt><br>我们可以创建一个长度为length + 1的数组作为桶数组，每个桶用于保存原数组中的某元素出现的次数。其中元素值对应于桶数组中元素的下标。比如上面的数组经过元素个数统计后，其桶数组如下：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710118.png" alt><br>其表示元素0出现的次数为1，元素1出现的次数为2，其他同理。得到桶数组后，我们可以依靠该数组的信息将数据以有序的方式拷贝回原数组中。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定arr的元素符合0 ~ arr.length</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bucket[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>)</span><br><span class="line">                arr[index++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以规定数组arr中的元素需满足0 到该数组中的最大值max，此时我们就需要创建一个长度为max + 1为的桶数组。当max很大时，我们不得不创建很大的桶数组，这就是我们上面说计数排序与被排序的样本的实际数据状况很有关系的原因。更改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定arr的元素符合0 ~ max</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bucket[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>)</span><br><span class="line">                arr[index++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序的时间复杂度为O(N)， 额外空间复杂度为O(N)。</p><h3 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h3><p>给定一个数组， 求如果排序之后， 相邻两数的最大差值， 要求时间复杂度O(N)， 且要求不能用非基于比较的排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxGap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 获取数组中的最大最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max == min)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建桶，每个桶包含boolean， min，max三个值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取每个桶中的最小和最大值，以及是否同中是否有值</span></span><br><span class="line">        <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            bid = bucket(arr[i], size, max, min);</span><br><span class="line">            mins[bid] = hasNum[bid] ? Math.min(mins[bid], arr[i]) : arr[i];</span><br><span class="line">            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], arr[i]) : arr[i];</span><br><span class="line">            hasNum[bid] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取桶之间的最大差值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNum[i]) &#123;</span><br><span class="line">                res = Math.max(res, mins[i] - lastMax);</span><br><span class="line">                lastMax = maxs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前num所对应的桶号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> size, <span class="keyword">long</span> max, <span class="keyword">long</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ((num - min) * size / (max - min));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#ccc;font-size:24px">------ 本文结束------</div></div></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/数据结构与算法/" rel="tag"><i class="fa fa-tag"></i> 数据结构与算法</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/09/06/2019-9-6-矩阵的最小路径和/" rel="next" title="矩阵的最小路径和"><i class="fa fa-chevron-left"></i> 矩阵的最小路径和</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/09/06/2019-9-6-KMP-算法/" rel="prev" title="KMP 算法">KMP 算法 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#〇、对数器"><span class="nav-text">〇、对数器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、冒泡排序"><span class="nav-text">一、冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、选择排序"><span class="nav-text">二、选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、插入排序"><span class="nav-text">三、插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、希尔排序"><span class="nav-text">四、希尔排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、归并排序"><span class="nav-text">五、归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、随机快速排序"><span class="nav-text">六、随机快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题一"><span class="nav-text">问题一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题二"><span class="nav-text">问题二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现代码"><span class="nav-text">实现代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七、堆排序"><span class="nav-text">七、堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heapInsert"><span class="nav-text">heapInsert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heapify"><span class="nav-text">heapify</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八、计数排序"><span class="nav-text">八、计数排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#补充问题"><span class="nav-text">补充问题</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/kanieki.png" alt="郑松涛"><p class="site-author-name" itemprop="name">郑松涛</p><div class="site-description" itemprop="description">积跬步，至千里</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">284</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ShotoZheng" title="GitHub &rarr; https://github.com/ShotoZheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:shotozheng@163.com" title="E-Mail &rarr; mailto:shotozheng@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">郑松涛</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.6m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">24:18</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div><div class="busuanzi-count"><script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/pjax/pjax.min.js?v=0.2.8"></script><script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.js"></script><script src="//lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script><script src="/js/schemes/pisces.js?v=7.4.0"></script><script src="/js/next-boot.js?v=7.4.0"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js?v=7.4.0"></script><script pjax>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><div id="pjax"><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Wechat,QQZone,Weibo,Douban,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'd6TU9yIpopEhNQKUras2D3Nr-gzGzoHsz',
    appKey: 'CJpUierMSXBHmTo6mJ8G1KO1',
    placeholder: 'Just go go',
    avatar: 'monsterid',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);</script></div></body></html><script type="text/javascript" src="/js/clicklove.js"></script><script src="/live2d-widget/autoload.js"></script>