<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.9.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0"><link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.4.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css?v=1.0.2"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"7.4.0",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="1. 最优化原理最优化原理指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足最优化原理，就称其具有最优子结构性质。 这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规"><meta name="keywords" content="动态规划,背包问题"><meta property="og:type" content="article"><meta property="og:title" content="动态规划-01背包问题"><meta property="og:url" content="https://ShotoZheng.github.io/2023/02/02/动态规划-01背包问题/index.html"><meta property="og:site_name" content="鱼肚白不是鱼"><meta property="og:description" content="1. 最优化原理最优化原理指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足最优化原理，就称其具有最优子结构性质。 这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127125837071.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127130511276.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127131113026.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127131334733.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127131514543.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127131648045.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127131758632.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127131856524.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127135116562.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127140135872.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127140523591.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127140601431.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127140648838.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127140807465.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127140944676.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127142401915.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127142454952.png"><meta property="og:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127144200501.png"><meta property="og:updated_time" content="2023-02-02T14:49:03.037Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="动态规划-01背包问题"><meta name="twitter:description" content="1. 最优化原理最优化原理指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足最优化原理，就称其具有最优子结构性质。 这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规"><meta name="twitter:image" content="https://shotozheng.github.io/2023/02/02/动态规划-01背包问题/image-20230127125837071.png"><link rel="canonical" href="https://ShotoZheng.github.io/2023/02/02/动态规划-01背包问题/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.css"><style>#needsharebutton-postbottom{cursor:pointer;height:26px;margin-top:10px;position:relative}#needsharebutton-postbottom .btn{border:1px solid $btn-default-border-color;border-radius:3px;display:initial;padding:1px 4px}</style><title>动态规划-01背包问题 | 鱼肚白不是鱼</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><link rel="stylesheet" href="/dist/APlayer.min.css"><div id="aplayer"></div><script type="text/javascript" src="/dist/APlayer.min.js"></script><script type="text/javascript" src="/dist/music.js"></script><div class="container use-motion"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">鱼肚白不是鱼</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">笨鸟先飞</p></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-随笔"><a href="/随笔/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>随笔</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article itemscope itemtype="http://schema.org/Article"><div class="post-block post"><link itemprop="mainEntityOfPage" href="https://ShotoZheng.github.io/2023/02/02/动态规划-01背包问题/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="郑松涛"><meta itemprop="description" content="积跬步，至千里"><meta itemprop="image" content="/images/kanieki.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="鱼肚白不是鱼"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">动态规划-01背包问题</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-02-02 22:34:35 / 修改时间：22:49:03" itemprop="dateCreated datePublished" datetime="2023-02-02T22:34:35+08:00">2023-02-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/动态规划/" itemprop="url" rel="index"><span itemprop="name">动态规划</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构与算法/动态规划/背包问题/" itemprop="url" rel="index"><span itemprop="name">背包问题</span></a></span> </span><span class="post-meta-item" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2023/02/02/动态规划-01背包问题/#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2023/02/02/动态规划-01背包问题/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>9.5k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="1-最优化原理"><a href="#1-最优化原理" class="headerlink" title="1. 最优化原理"></a>1. 最优化原理</h2><p><code>最优化原理</code>指的最优策略具有这样的性质：不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简单来说就是一个最优策略的子策略也是必须是最优的，而所有子问题的局部最优解将导致整个问题的全局最优。如果一个问题能满足<code>最优化原理</code>，就称其具有<code>最优子结构性质</code>。</p><p>这是判断问题能否使用动态规划解决的先决条件，如果一个问题不能满足最优化原理，那么这个问题就不适合用动态规划来求解。<a id="more"></a></p><p>这样说可能比较模糊，来举个栗子吧：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127125837071.png" style="zoom:50%"><p>如上图，求从A点到E点的最短距离，那么子问题就是求从A点到E点之间的中间点到E点的最短距离，比如这里的B点。</p><p>那么这个问题里，怎么证明最优化原理呢？</p><p>我们假设从A点到E点的最短距离为d，其最优策略的子策略假设经过B点，记该策略中B点到E点的距离为<code>d1</code>，A点到B点的距离为<code>d2</code>。我们可以使用反证法，假设存在B点到E点的最短距离<code>d3</code>，并且<code>d3 &lt; d1</code>，那么 <code>d3 + d2 &lt; d1 + d2 = d</code>，这与d是最短距离相矛盾，所以，<code>d1</code>是B点到E点的最短距离。</p><p>为了增加理解，这里再举一个反例：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127130511276.png" style="zoom:50%"><p>图中有四个点，A、B、C、D，相邻两点有两条连线，代表两条通道，d1,d2,d3,d4,d5,d6代表的是道路的长度，求A到D的所有通道中，总长度除以4得到的余数最小的路径为<strong>最优路径</strong>，求一条<strong>最优路径</strong>。</p><p>这里如果还是按照上面的思路去求解，就会误入歧途了。按照之前的思路，A的最优取值应该可以由B的最优取值来确定，而B的最优取值为（3+5）mod 4 = 0。所以应该选<code>d2</code>和<code>d6</code>这两条道路，而实际上，全局最优解是<code>d4+d5+d6</code>或者<code>d1+d5+d3</code>。所以这里子问题的最优解并不是原问题的最优解，即不满足最优化原理。所以就不适合使用动态规划来求解了。</p><h2 id="2-无后效性"><a href="#2-无后效性" class="headerlink" title="2. 无后效性"></a>2. 无后效性</h2><p><code>无后效性</code>指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关。某个阶段的状态一旦确定，则此后过程的演变不再受此前各种状态及决策的影响。换句话说，未来与过去无关，当前状态是此前历史状态的完整总结，此前历史决策只能通过影响当前的状态来影响未来的演变。再换句话说，过去做的选择不会影响现在能做的最优选择，现在能做的最优选择只与当前的状态有关，与经过如何复杂的决策到达该状态的方式无关。</p><p>这也是用来验证问题是否可以使用动态规划来解答的重要方法。</p><p>我们再回头看看上面的最短路径问题，如果在原来的基础上加上一个限制条件：<strong>同一个格子只能通过一次</strong>。那么， 这个题就不符合无后效性了，因为前一个子问题的解会对后面子问题的选择策略有影响，比如说，如果从A到B选择了一条如下图中绿色表示的路线，那么从B点出发到达E点的路线就只有一条了。也就是说从A点到B点的路径选择会影响B点到E点的路径选择。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127131113026.png" style="zoom:50%"><p>理论部分就此打住，接下来我们实战一下。</p><h2 id="3-01背包问题"><a href="#3-01背包问题" class="headerlink" title="3. 01背包问题"></a>3. 01背包问题</h2><p>假设你只有一个容量有限的背包，总容量为c，有n个可待选择的物品，每个物品只有一件，它们都有各自的重量和价值，你需要从中选择合适的组合来使得你背包中的物品总价值最大。简单起见，我们来将上面的问题具体化，举一个更具体的栗子：</p><p>假设有4个物品，它们的价值(v)和重量(w)如下图：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127131334733.png" alt="image-20230127131334733" style="zoom:50%"><p>背包总容量为10，现在要从中选择物品装入背包中，要求物品的重量不能超过背包的容量，并且最后放在背包中物品的总价值最大。</p><p>仔细想想，这里每个物品只有一个，对于每个物品而言，只有两种选择，盘它或者不盘，盘它记为1，不盘记为0，我们不能将物品进行分割，比如只拿半个是不允许的。这就是这个问题被称为<code>0/1背包</code>问题的原因。</p><p>所以究竟选还是不选，这是个问题。</p><p>让我们先来体验一下将珠宝装入背包的感觉，为了方便起见，用<code>xi</code>代表第i个珠宝的选择（<code>xi = 1</code> 代表选择该珠宝，0则代表不选），<code>vi</code>代表第i个珠宝的价值，<code>wi</code>代表第i个珠宝的重量。于是我们就有了这样的限制条件：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127131514543.png" style="zoom:50%"><p>我们的初始状态是背包容量为10，背包内物品总价值为0，接下来，我们就要开始做选择了。对于1号珠宝，当前容量为10，容纳它的重量2绰绰有余，因此有两种选择，选它或者不选。我们选择一个珠宝的时候，背包的容量会减少，但是里面的物品总价值会增加。就像下面这样：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127131648045.png" style="zoom:50%"><p>这样就分出了两种情况，我们继续进行选择，如果我们选择了珠宝1，那么对于珠宝2，当前剩余容量为8，大于珠宝2的容量3，因此也有两种选择，选或者不选。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127131758632.png" style="zoom:50%"><p>现在，我们得到了四个可能结果，我们每做出一个选择，就会将上面的每一种可能分裂成两种可能，后续的选择也是如此，最终，我们会得到如下的一张决策图：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127131856524.png" style="zoom:50%"><p>这里被涂上色的方框代表我们的最终待选结果，本来应该有16个待选结果，但有三个结果由于容量不足以容纳下最后一个珠宝，所以就没有继续进行裂变。</p><p>然后，我们从这些结果中，找出价值最大的那个，也就是<code>13</code>，这就是我们的最优选择，根据这个选择，依次找到它的所有路径，便可以知道该选哪几个珠宝，最终结果是：珠宝4，珠宝2，珠宝1。</p><h2 id="4-分治法"><a href="#4-分治法" class="headerlink" title="4. 分治法"></a>4. 分治法</h2><p>接下来，我们就来分析一下，如何将它扩展到一般情况。为了实现这个目的，我们需要将问题进行抽象并建模，然后将其划分为更小的子问题，找出递推关系式，这是分治思想中很重要的一步。</p><ol><li>抽象问题，背包问题抽象为寻找组合（x1,x2,x3…xn，其中xi取0或1，表示第i个物品取或者不取），vi代表第i个物品的价值，wi代表第i个物品的重量，总物品数为n，背包容量为c。</li><li>建模，问题即求max(x1v1 + x2v2 + x3v3 + … + xnvn)。</li><li>约束条件，x1w1 + x2w2 + x3w3 + … + xnwn &lt; c</li><li>定义函数KS(i,j)：代表当前背包剩余容量为j时，前i个物品最佳组合所对应的价值；</li></ol><p>那这里的递推关系式是怎样的呢？对于第i个物品，有两种可能：</p><ol><li>背包剩余容量不足以容纳该物品，此时背包的价值与前i-1个物品的价值是一样的，KS(i,j) = KS(i-1,j)</li><li>背包剩余容量可以装下该商品，此时需要进行判断，因为装了该商品不一定能使最终组合达到最大价值，如果不装该商品，则价值为：KS(i-1,j)，如果装了该商品，则价值为KS(i-1,j-wi) + vi，从两者中选择较大的那个，所以就得出了递推关系式：</li></ol><img src="/2023/02/02/动态规划-01背包问题/image-20230127135116562.png" style="zoom:50%"><p>对于这个问题的子问题，这里有必要详细说明一下。原问题是，将n件物品放入容量为c的背包，子问题则是，将前i件物品放入容量为j的背包，所得到的最优价值为KS(i,j)，如果只考虑第i件物品放还是不放，那么就可以转化为一个只涉及到前i-1个物品的问题。如果不放第i个物品，那么问题就转化为“前i-1件物品放入容量为j的背包中的最优价值组合”，对应的值为KS(i-1,j)。如果放第i个物品，那么问题就转化成了“前i-1件物品放入容量为j-wi的背包中的最优价值组合”，此时对应的值为KS(i-1,j-wi)+vi。</p><p>所以，就可以很容易的写出递归解法了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] vs = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] ws = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKnapsack1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = ks(<span class="number">4</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ks</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 初始条件</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ws[i] &gt; c)&#123;</span><br><span class="line">            <span class="comment">// 装不下该珠宝</span></span><br><span class="line">            result = ks(i-<span class="number">1</span>, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 可以装下</span></span><br><span class="line">            <span class="comment">// 不选择第 i 件物品</span></span><br><span class="line">            <span class="keyword">int</span> tmp1 = ks(i-<span class="number">1</span>, c);</span><br><span class="line">            <span class="comment">// 选择第 i 件物品</span></span><br><span class="line">            <span class="keyword">int</span> tmp2 = ks(i-<span class="number">1</span>, c-ws[i]) + vs[i];</span><br><span class="line">            result = Math.max(tmp1, tmp2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里为了方便处理，将数组ws和vs都增加了一个补位数0，防止数组越界，输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><p>这样，我们就轻松加愉快的解决了这个问题。</p><h2 id="5-动态规划解法"><a href="#5-动态规划解法" class="headerlink" title="5. 动态规划解法"></a>5. 动态规划解法</h2><h3 id="5-1-验证可行性"><a href="#5-1-验证可行性" class="headerlink" title="5.1 验证可行性"></a>5.1 验证可行性</h3><p>既然开头已经说了两个验证问题是否可以使用动态规划求解的方法，那么为何不试一试呢？</p><p>先来看看<code>最优化原理</code>。同样，我们使用反证法：</p><p>假设(x1，x2，…，xn)是01背包问题的最优解，则有(x2，x3，…，xn)是其子问题的最优解，假设(y2，y3，…，yn)是上述问题的子问题最优解，则有(v2y2+v3y3+…+vnyn)+v1x1 &gt; (v2x2+v3x3+…+vnxn)+v1x1。说明(X1，Y2，Y3，…，Yn)才是该01背包问题的最优解，这与最开始的假设(X1，X2，…，Xn)是01背包问题的最优解相矛盾，故01背包问题满足<code>最优性原理</code>。</p><p>至于<code>无后效性</code>，其实比较好理解。对于任意一个阶段，只要背包剩余容量和可选物品是一样的，那么我们能做出的现阶段的最优选择必定是一样的，是不受之前选择了什么物品所影响的。即满足<code>无后效性</code>。</p><h3 id="5-2-自上而下记忆法"><a href="#5-2-自上而下记忆法" class="headerlink" title="5.2 自上而下记忆法"></a>5.2 自上而下记忆法</h3><p>自上而下的解法与分治法的区别就是增加了一个数组用来存储计算的中间结果来减少重复计算。这里，我们只需要多定义一个二维数组。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127140135872.png" style="zoom:50%"><p>表格中，每一个格子都代表着一个子问题，我们最终的问题是求最右下角的格子的值，也就是<code>i=4,j=10</code>时的值。这里，我们的初始条件便是i=0或者j=0时对应的ks值为0，这很好理解，如果可选物品为0，或者剩余容量为0，那么最大价值自然也是0。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] vs = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] ws = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Integer[][] results = <span class="keyword">new</span> Integer[<span class="number">5</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKnapsack2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = ks2(<span class="number">4</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ks2</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="comment">// 如果该结果已经被计算，那么直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (results[i][c] != <span class="keyword">null</span>) <span class="keyword">return</span> results[i][c];</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 初始条件</span></span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ws[i] &gt; c)&#123;</span><br><span class="line">            <span class="comment">// 装不下该珠宝</span></span><br><span class="line">            result = ks2(i-<span class="number">1</span>, c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 可以装下</span></span><br><span class="line">            <span class="keyword">int</span> tmp1 = ks2(i-<span class="number">1</span>, c);</span><br><span class="line">            <span class="keyword">int</span> tmp2 = ks2(i-<span class="number">1</span>, c-ws[i]) + vs[i];</span><br><span class="line">            result = Math.max(tmp1, tmp2);</span><br><span class="line">        &#125;</span><br><span class="line">        results[i][c] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，其实只比分治多了三行代码。</p><h3 id="5-3-自下而上填表法"><a href="#5-3-自下而上填表法" class="headerlink" title="5.3 自下而上填表法"></a>5.3 自下而上填表法</h3><p>接下来，我们用自下而上的方法来解一下这道题，思路很简单，就是不断的填表，还是使用上面的表格，我们开始一行行填表。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127140523591.png" style="zoom:50%"><p>当i=1时，即只有珠宝1可供选择，那么如果容量足够的话，最大价值自然就是珠宝1的价值了。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127140601431.png" style="zoom:50%"><p>当i=2时，有两个物品可供选择，此时应用上面的递推关系式进行判断即可。这里以i=2,j=3为例进行分析：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127140648838.png" style="zoom:50%"><p>剩下的格子使用相同的方法进行填充即可：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127140807465.png" style="zoom:50%"><p>这样，我们就得到了最后的结果：13。根据结果，我们可以反向找出各个物品的选择，寻找的方法很简单，就是从<code>i=4,j=10</code>开始寻找，如果<code>ks(i-1,j)=ks(i,j)</code>，说明第i个物品没有被选中，从<code>ks(i-1,j)</code>继续寻找。否则，表示第i个物品已被选中，则从<code>ks(i-1,j-wi)</code>开始寻找。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127140944676.png" style="zoom:50%"><p>转化成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] vs = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] ws = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] results = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">11</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKnapsack3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = ks3(<span class="number">4</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ks(i,c) = max&#123;ks(i-1, c), ks(i-1, c-ws[i]) + vs[i]&#125;(条件：c&gt;=ws[i])</span></span><br><span class="line"><span class="comment">    * ks(i,c) = ks(i-1,c)(条件：c&lt;ws[i])</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ks3</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 开始填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">1</span>; m &lt;= i; m++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= j; n++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (n &lt; ws[m])&#123;</span><br><span class="line">                    <span class="comment">// 装不进去</span></span><br><span class="line">                    results[m][n] = results[m-<span class="number">1</span>][n];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 容量足够</span></span><br><span class="line">                    results[m][n] = Math.max(results[m - <span class="number">1</span>][n], results[m - <span class="number">1</span>][n - ws[m]] + vs[m]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，完美解决。时间复杂度即填表耗时<code>O(n * c)</code>，这里用了一个二维数组来存储子问题的解，所以空间复杂度为<code>O(n * c)</code>;</p><h3 id="5-4-空间优化过程"><a href="#5-4-空间优化过程" class="headerlink" title="5.4 空间优化过程"></a>5.4 空间优化过程</h3><p>自下而上填表发这种解法，我们还能再对它的空间复杂度进行优化。再回头看下之前的递推关系式：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127142401915.png" style="zoom:50%"><p>可以发现，每次求解 <code>KS(i,j)</code>只与<code>KS(i-1,m) {m:1...j}</code> 有关。也就是说，如果我们知道了<code>K(i-1,1...j)</code>就肯定能求出<code>KS(i,j)</code>，为了更直观的理解，再画一张图：</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127142454952.png" style="zoom:50%"><p>下一层只需要根据上一层的结果即可推出答案，举个栗子，看<code>i=3，j=5</code>时，在求这个子问题的最优解时，根据上述推导公式，<code>KS(3,5) = max{KS(2,5)</code>,<code>KS(2,0) + 3} = max{6,3} = 6</code>;如果我们得到了<code>i=2</code>时所有子问题的解，那么就很容易求出<code>i=3</code>时所有子问题的解。</p><p>因此，我们可以将求解空间进行优化，将二维数组压缩成一维数组，此时，装填转移方程变为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KS(j) = max&#123;KS(j), KS(j - wi) + vi&#125;</span><br></pre></td></tr></table></figure><p>这里<code>KS(j - wi)</code>就相当于原来的<code>KS(i-1, j - wi)</code>。需要注意的是，由于<code>KS(j)</code>是由它前面的<code>KS(m){m:1..j}</code>推导出来的，所以在第二轮循环扫描的时候应该由后往前进行计算，因为如果由前往后推导的话，前一次循环保存下来的值可能会被修改，从而造成错误。</p><p>这么说也许还是不太清楚，回头看上面的图，我们从<code>i=3</code>推算<code>i=4</code>的子问题的解时，此时一维数组中存放的是<code>{0,0,2,4,4,6,6,6,7,7,9}</code>，这是<code>i=3</code>时所有子问题的解，如果我们从前往后推算<code>i=4</code>时的解，比如，我们计算<code>KS(0) = 0，KS(1) = KS(1) = 0</code> (因为j=1时，装不下第三个珠宝，第三个珠宝的重量为5)，<code>KS(2) = 2,KS(3) = 4,KS(4) = 4, KS(5) = max{KS(5), KS(5-5) + 7} = 7,....,KS(10) = max{KS(10),KS(10 - 5) + 7} = 14</code>。在这里计算KS(8)的时候，我们就把原来KS(5)的内容修改掉了，这样，我们后续计算就无法找到这个位置的原值，也就是上一轮循环中计算出来的值了，所以在遍历的时候，需要从后往前进行倒序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] vs = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] ws = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] newResults = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = ksp(<span class="number">4</span>,<span class="number">10</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空间优化版</span></span><br><span class="line"><span class="comment">     * ks(c) = max&#123;ks‘(c), ks‘(c-ws[i]) + vs[i]&#125;(条件：c&gt;=ws[i])</span></span><br><span class="line"><span class="comment">     * ks(c) = ks‘(c)(条件：c&lt;ws[i])</span></span><br><span class="line"><span class="comment">     * ks(c) 等同于 ks(i,c)，ks‘(c-ws[i]) 等同于 ks(i-1, c-ws[i])，通过逆向遍历复用前一次结果来实现该等同效果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">ksp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 开始填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; vs.length; m++)&#123;</span><br><span class="line">            <span class="comment">// n &gt;= w 即剩余空间大于重量时，才装填</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> n = c; n &gt;= ws[m]; n--)&#123;</span><br><span class="line">                newResults[n] = Math.max(newResults[n] , newResults[n - ws[m]] + vs[m]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可以在这里输出中间结果</span></span><br><span class="line">            System.out.println(JSON.toJSONString(newResults));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newResults[newResults.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">0,0,0,0,0,0,0,0,0,0,0</span>]</span><br><span class="line">[<span class="meta">0,0,2,2,2,2,2,2,2,2,2</span>]</span><br><span class="line">[<span class="meta">0,0,2,4,4,6,6,6,6,6,6</span>]</span><br><span class="line">[<span class="meta">0,0,2,4,4,6,6,6,7,7,9</span>]</span><br><span class="line">[<span class="meta">0,0,2,4,4,7,7,9,11,11,13</span>]</span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p>这样，我们就顺利将空间复杂度从<code>O(n*c)</code>优化到了<code>O(c)</code>。当然，空间优化的代价是，我们只能知道最终的结果，但无法再回溯中间的选择，也就是无法根据最终结果来找到我们要选的物品组合。</p><h3 id="5-5-关于初始值"><a href="#5-5-关于初始值" class="headerlink" title="5.5 关于初始值"></a>5.5 关于初始值</h3><p><code>01背包问题</code>一般有两种不同的问法，一种是<code>“恰好装满背包”</code>的最优解，要求背包必须装满，那么在初始化的时候，除了<code>KS(0)</code>为<code>0</code>，其他的<code>KS(j)</code>都应该设置为<code>负无穷大</code>，这样就可以保证最终得到的<code>KS(c)</code>是恰好装满背包的最优解。另一种问法<code>不要求装满</code>，而是只希望最终得到的价值<code>尽可能大</code>，那么初始化的时候，应该将<code>KS(0...c)</code>全部设置为<code>0</code>。</p><p>为什么呢？因为初始化的数组，实际上是在没有任何物品可以放入背包的情况下的<code>合法状态</code>。如果要求背包恰好装满，那么此时只有容量为0的背包可以在什么都不装且价值为0的情况下被<code>“恰好装满”</code>，其他容量的背包均没有合法的解，因此属于未定义的状态，应该设置为<code>负无穷大</code>。如果背包不需要被装满，那么任何容量的背包都有合法解，那就是“什么都不装”。这个解的价值为0，所以初始状态的值都是0。</p><img src="/2023/02/02/动态规划-01背包问题/image-20230127144200501.png" style="zoom:50%"><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>回过头再看看上面的分析，会发现动态规划里最关键的问题其实是寻找原问题的子问题，并写出递推表达式，只要完成了这一步，代码部分都是水到渠成的事情了。</p><p>那么问题来了，怎样把问题拆分成子问题呢？</p><p>emmm，这个问题有点超纲了，说实话，我也没有掌握到诀窍，还是得具体情况具体分析，但是很多经典的问题都有其经典的套路，其它问题都可以归结到这些问题上面来，可以看做是它们的变种和延伸，把这些经典的问题吃透的话，自然能举一反三。比如采药问题，本质上就是01背包问题，而硬币问题，本质上就是我们之后要介绍的完全背包问题。</p><p><code>01背包问题</code>可以用<code>自上而下</code>的<code>递归记忆法</code>求解，也可以用<code>自下而上</code>的<code>填表法</code>求解，而后者可以将二维数组的解空间优化成一维数组的解空间，从而实现空间复杂度的优化。</p><p>对于<code>01背包问题</code>的两种不同问法，实际上的区别便是<code>初始值</code>设置不一样，解题思路是一样的。</p><p>关于<code>01背包问题</code>，介绍到这里就已经全部结束了，希望能对大家有所帮助。</p><p>个人认为，算法不在于刷多少个，而在于归纳总结，就跟做数学题一样，总有一些范式和套路，不管形式如何变化，其本质是一样的，万变不离其宗，说的就是这么回事。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:24px">------ 本文结束------</div></div></div><div class="post-widgets"><div id="needsharebutton-postbottom"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/动态规划/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a> <a href="/tags/背包问题/" rel="tag"><i class="fa fa-tag"></i> 背包问题</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2023/02/01/ElasticSearch-Ingest-Pipeline-Painless-Script/" rel="next" title="ElasticSearch-Ingest Pipeline & Painless Script"><i class="fa fa-chevron-left"></i> ElasticSearch-Ingest Pipeline & Painless Script</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2023/02/03/动态规划-完全背包问题/" rel="prev" title="动态规划-完全背包问题">动态规划-完全背包问题 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-最优化原理"><span class="nav-text">1. 最优化原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-无后效性"><span class="nav-text">2. 无后效性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-01背包问题"><span class="nav-text">3. 01背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-分治法"><span class="nav-text">4. 分治法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-动态规划解法"><span class="nav-text">5. 动态规划解法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-验证可行性"><span class="nav-text">5.1 验证可行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-自上而下记忆法"><span class="nav-text">5.2 自上而下记忆法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-自下而上填表法"><span class="nav-text">5.3 自下而上填表法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-空间优化过程"><span class="nav-text">5.4 空间优化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-关于初始值"><span class="nav-text">5.5 关于初始值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-总结"><span class="nav-text">6. 总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/kanieki.png" alt="郑松涛"><p class="site-author-name" itemprop="name">郑松涛</p><div class="site-description" itemprop="description">积跬步，至千里</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">286</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">64</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">53</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/ShotoZheng" title="GitHub &rarr; https://github.com/ShotoZheng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:shotozheng@163.com" title="E-Mail &rarr; mailto:shotozheng@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">郑松涛</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.6m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">24:32</span></div><div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div><span class="post-meta-divider">|</span><div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.4.0</div><div class="busuanzi-count"><script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer></div><script src="/lib/anime.min.js?v=3.1.0"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/lib/pjax/pjax.min.js?v=0.2.8"></script><script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.6.0/jquery.js"></script><script src="//lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script><script src="/js/schemes/pisces.js?v=7.4.0"></script><script src="/js/next-boot.js?v=7.4.0"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var id = element.id || '';
    var src = element.src || '';
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (id !=='') {
      script.id = element.id;
    }
    if (src !== '') {
      script.src = src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js?v=7.4.0"></script><script pjax>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><div id="pjax"><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-needmoreshare2@1/needsharebutton.min.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Wechat,QQZone,Weibo,Douban,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions)</script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: true,
    appId: 'd6TU9yIpopEhNQKUras2D3Nr-gzGzoHsz',
    appKey: 'CJpUierMSXBHmTo6mJ8G1KO1',
    placeholder: 'Just go go',
    avatar: 'monsterid',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
}, window.Valine);</script></div></body></html><script type="text/javascript" src="/js/clicklove.js"></script><script src="/live2d-widget/autoload.js"></script>