<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>玩转 Java8Stream (一、从零认识 Stream)</title>
      <link href="/2021/09/12/%E7%8E%A9%E8%BD%AC-Java8Stream-%E4%B8%80%E3%80%81%E4%BB%8E%E9%9B%B6%E8%AE%A4%E8%AF%86-Stream/"/>
      <url>/2021/09/12/%E7%8E%A9%E8%BD%AC-Java8Stream-%E4%B8%80%E3%80%81%E4%BB%8E%E9%9B%B6%E8%AE%A4%E8%AF%86-Stream/</url>
      
        <content type="html"><![CDATA[<p>相信 Java8 的 Stream 大家都已听说过了，但是可能大家不会用或者用的不熟，笔者将在《玩转Java8Stream》系列文章中带大家从零开始使用，循序渐进，带你走向 Stream 的巅峰。</p><a id="more"></a><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1. 操作符"></a>1. 操作符</h2><p>什么是操作符呢？操作符就是对数据进行的一种处理工作，一道加工程序；就好像工厂的工人对流水线上的产品进行一道加工程序一样。</p><p><img src="/2021/09/12/玩转-Java8Stream-一、从零认识-Stream/image-20210912102441380.png" alt></p><p><strong>Stream</strong> 的操作符大体上分为两种：<strong>中间操作符</strong>和<strong>终止操作符</strong></p><h2 id="2-中间操作符"><a href="#2-中间操作符" class="headerlink" title="2. 中间操作符"></a>2. 中间操作符</h2><p>对于数据流来说，中间操作符在执行制定处理程序后，数据流依然可以传递给下一级的操作符。</p><p>中间操作符包含 8 种(排除了parallel, sequential,这两个操作并不涉及到对数据流的加工操作)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. map(mapToInt,mapToLong,mapToDouble) 转换操作符，把比如A-&gt;B，这里默认提供了转int，long，double的操作符。</span><br><span class="line">2. flatmap(flatmapToInt,flatmapToLong,flatmapToDouble) 拍平操作比如把 int[]&#123;2,3,4&#125; 拍平 变成 2，3，4 也就是从原来的一个数据变成了3个数据，这里默认提供了拍平成int,long,double的操作符。</span><br><span class="line">3. limit 限流操作，比如数据流中有10个 我只要出前3个就可以使用。</span><br><span class="line">4. distint 去重操作，对重复元素去重，底层使用了 equals 方法。</span><br><span class="line">5. filter 过滤操作，把不想要的数据过滤。</span><br><span class="line">6. peek 挑出操作，如果想对数据进行某些操作，如：读取、编辑修改等。</span><br><span class="line">7. skip 跳过操作，跳过某些元素。</span><br><span class="line">8. sorted(unordered) 排序操作，对元素排序，前提是实现Comparable接口，当然也可以自定义比较器。</span><br></pre></td></tr></table></figure><h2 id="3-终止操作符"><a href="#3-终止操作符" class="headerlink" title="3. 终止操作符"></a>3. 终止操作符</h2><p>数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. collect 收集操作，将所有数据收集起来，这个操作非常重要，官方的提供的 Collectors 提供了非常多收集器，可以说 Stream 的核心在于 Collectors。</span><br><span class="line">2. count 统计操作，统计最终的数据个数。</span><br><span class="line">3. findFirst、findAny 查找操作，查找第一个、查找任何一个 返回的类型为 Optional。</span><br><span class="line">4. noneMatch、allMatch、anyMatch 匹配操作，数据流中是否存在符合条件的元素 返回值为 bool 值。</span><br><span class="line">5. min、max 最值操作，需要自定义比较器，返回数据流中最大最小的值。</span><br><span class="line">6. reduce 规约操作，将整个数据流的值规约为一个值，count、min、max 底层就是使用 reduce。</span><br><span class="line">7. forEach、forEachOrdered 遍历操作，这里就是对最终的数据进行消费了。</span><br><span class="line">8. toArray 数组操作，将数据流的元素转换成数组。</span><br></pre></td></tr></table></figure><p>这里只介绍了Stream，并没有涉及到<strong>IntStream</strong>、<strong>LongStream</strong>、<strong>DoubleStream</strong>，这三个流实现了一些特有的操作符，我将在后续文章中介绍到。</p><p>说了这么多，只介绍这些操作符还远远不够；俗话说，实践出真知。那么，Let‘s go。</p><h2 id="4-代码演练"><a href="#4-代码演练" class="headerlink" title="4. 代码演练"></a>4. 代码演练</h2><p><strong>Stream 的一系列操作必须要使用终止操作，否者整个数据流是不会流动起来的，即处理操作不会执行。</strong></p><h3 id="4-1-map"><a href="#4-1-map" class="headerlink" title="4.1 map"></a>4.1 map</h3><p>map，可以看到 map 操作符要求输入一个 Function 的函数是接口实例，功能是将 T 类型转换成 R 类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a stream consisting of the results of applying the given</span></span><br><span class="line"><span class="comment"> * function to the elements of this stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is an &lt;a href="package-summary.html#StreamOps"&gt;intermediate</span></span><br><span class="line"><span class="comment"> * operation&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; The element type of the new stream</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mapper a &lt;a href="package-summary.html#NonInterference"&gt;non-interfering&lt;/a&gt;,</span></span><br><span class="line"><span class="comment"> *               &lt;a href="package-summary.html#Statelessness"&gt;stateless&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *               function to apply to each element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the new stream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure><p>map 操作将原来的单词转换成了每个单的长度，利用了 String 自身的 length() 方法，该方法返回类型为 int。这里我直接使用了 lambda 表达式，关于 lambda 表达式还请读者们自行了解吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"grape"</span>)</span><br><span class="line">        .map(e -&gt; e.length()) <span class="comment">// 转成单词的长度 int</span></span><br><span class="line">        .forEach(e -&gt; System.out.println(e)); <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以这样，这里使用了成员函数引用，为了便于读者们理解，后续的例子中将使用 lambda 表达式而非函数引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"grape"</span>)</span><br><span class="line">        .map(String::length) <span class="comment">// 转成单词的长度 int</span></span><br><span class="line">        .forEach(System.out::println); <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">6</span><br><span class="line">12</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="4-2-mapToInt"><a href="#4-2-mapToInt" class="headerlink" title="4.2 mapToInt"></a>4.2 mapToInt</h3><p>mapToInt 将数据流中得元素转成 int，这限定了转换的类型 int，最终产生的流为 IntStream，及结果只能转化成 int。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapToInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"grape"</span>)</span><br><span class="line">        .mapToInt(e -&gt; e.length()) <span class="comment">// 转成int</span></span><br><span class="line">        .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapToInt 示例输出结果同 map 方法示例输出。</p><p>mapToLong、mapToDouble 与 mapToInt 类似，这里不再赘述。</p><h3 id="4-3-flatMap"><a href="#4-3-flatMap" class="headerlink" title="4.3 flatMap"></a>4.3 flatMap</h3><p>flatmap 作用就是将元素拍平拍扁 ，将拍扁的元素重新组成 Stream，并将这些 Stream 串行合并成一条 Stream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFlatMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">"a-b-c-d"</span>, <span class="string">"e-f-i-g-h"</span>)</span><br><span class="line">            .flatMap(e -&gt; Stream.of(e.split(<span class="string">"-"</span>)))</span><br><span class="line">            .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flatmap 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">e</span><br><span class="line">f</span><br><span class="line">i</span><br><span class="line">g</span><br><span class="line">h</span><br></pre></td></tr></table></figure><p>flatmapToInt、flatmapToLong、flatmapToDouble 跟 flatMap 都类似的，只是类型被限定了，这里就不在举例子了。</p><h3 id="4-4-limit"><a href="#4-4-limit" class="headerlink" title="4.4 limit"></a>4.4 limit</h3><p>limit 限制元素的个数，只需传入 long 类型表示限制的最大数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">            .limit(<span class="number">3</span>) <span class="comment">// 限制三个</span></span><br><span class="line">            .forEach(e -&gt; System.out.println(e)); <span class="comment">// 将输出前三个 1，2，3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-distinct"><a href="#4-5-distinct" class="headerlink" title="4.5 distinct"></a>4.5 distinct</h3><p>distinct 将根据 equals 方法进行判断，如果要对自己自定义的 bean 去重，则需要重写equals方法，但是这不是唯一的方法，后面文章我将带大家实现自定义（bean 的某个字段去重）去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistinct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">            .distinct() <span class="comment">// 去重</span></span><br><span class="line">            .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>distinct 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="4-6-filter"><a href="#4-6-filter" class="headerlink" title="4.6 filter"></a>4.6 filter</h3><p>filter 对某些元素进行过滤，不符合筛选条件的将无法进入流的下游。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">            .filter(e -&gt; e &gt;= <span class="number">5</span>) <span class="comment">// 过滤小于 5 的</span></span><br><span class="line">            .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>filter 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="4-7-peek"><a href="#4-7-peek" class="headerlink" title="4.7 peek"></a>4.7 peek</h3><p>peek 挑选 ，将元素挑选出来。返回由该流的元素组成的流，并在从结果流中消费元素之前对每个元素执行提供的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPeek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>, <span class="string">"four"</span>)</span><br><span class="line">            .filter(e -&gt; e.length() &gt; <span class="number">3</span>)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">"Filtered value: "</span> + e))</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .peek(e -&gt; System.out.println(<span class="string">"Mapped value: "</span> + e))</span><br><span class="line">            .collect(Collectors.toList()); <span class="comment">// 将流中元素收集并以 List 进行返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-skip"><a href="#4-8-skip" class="headerlink" title="4.8 skip"></a>4.8 skip</h3><p>skip 跳过元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSkip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">            .skip(<span class="number">4</span>) <span class="comment">// 跳过前四个</span></span><br><span class="line">            .forEach(e -&gt; System.out.println(e)); <span class="comment">// 输出的结果应该只有5，6，7，8，9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skip 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h3 id="4-9-sorted"><a href="#4-9-sorted" class="headerlink" title="4.9 sorted"></a>4.9 sorted</h3><p>sorted 排序 底层依赖 Comparable 实现，也可以提供自定义比较器。</p><p>这里 Integer 本身实现了比较器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSorted_comparable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sorted 默认比较器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>这里使用自定义比较器，当然 User 可以实现 Comparable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSorted_comparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User u1 = <span class="keyword">new</span> User(<span class="string">"u1"</span>, <span class="number">21</span>);</span><br><span class="line">    User u2 = <span class="keyword">new</span> User(<span class="string">"u2"</span>, <span class="number">41</span>);</span><br><span class="line">    User u3 = <span class="keyword">new</span> User(<span class="string">"u3"</span>, <span class="number">29</span>);</span><br><span class="line">    Stream.of(u1, u2, u3)</span><br><span class="line">            .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class="line">            .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User(name=u1, age=21)</span><br><span class="line">User(name=u3, age=29)</span><br><span class="line">User(name=u2, age=41)</span><br></pre></td></tr></table></figure><h3 id="4-10-collect"><a href="#4-10-collect" class="headerlink" title="4.10 collect"></a>4.10 collect</h3><p>collect 收集，使用系统提供的收集器可以将最终的数据流收集到 List，Set，Map 等容器中。</p><p>这里我使用 collect 将元素收集到一个 set 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"apple"</span>)</span><br><span class="line">            .collect(Collectors.toSet()) <span class="comment">//set 容器</span></span><br><span class="line">            .forEach(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咦？不是说终止操作符只能使用一次吗，为什么这里调用了 forEach 呢？forEach 不仅仅是 Stream 中的操作符还是各种集合中的一个语法糖，不信咱们试试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; stringSet = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"apple"</span>)</span><br><span class="line">            .collect(Collectors.toSet()); <span class="comment">// 收集的结果就是set</span></span><br><span class="line">    stringSet.forEach(e -&gt; System.out.println(e)); <span class="comment">// set的语法糖forEach</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">apple</span><br><span class="line">waltermaleon</span><br></pre></td></tr></table></figure><h3 id="4-11-count"><a href="#4-11-count" class="headerlink" title="4.11 count"></a>4.11 count</h3><p>count 统计数据流中的元素个数，返回的是 long 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"grape"</span>)</span><br><span class="line">            .count();</span><br><span class="line">    System.out.println(count); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-12-findFirst"><a href="#4-12-findFirst" class="headerlink" title="4.12 findFirst"></a>4.12 findFirst</h3><p>findFirst 获取流中的第一个元素</p><p>这里找到第一个元素 apple</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; stringOptional = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"grape"</span>)</span><br><span class="line">            .findFirst();</span><br><span class="line">    stringOptional.ifPresent(e-&gt;System.out.println(e)); <span class="comment">// apple</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-13-findAny"><a href="#4-13-findAny" class="headerlink" title="4.13 findAny"></a>4.13 findAny</h3><p>findAny 获取流中任意一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAny</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;String&gt; stringOptional = Stream.of(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">"waltermaleon"</span>, <span class="string">"grape"</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .findAny(); <span class="comment">// 在并行流下每次返回的结果可能一样也可能不一样, 不是并行流则返回流中固定的任意一个</span></span><br><span class="line">    stringOptional.ifPresent(e -&gt; System.out.println(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-14-noneMatch"><a href="#4-14-noneMatch" class="headerlink" title="4.14 noneMatch"></a>4.14 noneMatch</h3><p>noneMatch 数据流中的没有一个元素与条件匹配的，这里的作用是判断数据流中一个都没有与 aa 相等元素 ，但是流中存在 aa ，所以最终结果应该是 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNoneMatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = Stream.of(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"aa"</span>)</span><br><span class="line">            .noneMatch(e -&gt; e.equals(<span class="string">"aa"</span>));</span><br><span class="line">    System.out.println(result); <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>allMatch 和 anyMatch 一个是全匹配，一个是任意匹配和 noneMatch 类似，这里就不在举例了。</p><h3 id="4-15-min"><a href="#4-15-min" class="headerlink" title="4.15 min"></a>4.15 min</h3><p>min 最小的一个，传入比较器，也可能没有(如果数据流为空)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Integer&gt; integerOptional = Stream.of(<span class="number">0</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">1</span>)</span><br><span class="line">            .min((e1, e2) -&gt; e1.compareTo(e2));</span><br><span class="line">    integerOptional.ifPresent(e -&gt; System.out.println(e)); <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-16-max"><a href="#4-16-max" class="headerlink" title="4.16 max"></a>4.16 max</h3><p>max 元素中最大的，需要传入比较器，也可能没有（流为Empty时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Integer&gt; integerOptional = Stream.of(<span class="number">0</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">1</span>)</span><br><span class="line">            .max((e1, e2) -&gt; e1.compareTo(e2));</span><br><span class="line"></span><br><span class="line">    integerOptional.ifPresent(e -&gt; System.out.println(e)); <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-17-reduce"><a href="#4-17-reduce" class="headerlink" title="4.17 reduce"></a>4.17 reduce</h3><p>reduce 是一个规约操作，所有的元素归约成一个，比如对所有元素求和等。</p><p>这里实现了一个加法，指定了初始化的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReduce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = Stream.of(<span class="number">0</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, -<span class="number">1</span>)</span><br><span class="line">            .reduce(<span class="number">0</span>, (e1, e2) -&gt; e1 + e2);</span><br><span class="line">    System.out.println(sum); <span class="comment">// 31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-18-forEach"><a href="#4-18-forEach" class="headerlink" title="4.18 forEach"></a>4.18 forEach</h3><p>forEach 其实前就已经见过了，对每个数据遍历迭代</p><h3 id="4-19-forEachOrdered"><a href="#4-19-forEachOrdered" class="headerlink" title="4.19 forEachOrdered"></a>4.19 forEachOrdered</h3><p>forEachOrdered 适用用于并行流的情况下进行迭代，能保证迭代的<strong>有序性</strong></p><p>这里通过并行的方式输出数字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEachOrdered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .forEachOrdered(e -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + e);</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>forEachOrdered 执行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-6: 0</span><br><span class="line">ForkJoinPool.commonPool-worker-11: 2</span><br><span class="line">ForkJoinPool.commonPool-worker-11: 6</span><br><span class="line">ForkJoinPool.commonPool-worker-11: 5</span><br><span class="line">ForkJoinPool.commonPool-worker-11: 4</span><br><span class="line">ForkJoinPool.commonPool-worker-11: 9</span><br><span class="line">ForkJoinPool.commonPool-worker-11: 8</span><br><span class="line">ForkJoinPool.commonPool-worker-11: -1</span><br></pre></td></tr></table></figure><h3 id="4-20-toArray"><a href="#4-20-toArray" class="headerlink" title="4.20 toArray"></a>4.20 toArray</h3><p>toArray 转成数组，可以提供自定义数组生成器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object[] objects = Stream.of(<span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, -<span class="number">1</span>)</span><br><span class="line">            .toArray();</span><br><span class="line">    System.out.println(Arrays.toString(objects)); <span class="comment">// [0, 2, 6, 5, 4, 9, 8, -1]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Java8Stream 第一篇就带大家认识到这里，如果你能跟着我的文章把每一个例子都敲一遍，相信都能掌握这些操作符的初步用法；后续文章我会带大家一步步深入Stream。</p><blockquote><p>文章来源：<a href="https://www.jianshu.com/p/11c925cdba50" target="_blank" rel="noopener">https://www.jianshu.com/p/11c925cdba50</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDK8 </category>
          
          <category> Stream </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解、学习与使用 Java 中的 Optional</title>
      <link href="/2021/09/11/%E7%90%86%E8%A7%A3%E3%80%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8-Java-%E4%B8%AD%E7%9A%84-Optional/"/>
      <url>/2021/09/11/%E7%90%86%E8%A7%A3%E3%80%81%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8-Java-%E4%B8%AD%E7%9A%84-Optional/</url>
      
        <content type="html"><![CDATA[<p>从 Java 8 引入的一个很有趣的特性是 <em>Optional</em>  类。Optional 类主要解决的问题是臭名昭著的空指针异常（NullPointerException） —— 每个 Java 程序员都非常了解的异常。</p><p>本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。</p><p>Optional 是 Java 实现函数式编程的强劲一步，并且帮助在范式中实现。但是 Optional 的意义显然不止于此。</p><a id="more"></a><p>我们从一个简单的用例开始。在 Java 8 之前，任何访问对象方法或属性的调用都可能导致 <em>NullPointerException</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String isocode = user.getAddress().getCountry().getIsocode().toUpperCase();</span><br></pre></td></tr></table></figure><p>在这个小示例中，如果我们需要确保不触发异常，就得在访问每一个值之前对其进行明确地检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Country country = address.getCountry();</span><br><span class="line">        <span class="keyword">if</span> (country != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String isocode = country.getIsocode();</span><br><span class="line">            <span class="keyword">if</span> (isocode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isocode = isocode.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看到了，这很容易就变得冗长，难以维护。</p><p>为了简化这个过程，我们来看看用 <em>Optional</em> 类是怎么做的。从创建和验证实例，到使用其不同的方法，并与其它返回相同类型的方法相结合，下面是见证 <em>Optional</em>  奇迹的时刻。</p><h3 id="1-创建-Optional-实例"><a href="#1-创建-Optional-实例" class="headerlink" title="1. 创建 Optional 实例"></a>1. 创建 Optional 实例</h3><p>重申一下，这个类型的对象可能包含值，也可能为空。你可以使用同名方法创建一个空的 Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWhenCreateEmptyOptional_thenNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;User&gt; emptyOpt = Optional.empty();</span><br><span class="line">    emptyOpt.get(); <span class="comment">// java.util.NoSuchElementException: No value present</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫不奇怪，尝试访问 <em>emptyOpt</em> 变量的值会导致 <em>NoSuchElementException</em>。方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY; <span class="comment">// Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;();</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException(<span class="string">"No value present"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以使用 <em>of()</em> 和 ofNullable() 方法创建包含值的 <em>Optional*。两个方法的不同之处在于如果你把 *null</em> 值作为参数传递进去，<em>of()</em> 方法会抛出 <em>NullPointerException</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWhenCreateOfEmptyOptional_thenNullPointerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    Optional&lt;User&gt; opt = Optional.of(user); <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Objects.requireNonNull(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，我们并没有完全摆脱 <em>NullPointerException*。因此，你应该明确对象不为 *null</em> 的时候使用 <em>of()</em>。</p><p>如果对象即可能是 <em>null</em> 也可能是非 null，你就应该使用 <em>ofNullable()</em> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; opt = Optional.ofNullable(user);</span><br></pre></td></tr></table></figure><p>这是因为 Java 底层做了如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value == <span class="keyword">null</span> ? empty() : of(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-访问-Optional-对象的值"><a href="#2-访问-Optional-对象的值" class="headerlink" title="2. 访问 Optional 对象的值"></a>2. 访问 Optional 对象的值</h3><p>从 <em>Optional</em> 实例中取回实际值对象的方法之一是使用 <em>get()</em> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWhenCreateOfNullableOptional_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"John"</span>;</span><br><span class="line">    Optional&lt;String&gt; opt = Optional.ofNullable(name);</span><br><span class="line">    System.out.println(opt.get()); <span class="comment">// John</span></span><br><span class="line">    Assert.assertEquals(<span class="string">"John"</span>, opt.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，你看到了，这个方法会在值为 <em>null</em> 的时候抛出异常。要避免异常，你可以选择首先验证是否有值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenCheckIfPresent_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"john@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    Optional&lt;User&gt; opt = Optional.ofNullable(user);</span><br><span class="line">    Assert.assertTrue(opt.isPresent());</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(user.getEmail(), opt.get().getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>isPresent</em> 方法实际就是做了 Optional 值的非空校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查是否有值的另一个选择是 <em>ifPresent()</em> 方法。该方法除了执行检查，还接受一个<em>Consumer(消费者</em>) 参数，如果对象不是空的，就对执行传入的 Lambda 表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt.ifPresent( u -&gt; assertEquals(user.getEmail(), u.getEmail()));</span><br></pre></td></tr></table></figure><p>这个例子中，只有 user 用户不为 null 的时候才会执行断言。</p><p>接下来，我们来看看提供空值的方法。</p><h4 id="2-1-返回默认值"><a href="#2-1-返回默认值" class="headerlink" title="2.1 返回默认值"></a>2.1 返回默认值</h4><p><em>Optional</em> 类提供了 API 用以返回对象值，或者在对象为空的时候返回默认值。</p><p>这里你可以使用的第一个方法是 <em>orElse()</em>，它的工作方式非常直接，如果有值则返回该值，否则返回传递给它的参数值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenEmptyValue_thenReturnDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="string">"anna@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    User result = Optional.ofNullable(user).orElse(user2);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(user2.getEmail(), result.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <em>user</em> 对象是空的，所以返回了作为默认值的 <em>user2</em>。其中 orElse 底层做了如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">orElse</span><span class="params">(T other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对象的初始值不是 null，那么默认值会被忽略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenValueNotNull_thenIgnoreDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"john@gmail.com"</span>,<span class="string">"1234"</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="string">"anna@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    User result = Optional.ofNullable(user).orElse(user2); <span class="comment">// user</span></span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(<span class="string">"john@gmail.com"</span>, result.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个同类型的 API 是 <em>orElseGet()</em> —— 其行为略有不同。这个方法会在有值的时候返回值，如果没有值，它会执行作为参数传入的 <em>Supplier(供应者)</em> 函数式接口，并将返回其执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User result = Optional.ofNullable(user).orElseGet( () -&gt; user2);</span><br></pre></td></tr></table></figure><p><strong>orElse() 和 orElseGet() 的不同之处</strong></p><p>乍一看，这两种方法似乎起着同样的作用。然而事实并非如此。我们创建一些示例来突出二者行为上的异同。</p><p>我们先来看看对象为空时他们的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenEmptyValue_whenCompare_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    User result = Optional.ofNullable(user).orElse(createNewUser(<span class="string">"orElse"</span>));</span><br><span class="line">    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser(<span class="string">"orElseGet"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">createNewUser</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Creating New User with "</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">"extra@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，两种方法都调用了 <em>createNewUser()</em> 方法，这个方法会记录一个消息并返回 <em>User</em> 对象。</p><p>代码输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating New User with orElse</span><br><span class="line">Creating New User with orElseGet</span><br></pre></td></tr></table></figure><p>由此可见，当对象为空而返回默认对象时，行为并无差异。</p><p>我们接下来看一个类似的示例，但这里 <em>Optional</em>  不为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">givenPresentValue_whenCompare_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"john@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    User result = Optional.ofNullable(user).orElse(createNewUser(<span class="string">"orElse"</span>));</span><br><span class="line">    User result2 = Optional.ofNullable(user).orElseGet(() -&gt; createNewUser(<span class="string">"orElseGet"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating New User with orElse</span><br></pre></td></tr></table></figure><p>这个示例中，两个 <em>Optional</em>  对象都包含非空值，两个方法都会返回对应的非空值。不过，<em>orElse()</em> 方法仍然创建了 <em>User</em> 对象。与之相反，<em>orElseGet()</em> 方法不创建 <em>User</em> 对象。</p><p>在执行较密集的调用时，比如调用 Web 服务或数据查询，<strong>这个差异会对性能产生重大影响</strong>。</p><h4 id="2-2-返回异常"><a href="#2-2-返回异常" class="headerlink" title="2.2 返回异常"></a>2.2 返回异常</h4><p>除了 <em>orElse()</em> 和 <em>orElseGet()</em> 方法，Optional 还定义了 <em>orElseThrow()</em> API —— 它会在对象为空的时候抛出异常，而不是返回备选的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenThrowException_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    User result = Optional.ofNullable(user)</span><br><span class="line">        .orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，如果 <em>user</em> 值为 null，会抛出 <em>IllegalArgumentException</em>。</p><p>这个方法让我们有更丰富的语义，可以决定抛出什么样的异常，而不总是抛出 <em>NullPointerException</em>。</p><p>现在我们已经很好地理解了如何使用 Optional，我们来看看其它可以对 <em>Optional</em> 值进行转换和过滤的方法。</p><h4 id="2-3-转换值"><a href="#2-3-转换值" class="headerlink" title="2.3 转换值"></a>2.3 转换值</h4><p>有很多种方法可以转换 <em>Optional</em> 的值。我们从 <em>map()</em> 和 <em>flatMap()</em> 方法开始。</p><p>先来看一个使用 <em>map()</em> API 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenMap_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"anna@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    Optional&lt;String&gt; emailOp = Optional.ofNullable(user).map(u -&gt; u.getEmail());</span><br><span class="line">    String email = emailOp.orElse(<span class="string">"default@gmail.com"</span>);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(email, user.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>map()</em> 对值应用(调用)作为参数的函数，然后将返回的值包装在 <em>Optional</em> 中。这就使对返回值进行链试调用的操作成为可能 —— 这里的下一环就是 <em>orElse()</em>。</p><p>相比这下，<em>flatMap()</em> 需要函数作为 Optional 类型参数，并对值调用这个函数，然后直接返回结果。</p><p>下面的操作中，我们给 <em>User</em> 类添加了一个方法，用来返回 <em>Optional</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">getPosition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然 getter 方法返回 String 值的 <em>Optional*，你可以在对 *User</em> <em>的 Optional</em> 对象调用 <em>flatMap()</em> 时，用它作为参数。其返回的值是解除包装的 String 值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenFlatMap_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"anna@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    user.setPosition(<span class="string">"Developer"</span>);</span><br><span class="line">    String position = Optional.ofNullable(user)</span><br><span class="line">        .flatMap(u -&gt; u.getPosition()).orElse(<span class="string">"default"</span>);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(position, user.getPosition().get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-过滤值"><a href="#2-4-过滤值" class="headerlink" title="2.4 过滤值"></a>2.4 过滤值</h4><p>除了转换值之外，<em>Optional</em> 类也提供了按条件“过滤”值的方法。</p><p><em>filter()</em> 接受一个 <em>Predicate</em> 参数，返回测试结果为 true 的值。如果测试结果为 false，会返回一个空的 <em>Optional</em>。</p><p>来看一个根据基本的电子邮箱验证来决定接受或拒绝 <em>User(用户)</em> 的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenFilter_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"anna@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line">    Optional&lt;User&gt; result = Optional.ofNullable(user)</span><br><span class="line">        .filter(u -&gt; u.getEmail() != <span class="keyword">null</span> &amp;&amp; u.getEmail().contains(<span class="string">"@"</span>));</span><br><span class="line"></span><br><span class="line">    Assert.assertTrue(result.isPresent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果通过过滤器测试，<em>result</em> 对象会包含非空值。</p><h3 id="3-Optional-类的链式方法"><a href="#3-Optional-类的链式方法" class="headerlink" title="3. Optional 类的链式方法"></a>3. Optional 类的链式方法</h3><p>为了更充分的使用 <em>Optional</em>，你可以链接组合其大部分方法，因为它们都返回相同类似的对象。</p><p>我们使用 <em>Optional</em> 重写最早介绍的示例。</p><p>首先，重构类，使其 getter 方法返回 <em>Optional</em> 引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Address&gt; <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Country country;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Country&gt; <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(country);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String isocode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的嵌套结构可以用下面的图来表示：</p><p><img src="/2021/09/11/理解、学习与使用-Java-中的-Optional/image-20210911174435876.png" alt></p><p>现在可以删除 <em>null</em> 检查，替换为 <em>Optional</em> 的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenChaining_thenOk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"anna@gmail.com"</span>, <span class="string">"1234"</span>);</span><br><span class="line"></span><br><span class="line">    String result = Optional.ofNullable(user)</span><br><span class="line">      .flatMap(u -&gt; u.getAddress())</span><br><span class="line">      .flatMap(a -&gt; a.getCountry())</span><br><span class="line">      .map(c -&gt; c.getIsocode())</span><br><span class="line">      .orElse(<span class="string">"default"</span>);</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(result, <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以通过方法引用进一步缩减：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String result = Optional.ofNullable(user)</span><br><span class="line">  .flatMap(User::getAddress)</span><br><span class="line">  .flatMap(Address::getCountry)</span><br><span class="line">  .map(Country::getIsocode)</span><br><span class="line">  .orElse(<span class="string">"default"</span>);</span><br></pre></td></tr></table></figure><p>结果现在的代码看起来比之前采用条件分支的冗长代码简洁多了。</p><h3 id="4-Optional-应该怎么用？"><a href="#4-Optional-应该怎么用？" class="headerlink" title="4. Optional 应该怎么用？"></a>4. Optional 应该怎么用？</h3><p>在使用 <em>Optional</em> 的时候需要考虑一些事情，以决定什么时候怎样使用它。</p><p>重要的一点是 <strong><em>Optional</em></strong> <strong>不是</strong> <strong><em>Serializable</em></strong>。因此，它不应该用作类的字段。</p><p>如果你需要序列化的对象包含 <em>Optional</em> 值，<a href="https://stackify.com/java-xml-jackson/" target="_blank" rel="noopener"><em>Jackson</em> 库</a>支持把 <em>Optional</em> 当作普通对象。也就是说，<em>Jackson</em> 会把空对象看作 <em>null</em>，而有值的对象则把其值看作对应域的值。这个功能在 <a href="https://github.com/FasterXML/jackson-modules-java8" target="_blank" rel="noopener">jackson-modules-java8</a> 项目中。</p><p>它在另一种情况下也并不怎么有用，就是在将其类型用作方法或构建方法的参数时。这样做会让代码变得复杂，完全没有必要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"john@gmail.com"</span>, <span class="string">"1234"</span>, Optional.empty());</span><br></pre></td></tr></table></figure><p>使用重载方法来处理非空的参数要容易得多。</p><p><em>Optional</em> 主要用作返回类型。在获取到这个类型的实例后，如果它有值，你可以取得这个值，否则可以进行一些替代行为。</p><p><em>Optional</em> 类有一个非常有用的用例，就是将其与流或其它返回 <em>Optional</em> 的方法结合，以<strong>构建流畅的API</strong>。</p><p>我们来看一个示例，使用 <em>Stream</em> 返回 <em>Optional</em> 对象的 <em>findFirst()</em> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whenEmptyStream_thenReturnDefaultOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    User user = users.stream().findFirst().orElse(<span class="keyword">new</span> User(<span class="string">"default"</span>, <span class="string">"1234"</span>));</span><br><span class="line"></span><br><span class="line">    Assert.assertEquals(user.getEmail(), <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><em>Optional</em> 是 Java 语言的有益补充 —— 它旨在减少代码中的 <em>NullPointerExceptions</em>，虽然还不能完全消除这些异常。</p><p>它也是精心设计，自然融入 Java 8 函数式支持的功能。</p><p>总的来说，这个简单而强大的类有助于创建简单、可读性更强、比对应程序错误更少的程序。</p><blockquote><p>来源： <a href="https://www.oschina.net/translate/understanding-accepting-and-leveraging-optional-in?lang=chs&amp;page=2#" target="_blank" rel="noopener">https://www.oschina.net/translate/understanding-accepting-and-leveraging-optional-in?lang=chs&amp;page=2#</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDK8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 团队协作和远程库操作</title>
      <link href="/2021/08/14/Git-%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E5%92%8C-Github-%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/08/14/Git-%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E5%92%8C-Github-%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git-团队协作机制"><a href="#1-Git-团队协作机制" class="headerlink" title="1. Git 团队协作机制"></a>1. Git 团队协作机制</h2><h3 id="1-2-团队内协作"><a href="#1-2-团队内协作" class="headerlink" title="1.2 团队内协作"></a>1.2 团队内协作</h3><p><img src="/2021/08/14/Git-团队协作和-Github-操作/image-20210814161540306.png" alt="团队内协作"></p><p>我们以一个示例来介绍一下 Git 团队内是如何协作的。查看上图，首先岳不群会在本地创建一个本地库，然后 push 推送到远程库。此时令狐冲可以从远程库 clone 克隆项目到他自己的本地库中，然后令狐冲在本地库修改了部分项目代码并 push 到远程库中（前提是岳不群的远程库认为令狐冲是同一个团队的）。此时岳不群可以 pull 拉去远程库中最新的代码，也就是可以获取到令狐冲提交的代码。</p><a id="more"></a><h3 id="1-3-跨团队协作"><a href="#1-3-跨团队协作" class="headerlink" title="1.3 跨团队协作"></a>1.3 跨团队协作</h3><p><img src="/2021/08/14/Git-团队协作和-Github-操作/image-20210814162034633.png" alt="跨团队协作"></p><p>同样以一个示例来介绍一下 Git 跨团队是如何协作的。查看上图，首先已经存在一个岳不群的远程仓库，东方不败觉得岳不群的项目的不错就从岳不群的远程库 fork 了一份到自己的远程仓库中，然后东方不败将自己远程仓库的代码 clone 到其本地仓库中并在修改之后 push 到自己的远程仓库中。东方不败在对岳不群的项目进行补充修改之后向岳不群发起了一个 Pull request 请求。此时岳不群会收到东方不败的请求，在进行审核后进行 merge 合并到自己的远程库中。此时岳不群和令狐冲都可以岳不群的远程仓库中 pull 代码到自己的本地仓库中，也就能看到东方不败的代码。</p><h2 id="2-远程库操作"><a href="#2-远程库操作" class="headerlink" title="2. 远程库操作"></a>2. 远程库操作</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程仓库地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程仓库地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程库地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与 当前本地分支直接合并</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的分支</title>
      <link href="/2021/08/14/Git-%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2021/08/14/Git-%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是分支"><a href="#1-什么是分支" class="headerlink" title="1. 什么是分支"></a>1. 什么是分支</h2><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。（分支底层其实也是指针的引用）</p><p><img src="/2021/08/14/Git-的分支/image-20210814153546419.png" alt></p><a id="more"></a><h2 id="2-分支的操作"><a href="#2-分支的操作" class="headerlink" title="2. 分支的操作"></a>2. 分支的操作</h2><p><img src="/2021/08/14/Git-的分支/image-20210814153633146.png" alt></p><h3 id="2-1-查看分支"><a href="#2-1-查看分支" class="headerlink" title="2.1 查看分支"></a>2.1 查看分支</h3><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的分支/image-20210814153732874.png" style=" margin-left: 0px"><p>*  号代表当前所在的分区，也就是 master 主分区</p><h3 id="2-2-创建分支"><a href="#2-2-创建分支" class="headerlink" title="2.2 创建分支"></a>2.2 创建分支</h3><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch 分支名</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的分支/image-20210814153948857.png" style=" margin-left: 0px"><h3 id="2-3-修改分支数据"><a href="#2-3-修改分支数据" class="headerlink" title="2.3 修改分支数据"></a>2.3 修改分支数据</h3><img src="/2021/08/14/Git-的分支/image-20210814154418900.png" style=" margin-left: 0px"><h3 id="2-4-切换分支"><a href="#2-4-切换分支" class="headerlink" title="2.4 切换分支"></a>2.4 切换分支</h3><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的分支/image-20210814154606826.png" style=" margin-left: 0px"><p>可以发现，hotfix 分支的数据和 master 分支的数据不太一样。下面我们对 hotfix 分支的数据进行简单地的修改，具体如下所示，然后提交到本地库。</p><img src="/2021/08/14/Git-的分支/image-20210814160828201.png" style=" margin-left: 0px"><h3 id="2-5-合并分支"><a href="#2-5-合并分支" class="headerlink" title="2.5 合并分支"></a>2.5 合并分支</h3><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 分支名</span><br></pre></td></tr></table></figure><p>2）案例实操 在 master 分支上合并 hot-fix 分支</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge hotfix</span><br></pre></td></tr></table></figure><h3 id="2-6-产生冲突"><a href="#2-6-产生冲突" class="headerlink" title="2.6 产生冲突"></a>2.6 产生冲突</h3><p>冲突产生的表现：后面状态为 MERGING</p><img src="/2021/08/14/Git-的分支/image-20210814160302670.png" style=" margin-left: 0px"><p>冲突产生的原因： 合并分支时，两个分支在<strong>同一个文件的同一个位置</strong>有两套完全不同的修改。Git 无法替我们决定使用哪一个。必须人为决定新代码内容。 </p><p>查看状态（检测到有文件有两处修改）</p><img src="/2021/08/14/Git-的分支/image-20210814160355537.png" style=" margin-left: 0px"><h4 id="2-6-1-解决冲突"><a href="#2-6-1-解决冲突" class="headerlink" title="2.6.1 解决冲突"></a>2.6.1 解决冲突</h4><p>1）编辑有冲突的文件，删除特殊符号，决定要使用的内容</p><p>特殊符号：&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 当前分支的代码 ======= 合并过来的代码 &gt;&gt;&gt;&gt;&gt;&gt;&gt; hotfix，重新修改 hello.txt 如下：</p><img src="/2021/08/14/Git-的分支/image-20210814160628627.png" style=" margin-left: 0px"><p>2）添加到暂存区</p><p>3）执行提交（注意：此时使用 git commit 命令时不能带文件名）</p><img src="/2021/08/14/Git-的分支/image-20210814160736113.png" style=" margin-left: 0px">]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 的基本命令</title>
      <link href="/2021/08/14/Git-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/08/14/Git-%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git-工作机制"><a href="#1-Git-工作机制" class="headerlink" title="1. Git 工作机制"></a>1. Git 工作机制</h2><img src="/2021/08/14/Git-的基本使用/image-20210814144256051.png" alt style="zoom:80%; margin-left: 0px;"><p>如上图，首先我们会在工作区编写代码，然后使用 <code>git add</code> 命令在代码提交的暂存区之中，最后使用<code>git commit</code> 将代码提交到本地仓库。<a id="more"></a></p><h2 id="2-Git-常用命令"><a href="#2-Git-常用命令" class="headerlink" title="2. Git 常用命令"></a>2. Git 常用命令</h2><table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config –global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config –global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td>git init</td><td>初始化本地库</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git add 文件名</td><td>添加到暂存区</td></tr><tr><td>git commit -m “日志信息” 文件名</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git log</td><td>查看详细历史记录</td></tr><tr><td>git reset –hard 版本号</td><td>版本穿梭</td></tr></tbody></table><h3 id="2-1-设置用户签名"><a href="#2-1-设置用户签名" class="headerlink" title="2. 1 设置用户签名"></a>2. 1 设置用户签名</h3><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure><p>2）案例实操</p><p>全局范围的签名设置：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">admin@DESKTOP-MVDUOEL MINGW64 ~/Desktop/helloGit (master)</span><br><span class="line">$ git config --global user.name ShotoZheng</span><br><span class="line"></span><br><span class="line">admin@DESKTOP-MVDUOEL MINGW64 ~/Desktop/helloGit (master)</span><br><span class="line">$ git config --global user.email shotozheng@<span class="number">163</span>.com</span><br><span class="line"></span><br><span class="line">admin@DESKTOP-MVDUOEL MINGW64 ~/Desktop/helloGit (master)</span><br><span class="line">$ cat ~/.gitconfig</span><br><span class="line">[user]</span><br><span class="line">        email = shotozheng@<span class="number">163</span>.com</span><br><span class="line">        name = ShotoZheng</span><br><span class="line">[http]</span><br><span class="line">        sslVerify = false</span><br><span class="line"></span><br><span class="line">admin@DESKTOP-MVDUOEL MINGW64 ~/Desktop/helloGit (master)</span><br></pre></td></tr></table></figure><p>说明： 签名的作用是区分不同操作者身份。用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。</p><p><span style="color: red">※注意</span>：这里设置用户签名和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。</p><h3 id="2-2-初始化本地库"><a href="#2-2-初始化本地库" class="headerlink" title="2.2 初始化本地库"></a>2.2 初始化本地库</h3><p>1）基本语法 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的基本使用/image-20210814145417593.png" alt style=" margin-left: 0px;"><p>3）结果查看</p><img src="/2021/08/14/Git-的基本使用/image-20210814145456756.png" alt style=" margin-left: 0px;"><h3 id="2-3-查看本地库状态"><a href="#2-3-查看本地库状态" class="headerlink" title="2.3 查看本地库状态"></a>2.3 查看本地库状态</h3><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>2）案例实操</p><h4 id="2-3-1-首次查看（工作区没有任何文件）"><a href="#2-3-1-首次查看（工作区没有任何文件）" class="headerlink" title="2.3.1 首次查看（工作区没有任何文件）"></a>2.3.1 首次查看（工作区没有任何文件）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814145631043.png" alt style=" margin-left: 0px;"><h4 id="2-3-2-新增文件（hello-txt）"><a href="#2-3-2-新增文件（hello-txt）" class="headerlink" title="2.3.2  新增文件（hello.txt）"></a>2.3.2  新增文件（hello.txt）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814145800460.png" alt style=" margin-left: 0px;"><h4 id="2-3-3-再次查看（检测到未追踪的文件）"><a href="#2-3-3-再次查看（检测到未追踪的文件）" class="headerlink" title="2.3.3 再次查看（检测到未追踪的文件）"></a>2.3.3 再次查看（检测到未追踪的文件）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814150911572.png" alt style=" margin-left: 0px;"><h3 id="2-4-添加暂存区"><a href="#2-4-添加暂存区" class="headerlink" title="2.4 添加暂存区"></a>2.4 添加暂存区</h3><h4 id="2-4-1-将工作区的文件添加到暂存区"><a href="#2-4-1-将工作区的文件添加到暂存区" class="headerlink" title="2.4.1 将工作区的文件添加到暂存区"></a>2.4.1 将工作区的文件添加到暂存区</h4><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的基本使用/image-20210814151104402.png" alt style=" margin-left: 0px;"><h4 id="2-4-2-查看状态（检测到暂存区有新文件）"><a href="#2-4-2-查看状态（检测到暂存区有新文件）" class="headerlink" title="2.4.2 查看状态（检测到暂存区有新文件）"></a>2.4.2 查看状态（检测到暂存区有新文件）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814151155259.png" alt style=" margin-left: 0px;"><h3 id="2-5-提交本地库"><a href="#2-5-提交本地库" class="headerlink" title="2.5 提交本地库"></a>2.5 提交本地库</h3><h4 id="2-5-1-将暂存区的文件提交到本地库"><a href="#2-5-1-将暂存区的文件提交到本地库" class="headerlink" title="2.5.1 将暂存区的文件提交到本地库"></a>2.5.1 将暂存区的文件提交到本地库</h4><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"日志信息"</span> 文件名</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的基本使用/image-20210814151337018.png" alt style=" margin-left: 0px;"><h4 id="2-5-2-查看状态（没有文件需要提交）"><a href="#2-5-2-查看状态（没有文件需要提交）" class="headerlink" title="2.5.2 查看状态（没有文件需要提交）"></a>2.5.2 查看状态（没有文件需要提交）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814151419795.png" alt style=" margin-left: 0px;"><h3 id="2-6-修改文件（hello-txt）"><a href="#2-6-修改文件（hello-txt）" class="headerlink" title="2.6 修改文件（hello.txt）"></a>2.6 修改文件（hello.txt）</h3><img src="/2021/08/14/Git-的基本使用/image-20210814151755112.png" alt style=" margin-left: 0px;"><h4 id="2-6-1-查看状态（检测到工作区有文件被修改）"><a href="#2-6-1-查看状态（检测到工作区有文件被修改）" class="headerlink" title="2.6.1 查看状态（检测到工作区有文件被修改）"></a>2.6.1 查看状态（检测到工作区有文件被修改）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814151851419.png" alt style=" margin-left: 0px;"><h4 id="2-6-2-将修改的文件再次添加暂存区"><a href="#2-6-2-将修改的文件再次添加暂存区" class="headerlink" title="2.6.2 将修改的文件再次添加暂存区"></a>2.6.2 将修改的文件再次添加暂存区</h4><img src="/2021/08/14/Git-的基本使用/image-20210814151931892.png" alt style=" margin-left: 0px;"><h4 id="2-6-3-查看状态（工作区的修改添加到了暂存区）"><a href="#2-6-3-查看状态（工作区的修改添加到了暂存区）" class="headerlink" title="2.6.3 查看状态（工作区的修改添加到了暂存区）"></a>2.6.3 查看状态（工作区的修改添加到了暂存区）</h4><img src="/2021/08/14/Git-的基本使用/image-20210814152013210.png" alt style=" margin-left: 0px;"><h3 id="2-7-历史版本"><a href="#2-7-历史版本" class="headerlink" title="2.7 历史版本"></a>2.7 历史版本</h3><h4 id="2-7-1-查看历史版本"><a href="#2-7-1-查看历史版本" class="headerlink" title="2.7.1 查看历史版本"></a>2.7.1 查看历史版本</h4><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog 查看版本信息</span><br><span class="line">git <span class="built_in">log</span> 查看版本详细信息</span><br></pre></td></tr></table></figure><p>2）案例实操</p><img src="/2021/08/14/Git-的基本使用/image-20210814152221410.png" alt style=" margin-left: 0px;"><img src="/2021/08/14/Git-的基本使用/image-20210814152254811.png" alt style=" margin-left: 0px;"><h4 id="2-7-2-版本穿梭"><a href="#2-7-2-版本穿梭" class="headerlink" title="2.7.2 版本穿梭"></a>2.7.2 版本穿梭</h4><p>1）基本语法</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure><p>2）案例实操</p><ul><li><p>首先查看当前的历史记录，可以看到当前是在 96769f1 这个版本</p>  <img src="/2021/08/14/Git-的基本使用/image-20210814152221410.png" alt style=" margin-left: 0px;"></li><li><p>切换到 f296c3e版本，也就是我们第一次提交的版本</p>  <img src="/2021/08/14/Git-的基本使用/image-20210814152629111.png" alt style=" margin-left: 0px;"></li><li><p>切换完毕之后再查看历史记录，当前成功切换到了 f296c3e版本</p><img src="/2021/08/14/Git-的基本使用/image-20210814152737707.png" alt style=" margin-left: 0px;"></li><li><p>然后查看文件 hello.txt，发现文件内容已经变化</p>  <img src="/2021/08/14/Git-的基本使用/image-20210814152925055.png" alt style=" margin-left: 0px;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openFeign 远程调用丢失请求头问题</title>
      <link href="/2021/07/18/openFeign-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2021/07/18/openFeign-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718111752865.png" alt="openFeign 远程调用"></p><a id="more"></a><p>上图是 OpenFeign 远程调用的一个流程图，首先浏览器有一个向订单服务的请求1，由于用户已经登录此时该请求则默认带上了相关的 Cookie 信息。在订单服务中，其需要通过远程调用去请求购物车服务获取对应的数据，因而创建了对应的新的请求2。默认情况下该请求不会有任何 Cookie 等信息。因此在调用购物车服务时，由于购物车服务会判断用户是否已经登录从而去取请求的 Cookie ，因此此时请求2  的 Cookie 不存在从而购物车服务无法正常调用。</p><p>如下是订单服务的一个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取订单确认信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderConfirmVo <span class="title">confirmOrder</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    OrderConfirmVo confirmVo = <span class="keyword">new</span> OrderConfirmVo();</span><br><span class="line">    <span class="comment">// openfeign 远程调用购物车服务</span></span><br><span class="line">    List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();</span><br><span class="line">    confirmVo.setItems(items);</span><br><span class="line">    <span class="keyword">return</span> confirmVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>购物车服务存在如下拦截器，其会拦截所有未登录用户的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfoTo&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从 session 中获取登录的用户信息，如果为空则不放行</span></span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        MemberRespVo member = (MemberRespVo) session.getAttribute(AuthServerConstant.LOGIN_USER);</span><br><span class="line">        <span class="keyword">if</span> (member == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们通过代码调试时，confirmOrder 方法中第 8 行中的 cartFeignService 对象实际为一个代理对象，调用 getCurrentUserCartItems 方法时，其首先会调用 ReflectiveFeign 的 invoke 方法，如下图：</p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718113659790.png" style="zoom:80%;"><p>然后则是调用 SynchronousMethodHandler 的 invoke 方法：</p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718113811729.png" style="zoom:80%;"><p>接着会调用执行方法 executeAndDecode 方法，该方法首先会通过调用 targetRequest 获取请求信息：</p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718113958648.png" style="zoom:80%;"><p>targetRequest 方法中会遍历所有请求器链获取其次 openFeign 调用的所有请求信息：</p><p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718114048161.png" alt="image-20210718114048161"></p><p>默认情况下 requestInterceptors 对象没有任何请求拦截器信息，因此 targetRequest 方法也就无法获取到任何请求信息。那么为了让 openFeign 的请求带上 Cookie 等信息，我们的解决办法就是向 Spring 容器中加入 RequestInterceptor，然后在该 RequestInterceptor 中封装我们的 Cookie 等信息即可。如下是<strong>订单服务</strong>的 RequestInterceptor 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向容器中加入请求拦截器，并封装当前请求的 Cookie 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"requestInterceptor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">requestInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//1、RequestContextHolder拿到当前订单服务的请求</span></span><br><span class="line">                ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">                <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    HttpServletRequest request = attributes.getRequest();</span><br><span class="line">                    <span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//同步请求头数据，Cookie</span></span><br><span class="line">                        String cookie = request.getHeader(<span class="string">"Cookie"</span>);</span><br><span class="line">                        <span class="comment">//给远程调用的新请求同步了当前请求的cookie</span></span><br><span class="line">                        template.header(<span class="string">"Cookie"</span>, cookie);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们便解决了 confirmOrder 方法在<strong>单线程</strong>远程调用购物车服务时的 openFeign 调用丢失请求头的问题。如下是相关示意图：</p><p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718115410177.png" alt></p><p>为什么这里要强调是在单线程情况下，下面我们改造 confirmOrder 方法，将其改造为多线程异步执行的执行方式。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderConfirmVo <span class="title">confirmOrder</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    OrderConfirmVo confirmVo = <span class="keyword">new</span> OrderConfirmVo();</span><br><span class="line">    log.info(<span class="string">"主线程...."</span> + Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; cartFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//远程查询购物车所有选中的购物项</span></span><br><span class="line">        log.info(<span class="string">"cart线程...."</span> + Thread.currentThread().getId());</span><br><span class="line">        List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();</span><br><span class="line">        confirmVo.setItems(items);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    CompletableFuture.allOf(cartFuture).get();</span><br><span class="line">    <span class="keyword">return</span> confirmVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时就会产生一个新的问题，调用订单服务的请求1所在的 ThreadLocal 包含有用户登录的信息，但是远程调用购物车服务的请求2 的 ThreadLocal 没有包含用户登录信息，因为两个请求不在同一个线程，请求2 在设置请求拦截器 RequestInterceptor  时使用的 RequestContextHolder 请求上下文是属于不同线程的，只有请求1 的 RequestContextHolder 才具备 Cookie 等信息，那么请求2 在设置  Cookie 时就会不起作用。为了解决可以问题，我们可以在 confirmOrder 方法中为请求2 手动设置上下文信息，那么请求2 就包含有对应的 Cookie 等信息，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderConfirmVo <span class="title">confirmOrder</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    OrderConfirmVo confirmVo = <span class="keyword">new</span> OrderConfirmVo();</span><br><span class="line">    log.info(<span class="string">"主线程...."</span> + Thread.currentThread().getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程请求上下文，向子线程设置请求上下文</span></span><br><span class="line">    RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    CompletableFuture&lt;Void&gt; cartFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//远程查询购物车所有选中的购物项</span></span><br><span class="line">        log.info(<span class="string">"cart线程...."</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">// 每一个线程都来共享之前的请求数据</span></span><br><span class="line">        RequestContextHolder.setRequestAttributes(requestAttributes);</span><br><span class="line">        List&lt;OrderItemVo&gt; items = cartFeignService.getCurrentUserCartItems();</span><br><span class="line">        confirmVo.setItems(items);</span><br><span class="line">    &#125;, executor);</span><br><span class="line"></span><br><span class="line">    CompletableFuture.allOf(cartFuture).get();</span><br><span class="line">    <span class="keyword">return</span> confirmVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是单线程和多线程不同情况下的示意图：</p><p><img src="/2021/07/18/openFeign-远程调用丢失请求头问题/image-20210718122323455.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
          <category> OpenFeign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）谷粒商城开发-认证服务开发</title>
      <link href="/2021/07/12/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2021/07/12/%EF%BC%88%E4%BA%94%EF%BC%89%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-用户注册"><a href="#1-用户注册" class="headerlink" title="1. 用户注册"></a>1. 用户注册</h2><h3 id="1-1-发送验证码"><a href="#1-1-发送验证码" class="headerlink" title="1.1 发送验证码"></a>1.1 发送验证码</h3><ul><li><input checked disabled type="checkbox"> 使用 Redis 缓存存储指定生存时间验证码，其中手机号为 key，值的时间戳 + 验证码。时间戳的作用用于实现用户执行时间内不能重复发送验证码；</li><li><input checked disabled type="checkbox"> 验证码的发送采阿里云第三方服务实现，传入指定手机号和验证码；</li><li><input checked disabled type="checkbox"> 缓存中的验证码未过期且与用户的验证码相互匹配，且此时支持再次发送验证码，那么再次调用第三方服务发送验证码；</li><li><input checked disabled type="checkbox"> 缓存中的验证码已经过期，那么生成新的验证码并调用第三方服务发送验证码。</li></ul><a id="more"></a><h3 id="1-2-用户密码加密"><a href="#1-2-用户密码加密" class="headerlink" title="1.2 用户密码加密"></a>1.2 用户密码加密</h3><p>为了保证用户的数据安全，用户的密码需要以密文的方式存储到数据库中，如下是几种加密策略：</p><h4 id="1-2-1-MD5-加密"><a href="#1-2-1-MD5-加密" class="headerlink" title="1.2.1 MD5 加密"></a>1.2.1 MD5 加密</h4><p>可以使用 MD5 工具类实现密码进行加密，虽然 MD5 加密是不可逆的，但是可能会被暴力破解</p><h4 id="1-2-2-MD5-盐值加密"><a href="#1-2-2-MD5-盐值加密" class="headerlink" title="1.2.2 MD5 盐值加密"></a>1.2.2 MD5 盐值加密</h4><p>在 MD5 加密的基础上，可以生成一段随机的盐值（随机序列）并按照<strong>自定义拼接规则（避免通过盐值反向破解）</strong>与对密码进行拼接，不过这个盐值需要存储到数据库中。此方法虽然可以避免密码被破解，但是需要向数据库存储盐值。</p><h4 id="1-2-3-BCrypt-加密"><a href="#1-2-3-BCrypt-加密" class="headerlink" title="1.2.3 BCrypt 加密"></a>1.2.3 BCrypt 加密</h4><p>spring security 提供了一个加密工具，可以实现比 MD5 盐值加密更便捷和优异的加密结果，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 密码加密逻辑</span></span><br><span class="line">BCryptPasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">String encode = passwordEncoder.encode(<span class="string">"这是密码"</span>);</span><br><span class="line"><span class="comment">// 密码入库...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 密码匹配逻辑</span></span><br><span class="line">String password = <span class="string">"这是密码"</span>; <span class="comment">// 用户输入的密码</span></span><br><span class="line">String passwordDb = <span class="string">"asdhashdashd"</span>; <span class="comment">//  从数据库获取的密码密文</span></span><br><span class="line">BCryptPasswordEncoder passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line"><span class="keyword">boolean</span> matches = passwordEncoder.matches(password, passwordDb);</span><br><span class="line"><span class="keyword">if</span> (matches) &#123;</span><br><span class="line">    <span class="comment">// 为 true 则密码匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-分布式-Session-共享和-SpringSession-原理"><a href="#2-分布式-Session-共享和-SpringSession-原理" class="headerlink" title="2. 分布式 Session 共享和 SpringSession 原理"></a>2. 分布式 Session 共享和 SpringSession 原理</h2><h3 id="2-1-Session-共享问题"><a href="#2-1-Session-共享问题" class="headerlink" title="2.1 Session 共享问题"></a>2.1 Session 共享问题</h3><p>在单服务应用下，用户使用浏览器登录成功后，后台会生成一个指定 sessioId 的 Cookie 并命令浏览器保存起来。用户下次进行访问网站时就可以带上该 Cookie 进行用户验证通过时就可以免登录操作。</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714222320517.png" alt="单服务 session 获取"></p><p>但是单服务应用下，不能跨子域名和多服务共享 session。如下图，比如存在多个会员服务，因为存在第一个会员服务存在 session 而第二个会员服务不存在 session，那么就存在服务之间的共享问题。而对于不同的服务则存在跨域名 session 共享问题，比如用户使用会员服务登录成功后获取到 session，但是订单服务则无法获取。</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714222802194.png" alt="单服务 session 共享问题"></p><h3 id="2-2-Session-共享问题解决策略"><a href="#2-2-Session-共享问题解决策略" class="headerlink" title="2.2 Session 共享问题解决策略"></a>2.2 Session 共享问题解决策略</h3><p>1）<strong>Session 复制同步方案</strong>：比如不同 tomcat 之间进行 session 复制同步共享</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714223353431.png" alt="Session 复制同步方案"></p><p>2）客户端以 Cookie 形式存储 session</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714223532730.png" alt="客户端存储"></p><p>3）Hash 一致性：将不同的 IP 以 hash 形式映射到多台服务器上，由指定服务器存储对应 session 信息</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714223744395.png" alt="Hash 一致性"></p><p>4）统一 session 存储</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714224034521.png" alt="统一存储"></p><p>5）跨域名-子域 session 共享问题</p><p>前面已经说过，普通的 session 机制对于不同子域名之间的 session 共享是不起作用的，即不同域名之间无法进行 session 共享。但是我们可以设置 session 的作用域，即扩大其作用域到父域名上，这样不同的子域就可以实现 session 共享。</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714224708671.png" alt="子域 session 共享问题"></p><h3 id="2-3-SpringSession-原理"><a href="#2-3-SpringSession-原理" class="headerlink" title="2.3 SpringSession 原理"></a>2.3 SpringSession 原理</h3><p>SpringSession 是 Spring 提供的一个分布式 session 共享框架，其可以采用公共的存储容器（MongoDB、Redis）来存储多个服务的 Session 信息，并支持设置 Session  的作用域，其可以简单的解决 Session 共享问题。</p><p>如下是 SpringSession 的核心代码，其重点就是 SpringSession 对原有的 Session 对应进行了重新和包装（装饰者模式），后面我们在登录成功后往前端生成返回 Cookie 时的 Sesssion 对象就是 SpringSession 包装后的。</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714225257026.png" alt="SpringSession 核心代码"></p><h2 id="3-用户登录"><a href="#3-用户登录" class="headerlink" title="3. 用户登录"></a>3. 用户登录</h2><h3 id="3-1-OAuth2-社交账号登录"><a href="#3-1-OAuth2-社交账号登录" class="headerlink" title="3.1 OAuth2 社交账号登录"></a>3.1 OAuth2 社交账号登录</h3><p>社交登录流程如下所示：</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714220925734.png" alt="社交登录流程"></p><h3 id="3-2-单点登录"><a href="#3-2-单点登录" class="headerlink" title="3.2 单点登录"></a>3.2 单点登录</h3><p>下图是存在认证中心的分布式单点登录流程：</p><p><img src="/2021/07/12/（五）谷粒商城开发-认证服务开发/image-20210714233512324.png" alt="单点登录"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CompletableFuture 异步编排</title>
      <link href="/2021/07/10/CompletableFuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/"/>
      <url>/2021/07/10/CompletableFuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p><code>Future</code> 是 Java 5 添加的类，用来描述一个异步计算的结果。你可以使用<code>isDone</code>方法检查计算是否完成，或者使用<code>get</code>阻塞住调用线程，直到计算完成返回结果，你也可以使用<code>cancel</code> 方法停止任务的执行。</p><p>虽然 <code>Future</code> 以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的 初衷相违背，轮询的方式又会耗费无谓的 CPU 资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？<a id="more"></a></p><p>很多语言，比如 Node.js，采用回调的方式实现异步编程。Java 的一些框架，比如 Netty，自己扩展了 Java 的 <code>Future</code> 接口，提供了 <code>addListener</code> 等多个扩展方法；Google guava 也提供了通用的扩展 Future；Scala 也提供了简单易用且功能强大的 Future/Promise 异步编程模式。</p><p>作为正统的 Java 类库，是不是应该做点什么，加强一下自身库的功能呢？</p><p>在 Java 8 中, 新增加了一个包含 50 个方法左右的类: CompletableFuture，提供了非常强大的 Future 的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合 CompletableFuture 的方法。 CompletableFuture 类实现了 Future 接口，所以你还是可以像以前一样通过<code>get</code>方法阻塞或者轮询的方式获得结果，但是这种方式不推荐使用。</p><p>CompletableFuture 和 FutureTask 同属于 Future 接口的实现类，都可以获取线程的执行结果。</p><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710164910977.png" alt="类结构图"></p><h2 id="1-异步对象创建"><a href="#1-异步对象创建" class="headerlink" title="1. 异步对象创建"></a>1. 异步对象创建</h2><p>CompletableFuture 提供了如下四个静态方法来创建一个异步操作：</p><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710165027426.png" alt="静态方法"></p><ul><li><p>runXxxx 都是没有返回结果的，supplyXxx 都是可以获取返回结果的；</p></li><li><p>可以传入自定义的线程池，否则就用默认的线程池；</p></li><li><p>Supplier 是一个函数式接口，该接口内定义了一个 get 方法，我们只需在方法内定义要执行的任务即可。Supplier 的具体如下代码所示：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>创建示例：</p><ul><li>runAsync(Runnable runnable, Executor executor )</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 线程池 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"runAsync..."</span>);</span><br><span class="line">        &#125;, threadPool);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runAsync(Runnable runnable)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"supplyAsync..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"哈哈哈哈"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 任务执行结果：哈哈哈哈</span></span><br><span class="line">    log.info(<span class="string">"任务执行结果：&#123;&#125;"</span>, future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-任务完成时回调"><a href="#2-任务完成时回调" class="headerlink" title="2. 任务完成时回调"></a>2. 任务完成时回调</h2><h3 id="2-1-whenComplete-方法"><a href="#2-1-whenComplete-方法" class="headerlink" title="2.1 whenComplete 方法"></a>2.1 whenComplete 方法</h3><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710172647015.png" alt="回调方法"></p><p>whenComplete 可以处理正常和异常的计算结果，exceptionally 处理异常情况。</p><p>whenComplete 和 whenCompleteAsync 的区别： </p><ul><li><strong>whenComplete：是执行当前任务的线程执行继续执行 whenComplete 中的任务。</strong></li><li><strong>whenCompleteAsync：是执行完当前任务之后把 whenCompleteAsync 中的任务提交给线程池来进行执行。</strong></li></ul><p>方法不以 Async 结尾，意味着 Action 使用相同的线程执行，而 Async 可能会使用其他线程 执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"任务1结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * whenComplete 的参数为函数接口接口 BiConsumer</span></span><br><span class="line"><span class="comment">     * BiConsumer 定义有 void accept(T t, U u); 该方法</span></span><br><span class="line"><span class="comment">     * t 表示调用 whenComplete 的任务执行返回结果</span></span><br><span class="line"><span class="comment">     * u 表示调用 whenComplete 的任务执行返回异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = future1.whenComplete((res, ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"future1执行结果：&#123;&#125;"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"future1执行异常：&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally((ex) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"exceptionally 仅负责处理 future1 的异常信息"</span>);</span><br><span class="line">        <span class="keyword">return</span> ex.getMessage();</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">"end ==========&gt;&gt;"</span> + future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">future1执行结果：<span class="keyword">null</span></span><br><span class="line">future1执行异常：java.lang.ArithmeticException: / by zero</span><br><span class="line">exceptionally 仅负责处理 future1 的异常信息</span><br><span class="line">end ==========&gt;&gt;java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><h3 id="2-2-handle-方法"><a href="#2-2-handle-方法" class="headerlink" title="2.2 handle 方法"></a>2.2 handle 方法</h3><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710175524168.png" alt="handle 方法"></p><p>使用方式同 whenComplete 方法，唯一的不同是 handle 方法中的 BiFunction 具备返回值，而 whenComplete 方法中的 BiConsumer 不具备返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackHandleDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"任务1结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// R apply(T t, U u);</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = future1.handle((res, ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"future1执行结果：&#123;&#125;"</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"future1执行异常：&#123;&#125;"</span>, ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"新的结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">"end ==========&gt;&gt;"</span> + future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">future1执行结果：任务<span class="number">1</span>结果</span><br><span class="line">end ==========&gt;&gt;新的结果</span><br></pre></td></tr></table></figure><h2 id="3-线程串行化"><a href="#3-线程串行化" class="headerlink" title="3. 线程串行化"></a>3. 线程串行化</h2><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710181242191.png" alt="线程串行化方法"></p><p>thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前 任务的返回值；</p><p>thenAccept 方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果；</p><p>thenRun 方法：只要调用方的任务执行完成，就开始执行 thenRun 中的任务。</p><p>以上都要前置任务成功完成。<code>Function&lt;? super T,? extends</code>, T：上一个任务返回结果的类型</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenApply 示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenApplyDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"任务1结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// R apply(T t);</span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = future1.thenApply(t -&gt; &#123;</span><br><span class="line">        <span class="comment">// 上一个任务的执行结果：任务1结果</span></span><br><span class="line">        log.info(<span class="string">"上一个任务的执行结果：&#123;&#125;"</span>, t);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"新的执行结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 新的任务执行结果：新的执行结果</span></span><br><span class="line">    log.info(<span class="string">"新的任务执行结果：&#123;&#125;"</span>, future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenAccept 示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenAcceptDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"任务1结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// void accept(T t);</span></span><br><span class="line">    future1.thenAccept(t -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"上一个任务的执行结果：&#123;&#125;"</span>, t);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenRun 示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenRunDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"任务1结果"</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// void run();</span></span><br><span class="line">    future1.thenRun(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"future1 执行完后继续执行"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-任务组合"><a href="#4-任务组合" class="headerlink" title="4. 任务组合"></a>4. 任务组合</h2><h3 id="4-1-两任务组合"><a href="#4-1-两任务组合" class="headerlink" title="4.1 两任务组合"></a>4.1 两任务组合</h3><h4 id="4-1-1-两组合任务执行完成"><a href="#4-1-1-两组合任务执行完成" class="headerlink" title="4.1.1 两组合任务执行完成"></a>4.1.1 两组合任务执行完成</h4><p>两个任务必须都完成，触发该任务：</p><ul><li>thenCombine：组合两个 future，获取两个 future 的返回结果，并返回当前任务的返回值 </li><li>thenAcceptBoth：组合两个 future，获取两个 future 任务的返回结果，然后处理任务，没有返回值。 </li><li>runAfterBoth：组合两个 future，不需要获取 future 的结果，只需两个 future 处理完任务后， 处理该任务。</li></ul><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710204057541.png" alt></p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thenCombine 示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenCombine</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// R apply(T t, U u);</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = future1.thenCombine(future2, (res1, res2) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"res1:&#123;&#125;"</span>, res1);</span><br><span class="line">        log.info(<span class="string">"res2:&#123;&#125;"</span>, res2);</span><br><span class="line">        <span class="keyword">return</span> res1 + res2;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">"res1 + res2 = "</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thenAcceptBoth 示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thenAcceptBoth</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// void accept(T t, U u);</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = future1.thenAcceptBoth(future2, (res1, res2) -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"res1:&#123;&#125;"</span>, res1);</span><br><span class="line">        log.info(<span class="string">"res2:&#123;&#125;"</span>, res2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runAfterBoth 示例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAfterBoth</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// void run();</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; future = future1.runAfterBoth(future2, () -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"start ...."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-两组合任务单个执行完成"><a href="#4-1-2-两组合任务单个执行完成" class="headerlink" title="4.1.2 两组合任务单个执行完成"></a>4.1.2 两组合任务单个执行完成</h4><p>当两个任务中，任意一个 future 任务完成的时候，执行任务：</p><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710205746094.png" alt></p><ul><li><p>applyToEither：两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值。；</p></li><li><p>acceptEither：两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值；</p></li><li><p>runAfterEither：两个任务有一个执行完成，不需要获取 future 的结果，处理任务，也没有返回值。</p></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// applyToEither</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyToEither</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"任务1开始执行...."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"任务2开始执行...."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// R apply(T t);</span></span><br><span class="line">    <span class="comment">// future1 或 future2 谁先执行完成，就是谁的结果值</span></span><br><span class="line">    CompletableFuture&lt;Integer&gt; future = future1.applyToEither(future2, res -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"任务3开始执行...."</span> + res);</span><br><span class="line">        <span class="keyword">return</span> res * <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    log.info(<span class="string">"执行结果："</span> + future.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他方法类似</span></span><br></pre></td></tr></table></figure><h3 id="4-2-多任务组合"><a href="#4-2-多任务组合" class="headerlink" title="4.2 多任务组合"></a>4.2 多任务组合</h3><p><img src="/2021/07/10/CompletableFuture-异步编排/image-20210710211031143.png" alt></p><ul><li>allOf：等待所有任务完成；</li><li>anyOf：只要有一个任务完成。总任务的返回值为最快执行完成的子任务的返回值</li></ul><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allOf</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allOfDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"任务1开始执行...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"任务2开始执行...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"任务3开始执行...."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Void&gt; future = CompletableFuture.allOf(future1, future2, future3);</span><br><span class="line">    <span class="comment">// 阻塞等待所有任务执行完毕</span></span><br><span class="line">    future.get();</span><br><span class="line">    log.info(<span class="string">"子任务全部执行后继续执行&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// anyOf</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyOfDemo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"任务1开始执行...."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"任务2开始执行...."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"任务3开始执行...."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(future1, future2, future3);</span><br><span class="line">    <span class="comment">// get 方法阻塞等待所有任务执行完毕，future3 最先执行，返回值为 30</span></span><br><span class="line">    log.info(<span class="string">"子任务全部执行后继续执行&gt;&gt;&gt;&gt;&gt;"</span> + future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）谷粒商城开发-检索服务开发</title>
      <link href="/2021/07/10/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2021/07/10/%EF%BC%88%E5%9B%9B%EF%BC%89%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-三级分类查询优化"><a href="#1-三级分类查询优化" class="headerlink" title="1. 三级分类查询优化"></a>1. 三级分类查询优化</h2><p>使用示例：</p><ul><li><a href="https://shotozheng.top/2021/07/04/SpringBoot-%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE-Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">Redis 缓存的使用和分布式锁实现</a></li><li><a href="https://shotozheng.top/2021/07/05/SpringBoot-%E4%B8%AD-Redisson-%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">SpringBoot 中 Redisson 的使用</a></li><li><a href="https://shotozheng.top/2021/07/06/SpringCache-%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">SpringCache 使用</a></li></ul><ul><li><input checked disabled type="checkbox"> 利用 Redis 实现三级分类数据缓存</li><li><input checked disabled type="checkbox"> 利用 Redisson 实现分布式，解决缓存一致性、缓存穿透、缓存雪崩和缓存击穿等问题</li><li><input checked disabled type="checkbox"> 利用 SpringCache 缓存组件实现三级分类数据缓存，并解决缓存一致性问题</li></ul><h2 id="2-上架商品检索功能开发"><a href="#2-上架商品检索功能开发" class="headerlink" title="2. 上架商品检索功能开发"></a>2. 上架商品检索功能开发</h2><ul><li><input checked disabled type="checkbox"> 根据查询数据封装请求类，并构建 ES 的 DSL 检索语句</li><li><input checked disabled type="checkbox"> 解析 ES 检索结果并封装成检索结果对象返回前端</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCache 使用</title>
      <link href="/2021/07/06/SpringCache-%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/07/06/SpringCache-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager 接口来统一不同的缓存技术， 并支持使用 JCache（JSR-107）注解简化我们开发；</p><p>Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合。Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ， 如 RedisCache ， EhCacheCache , ConcurrentMapCache 等；</p><p><strong>每次调用需要缓存功能的方法时，Spring 会检查检查指定参数的指定的目标方法是否已经被调用过。如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户，下次调用直接从缓存中获取。</strong></p><p>使用 Spring 缓存抽象时我们需要关注以下两点：</p><ol><li>确定方法需要被缓存以及他们的缓存策略</li><li>从缓存中读取之前缓存存储的数据</li></ol><a id="more"></a><h2 id="2-简单使用"><a href="#2-简单使用" class="headerlink" title="2. 简单使用"></a>2. 简单使用</h2><p>下面我们使用底层实现采用 Redis 的 Cache 缓存技术</p><h3 id="2-1-导入依赖"><a href="#2-1-导入依赖" class="headerlink" title="2.1 导入依赖"></a>2.1 导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-application-yml-配置缓存"><a href="#2-2-application-yml-配置缓存" class="headerlink" title="2.2 application.yml 配置缓存"></a>2.2 application.yml 配置缓存</h3><p>1) 配置 Redis 连接信息：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    host:</span> <span class="number">192.168</span><span class="number">.160</span><span class="number">.129</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>2) 配置 cache 使用 redis:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cache:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><h3 id="2-3-开启缓存"><a href="#2-3-开启缓存" class="headerlink" title="2.3 开启缓存"></a>2.3 开启缓存</h3><p>在启动类上加上缓存开启注解 @EnableCaching</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallProductApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GulimallProductApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-加缓存注解-Cacheable"><a href="#2-4-加缓存注解-Cacheable" class="headerlink" title="2.4 加缓存注解 @Cacheable"></a>2.4 加缓存注解 @Cacheable</h3><p>如下代码所示，在方法上加上 @Cacheable 注解后，会将该方法的返回值存储缓存中。当下一次请求调用该方法时，会先查询缓存是否有数据，有则直接将缓存中的数据进行返回。<strong>其中注解中的值 “category” 为缓存分区名称。该注解也可以指明 key 值，代表具体的缓存名称（可以这么理解吧~）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 SpringCache 来实现缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Cacheable</span>(<span class="string">"category"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">getLevel1Categorys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"getLevel1Categorys....."</span>);</span><br><span class="line">    List&lt;CategoryEntity&gt; categoryEntities = baseMapper.selectList(<span class="keyword">new</span> QueryWrapper&lt;CategoryEntity&gt;().eq(<span class="string">"parent_cid"</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> categoryEntities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后，redis 中的数据如下所示，其存在如下默认行为：</p><ol><li>key 值 “SimpleKey []” 是默认生成的；</li><li>TTL 的值为 -1，表示该缓存永不过期；</li><li>缓存的数据在为乱码数据，因为底层默认使用 JDK 进行序列化（源码有体现）</li></ol><p><img src="/2021/07/06/SpringCache-使用/image-20210706230947336.png" alt="图1-默认的缓存数据"></p><p>针对上诉的默认行为，可以有针对解决方法：</p><p>1) 可以在注解 @Cacheable()中指定 key 的值，比如下述代码即可指定 key 的值为 categoryKey，因为 key 支持使用表达式，所以字符串时需要加单引号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"category"</span>, key = <span class="string">"'categoryKey'"</span>)</span><br></pre></td></tr></table></figure><p>2) TTL 的值可以在配置文件中指定，比如下述代码配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 设置 36s 后过期</span><br><span class="line">spring.cache.redis.time-to-live=36000</span><br></pre></td></tr></table></figure><p>重新执行后的效果如下：</p><p><img src="/2021/07/06/SpringCache-使用/image-20210706232356539.png" alt></p><p>针对缓存的数据在为乱码的问题，我们需要自定义配置类并更换底层的序列化机制，可以查看下文自定义缓存配置。</p><h2 id="3-自定义缓存配置"><a href="#3-自定义缓存配置" class="headerlink" title="3. 自定义缓存配置"></a>3. 自定义缓存配置</h2><p>查看如下代码，可以使用自定义配置类 MyCacheConfig 实现自定义缓存配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.cache.CacheProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(CacheProperties.class)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCacheConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义缓存配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheProperties SpringCache 默认注入到 IOC 容器中的配置类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RedisCacheConfiguration <span class="title">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();</span><br><span class="line">        <span class="comment">// key 采用字符串序列化</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()));</span><br><span class="line">        <span class="comment">// value 采用 json 序列化</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));</span><br><span class="line">        CacheProperties.Redis redisProperties = cacheProperties.getRedis();</span><br><span class="line">        <span class="comment">// 将配置文件中的所有配置都生效</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// @Cacheable 的 key 前缀</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            config = config.prefixKeysWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否缓存 null，防止缓存穿透</span></span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// @Cacheable 的 key 前缀是否开启</span></span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看第 27 行代码，这里我们指定缓存中的值采用 json 序列化器进行序列化，加上以上配置后 getLevel1Categorys 方法代码（查看 2.4）执行结果如下所示：</p><p><img src="/2021/07/06/SpringCache-使用/image-20210707205602621.png" alt="指定 json 序列化器"></p><p>另外，查看 MyCacheConfig 类中的第 38 - 40 行代码，其用来读取配置文件是否配置允许缓存空值，默认为 true</p><h2 id="4-CacheEvict"><a href="#4-CacheEvict" class="headerlink" title="4. @CacheEvict"></a>4. @CacheEvict</h2><p>与 @Cacheable 相反，@CacheEvict 则是从缓存中删除数据。注解 @CacheEvict 中的 value 表示要删除的缓存分区的名称，key 表示要删除的缓存名称，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新分类和品牌分类关联表的分类名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CacheEvict</span> 采用失效模式来解决缓存一致性问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> category</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>, key = <span class="string">"'categoryKey'"</span>)</span><br><span class="line"><span class="meta">@Transactional</span>(rollbackFor = Exception.class)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDetail</span><span class="params">(CategoryEntity category)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.updateById(category);</span><br><span class="line">    categoryBrandRelationService.updateCategoryName(category.getCatId(), category.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@CacheEvict(value = &quot;category&quot;, key = &quot;&#39;categoryKey&#39;&quot;)</code> 的作用就是当调用 updateDetail 时，会将缓存分区 category 下名为 categoryKey 缓存删掉。我们同样可以删除整个分区下的所有缓存分区，注解写法为：<code>@CacheEvict(value = &quot;category&quot;, allEntries = true)</code></p><h2 id="5-Caching"><a href="#5-Caching" class="headerlink" title="5. @Caching"></a>5. @Caching</h2><p>@Caching 注解支持组合多步操作（多步删除缓存、多步添加缓存等），比如可以使用 @Caching 组合多个删除缓存 @CacheEvict 操作，示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching</span>(evict = &#123;</span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>, key = <span class="string">"'categoryKey'"</span>),</span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"category"</span>, key = <span class="string">"'getCatalogJson'"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="6-CachePut"><a href="#6-CachePut" class="headerlink" title="6. @CachePut"></a>6. @CachePut</h2><p>该注解的作用就是在更新完成数据库时，其会自动将更新方法返回的最新数据添加进缓存中，相当于采用双写模式来解决缓存一致性问题，比如下述方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新完成数据库数据之后，返回最新数据。<span class="doctag">@CachePut</span> 会将最新数据加入到缓存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@CachePut</span>(value = <span class="string">"category"</span>, key = <span class="string">"'categoryKey'"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">updateDetail</span><span class="params">(CategoryEntity category)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.updateById(category);</span><br><span class="line">    <span class="keyword">this</span>.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-SpringCache-使用总结"><a href="#7-SpringCache-使用总结" class="headerlink" title="7. SpringCache 使用总结"></a>7. SpringCache 使用总结</h2><h3 id="7-1-不足之处"><a href="#7-1-不足之处" class="headerlink" title="7.1 不足之处"></a>7.1 不足之处</h3><p>1）读模式：</p><ul><li><input checked disabled type="checkbox"> <p>缓存穿透：查询一个 null 数据。解决：缓存空数据，使用 <code>spring.cache.redis.cache-null-values=true</code></p></li><li><input disabled type="checkbox"> <p>缓存击穿：大量并发进来同时查询一个正好过期的数据。解决：加锁；<strong>SpringCache 默认是不加分布式锁的，但是 @Cacheable 注解支持使用 sync = true 来实现本地锁，可以解决一定程度的并发缓存击穿问题</strong></p></li><li><input disabled type="checkbox"> <p>缓存雪崩：大量的 key 同时过期。解决：加随机时间。SpringCache 仅支持过期时间，例如 <code>spring.cache.redis.time-to-live=3600000</code>，因为随机过期时间也会出现 key 同时过期的情况。</p></li></ul><p>2）写模式：（缓存与数据库一致）</p><ul><li>读写加锁；</li><li>引入Canal，感知到MySQL的更新去更新数据库；</li><li>读多写多，直接去数据库查询就行</li></ul><p>总结：</p><ul><li>常规数据：读多写少，即时性和一致性要求不高的数据，完全可以使用Spring-Cache；对于写模式，只要缓存的数据有过期时间就足够了。</li><li>特殊数据：特殊设计</li></ul>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
          <category> SpringCache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 中 Redisson 的使用</title>
      <link href="/2021/07/05/SpringBoot-%E4%B8%AD-Redisson-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/07/05/SpringBoot-%E4%B8%AD-Redisson-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SpringBoot-整合"><a href="#1-SpringBoot-整合" class="headerlink" title="1. SpringBoot 整合"></a>1. SpringBoot 整合</h2><p>1）导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>2）实现配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedissonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 所有对Redisson的使用都是通过RedissonClient对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(destroyMethod = <span class="string">"shutdown"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redisson</span><span class="params">(@Value(<span class="string">"$&#123;spring.redis.host&#125;"</span>)</span> String url) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1、创建配置</span></span><br><span class="line">        <span class="comment">//Redis url should start with redis:// or rediss://</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://"</span> + url + <span class="string">":6379"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据 Config 创建出 RedissonClient 示例</span></span><br><span class="line">        RedissonClient redissonClient = Redisson.create(config);</span><br><span class="line">        <span class="keyword">return</span> redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Lock-锁"><a href="#2-Lock-锁" class="headerlink" title="2. Lock 锁"></a>2. Lock 锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 lock 锁的使用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取一把锁，只要锁的名字一样，就是同一把锁</span></span><br><span class="line">    RLock lock = redissonClient.getLock(<span class="string">"my-lock"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lock.lock(10,TimeUnit.SECONDS); //10秒自动解锁,自动解锁时间一定要大于业务的执行时间。不会自动过期续期，谨慎使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁，默认加的锁都是30s时间</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"加锁成功，执行业务..."</span> + Thread.currentThread().getId());</span><br><span class="line">        Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3解锁</span></span><br><span class="line">        log.info(<span class="string">"释放锁..."</span> + Thread.currentThread().getId());</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察如上代码，经测试发现如下两点（看门狗原理以预防死锁）：</p><ul><li>RLock 锁系统默认过期时间为 30s；</li><li>当业务代码执行时间超过默认过期时间时长时，RLock 锁会每个三分之一个看门狗时间来自动续期，即重新设置为 30s。</li></ul><h2 id="3-读写锁"><a href="#3-读写锁" class="headerlink" title="3. 读写锁"></a>3. 读写锁</h2><p>查看下面代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用写锁进行写数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/writeValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">writeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取读写锁，并设置写锁</span></span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">    RLock writeLock = readWriteLock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"成功加上写锁..."</span>);</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        s = UuidUtils.generateUuid();</span><br><span class="line">        Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"value"</span>, s);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用读锁进行读数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/readValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s = <span class="keyword">null</span>;</span><br><span class="line">    RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(<span class="string">"rw-lock"</span>);</span><br><span class="line">    RLock readLock = readWriteLock.readLock();</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"获取读锁..."</span>);</span><br><span class="line">        s = redisTemplate.opsForValue().get(<span class="string">"value"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经测试得出以下结论：</p><ul><li>写锁 + 写锁：并发互斥</li><li>读锁 + 写锁：并发互斥，无论先后</li><li>读锁 + 读锁：并发进行，相当于无锁</li></ul><h2 id="4-闭锁"><a href="#4-闭锁" class="headerlink" title="4. 闭锁"></a>4. 闭锁</h2><p>Redisson 的闭锁和 JUC 包下的 CountDownLatch 有一样的效果，即是主线程先等待其他线程执行完成之后再继续执行。闭锁存在一个计数器，当计数等于 0 的时候，表示其他线程已经执行完成，主线程继续执行。查看如下示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放假，锁门</span></span><br><span class="line"><span class="comment"> * 1班没人了，2</span></span><br><span class="line"><span class="comment"> * 5个班全部走完，我们可以锁大门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/lockDoor"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lockDoor</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RCountDownLatch door = redissonClient.getCountDownLatch(<span class="string">"door"</span>);</span><br><span class="line">    door.trySetCount(<span class="number">5</span>);</span><br><span class="line">    door.await(); <span class="comment">//等待闭锁都完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"放假了..."</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/gogogo/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gogogo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">    RCountDownLatch door = redissonClient.getCountDownLatch(<span class="string">"door"</span>);</span><br><span class="line">    door.countDown();<span class="comment">//计数减一；</span></span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">"班的人都走了..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 gogogo 方法全部执行五次之后，RCountDownLatch 中的计数器变为 0 ，主线程从第 12 行代码开始继续执行。</p><h2 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5. 信号量"></a>5. 信号量</h2><p>Redisson 也提供信号量机制，查看如下代码示例，把信号量当做一个停车车位，假设现在 redis 中已经存在 key 为 park 且值为 3 的数据，其中 3 表示初始的车位数。调用了三次 park 方法之后，3 会变为 0，此时调用 park 方法将会返回 error表示不可停车，直到调用 go 方法是 0 变为 1 开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 车库停车，一个信号量相当于一个车位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/park"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">park</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RSemaphore park = redissonClient.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    <span class="comment">//获取一个信号量（车位），会持续等待</span></span><br><span class="line">    <span class="comment">// park.acquire();</span></span><br><span class="line">    <span class="comment">//  尝试获取一个信息量（车位），获取不到直接得到 false</span></span><br><span class="line">    <span class="keyword">boolean</span> b = park.tryAcquire();</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        <span class="comment">// 执行业务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok=&gt;"</span> + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 离开车位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/go"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">go</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    RSemaphore park = redissonClient.getSemaphore(<span class="string">"park"</span>);</span><br><span class="line">    park.release();<span class="comment">// 释放一个信号量（车位）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-缓存一致性问题"><a href="#6-缓存一致性问题" class="headerlink" title="6. 缓存一致性问题"></a>6. 缓存一致性问题</h2><p>缓存一致性问题指的是数据库数据和缓存中的数据不一致的问题，解决缓存一致性问题主要有如下两种模式：</p><ul><li>双写模式：在更新数据库数据的时候，同时更新缓存中的数据；</li><li>失效模式：在更新数据库数据的时候，将缓存的数据删除掉，等下次查询时重新从数据库获取并写入缓存</li></ul><p>但是两者都存在一定的问题，下图为双写模式下可能遇到的问题，简单的将就是写数据库和写缓存两步操作不是原子操作导致的并发问题。</p><p><img src="/2021/07/05/SpringBoot-中-Redisson-的使用/image-20210706211909042.png" alt="双写模式问题"></p><p>同理在失效模式下也有相似的问题，观察下图，第一个请求写完数据库之后成功删除了缓存数据，第二个请求写数据库花费的时间较长。当第三个请求过来时发现缓存中数据不存在，此时去读取数据库获取数据库数据（旧数据，此时第二个请求还没写完数据库），并最后将数据库的旧数据更新进缓存。和双写模式类似，这是由于写数据库和删缓存两步操作不是原子操作导致的并发问题。</p><p><img src="/2021/07/05/SpringBoot-中-Redisson-的使用/image-20210706212157331.png" alt="失效模式问题"></p><h3 id="6-1-缓存一致性问题解决方案"><a href="#6-1-缓存一致性问题解决方案" class="headerlink" title="6.1 缓存一致性问题解决方案"></a>6.1 缓存一致性问题解决方案</h3><p>1、如果是用户纬度数据（订单数据、用户数据），这种并发几率非常小，不用考虑这个问题，缓存数据加上过期时间，每隔一段时间触发读的主动更新即可；</p><p>2、如果是菜单，商品介绍等基础数据，也可以去使用canal订阅binlog的方式；</p><p>3、缓存数据 + 过期时间也足够解决大部分业务对于缓存的要求；</p><p>4、通过加锁保证并发读写，写写的时候按顺序排好队（<strong>SpringCache 实现</strong>）。读读无所谓。所以适合使用读写锁。（业务不关心髒数据，允许临时髒数据可忽略）</p><p>我们能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保证每天拿到当前最新数据即可。 我们不应该过度设计，增加系统的复杂性 。 遇到实时性、一致性要求高的数据，就应该查数据库，即使慢点。</p><h3 id="6-2-canal-订阅-binlog-方式"><a href="#6-2-canal-订阅-binlog-方式" class="headerlink" title="6.2 canal 订阅 binlog 方式"></a>6.2 canal 订阅 binlog 方式</h3><p>解决缓存一致性问题也可以使用 Canal。Canal 是一个中间件，当我们更新了数据库的数据时其会自动去更新缓存的数据从而避免缓存一致性问题。观察下图，canal 会去监听数据的操作，其实质是去获取数据库的 binlog 日志记录，然后根据 binlog 对订阅了 canal 缓存 redis 数据进行更新。</p><p><img src="/2021/07/05/SpringBoot-中-Redisson-的使用/image-20210706213741379.png" alt="Canal 原理图"></p><p>canal 订阅 binlog 方式的工作原理其实是数据库的主从备份，<strong>canal 相当于一个伪装的数据库从服务器。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
          <category> Redisson </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> Redisson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 缓存的使用和分布式锁实现</title>
      <link href="/2021/07/04/SpringBoot-%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE-Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/07/04/SpringBoot-%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE-Redis-%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-本地缓存"><a href="#1-本地缓存" class="headerlink" title="1. 本地缓存"></a>1. 本地缓存</h2><p>关于缓存可以有多种实现，例如下图，在单服务节点项目中，可以实现本地缓存。简单的本地缓存实现比如可以在类中创建一个静态的 Map 集合，然后存储缓存对象即可。等到其他请求再次访问时，可以直接将 Map 中的对象直接进行返回。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210704194749623.png" alt="单服务本地缓存"></p><a id="more"></a><p>但是本地缓存有个严重的弊端，其仅支持少量缓存和单节点应用。例如下图的分布式集群项目中，产品中心 gulimall-product 有多个服务。当请求经过第一个节点，然后更新了对应的数据和缓存，此时第二个节点的缓存则无法对应同步更新，那么就会造成多个节点本地缓存数据一致性问题。另外，请求第一次经过第一个节点时，会发现此时没有本地缓存从而将数据库中的数据加入到本地缓存中。但是在分布式集群项目中，其他请求可能会经过其他服务节点，由于其他服务节点也可能本地缓存为空而需要再次查询数据库，导致缓存没有有效利用。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210704195203934.png" alt="分布式集群"></p><h2 id="2-分布式缓存"><a href="#2-分布式缓存" class="headerlink" title="2. 分布式缓存"></a>2. 分布式缓存</h2><p>由于本地缓存在分布式集群项目中存在多种问题，如下图我们将缓存作为一个公共的资源，并使用缓存中间件来实现：</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210704200105236.png" alt="Redis 缓存"></p><h2 id="3-高并发下缓存失效问题"><a href="#3-高并发下缓存失效问题" class="headerlink" title="3. 高并发下缓存失效问题"></a>3. 高并发下缓存失效问题</h2><h3 id="3-1-缓存穿透"><a href="#3-1-缓存穿透" class="headerlink" title="3.1 缓存穿透"></a>3.1 缓存穿透</h3><p><strong>缓存穿透：</strong> 指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p><p><strong>风险：</strong> 利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃。</p><p><strong>解决：</strong> null结果缓存，并加入短暂过期时间。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210704204250178.png" alt="缓存穿透"></p><p>观察如下示例，第 13 行时会判断从数据库中查询的对象存不存在，如果存在那么就存入到缓存中，但是这样会导致缓存穿透的问题，导致多个请求去查询数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试缓存穿透</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> catId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CategoryEntity <span class="title">testCachePenetrate</span><span class="params">(Long catId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 查询缓存</span></span><br><span class="line">    String catalogString = redisTemplate.opsForValue().get(<span class="string">"catalog"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(catalogString)) &#123;</span><br><span class="line">        <span class="comment">// 2. 缓存对象不存在则查询数据库</span></span><br><span class="line">        CategoryEntity entityFromDb = getCategoryEntityFromDb(catId);</span><br><span class="line">        <span class="keyword">if</span> (entityFromDb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 查询对象存在时存入缓存</span></span><br><span class="line">            String jsonString = JSON.toJSONString(entityFromDb);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalog"</span>, jsonString);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entityFromDb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 缓存对象存在那么反序列后返回</span></span><br><span class="line">    CategoryEntity categoryEntity = JSON.parseObject(catalogString, CategoryEntity.class);</span><br><span class="line">    <span class="keyword">return</span> categoryEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改如上代码，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试缓存穿透</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> catId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CategoryEntity <span class="title">testCachePenetrate</span><span class="params">(Long catId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 11 ~ 50 的随机数</span></span><br><span class="line">    <span class="keyword">int</span> r = (<span class="keyword">int</span>) (Math.random() * <span class="number">40</span>) + <span class="number">11</span>;</span><br><span class="line">    <span class="comment">// 1. 查询缓存</span></span><br><span class="line">    String catalogString = redisTemplate.opsForValue().get(<span class="string">"catalog"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(catalogString)) &#123;</span><br><span class="line">        <span class="comment">// 2. 缓存对象不存在则查询数据库，并序列化后存入缓存中</span></span><br><span class="line">        CategoryEntity entityFromDb = getCategoryEntityFromDb(catId);</span><br><span class="line">        <span class="keyword">if</span> (entityFromDb != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String jsonString = JSON.toJSONString(entityFromDb);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalog"</span>, jsonString);</span><br><span class="line">            <span class="keyword">return</span> entityFromDb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 为避免缓存穿透，设置 null 值和随机过期时间</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"catalog"</span>, <span class="string">"null"</span>, r, TimeUnit.SECONDS);</span><br><span class="line">        log.info(<span class="string">"catalog 会在&#123;&#125;秒后过期"</span>, r);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 缓存对象存在那么反序列后返回</span></span><br><span class="line">    CategoryEntity categoryEntity = JSON.parseObject(catalogString, CategoryEntity.class);</span><br><span class="line">    <span class="keyword">return</span> categoryEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-缓存雪崩"><a href="#3-2-缓存雪崩" class="headerlink" title="3.2 缓存雪崩"></a>3.2 缓存雪崩</h3><p><strong>缓存雪崩：</strong> 缓存雪崩是指在我们设置缓存时key采用了相同的过期时间， 导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。</p><p><strong>解决：</strong> 原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><h3 id="3-3-缓存击穿"><a href="#3-3-缓存击穿" class="headerlink" title="3.3 缓存击穿"></a>3.3 缓存击穿</h3><p><strong>缓存穿透：</strong></p><ul><li>对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。</li><li>如果这个key在大量请求同时进来前正好失效，那么所有对这个key的数据查询都落到db，我们称为缓存击穿。</li></ul><p><strong>解决：</strong> 加锁 ，大量并发只让一个去查，其他人等待，查到以后释放锁，其他人获取到锁，先查缓存，就会有数据，不用去db查询。</p><h2 id="4-分布式锁基本原理和实现"><a href="#4-分布式锁基本原理和实现" class="headerlink" title="4. 分布式锁基本原理和实现"></a>4. 分布式锁基本原理和实现</h2><p>为了解决缓存击穿问题，我们可以对缓存加上分布式锁。如下图，在分布式环境下，如果仅仅是加上本地锁，比如 synchronized 是无法起作用的，下面可以做一下演示示例。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210705202643154.png" alt="分布式锁"></p><h3 id="4-1-synchronized-本地锁"><a href="#4-1-synchronized-本地锁" class="headerlink" title="4.1 synchronized 本地锁"></a>4.1 synchronized 本地锁</h3><p>查看如下代码，这里我们使用 synchronized  本地锁进行加锁。在单服务项目时，下面这种写法面对并发请求不会导致并发问题。但是在多服务项目环境下，第 9 行的 getCatalogJsonFromDb 方法可能会调用多次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonWithSynchronized() &#123;</span><br><span class="line">    String catalogJsonString = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 1. 查询缓存</span></span><br><span class="line">        catalogJsonString = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(catalogJsonString)) &#123;</span><br><span class="line">            <span class="comment">// 2. 缓存对象不存在则查询数据库，并序列化后存入缓存中</span></span><br><span class="line">            Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJson = getCatalogJsonFromDb();</span><br><span class="line">            String jsonString = JSON.toJSONString(catalogJson);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalogJson"</span>, jsonString);</span><br><span class="line">            <span class="keyword">return</span> catalogJson;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 缓存对象存在那么反序列后返回</span></span><br><span class="line">    TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;  typeReference = <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;()&#123;&#125;;</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJson = JSON.parseObject(catalogJsonString, typeReference);</span><br><span class="line">    <span class="keyword">return</span> catalogJson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-分布式锁"><a href="#4-2-分布式锁" class="headerlink" title="4.2 分布式锁"></a>4.2 分布式锁</h3><p>如下图，可以将多个服务的本地锁抽取为一个公共锁。我们可以同时去一个地方“占坑”，如果占到，就执行逻辑。否则就必须等待，直到释放锁。 “占坑”可以去redis，可以去数据库，可以去任何大家都能访问的地方，而等待可以使用自旋的方式进行。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210705210028355.png" alt></p><h4 id="4-2-1-阶段一"><a href="#4-2-1-阶段一" class="headerlink" title="4.2.1 阶段一"></a>4.2.1 阶段一</h4><p>在 redis 中存在命令 setnx，如下图，当执行 setnx(“lock”, 1111) 时，如果 redis 中没有 ‘lock’ 这个 key，也就是当前还没有缓存还没有加锁，那么就返回 ture 并将 ‘lock’ 到缓存中充当锁。那么当下一个请求过来时会发现缓存中已经存在锁，则会进行等待直到第一个请求的锁释放。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210705211114872.png" alt="setnx加锁"></p><p>代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJson() &#123;</span><br><span class="line">    <span class="comment">// 1. 查询缓存</span></span><br><span class="line">    String catalogJsonString = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(catalogJsonString)) &#123;</span><br><span class="line">        <span class="comment">// 2. 缓存对象不存在则查询数据库，并序列化后存入缓存中</span></span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 缓存对象存在那么反序列后返回</span></span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; catalogJson = JSON.parseObject(catalogJsonString, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> catalogJson;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 采用 redis lock 实现分布式锁(双重检查锁)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonWithRedisLock() &#123;</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, <span class="string">"1111"</span>);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        String catalogJSON = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(catalogJSON)) &#123;</span><br><span class="line">            dataFromDb = JSON.parseObject(catalogJSON, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataFromDb = getCatalogJsonFromDb();</span><br><span class="line">            String s = JSON.toJSONString(dataFromDb);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalogJson"</span>, s, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除锁</span></span><br><span class="line">        redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁失败...等待重试"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>观察如上代码，第 32 行代码会将锁进行释放。但是在程序运行过程中，可能由于断电或者程序退出等原因导致线程在获取到锁之后可能没有释放锁，从而造成死锁。初步解决办法就是为锁设置过期时间，因此即便锁没有及时释放，到期后也会自动进行释放。</strong></p><h4 id="4-2-2-阶段二"><a href="#4-2-2-阶段二" class="headerlink" title="4.2.2 阶段二"></a>4.2.2 阶段二</h4><p>如下代码第 7 行，我们为锁设置过期时间，比如 30s 后锁会自动失效。但是现在依然存在一个问题，即在执行 expire 方法之前程序崩溃断电了导致设置锁过期时间没有成功的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonWithRedisLock() &#123;</span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, <span class="string">"1111"</span>);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        <span class="comment">// 为锁设置过期时间，30s 后过期</span></span><br><span class="line">        redisTemplate.expire(<span class="string">"lock"</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">        String catalogJSON = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(catalogJSON)) &#123;</span><br><span class="line">            dataFromDb = JSON.parseObject(catalogJSON, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataFromDb = getCatalogJsonFromDb();</span><br><span class="line">            String s = JSON.toJSONString(dataFromDb);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalogJson"</span>, s, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除锁</span></span><br><span class="line">        redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁失败...等待重试"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210705221141192.png" alt="设置锁过期时间"></p><p><strong>针对这一问题，我们需要将获取锁和设置锁的过期时间作为一个原子操作来执行</strong>。redis 也提供了相应的方法 setnxex。修改后的代码如下所示，主要实现为第 3 行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonWithRedisLock() &#123;</span><br><span class="line">    <span class="comment">// 加锁的同时并设置过期时间</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, <span class="string">"1111"</span>, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        String catalogJSON = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(catalogJSON)) &#123;</span><br><span class="line">            dataFromDb = JSON.parseObject(catalogJSON, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataFromDb = getCatalogJsonFromDb();</span><br><span class="line">            String s = JSON.toJSONString(dataFromDb);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalogJson"</span>, s, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除锁</span></span><br><span class="line">        redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁失败...等待重试"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-阶段三"><a href="#4-2-3-阶段三" class="headerlink" title="4.2.3 阶段三"></a>4.2.3 阶段三</h4><p>但是现在依然存在问题，观察下图，第一个请求在获取到锁的时候，该锁会在 10s 后过期。但是该请求执行业务时间较长，比如可能花了 30s。那么第一个请求再还没释放锁之前其获取到的锁就已经失效了。这是第二个请求会获取到锁并执行业务。等第一个请求开始删除锁时，这时候会删除掉第二个请求获取的锁，从而出现把别人的锁删除的情况。</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210705222339760.png" alt="锁过期时长问题"></p><p>为了避免这种情况，在占锁的时候，值指定为uuid，每个人匹配是自己的锁才删除。</p><h4 id="4-2-4-阶段四"><a href="#4-2-4-阶段四" class="headerlink" title="4.2.4 阶段四"></a>4.2.4 阶段四</h4><p>观察如下代码，我们使用 UUID 来避免用户删除掉其他人的锁的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonWithRedisLock() &#123;</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁的同时并设置过期时间</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        String catalogJSON = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(catalogJSON)) &#123;</span><br><span class="line">            dataFromDb = JSON.parseObject(catalogJSON, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dataFromDb = getCatalogJsonFromDb();</span><br><span class="line">            String s = JSON.toJSONString(dataFromDb);</span><br><span class="line">            redisTemplate.opsForValue().set(<span class="string">"catalogJson"</span>, s, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125;</span><br><span class="line">        String lockValue = redisTemplate.opsForValue().get(<span class="string">"lock"</span>);</span><br><span class="line">        <span class="keyword">if</span> (uuid.equals(lockValue)) &#123;</span><br><span class="line">            <span class="comment">//删除自己的锁</span></span><br><span class="line">            redisTemplate.delete(<span class="string">"lock"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁失败...等待重试"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在依然存在一个问题，观察 16 - 20 行代码，其中获取锁和删除锁并不是原子操作。那么在并发的情况下，可能依然会出现删除掉其他人的锁的问题。下面我们可以将获取当前线程的锁和删除锁作为一个原子操作，也就是使用 redis 提供的 lua 脚本来执行，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;Catelog2Vo&gt;&gt; getCatalogJsonWithRedisLock() &#123;</span><br><span class="line">    String uuid = UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">// 加锁的同时并设置过期时间</span></span><br><span class="line">    Boolean lock = redisTemplate.opsForValue().setIfAbsent(<span class="string">"lock"</span>, uuid, <span class="number">30</span>, TimeUnit.SECONDS);</span><br><span class="line">    Map&lt;String, List&lt;Catelog2Vo&gt;&gt; dataFromDb;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁成功..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String catalogJSON = redisTemplate.opsForValue().get(<span class="string">"catalogJson"</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(catalogJSON)) &#123;</span><br><span class="line">                dataFromDb = JSON.parseObject(catalogJSON, <span class="keyword">new</span> TypeReference&lt;Map&lt;String, List&lt;Catelog2Vo&gt;&gt;&gt;() &#123;&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dataFromDb = getCatalogJsonFromDb();</span><br><span class="line">                String s = JSON.toJSONString(dataFromDb);</span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">"catalogJson"</span>, s, <span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">            <span class="comment">//删除当前值为 uuid 的锁</span></span><br><span class="line">            Long lock1 = redisTemplate.execute(<span class="keyword">new</span> DefaultRedisScript&lt;Long&gt;(script, Long.class), Arrays.asList(<span class="string">"lock"</span>), uuid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dataFromDb;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"获取分布式锁失败...等待重试"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCatalogJsonWithRedisLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码执行过程如下所示：</p><p><img src="/2021/07/04/SpringBoot-分布式项目-Redis-缓存的使用/image-20210705223954001.png" alt="当前线程锁删除原子"></p><p>至此我们便完成了 Redis 分布式锁的实现，另外 Redis 也提供了相关的类 Redisson 来实现分布式锁。</p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 整合 ElasticSearch-High-level-client</title>
      <link href="/2021/06/30/SpringBoot-%E6%95%B4%E5%90%88-ElasticSearch-High-level-client/"/>
      <url>/2021/06/30/SpringBoot-%E6%95%B4%E5%90%88-ElasticSearch-High-level-client/</url>
      
        <content type="html"><![CDATA[<blockquote><p>ElasticSearch-high-level-client 是 java 操作 ElasticSearch 的一个客户端 API </p></blockquote><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-测试保存数据"><a href="#2-测试保存数据" class="headerlink" title="2. 测试保存数据"></a>2. 测试保存数据</h3><p>下面测试测试索引保存数据到 ES 中，具体步骤如下，可以参考官网进行：<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.4/java-rest-high.html" target="_blank" rel="noopener">Java High Level REST Client</a></p><p>1）构建 RestHighLevelClient ，该类用于与 ES 做交互，我们将其创建加入 IOC 容器之中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallElasticSearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_IP = <span class="string">"192.168.160.129"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHEME = <span class="string">"http"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 RestHighLevelClient 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(<span class="keyword">new</span> HttpHost(HOST_IP, PORT, SCHEME));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）请求统一定制，便于对 ES 的请求进行统一处理，比如设置请求头和响应等；下面仅进行简单的使用，还是同一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallElasticSearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_IP = <span class="string">"192.168.160.129"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9200</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCHEME = <span class="string">"http"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求统一定制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.Builder builder = RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        <span class="comment">// 这里定制请求...</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  创建 RestHighLevelClient 实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">RestHighLevelClient <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(<span class="keyword">new</span> HttpHost(HOST_IP, PORT, SCHEME));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）创建测试类，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallSearchApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String spuName;</span><br><span class="line">        <span class="keyword">private</span> Long id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 发送实体数据</span></span><br><span class="line">        Product product = <span class="keyword">new</span> Product();</span><br><span class="line">        product.setSpuName(<span class="string">"华为"</span>);</span><br><span class="line">        product.setId(<span class="number">10L</span>);</span><br><span class="line">        <span class="comment">// 2. 转为 JSON 字符串</span></span><br><span class="line">        String productJsonStr = JSON.toJSONString(product);</span><br><span class="line">        <span class="comment">// 3. 创建索引</span></span><br><span class="line">        IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">"product"</span>);</span><br><span class="line">        <span class="comment">// 4. 文档标识</span></span><br><span class="line">        request.id(<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 5. 设置传送数据</span></span><br><span class="line">        request.source(productJsonStr, XContentType.JSON);</span><br><span class="line">        <span class="comment">// 6. 索引操作请求，设置请求 RequestOptions COMMON_OPTIONS</span></span><br><span class="line">        IndexResponse indexResponse = client.index(request, GulimallElasticSearchConfig.COMMON_OPTIONS);</span><br><span class="line">        <span class="comment">// 7. 打印响应信息</span></span><br><span class="line">        log.info(<span class="string">"响应信息：&#123;&#125;"</span>, indexResponse.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）运行成功后，可以在 kibana 操作页面查询索引进 ES 的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET product/_search</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "match_all": &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/06/30/SpringBoot-整合-ElasticSearch-High-level-client/image-20210701210325871.png" alt></p><p>更多操作，可以参照官方文档~</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch 分词器安装与词库自定义</title>
      <link href="/2021/06/29/ElasticSearch-%E5%88%86%E8%AF%8D%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AF%8D%E5%BA%93%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
      <url>/2021/06/29/ElasticSearch-%E5%88%86%E8%AF%8D%E5%99%A8%E5%AE%89%E8%A3%85%E4%B8%8E%E8%AF%8D%E5%BA%93%E8%87%AA%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>准备工作： <span id="inline-blue"> 在 CentOs7 使用 Docker 安装 ElasticSearch 7.4.2</span></p><h2 id="1-分词概念"><a href="#1-分词概念" class="headerlink" title="1. 分词概念"></a>1. 分词概念</h2><p>一个 tokenizer（分词器）接收一个字符流，将之分割为独立的 tokens（词元，通常是独立的单词），然后输出 tokens 流。 例如，<code>whitespace tokenizer</code> 遇到空白字符时分割文本。它会将文本 “Quick brown fox!” 分割 为 [Quick, brown, fox!]。 该 tokenizer（分词器）还负责记录各个 term（词条）的顺序或 position 位置（用于 phrase 短语和 word proximity 词近邻查询），以及 term（词条）所代表的原始 word（单词）的 start （起始）和 end（结束）的 character offsets（字符偏移量）（用于高亮显示搜索的内容）。 Elasticsearch 提供了很多内置的分词器，可以用来构建 custom analyzers（自定义分词器）。</p><a id="more"></a><h2 id="2-分词器安装"><a href="#2-分词器安装" class="headerlink" title="2. 分词器安装"></a>2. 分词器安装</h2><ol><li><p>进入 docker 中的 elasticsearch（简称 es） 与本地 linux elasticsearch 挂载的 plugins 目录，或者直接进入 docker 中 es 中的 plugins 目录：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 获取 elasticsearch 的容器id</span><br><span class="line">docker ps </span><br><span class="line"><span class="meta">#</span># 进入 docker 中 es 目录中</span><br><span class="line">docker exec -it 容器id /bin/bash</span><br><span class="line">cd plugins</span><br></pre></td></tr></table></figure></li><li><p>下载分词器，并解压到 plugins/ik/ 目录下：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 下载分词器</span><br><span class="line">wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip</span><br><span class="line"><span class="meta">#</span># 解压到指定目录</span><br><span class="line">unzip elasticsearch-analysis-ik-7.4.2.zip -d ./ik</span><br><span class="line"><span class="meta">#</span># 删除压缩包</span><br><span class="line">rm elasticsearch-analysis-ik-7.4.2.zip</span><br></pre></td></tr></table></figure></li><li><p>授予全部权限：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 ./ik</span><br></pre></td></tr></table></figure></li><li><p>查看分词器是否安装成功：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 进入 docker 容器</span><br><span class="line">docker exec -it elasticsearch /bin/bash</span><br><span class="line"><span class="meta">#</span># 进入 bin 目录</span><br><span class="line">cd bin</span><br><span class="line"><span class="meta">#</span># 执行如下命令，若显示 ik 则表示分词器安装成功</span><br><span class="line">elasticsearch-plugin list</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-测试分词器"><a href="#3-测试分词器" class="headerlink" title="3. 测试分词器"></a>3. 测试分词器</h2><p>首先进入 kibana 开发工具页面（IP 为 kibana 自己的服务器 地址）：<a href="http://192.168.160.129:5601/app/kibana#/dev_tools/console?_g=()" target="_blank" rel="noopener">http://192.168.160.129:5601/app/kibana#/dev_tools/console?_g=()</a></p><ul><li><p>使用默认分词器：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  "text": "我是中国人"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <img src="/2021/06/29/ElasticSearch-分词器安装与词库自定义/image-20210630204908915.png" alt="默认分词器" style="zoom:80%;"></li><li><p>使用中文分词器（ik_smart）：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  "analyzer": "ik_smart",</span><br><span class="line">  "text": "我是中国人"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2021/06/29/ElasticSearch-分词器安装与词库自定义/image-20210630204954490.png" alt="ik_smart"></p></li><li><p>使用中文分词器（ik_max_word）：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">  "analyzer": "ik_max_word",</span><br><span class="line">  "text": "我是中国人"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/2021/06/29/ElasticSearch-分词器安装与词库自定义/image-20210630205043804.png" alt="ik_max_word"></p></li></ul><h2 id="4-自定义词库"><a href="#4-自定义词库" class="headerlink" title="4. 自定义词库"></a>4. 自定义词库</h2><p>下面我们通过 nginx 来获取静态自定义词库资源，然后将自定义词库资源路径配置在 elasticsearch 指定配置文件中。</p><p>1）创建 /mydata/nginx 文件夹，存放 nginx 数据等信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /mydata/nginx</span><br></pre></td></tr></table></figure><p>2）创建 docker nginx 实例，复制配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata</span><br><span class="line"><span class="meta">#</span># 创建 docker 实例</span><br><span class="line">docker run -p 80:80 --name nginx -d nginx:1.10</span><br><span class="line"><span class="meta">#</span># 复制 docker nginx 实例中配置信息复制到当前目录下的 nginx 目录中</span><br><span class="line">docker container cp nginx:/etc/nginx .</span><br></pre></td></tr></table></figure><p>3）停止并删除 nginx 实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx</span><br><span class="line">docker rm nginx</span><br></pre></td></tr></table></figure><p>4）移动拷贝操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span># 更改 nginx 名称</span><br><span class="line">mv nginx conf</span><br><span class="line"><span class="meta">#</span># 重新创建 nginx 目录</span><br><span class="line">mkdir nginx</span><br><span class="line"><span class="meta">#</span># 将 conf 全部移到 nginx 目录下</span><br><span class="line">mv conf nginx/</span><br></pre></td></tr></table></figure><p>5）运行 nginx 实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /mydata/nginx</span><br><span class="line">docker run -p 80:80 --name nginx \</span><br><span class="line">-v /mydata/nginx/html:/usr/share/nginx/html \</span><br><span class="line">-v /mydata/nginx/logs:/var/log/nginx \</span><br><span class="line">-v /mydata/nginx/conf:/etc/nginx \</span><br><span class="line">-d nginx:1.10</span><br></pre></td></tr></table></figure><p>6）验证 nginx 是否安装成功：</p><p>访问 <code>https://nginx服务器IP:80</code>，若出现如下页面则说明 nginx 安装成功</p><p><img src="/2021/06/29/ElasticSearch-分词器安装与词库自定义/image-20210630215558169.png" alt><br>7）在 nginx 的 html 目录下创建分词文件，比如创建 /mydata/nginx/html/es/fenci/myword.txt 文件，并输入自定义分词数据</p><p>8）修改 /usr/share/elasticsearch/plugins/ik/config/ 中的 IKAnalyzer.cfg.xml，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">        &lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span><br><span class="line">        &lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="line">        &lt;entry key=&quot;ext_dict&quot;&gt;&lt;/entry&gt;</span><br><span class="line">         &lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span><br><span class="line">        &lt;entry key=&quot;ext_stopwords&quot;&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;!--用户可以在这里配置远程扩展字典 --&gt;</span><br><span class="line">        &lt;!-- 注释：如下内容修改成自定义词库路径地址--&gt;</span><br><span class="line">         &lt;entry key=&quot;remote_ext_dict&quot;&gt;http://192.168.160.129/es/fenci/myword.txt&lt;/entry&gt;</span><br><span class="line">        &lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span><br><span class="line">        &lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>9）重新启动 nginx 和 elasticsearch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker restart nginx</span><br><span class="line">docker restart elasticsearch</span><br></pre></td></tr></table></figure><p>10）在 kibana 验证分词效果</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot JSR303 分组校验和自定义校验注解</title>
      <link href="/2021/06/14/SpringBoot-JSR303-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/06/14/SpringBoot-JSR303-%E5%88%86%E7%BB%84%E6%A0%A1%E9%AA%8C%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>环境准备：引入 spring-boot-starter-web 启动器依赖</p></blockquote><h3 id="1-基础校验"><a href="#1-基础校验" class="headerlink" title="1. 基础校验"></a>1. 基础校验</h3><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"pms_brand"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"品牌名不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌logo地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"品牌logo地址不能为空"</span>)</span><br><span class="line">    <span class="meta">@URL</span>(message = <span class="string">"品牌logo地址必须是一个合法的url地址"</span>)</span><br><span class="line">    <span class="keyword">private</span> String logo;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"品牌介绍不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String descript;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示状态[0-不显示；1-显示]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"品牌状态不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer showStatus;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检索首字母</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"检索首字母不能为空"</span>)</span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"^[a-zA-Z]$"</span>, message = <span class="string">"检索首字母必须在a-z或者A-Z范围内"</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstLetter;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上使用 @NotBlank、@URL、@Pattern 等校验注解对实体类对应字段进行校验，要开启校验注解，还需要在映射方法入参前加上注解 @Valid，例如下述代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(@Valid @RequestBody BrandEntity brand)</span> </span>&#123;</span><br><span class="line">    brandService.save(brand);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-分组校验"><a href="#2-分组校验" class="headerlink" title="2. 分组校验"></a>2. 分组校验</h3><p>在一下特殊场合，可能需要进行分组校验，观察 BrandEntity 类 brandId 字段，当我们调用新增方法时，brandId 需要为空。在进行更新方法时，brandId 不能为空。为了实现这种分组校验效果，我们可以使用注解中的 groups 参数来实现。</p><p><img src="/2021/06/14/SpringBoot-JSR303-分组校验和自定义校验注解/image-20210614102006173.png" alt="image-20210614102006173"></p><h4 id="2-1-实现分组接口"><a href="#2-1-实现分组接口" class="headerlink" title="2.1 实现分组接口"></a>2.1 实现分组接口</h4><p>创建一个 AddGroup 和 UpdateGroup 接口，接口内不需要任何方法和属性，接口仅作为唯一标识使用。</p><h4 id="2-2-声明分组"><a href="#2-2-声明分组" class="headerlink" title="2.2 声明分组"></a>2.2 声明分组</h4><p>如下我们在 brandId 字段上使用多个分组，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"pms_brand"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 品牌id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"更新品牌时品牌id不能为空"</span>, groups = &#123;UpdateGroup.class&#125;)</span><br><span class="line">    <span class="meta">@Null</span>(message = <span class="string">"新增品牌时品牌id必须为空"</span>, groups = &#123;AddGroup.class&#125;)</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：开启分组后，原有没有指定分组的注解会失效，所以需要对使用校验注解的字段开启分组</strong></p><h4 id="2-3-开启分组"><a href="#2-3-开启分组" class="headerlink" title="2.3 开启分组"></a>2.3 开启分组</h4><p>这里不再使用 @Valid 注解，而是使用 @Validated 注解，该注解支持指定校验分组，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> brand 品牌实体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> R <span class="title">save</span><span class="params">(@Validated(value = AddGroup.class)</span> @RequestBody BrandEntity brand) </span>&#123;</span><br><span class="line">    brandService.save(brand);</span><br><span class="line">    <span class="keyword">return</span> R.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-自定义校验注解"><a href="#3-自定义校验注解" class="headerlink" title="3. 自定义校验注解"></a>3. 自定义校验注解</h3><p>@Pattern 注解只适用于字符串，目前 BrandEntity 中的 showStatus 字段仅接收 0 和 1 的整数，我们可以实现自定义校验注解来实现这种效果。</p><p><img src="/2021/06/14/SpringBoot-JSR303-分组校验和自定义校验注解/image-20210614105020055.png" alt="image-20210614105020055"></p><h4 id="3-1-创建注解"><a href="#3-1-创建注解" class="headerlink" title="3.1 创建注解"></a>3.1 创建注解</h4><p>其中 message 、groups 和 payload 为校验注解的三个基本方法，不可以缺少。values 方法则为自定义方法，表示传入的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shotozheng</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123; ListValueConstraintValidator.class &#125;) <span class="comment">// 指定自定义的校验器</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;) <span class="comment">// 注解支持使用的位置</span></span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="comment">// 注解运行时获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认提示信息 */</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "</span>&#123;com.atguigu.common.validate.ListValue.message&#125;<span class="string">";</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /** 分组 */</span></span><br><span class="line"><span class="string">    Class&lt;?&gt;[] groups() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Class&lt;? extends Payload&gt;[] payload() default &#123; &#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int[] values() default  &#123; &#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>message 方法用于从默认名为 ValidationMessage.properties 的配置文件中读取自定义的提示信息，因此需要在 resources 文件夹下创建 ValidationMessage.properties 配置文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 自定义校验注解默认消息提示配置</span><br><span class="line">com.atguigu.common.validate.ListValue.message=不合法的参数值</span><br></pre></td></tr></table></figure><h4 id="3-2-创建注解校验器"><a href="#3-2-创建注解校验器" class="headerlink" title="3.2 创建注解校验器"></a>3.2 创建注解校验器</h4><p>@Constraint 注解用于指定自定义校验器，@Constraint 注解内容如下所示：</p><p><img src="/2021/06/14/SpringBoot-JSR303-分组校验和自定义校验注解/image-20210614112926344.png" alt="image-20210614112926344"></p><p>其中 validateBy 方法指明传入的参数必须是 ConstraintValidator 接口的实现类，同时需要指明泛型，查看如下注释信息。第一个泛型表示自定义注解 ListValue 类型，第二个则是注解使用在的目标字段类型，由于我们使用自定义注解是作用在  BrandEntity 中的 Integer 类型的 showStatus 的字段上，因此第二个泛型为 Integer。</p><p><img src="/2021/06/14/SpringBoot-JSR303-分组校验和自定义校验注解/image-20210614113115704.png" alt="image-20210614113115704"></p><p> 下面我们创建自定义注解校验器，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解 <span class="doctag">@ListValue</span>校验器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ListValue</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; dataSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * values 数组的值为注解上指明的值，即0和1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> constraintAnnotation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ListValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] values = constraintAnnotation.values();</span><br><span class="line">        <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> val : values) &#123;</span><br><span class="line">                dataSet.add(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要校验的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataSet.contains(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要在 @ListValue 注解中指明使用的校验器即可，如：<code>@Constraint(validatedBy = { ListValueConstraintValidator.class })</code>。</p><h4 id="3-3-使用自定义注解"><a href="#3-3-使用自定义注解" class="headerlink" title="3.3 使用自定义注解"></a>3.3 使用自定义注解</h4><p>最后在 BrandEntity  的 showStatus 字段上使用 @ListValue 注解即可实现相应校验功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"pms_brand"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrandEntity</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示状态[0-不显示；1-显示]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"品牌状态不能为空"</span>, groups = &#123;AddGroup.class, UpdateGroup.class, UpdateStatusGroup.class&#125;)</span><br><span class="line">    <span class="meta">@ListValue</span>(values = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, groups = &#123;AddGroup.class, UpdateGroup.class, UpdateStatusGroup.class&#125;)</span><br><span class="line">    <span class="keyword">private</span> Integer showStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> JSR303 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oss 实现文件上传</title>
      <link href="/2021/06/07/oss-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/06/07/oss-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1. 文件存储"></a>1. 文件存储</h2><h3 id="1-1-普通文件存储方式和问题"><a href="#1-1-普通文件存储方式和问题" class="headerlink" title="1.1 普通文件存储方式和问题"></a>1.1 普通文件存储方式和问题</h3><p>单点项目服务上传方式如图1所示，即浏览器上传文件生成文件流最终写在服务器指定目录文件下。但是当在分布式的情况下时，如图2所示，由于文件可能上传到某台服务器上，因此有些服务器缺少对应的上传文件，导致无法访问到上传的文件。</p><a id="more"></a><p><img src="/2021/06/07/oss-实现文件上传/image-20210607230520569.png" alt="图1"></p><p><img src="/2021/06/07/oss-实现文件上传/image-20210607230710320.png" alt="图2"></p><h3 id="1-2-公共文件中心存储"><a href="#1-2-公共文件中心存储" class="headerlink" title="1.2 公共文件中心存储"></a>1.2 公共文件中心存储</h3><p>如图3所示，我们将上传的文件集中存储在文件存储中心，文件存储中心可以是自建服务器中心，也可以利用第三方云存储，比如阿里云对象存储。文章后面我们采用阿里云对象存储 OSS 来实现文件的上传功能。</p><p><img src="/2021/06/07/oss-实现文件上传/image-20210607231116770.png" alt="图3"></p><h2 id="2-OSS-文件上传"><a href="#2-OSS-文件上传" class="headerlink" title="2. OSS 文件上传"></a>2. OSS 文件上传</h2><h3 id="2-1-阿里云对象存储-普通上传方式"><a href="#2-1-阿里云对象存储-普通上传方式" class="headerlink" title="2.1 阿里云对象存储-普通上传方式"></a>2.1 阿里云对象存储-普通上传方式</h3><p>对于普通上传方式，用户在浏览器点击上传文件，然后生成文件流传输到后台，然后交由后台使用 OSS 登录秘钥等信息实现将文件上传到 OSS 文件存储中心。因为上传文件传输的步骤需要经过应用服务器处理，所以这种方式有一个很大的缺点就是应用服务器容易遇到性能瓶颈。</p><p><img src="/2021/06/07/oss-实现文件上传/image-20210607231419584.png" alt="普通上传方式"></p><h3 id="2-2-阿里云对象存储-服务端签名后直传"><a href="#2-2-阿里云对象存储-服务端签名后直传" class="headerlink" title="2.2 阿里云对象存储-服务端签名后直传"></a>2.2 阿里云对象存储-服务端签名后直传</h3><p>阿里云对象存储提供给我们另外一种解决方案，如下图，用户首先向服务获取 OSS 访问秘钥等信息，然后直接由用户在浏览器实现将文件上传到 OSS 文件存储中心，以此避免后台应用服务器进行文件数据传输和上传等步骤。</p><p><img src="/2021/06/07/oss-实现文件上传/image-20210607231823480.png" alt="服务端签名后直传"></p><h2 id="3-普通-Java-实现"><a href="#3-普通-Java-实现" class="headerlink" title="3. 普通 Java 实现"></a>3. 普通 Java 实现</h2><ol><li><p>创建 Bucket，创建地址<a href="https://oss.console.aliyun.com/bucket" target="_blank" rel="noopener">点击进入</a>，创建完成后即可获取查看 Endpoint 信息；</p></li><li><p>创建 RAM 访问控制子用户，得到  AccessKey 和 accessKeySecret；</p></li><li><p>创建 Maven 工程，引入依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建如下测试方法，即可将对应路径中的文件上传到 OSS 文件中心：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOssUpload</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Endpoint以广州为例，其它Region请按实际情况填写。</span></span><br><span class="line">    String endpoint = <span class="string">"https://oss-cn-guangzhou.aliyuncs.com"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM账号进行API访问或日常运维，请登录RAM控制台创建RAM账号。</span></span><br><span class="line">    String accessKeyId = <span class="string">"xxxx"</span>;</span><br><span class="line">    String accessKeySecret = <span class="string">"xxxx"</span>;</span><br><span class="line">    String bucketName = <span class="string">"gulimall-oss-shotozheng"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建OSSClient实例。</span></span><br><span class="line">    OSS ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;yourObjectName&gt;上传文件到OSS时需要指定包含文件后缀在内的完整路径，例如abc/efg/123.jpg。</span></span><br><span class="line">    String objectName = <span class="string">"imgs/aa.jpeg"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传文件流</span></span><br><span class="line">    InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\admin\\Pictures\\Camera Roll\\f.jpeg"</span>);</span><br><span class="line">    ossClient.putObject(bucketName, objectName, inputStream);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">    ossClient.shutdown();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"上传完成..."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于更新信息，可以查看<a href="https://help.aliyun.com/document_detail/32011.html?spm=a2c4g.11186623.6.919.7a2734f3pyh51E" target="_blank" rel="noopener">官网</a>。</p></li></ol><h2 id="4-Spring-Cloud-实现"><a href="#4-Spring-Cloud-实现" class="headerlink" title="4. Spring Cloud 实现"></a>4. Spring Cloud 实现</h2><ol><li><p>创建 Bucket，创建地址<a href="https://oss.console.aliyun.com/bucket" target="_blank" rel="noopener">点击进入</a>，创建完成后即可获取查看 Endpoint 信息；</p></li><li><p>创建 RAM 访问控制子用户，得到  AccessKey 和 accessKeySecret；</p></li><li><p>POM 文件引入依赖：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>application.yml 中配置如下信息：</p> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    alicloud:</span></span><br><span class="line"><span class="attr">      access-key:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">      secret-key:</span> <span class="string">xxx</span></span><br><span class="line"><span class="attr">      oss:</span></span><br><span class="line"><span class="attr">        endpoint:</span> <span class="string">oss-cn-guangzhou.aliyuncs.com</span></span><br><span class="line"><span class="attr">        bucket:</span> <span class="string">gulimall-oss-shotozheng</span></span><br></pre></td></tr></table></figure></li><li><p>创建测试类，如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssUploadTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;spring.cloud.alicloud.oss.bucket&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveFile</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">        String objectName = <span class="string">"imgs/bb.jpeg"</span>;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\admin\\Pictures\\Camera Roll\\f.jpeg"</span>);</span><br><span class="line">        ossClient.putObject(bucket, objectName, inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭OSSClient。</span></span><br><span class="line">        ossClient.shutdown();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"上传完成..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务端签名后上传，前台访问后台获取访问 OSS 上传签名之后才能直接在前端上传文件到 OSS 文件中，如下是获取服务端签名代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> OSSClient ossClient;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;spring.cloud.alicloud.access-key&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String accessId;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;spring.cloud.alicloud.oss.endpoint&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String endpoint;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">"$&#123;spring.cloud.alicloud.oss.bucket&#125;"</span>)</span><br><span class="line">        <span class="keyword">private</span> String bucket;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@RequestMapping</span>(<span class="string">"/oss/policy"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">policy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// host的格式为 bucketname.endpoint</span></span><br><span class="line">            String host = <span class="string">"https://"</span> + bucket + <span class="string">"."</span> + endpoint;</span><br><span class="line">            <span class="comment">// 用户上传文件时指定的前缀。</span></span><br><span class="line">            String prefix = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">            String dir = prefix + <span class="string">"/"</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> expireTime = <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">long</span> expireEndTime = System.currentTimeMillis() + expireTime * <span class="number">1000</span>;</span><br><span class="line">                Date expiration = <span class="keyword">new</span> Date(expireEndTime);</span><br><span class="line">                <span class="comment">// PostObject请求最大可支持的文件大小为5 GB，即CONTENT_LENGTH_RANGE为5*1024*1024*1024。</span></span><br><span class="line">                PolicyConditions policyConds = <span class="keyword">new</span> PolicyConditions();</span><br><span class="line">                policyConds.addConditionItem(PolicyConditions.COND_CONTENT_LENGTH_RANGE, <span class="number">0</span>, <span class="number">1048576000</span>);</span><br><span class="line">                policyConds.addConditionItem(MatchMode.StartWith, PolicyConditions.COND_KEY, dir);</span><br><span class="line">    </span><br><span class="line">                String postPolicy = ossClient.generatePostPolicy(expiration, policyConds);</span><br><span class="line">                <span class="keyword">byte</span>[] binaryData = postPolicy.getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">                String encodedPolicy = BinaryUtil.toBase64String(binaryData);</span><br><span class="line">                String postSignature = ossClient.calculatePostSignature(postPolicy);</span><br><span class="line">    </span><br><span class="line">                Map&lt;String, String&gt; respMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">                respMap.put(<span class="string">"accessid"</span>, accessId);</span><br><span class="line">                respMap.put(<span class="string">"policy"</span>, encodedPolicy);</span><br><span class="line">                respMap.put(<span class="string">"signature"</span>, postSignature);</span><br><span class="line">                respMap.put(<span class="string">"dir"</span>, dir);</span><br><span class="line">                respMap.put(<span class="string">"host"</span>, host);</span><br><span class="line">                respMap.put(<span class="string">"expire"</span>, String.valueOf(expireEndTime / <span class="number">1000</span>));</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">return</span> respMap;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.info(e.getMessage());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ossClient.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> 访问结果如下图所示：</p><p> <img src="/2021/06/07/oss-实现文件上传/image-20210609230035269.png" alt="获取签名结果"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）谷粒商城开发-商品服务开发</title>
      <link href="/2021/06/06/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/"/>
      <url>/2021/06/06/%EF%BC%88%E4%B8%89%EF%BC%89%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SpringCloud-Alibaba-集成"><a href="#1-SpringCloud-Alibaba-集成" class="headerlink" title="1. SpringCloud Alibaba 集成"></a>1. SpringCloud Alibaba 集成</h2><ul><li><input checked disabled type="checkbox"> 集成 Nacos 作为注册中心</li><li><input checked disabled type="checkbox"> 采用 OpenFeign 方式进行 RPC 操作</li><li><input checked disabled type="checkbox"> 集成 Nacos 作为配置中心</li><li><input checked disabled type="checkbox"> 采用 SporingCloud Gateway 作为网关，实现路径重写和负载均衡等</li></ul><a id="more"></a><h2 id="2-前端了解"><a href="#2-前端了解" class="headerlink" title="2. 前端了解"></a>2. 前端了解</h2><ul><li><input checked disabled type="checkbox"> ES6 语言基础了解</li><li><input checked disabled type="checkbox"> VUE 基础了解</li><li><input checked disabled type="checkbox"> ElementUI 基础了解</li></ul><h2 id="3-三级分类开发"><a href="#3-三级分类开发" class="headerlink" title="3. 三级分类开发"></a>3. 三级分类开发</h2><h3 id="3-1-网关路径重写和跨域问题"><a href="#3-1-网关路径重写和跨域问题" class="headerlink" title="3.1 网关路径重写和跨域问题"></a>3.1 网关路径重写和跨域问题</h3><ul><li><p>前端 renren-fast-vue 项目统一后台网关访问路径，比如<code>http://localhost:88/api/</code> + <code>模块标识，如 product,order 等</code>，后台 gulimall-gateway 网关项目则对不同的访问路径进行重写，并分发到对应的功能模块中，比如前端访问路径为 <code>http://localhost:88/api/product/*</code> ，则会被重写为 <code>http://localhost:88/product/*</code> 并负载均衡访问 gulimall-product 项目模块</p></li><li><p>由于前后台端口不一致而导致跨域问题，对应解决方法查看 <a href="http://shotozheng.top/2021/05/30/%E8%A7%A3%E5%86%B3-cors-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">cors 跨域问题处理</a> 该文章</p></li></ul><h3 id="3-2-三级分类树查询功能"><a href="#3-2-三级分类树查询功能" class="headerlink" title="3.2 三级分类树查询功能"></a>3.2 三级分类树查询功能</h3><blockquote><p>数据模型：pms_category</p></blockquote><ul><li>查询渲染三级分类树，需要从后台查询出对应的树形数据结构数据，对应的解决方法查看 <a href="http://shotozheng.top/2021/05/30/Java-%E5%AE%9E%E7%8E%B0%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/" target="_blank" rel="noopener">Java 实现树形数据查询</a> 该文章</li><li>分类删除功能开发（MyBatis-Plus 逻辑删除）</li><li>分类新增功能开发</li><li>分类修改、批量修改功能开发</li></ul><p>前端页面效果：</p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703175336893.png" alt="三级分类"></p><h2 id="4-品牌管理开发"><a href="#4-品牌管理开发" class="headerlink" title="4. 品牌管理开发"></a>4. 品牌管理开发</h2><blockquote><p>数据模型：pms_brand 和 pms_category_brand_relation</p></blockquote><ul><li><input checked disabled type="checkbox"> 品牌新增：<a href="https://shotozheng.top/2021/06/07/oss-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" target="_blank" rel="noopener">OSS 文件上传</a> </li><li><input checked disabled type="checkbox"> 品牌分类关联设置：一个 brand 可以属于多个 category</li><li><input checked disabled type="checkbox"> JSR303 校验和自定义校验器、统一异常处理</li></ul><p>前端页面效果：</p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703175147140.png" alt="品牌管理"></p><h2 id="5-平台属性"><a href="#5-平台属性" class="headerlink" title="5. 平台属性"></a>5. 平台属性</h2><blockquote><p>数据模型：pms_attr_group(属性分组)、pms_attr(规格参数和销售属性)</p></blockquote><ul><li>属性分组<ul><li>实现属性分组 attr_group 属于一个分类 category</li><li>实现属性分组 attr_group 关联未关联的属性 attr</li></ul></li><li>规格参数<ul><li>实现属性分类和所属该类下的分组</li></ul></li><li>销售属性<ul><li>实现属性分类和所属该类下的分组</li></ul></li></ul><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703175211527.png" alt="属性分组"></p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703175235109.png" alt="规格参数"></p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703175253118.png" alt="销售属性"></p><h2 id="6-商品维护"><a href="#6-商品维护" class="headerlink" title="6. 商品维护"></a>6. 商品维护</h2><blockquote><p>备注：SPU 可以理解为一个类别，比如 小米9，小米10；SKU 则是对应 SPU 下的具体可销售产品，比如小米9 (12 + 256G、黑色)</p></blockquote><h3 id="6-1-商品发布"><a href="#6-1-商品发布" class="headerlink" title="6.1 商品发布"></a>6.1 商品发布</h3><p>1）设置基本信息：</p><ul><li>数据流向：pms_spu_info SPU 基本信息表、pms_spu_info_desc 描述信息表、pms_spu_images 图片集表</li></ul><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703164625274.png" alt="基本"></p><p>2）设置规格参数，数据来源于某一分类下的 pms_attr_group 和相关 pms_attr 信息</p><ul><li>数据流向：pms_product_attr_value SPU 产品属性表</li></ul><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703164824219.png" alt="设置规格参数"></p><p>3）设置销售属性，数据来源于某一分类下的 pms_attr_group 和相关 pms_attr 信息，入库数据模型：</p><ul><li>数据流向：pms_sku_sale_attr_value SKU 销售属性表</li></ul><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703164909675.png" alt="设置销售属性"></p><p>4）设置 SKU 信息，产品记录数据为销售属性的笛卡尔积</p><ul><li>数据流向：pms_sku_info 基本信息表，pms_sku_images 图片集表</li></ul><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703165352238.png" alt="设置 SKU 信息"></p><p>5）发布后会在商品管理页面生成如下 SKU 记录：</p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703170123920.png" alt="SKU 记录"></p><h3 id="6-2-SPU-管理"><a href="#6-2-SPU-管理" class="headerlink" title="6.2 SPU 管理"></a>6.2 SPU 管理</h3><h4 id="6-3-商品上架"><a href="#6-3-商品上架" class="headerlink" title="6.3 商品上架"></a>6.3 商品上架</h4><p><strong>商品的上架，主要是实现该商品支持被检索</strong>。商品发布后，会在 SPU 管理页面生成对应一条 SPU 记录，来自于 pms_spu_info SPU 基本信息表。</p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703165819803.png" alt="SPU 列表"></p><p>上架流程如下图所示：</p><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210703172813605.png" alt="上架流程"></p><p> SKU 检索商品对象具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkuEsModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long skuId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 上架 spuId */</span></span><br><span class="line">    <span class="keyword">private</span> Long spuId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String skuTitle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal skuPrice;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String skuImg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long saleCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 是否有库存 */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean hasStock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 热点值 */</span></span><br><span class="line">    <span class="keyword">private</span> Long hotScore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long brandId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long catalogId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brandName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String brandImg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String catalogName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 可被检索 product_attr */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Attrs&gt; attrs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SPU 销售属性 product_attr_value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Attrs</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Long attrId;</span><br><span class="line">        <span class="keyword">private</span> String attrName;</span><br><span class="line">        <span class="keyword">private</span> String attrValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-商品详情"><a href="#7-商品详情" class="headerlink" title="7. 商品详情"></a>7. 商品详情</h2><p>商品详情查询步骤如下，其中 skuId  为入参：</p><p>1）通过 skuId 查询<strong>商品基本信息</strong>，并获取 spuId 和 catelogId</p><p>2）通过 spuId 获取<strong>销售属性</strong></p><p>3）通过 spuId 获取<strong>商品介绍信息</strong></p><p>4）通过 spuId 和 catelogId 获取<strong>规格参数信息</strong></p><p>5）通过 skuId 获取<strong>图片信息</strong></p><p>可以发现，1）和 5）都是通过入参 skuId 查询获取对应的信息，而2）、3）和 4）则是需要 1）的执行结果。为了加快执行速度，我们可以采用 CompletFuture 并发编排来执行。即 1) 和 5）并发执行，2）、3）、4）则是在 1）执行完成之后共同并发执行。</p><p>异步编排执行可以参考<a href="https://shotozheng.top/2021/07/10/CompletableFuture-%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92/" target="_blank" rel="noopener">CompletableFuture 异步编排</a></p><h2 id="8-购物车开发"><a href="#8-购物车开发" class="headerlink" title="8. 购物车开发"></a>8. 购物车开发</h2><ul><li><input checked disabled type="checkbox"> 购物车的数据结构如下：</li></ul><p><img src="/2021/06/06/（三）谷粒商城开发-商品服务开发/image-20210717085957729.png" alt="购物车数据结构"></p><ul><li><input checked disabled type="checkbox"> 存在离线购物车的功能，即用户在未登录时可以先为该离线用户创建一个用户标识，在 Redis 中维护一个对应的购物车数据，支持对购物车中的购物项进行增删改查等操作；</li><li><input checked disabled type="checkbox"> 登录后的用户会在缓存中创建一个购物车，如果该用户的离线购物车存在购物项，则会将离线购物车的购物项合并到正式的购物车之中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 谷粒商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cors 跨域问题处理</title>
      <link href="/2021/05/30/%E8%A7%A3%E5%86%B3-cors-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2021/05/30/%E8%A7%A3%E5%86%B3-cors-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><strong>跨域</strong>：指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 Javascript 施加的安全限制。</p><p><strong>同源策略</strong>：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域。具体场景如下所示：</p><a id="more"></a><p><img src="/2021/05/30/解决-cors-跨域问题/image-20210530155150910.png" alt></p><p>跨域前端产生的报错如下所示，即从 <code>http://localhost:8001</code> 访问 <code>http://localhost:88/api/sys/login</code> 时被 CORS 策略阻止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">'http://localhost:88/api/sys/login'</span> <span class="keyword">from</span> origin <span class="string">'http://localhost:8001'</span> has been blocked by CORS policy: Response to preflight request doesn<span class="string">'t pass access control check: No '</span>Access-Control-Allow-Origin<span class="string">' header is present on the requested resource.</span></span><br></pre></td></tr></table></figure><h2 id="2-跨域流程"><a href="#2-跨域流程" class="headerlink" title="2. 跨域流程"></a>2. 跨域流程</h2><p>如下图是跨域的流程，具体关于非简单请求概念和其他跨域相关内容，可访问官网：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><p><img src="/2021/05/30/解决-cors-跨域问题/image-20210530155453524.png" alt="跨域流程"></p><h2 id="3-解决跨域方案"><a href="#3-解决跨域方案" class="headerlink" title="3. 解决跨域方案"></a>3. 解决跨域方案</h2><h3 id="3-1-nginx-配置同源"><a href="#3-1-nginx-配置同源" class="headerlink" title="3.1 nginx 配置同源"></a>3.1 nginx 配置同源</h3><p>根据产生跨域的原因，我们可以使用 nginx 对不同的请求配置成相同的地址和端口，然后在使用 nginx 内部进行请求转发，例如下图所示，这样可以有效解决跨域问题。</p><p><img src="/2021/05/30/解决-cors-跨域问题/image-20210530155852430.png" alt></p><h3 id="3-2-请求全局过滤"><a href="#3-2-请求全局过滤" class="headerlink" title="3.2 请求全局过滤"></a>3.2 请求全局过滤</h3><p>根据跨域流程我们知道浏览器首先会发送预检请求给服务器，然后根据服务器的响应是否允许实现跨域请求。因此我们只需要让服务器对指定的请求响应允许跨域请求即可，具体实现则是配置对应的响应头。常用的响应头如下所示：</p><ul><li>Access-Control-Allow-Origin：支持哪些来源的请求跨域</li><li>Access-Control-Allow-Methods：支持哪些方法跨域</li><li>Access-Control-Allow-Credentials：跨域请求默认不包含 cookie，设置为 true 可以包含 cookie</li><li>Access-Control-Expose-Headers：跨域请求暴露的字段<ul><li>CORS请求时，XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到6个基本字段： Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</li></ul></li><li>Access-Control-Max-Age：表明该响应的有效时间为多少秒。在有效时间内，浏览器无须为同一请求再次发起预检请求。请注意，浏览器自身维护了一个最大有效时间，如果该首部字段的值超过了最大有效时间，将不会生效。</li></ul><p>下面以 SpringBoot 为示例，通过过滤器实现对请求进行跨域处理，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跨域处理配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhengst</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GulimallCorsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsWebFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        CorsConfiguration configuration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">// 允许暴露所有请求头</span></span><br><span class="line">        configuration.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 允许暴露所有请求方法</span></span><br><span class="line">        configuration.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 允许暴露所有请求来源</span></span><br><span class="line">        configuration.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 支持请求包含 cookie</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, configuration);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 实现树形数据查询</title>
      <link href="/2021/05/30/Java-%E5%AE%9E%E7%8E%B0%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/"/>
      <url>/2021/05/30/Java-%E5%AE%9E%E7%8E%B0%E6%A0%91%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，我们可以通过 SQL 的方式和 Java 的方式获取树形数据，比如常见的菜单数据、用户组织数据等。下面我们使用 Java 的 Stream 类处理获取树形数据。</p><p>下图是对应的数据模型，我们主要需要关注的就是分类标识 cat_id、父分类标识 parent_cid 和排序字段 sort。</p><p><img src="/2021/05/30/Java-实现树形数据查询/image-20210530103535642.png" alt="数据模型"></p><a id="more"></a><p>如下是对应的代码，具体分析见注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 树形查询分类列表数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title">listWithTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 查询所有分类数据</span></span><br><span class="line">    List&lt;CategoryEntity&gt; entities = baseMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 过滤获取所有父分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; collect = entities.stream().filter(</span><br><span class="line">        e -&gt; e.getParentCid() == <span class="number">0</span></span><br><span class="line">    ).map(e -&gt; &#123;</span><br><span class="line">        <span class="comment">// 3. 设置每个父分类的子分类</span></span><br><span class="line">        e.setChildren(getChildren(e, entities));</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 4. 对所有父分类进行升序排序</span></span><br><span class="line">    &#125;).sorted((e1, e2) -&gt; (e1.getSort() == <span class="keyword">null</span> ? <span class="number">0</span> : e1.getSort()) - (e2.getSort() == <span class="keyword">null</span> ? <span class="number">0</span> : e2.getSort())).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> collect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归设置父分类的所有子分类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> curMenu 当前菜单分类实体</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> allMenus 所有菜单分类列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;CategoryEntity&gt; <span class="title">getChildren</span><span class="params">(CategoryEntity curMenu, List&lt;CategoryEntity&gt; allMenus)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 过滤获取当前父分类的所有子分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; entities = allMenus.stream().filter(e -&gt;</span><br><span class="line">                                                             curMenu.getCatId().equals(e.getParentCid())</span><br><span class="line">                                                            ).map(e -&gt; &#123;</span><br><span class="line">        <span class="comment">// 2. 设置当前父分类的所有子分类</span></span><br><span class="line">        e.setChildren(getChildren(e, allMenus));</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 3. 对所有父分类进行升序排序</span></span><br><span class="line">    &#125;).sorted((e1, e2) -&gt; (e1.getSort() == <span class="keyword">null</span> ? <span class="number">0</span> : e1.getSort()) - (e2.getSort() == <span class="keyword">null</span> ? <span class="number">0</span> : e2.getSort())).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> entities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是对应的数据返回结果：</p><p><img src="/2021/05/30/Java-实现树形数据查询/image-20210530104005448.png" alt="查询结果"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 业务场景 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）谷粒商城开发-基础项目搭建</title>
      <link href="/2021/05/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/05/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E5%9F%BA%E7%A1%80%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-创建-Github-仓库"><a href="#1-创建-Github-仓库" class="headerlink" title="1. 创建 Github 仓库"></a>1. 创建 Github 仓库</h2><p>创建 Github 仓库，地址：<a href="https://github.com/ShotoZheng/gulimall" target="_blank" rel="noopener">https://github.com/ShotoZheng/gulimall</a></p><h2 id="2-创建项目微服务"><a href="#2-创建项目微服务" class="headerlink" title="2. 创建项目微服务"></a>2. 创建项目微服务</h2><h3 id="2-1-创建项目模块"><a href="#2-1-创建项目模块" class="headerlink" title="2.1 创建项目模块"></a>2.1 创建项目模块</h3><p>包括公共服务、商品服务、仓储服务、订单服务、优惠券服务、用户服务，具体如下图：</p><p><img src="/2021/05/16/谷粒商城开发-基础项目搭建/image-20210516230836932.png" alt="项目模块"></p><a id="more"></a><h3 id="2-2-创建数据库模型"><a href="#2-2-创建数据库模型" class="headerlink" title="2.2 创建数据库模型"></a>2.2 创建数据库模型</h3><p>创建下述数据库模型，修改上述微服务项目，修改相关 application.yml 配置信息。</p><p><img src="/2021/05/16/谷粒商城开发-基础项目搭建/image-20210516232716845.png" alt="数据库模型"></p><h3 id="2-2-使用人人开源"><a href="#2-2-使用人人开源" class="headerlink" title="2.2 使用人人开源"></a>2.2 使用人人开源</h3><h4 id="2-2-1-搭建前后台管理系统"><a href="#2-2-1-搭建前后台管理系统" class="headerlink" title="2.2.1 搭建前后台管理系统"></a>2.2.1 搭建前后台管理系统</h4><p>这里我们使用人人开源快速搭建后台管理系统平台，并实现前后端分离。</p><ol><li><p>后台项目：<a href="https://gitee.com/renrenio/renren-fast" target="_blank" rel="noopener">https://gitee.com/renrenio/renren-fast</a></p><p> 1.1 创建自带的数据库模型，修改数据库连接信息</p></li><li><p>前端项目：<a href="https://gitee.com/renrenio/renren-fast-vue" target="_blank" rel="noopener">https://gitee.com/renrenio/renren-fast-vue</a></p><p> 2.1 vscode 打开，使用 npm install 安装相关依赖，然后使用 npm run dev 运行</p></li></ol><p>演示效果如下：</p><p><img src="/2021/05/16/谷粒商城开发-基础项目搭建/image-20210516233403482.png" alt></p><h4 id="2-2-2-生成微服务模块代码"><a href="#2-2-2-生成微服务模块代码" class="headerlink" title="2.2.2 生成微服务模块代码"></a>2.2.2 生成微服务模块代码</h4><p>同样的，可以使用 <a href="https://gitee.com/renrenio/renren-generator" target="_blank" rel="noopener">renren-generator</a> 生成谷粒商城各个微服务模块简单的增删改查代码，然后将生成的代码添加到对应的功能模块即可。大致步骤如下：</p><ol><li><p>修改数据库连接信息，指明指定功能模块的数据库连接地址：</p><p> <img src="/2021/05/16/谷粒商城开发-基础项目搭建/image-20210516233926921.png" alt="配置数据库连接地址"></p></li><li><p>修改生成规则，包括包名、模块名、作者信息等：</p><p> <img src="/2021/05/16/谷粒商城开发-基础项目搭建/image-20210516234000389.png" alt="修改生成规则，包括包名、模块名、作者信息等"></p><h2 id="3-项目代码"><a href="#3-项目代码" class="headerlink" title="3. 项目代码"></a>3. 项目代码</h2><p> <a href="https://github.com/ShotoZheng/gulimall/commit/92501d7880017e449b1dc513791431063c0bba58" target="_blank" rel="noopener">基础微服务模块搭建</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 谷粒商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）谷粒商城开发-介绍和基础环境搭建</title>
      <link href="/2021/05/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/05/16/%E8%B0%B7%E7%B2%92%E5%95%86%E5%9F%8E%E5%BC%80%E5%8F%91-%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>详见 <a href="https://github.com/ShotoZheng/gulimall-data/blob/main/01%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%26%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.docx" target="_blank" rel="noopener">分布式基础&amp;项目环境搭建 </a>文档</p></blockquote><h2 id="1-分布式基础-amp-环境搭建"><a href="#1-分布式基础-amp-环境搭建" class="headerlink" title="1. 分布式基础 &amp; 环境搭建"></a>1. 分布式基础 &amp; 环境搭建</h2><h3 id="1-1-项目架构图"><a href="#1-1-项目架构图" class="headerlink" title="1.1 项目架构图"></a>1.1 项目架构图</h3><h4 id="1-1-1-项目微服务架构图"><a href="#1-1-1-项目微服务架构图" class="headerlink" title="1.1.1 项目微服务架构图"></a>1.1.1 项目微服务架构图</h4><p><img src="/2021/05/16/谷粒商城开发-介绍和基础环境搭建/image-20210516222200891.png" alt="项目微服务架构图"></p><a id="more"></a><h4 id="1-1-2-微服务划分图"><a href="#1-1-2-微服务划分图" class="headerlink" title="1.1.2 微服务划分图"></a>1.1.2 微服务划分图</h4><p><img src="/2021/05/16/谷粒商城开发-介绍和基础环境搭建/image-20210516222330177.png" alt="微服务划分图"></p><h2 id="2-分布式基础概念"><a href="#2-分布式基础概念" class="headerlink" title="2. 分布式基础概念"></a>2. 分布式基础概念</h2><h3 id="2-1-微服务概念"><a href="#2-1-微服务概念" class="headerlink" title="2.1 微服务概念"></a>2.1 微服务概念</h3><p>微服务架构风格，就像是把一个单独的应用程序开发为一套小服务，每个小服务运行在自己的进程中，并使用轻量级机制通信，通常是 HTTP API。这些服务围绕业务能力来构建， 并通过完全自动化部署机制来独立部署。这些服务使用不同的编程语言书写，以及不同数据存储技术，并保持最低限度的集中式管理。</p><p>简而言之：拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行。</p><h3 id="2-2-集群-amp-分布式-amp-节点"><a href="#2-2-集群-amp-分布式-amp-节点" class="headerlink" title="2.2 集群&amp;分布式&amp;节点"></a>2.2 集群&amp;分布式&amp;节点</h3><p>分布式是指将不同的业务分布在不同的地方，集群指的是将几台服务器集中在一起，实现同一业务。分布式中的每一个节点，都可以做集群。而集群并不一定就是分布式的。节点则是指集群中的一个服务器。</p><h2 id="3-环境搭建"><a href="#3-环境搭建" class="headerlink" title="3. 环境搭建"></a>3. 环境搭建</h2><h3 id="3-1-安装虚拟机"><a href="#3-1-安装虚拟机" class="headerlink" title="3.1 安装虚拟机"></a>3.1 安装虚拟机</h3><p>使用 VirtualWare + 镜像，也可以使用 Oracle VirtualBox + Vagrant 的方式进行虚拟机下载、安装和配置；</p><h3 id="3-2-安装-docker"><a href="#3-2-安装-docker" class="headerlink" title="3.2 安装 docker"></a>3.2 安装 docker</h3><ol><li>docker 安装文档：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></li><li>docker 安装 mysql 5.7 镜像，设置开机自启；</li><li>docker 安装 redis（最新版），设置开机自启；</li></ol><h3 id="3-3-开发环境统一"><a href="#3-3-开发环境统一" class="headerlink" title="3.3 开发环境统一"></a>3.3 开发环境统一</h3><ol><li>安装配置 Maven 3.6.2；</li><li>安装配置 JDK 1.8；</li><li>Idea 安装 lombok、mybatisx 插件;</li><li>Vscode 安装 Vetur、EsLint、Auto Close Tag、Auto Rename Tag、JavaScript(ES6) code snippets、HTML CSS Support、HTML Snippets、Open in browser、Live Server、Chinese (Simplified) Language Pack for Visual Studio Code </li><li>git 安装配置，ssh 设置；</li><li>Node 12.16 安装，并设置淘宝镜像：<code>npm config set registry http://registry.npm.taobao.org/</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 谷粒商城 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 谷粒商城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 RabbitMQ 因网络超时导致的 An unexpected connection driver error occured 问题</title>
      <link href="/2021/05/04/%E8%A7%A3%E5%86%B3-RabbitMQ-%E5%9B%A0%E7%BD%91%E7%BB%9C%E8%B6%85%E6%97%B6%E5%AF%BC%E8%87%B4%E7%9A%84-An-unexpected-connection-driver-error-occured-%E9%97%AE%E9%A2%98/"/>
      <url>/2021/05/04/%E8%A7%A3%E5%86%B3-RabbitMQ-%E5%9B%A0%E7%BD%91%E7%BB%9C%E8%B6%85%E6%97%B6%E5%AF%BC%E8%87%B4%E7%9A%84-An-unexpected-connection-driver-error-occured-%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>如下是获取与 RabbitMQ 连接的一段代码，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 连接对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">// 定义连接工厂</span></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    <span class="comment">// 设置服务地址</span></span><br><span class="line">    factory.setHost(<span class="string">"192.168.31.41"</span>);</span><br><span class="line">    <span class="comment">// 设置端口</span></span><br><span class="line">    factory.setPort(<span class="number">5672</span>);</span><br><span class="line">    <span class="comment">// 设置账号信息，用户名，密码和虚拟主机</span></span><br><span class="line">    factory.setVirtualHost(<span class="string">"host1"</span>);</span><br><span class="line">    factory.setUsername(<span class="string">"shoto"</span>);</span><br><span class="line">    factory.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line">    <span class="comment">// 握手超时设置需要有，因为不同机器之前的网络情况不同，因此可能导致网络超时而无法连接</span></span><br><span class="line"><span class="comment">//        factory.setHandshakeTimeout(300 * 1000);</span></span><br><span class="line">    <span class="comment">// 通过工厂获取连接</span></span><br><span class="line">    Connection connection = factory.newConnection();</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在用户权限、连接信息、erlang 和 RabbitMQ 版本适配都正确的情况，运行依旧报下述错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.TimeoutException</span><br><span class="line">    at com.rabbitmq.utility.BlockingCell.get(BlockingCell.java:77)</span><br><span class="line">    at com.rabbitmq.utility.BlockingCell.uninterruptibleGet(BlockingCell.java:120)</span><br><span class="line">    at com.rabbitmq.utility.BlockingValueOrException.uninterruptibleGetValue(BlockingValueOrException.java:36)</span><br><span class="line">    at com.rabbitmq.client.impl.AMQChannel$BlockingRpcContinuation.getReply(AMQChannel.java:451)</span><br><span class="line">    at com.rabbitmq.client.impl.AMQConnection.start(AMQConnection.java:323)</span><br><span class="line">    at com.rabbitmq.client.impl.recovery.RecoveryAwareAMQConnectionFactory.newConnection(RecoveryAwareAMQConnectionFactory.java:63)</span><br><span class="line">    at com.rabbitmq.client.impl.recovery.AutorecoveringConnection.init(AutorecoveringConnection.java:177)</span><br><span class="line">    at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:1161)</span><br><span class="line">    at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:1118)</span><br><span class="line">    at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:1076)</span><br><span class="line">    at com.rabbitmq.client.ConnectionFactory.newConnection(ConnectionFactory.java:1236)</span><br><span class="line">    at com.shoto.utils.ConnectionUtil.getConnection(ConnectionUtil.java:31)</span><br><span class="line">    at com.shoto.utils.ConnectionUtil.main(ConnectionUtil.java:42)</span><br><span class="line">2021-01-30 20:25:20 761 ERROR [AMQP Connection 192.168.31.41:5672] ForgivingExceptionHandler - An unexpected connection driver error occured - (124)</span><br><span class="line">java.net.SocketException: Socket Closed</span><br><span class="line">    at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">    at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">    at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">    at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">    at java.io.BufferedInputStream.fill(BufferedInputStream.java:246)</span><br><span class="line">    at java.io.BufferedInputStream.read(BufferedInputStream.java:265)</span><br><span class="line">    at java.io.DataInputStream.readUnsignedByte(DataInputStream.java:288)</span><br><span class="line">    at com.rabbitmq.client.impl.Frame.readFrom(Frame.java:91)</span><br><span class="line">    at com.rabbitmq.client.impl.SocketFrameHandler.readFrame(SocketFrameHandler.java:164)</span><br><span class="line">    at com.rabbitmq.client.impl.AMQConnection$MainLoop.run(AMQConnection.java:604)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><p>后来才发现是由于网络连接 RabbitMQ 超时导致的，解决办法就是在连接的时候增加如下代码，具体产生问题原因未知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 握手超时设置需要有，因为不同机器之前的网络情况不同，因此可能导致网络超时而无法连接</span></span><br><span class="line">factory.setHandshakeTimeout(<span class="number">300</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 访问 oracle 11g 中的存储过程</title>
      <link href="/2021/05/04/Java-%E8%AE%BF%E9%97%AE-oracle-11g-%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/2021/05/04/Java-%E8%AE%BF%E9%97%AE-oracle-11g-%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>下面介绍几种常用的 Java 访问 oarcle 存储过程的示例，需要说明的是创建 Java 项目记得装载 odbc 驱动包，并创建按如下 student 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> STUDENT</span><br><span class="line">(</span><br><span class="line">  sno   <span class="built_in">number</span>,</span><br><span class="line">  sname VARCHAR2(<span class="number">10</span>),</span><br><span class="line">  sage  <span class="built_in">number</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-没有返回参数的过程"><a href="#1-没有返回参数的过程" class="headerlink" title="1. 没有返回参数的过程"></a>1. 没有返回参数的过程</h2><h3 id="1-1-插入记录"><a href="#1-1-插入记录" class="headerlink" title="1.1 插入记录"></a>1.1 插入记录</h3><p>首先创建如下存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> test1(inSno <span class="keyword">in</span> <span class="built_in">number</span>, inSname <span class="keyword">in</span> varchar2, inSage <span class="keyword">in</span> <span class="built_in">number</span>) </span><br><span class="line"><span class="keyword">is</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> student(sno, sname, sage) <span class="keyword">values</span>(inSno, inSname, inSage);</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>编写如下程序，即可实现对存储过程的访问，从而实现对学生记录的插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Connection conn;</span><br><span class="line">    <span class="keyword">private</span> CallableStatement callStmt;</span><br><span class="line">    <span class="keyword">private</span> ResultSet rs;</span><br><span class="line">    <span class="keyword">private</span> String driver = <span class="string">"oracle.jdbc.driver.OracleDriver"</span>;</span><br><span class="line">    <span class="keyword">private</span> String url = <span class="string">"jdbc:oracle:thin:@127.0.0.1:1521:orcl"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试没有返回参数的过程的调用（插入）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inSno</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inSname</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inSage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotReturnParamInsert</span><span class="params">(<span class="keyword">int</span> inSno, String inSname, <span class="keyword">int</span> inSage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = DriverManager.getConnection(url, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">                <span class="comment">// 三个占位符表示三个参数</span></span><br><span class="line">                callStmt = conn.prepareCall(<span class="string">"&#123;call test1(?, ?, ?)&#125;"</span>);</span><br><span class="line">                <span class="comment">// 传入参数值</span></span><br><span class="line">                callStmt.setInt(<span class="number">1</span>, inSno);</span><br><span class="line">                callStmt.setString(<span class="number">2</span>, inSname);</span><br><span class="line">                callStmt.setInt(<span class="number">3</span>, inSage);</span><br><span class="line">                <span class="comment">// 执行</span></span><br><span class="line">                callStmt.execute();</span><br><span class="line">                System.out.println(<span class="string">"执行成功了！"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (callStmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    callStmt.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TestDemo().testNotReturnParamInsert(<span class="number">6</span>, <span class="string">"Jane"</span>, <span class="number">26</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-更新记录"><a href="#1-2-更新记录" class="headerlink" title="1.2 更新记录"></a>1.2 更新记录</h3><p>同样创建如下存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> test2(inSno <span class="keyword">in</span> <span class="built_in">number</span>, inSage <span class="keyword">in</span> <span class="built_in">number</span>) </span><br><span class="line"><span class="keyword">is</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> sage = inSage <span class="keyword">where</span> sno = inSno;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>编写如下程序方法，即可实现对存储过程的访问，从而实现对学生记录的更新：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 测试没有返回参数的过程的调用（更新）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> inSno</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> inSage</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNotReturnParamUpdate</span><span class="params">(<span class="keyword">int</span> inSno, <span class="keyword">int</span> inSage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">            callStmt = conn.prepareCall(<span class="string">"&#123;call test2(?, ?)&#125;"</span>);</span><br><span class="line">            callStmt.setInt(<span class="number">1</span>, inSno);</span><br><span class="line">            callStmt.setInt(<span class="number">2</span>, inSage);</span><br><span class="line">            callStmt.execute();</span><br><span class="line">            System.out.println(<span class="string">"执行成功了！"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (callStmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callStmt.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-有返回参数的过程"><a href="#2-有返回参数的过程" class="headerlink" title="2. 有返回参数的过程"></a>2. 有返回参数的过程</h2><p>创建如下存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> test3(inSno <span class="keyword">in</span> <span class="built_in">number</span>, outSname <span class="keyword">out</span> varchar2, outSage <span class="keyword">out</span> <span class="built_in">number</span>) <span class="keyword">is</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> sname, sage <span class="keyword">into</span> outSname, outSage <span class="keyword">from</span> student <span class="keyword">where</span> sno = inSno;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>编写如下程序方法，即可实现对存储过程的访问，从而实现对指定学号的学生姓名和年龄的获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试有返回参数的过程的调用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inSno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnParam</span><span class="params">(<span class="keyword">int</span> inSno)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">            callStmt = conn.prepareCall(<span class="string">"&#123;call test3(?, ?, ?)&#125;"</span>);</span><br><span class="line">            callStmt.setInt(<span class="number">1</span>, inSno);</span><br><span class="line">            <span class="comment">// out 类型的参数需要进行注册，并指明类型</span></span><br><span class="line">            callStmt.registerOutParameter(<span class="number">2</span>, Types.VARCHAR);</span><br><span class="line">            callStmt.registerOutParameter(<span class="number">3</span>, Types.INTEGER);</span><br><span class="line">            callStmt.execute();</span><br><span class="line">            <span class="comment">// 获取返回结果</span></span><br><span class="line">            String name = callStmt.getString(<span class="number">2</span>);</span><br><span class="line">            Integer age = callStmt.getInt(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">"学生学号："</span> + inSno + <span class="string">", 姓名："</span> + name + <span class="string">", 年龄："</span> + age);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (callStmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callStmt.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-返回列表的过程"><a href="#3-返回列表的过程" class="headerlink" title="3. 返回列表的过程"></a>3. 返回列表的过程</h2><p>由于 oracle 存储过程要返回列表结果集，需要在存储过程的 out 参数中指明为 ref 游标类型的参数。为了实现这种效果，我们首先创建如下程序包头，并声明 ref 游标类型变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建程序包头</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> pack1 <span class="keyword">is</span></span><br><span class="line">    <span class="keyword">type</span> test_cursor <span class="keyword">is</span> <span class="keyword">ref</span> <span class="keyword">cursor</span>; <span class="comment">-- 声明一个 ref 游标类型的类型变量</span></span><br><span class="line"><span class="keyword">end</span> pack1;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> test4(p_cursor <span class="keyword">out</span> pack1.test_cursor) <span class="keyword">is</span> <span class="comment">-- out 参数类型为 test_cursor 类型，也即是 ref 游标类型</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">open</span> p_cursor <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment">-- 返回的结果集为游标类型</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>编写如下程序方法，即可获取列表结果集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">            callStmt = conn.prepareCall(<span class="string">"&#123;call test4(?)&#125;"</span>);</span><br><span class="line">            <span class="comment">// 注册为游标类型</span></span><br><span class="line">            callStmt.registerOutParameter(<span class="number">1</span>, OracleTypes.CURSOR);</span><br><span class="line">            callStmt.execute();</span><br><span class="line">            <span class="comment">// 获取返回结果</span></span><br><span class="line">            rs = (ResultSet) callStmt.getObject(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"学生学号："</span> + rs.getInt(<span class="number">1</span>) + <span class="string">", 姓名："</span> + rs.getString(<span class="number">2</span>) + <span class="string">", 年龄："</span> + rs.getInt(<span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (callStmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callStmt.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-返回带分页的列表的过程"><a href="#4-返回带分页的列表的过程" class="headerlink" title="4. 返回带分页的列表的过程"></a>4. 返回带分页的列表的过程</h2><p>创建如下存储过程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里我们依旧使用上述事例的程序包包头 pack1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> test5(pageSize <span class="keyword">in</span> <span class="built_in">number</span>, pageNo <span class="keyword">in</span> <span class="built_in">number</span>, p_cursor <span class="keyword">out</span> pack1.test_cursor) <span class="keyword">is</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">open</span> p_cursor <span class="keyword">for</span> </span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> s.*, <span class="keyword">rownum</span> rn <span class="keyword">from</span> student s) <span class="keyword">where</span> rn &gt;= pageSize * (pageNo - <span class="number">1</span>） + <span class="number">1</span> <span class="keyword">and</span> rn &lt;= pageSize * pageNo;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>编写如下程序方法，即可获取列表分页结果集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnPageList</span><span class="params">(<span class="keyword">int</span> pageSize, <span class="keyword">int</span> pageNo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = DriverManager.getConnection(url, <span class="string">"scott"</span>, <span class="string">"tiger"</span>);</span><br><span class="line">            callStmt = conn.prepareCall(<span class="string">"&#123;call test5(?, ?, ?)&#125;"</span>);</span><br><span class="line">            callStmt.setInt(<span class="number">1</span>, pageSize);</span><br><span class="line">            callStmt.setInt(<span class="number">2</span>, pageNo);</span><br><span class="line">            callStmt.registerOutParameter(<span class="number">3</span>, OracleTypes.CURSOR);</span><br><span class="line">            callStmt.execute();</span><br><span class="line">            rs = (ResultSet) callStmt.getObject(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"学生学号："</span> + rs.getInt(<span class="number">1</span>) + <span class="string">", 姓名："</span> + rs.getString(<span class="number">2</span>) + <span class="string">", 年龄："</span> + rs.getInt(<span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (callStmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">                callStmt.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的程序包</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>程序包是对相关过程、函数、变量、游标和异常等对象的封装。程序包具有模块化、更轻松的应用程序设计、信息隐藏、新增功能和性能更佳等优点。程序包由规范（包头）和主体（包体）两部分组成，及其作用如下图所示：</p><p><img src="/2021/05/04/oracle-11g-的程序包/20201107115621459.png" alt></p><p>需要说明的是，包头中声明的变量为公共变量，程序包可以进行访问。而包体中的为私有变量，只能在包体中进行访问。</p><a id="more"></a><h2 id="2-创建"><a href="#2-创建" class="headerlink" title="2. 创建"></a>2. 创建</h2><h3 id="2-1-创建语法"><a href="#2-1-创建语法" class="headerlink" title="2.1 创建语法"></a>2.1 创建语法</h3><p>程序包包头创建语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">PACKAGE</span> package_name <span class="comment">-- 使用到了package</span></span><br><span class="line"><span class="keyword">IS</span>|<span class="keyword">AS</span></span><br><span class="line">[<span class="keyword">Public</span> item declarations] <span class="comment">-- 公共对象声明</span></span><br><span class="line">[Subprogram specification] <span class="comment">-- 子程序规范</span></span><br><span class="line"><span class="keyword">END</span> [package_name];</span><br></pre></td></tr></table></figure><p>程序包包体创建语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">PACKAGE</span> <span class="keyword">BODY</span> package_name <span class="comment">-- 使用到了package 和 body</span></span><br><span class="line"><span class="keyword">IS</span>|<span class="keyword">AS</span></span><br><span class="line">[<span class="keyword">Private</span> item declarations] <span class="comment">-- 私有对象声明</span></span><br><span class="line">[Subprogram bodies] <span class="comment">-- 子程序主体</span></span><br><span class="line">[<span class="keyword">BEGIN</span> Initialization]</span><br><span class="line"><span class="keyword">END</span> [package_name];</span><br></pre></td></tr></table></figure><h3 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h3><p>假设现在有如下 student 表，具体内容如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      5 lisi                                            -6</span><br><span class="line">                                      1 Tom                                             31</span><br><span class="line">                                      2 Kite                                            32</span><br><span class="line">                                      3 Bob                                             33</span><br><span class="line">                                      4 Mike                                            34</span><br></pre></td></tr></table></figure><p>首先创建如下程序包包头：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> pack1</span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">    aa <span class="built_in">int</span> := <span class="number">-9</span>; <span class="comment">-- 公共变量</span></span><br><span class="line">    procedure insert_student(a1 in student%rowtype); <span class="comment">-- 声明一个存储过程</span></span><br><span class="line">    procedure update_student(a2 in student%rowtype); <span class="comment">-- 声明一个存储过程</span></span><br><span class="line"><span class="keyword">end</span> pack1;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>接着创建对应的包体：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> <span class="keyword">body</span> pack1 <span class="comment">-- 增加一个 body 且名字相对应</span></span><br><span class="line"><span class="keyword">is</span></span><br><span class="line">    bb <span class="built_in">int</span> := <span class="number">5</span>; <span class="comment">-- 声明一个私有变量</span></span><br><span class="line">    <span class="comment">-- 定义第一个存储过程</span></span><br><span class="line">    procedure insert_student(a1 in student%rowtype)</span><br><span class="line">    is</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> student(sno, sname, sage) <span class="keyword">values</span> (a1.sno, a1.sname, a1.sage);</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line">    <span class="comment">-- 验证一下私有变量</span></span><br><span class="line">    dbms_output.put_line(pack1.bb);</span><br><span class="line">    <span class="keyword">end</span> insert_student;</span><br><span class="line">    <span class="comment">-- 定义第二个存储过程</span></span><br><span class="line">    procedure update_student(a2 in student%rowtype)</span><br><span class="line">    is</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> sname = a2.sname, sage = a2.sage <span class="keyword">where</span> sno = a2.sno;</span><br><span class="line">    <span class="keyword">commit</span>;</span><br><span class="line">    <span class="keyword">end</span> update_student;</span><br><span class="line"><span class="keyword">end</span> pack1;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>我们来验证一下公有变量和私有变量得访问限制，查看下面输出结果，包体中的公共变量可以在程序包访问。而包体中的私有变量则不可以：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; execute dbms_output.put_line(pack1.aa);</span><br><span class="line"></span><br><span class="line">-9</span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------------------</span></span><br><span class="line"></span><br><span class="line">SQL&gt; execute dbms_output.put_line(pack1.bb);</span><br><span class="line"><span class="keyword">begin</span> dbms_output.put_line(pack1.bb); <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">ORA-06550: 第 1 行, 第 34 列: </span><br><span class="line">PLS-00302: 必须声明 'BB' 组件</span><br><span class="line">ORA-06550: 第 1 行, 第 7 列: </span><br><span class="line">PL/SQL: Statement ignored</span><br></pre></td></tr></table></figure><p>同样也可以调用程序包中定义的存储过程，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    stu student%rowtype;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    stu.sno := <span class="number">7</span>;</span><br><span class="line">    stu.sname := '张章';</span><br><span class="line">    stu.sage := 42;</span><br><span class="line">    <span class="comment">-- 调用程序包</span></span><br><span class="line">    pack1.insert_student(stu);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 执行上述 PL/SQL 块之后，student 多了一条相应的记录</span></span><br><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      7 张章                                            42</span><br><span class="line">                                      5 lisi                                            -6</span><br><span class="line">                                      1 Tom                                             31</span><br><span class="line">                                      2 Kite                                            32</span><br><span class="line">                                      3 Bob                                             33</span><br><span class="line">                                      4 Mike                                            34</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    stu student%rowtype;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    stu.sno := <span class="number">5</span>;</span><br><span class="line">    stu.sname := 'zhangsan';</span><br><span class="line">    stu.sage := 12;</span><br><span class="line">    <span class="comment">-- 调用程序包</span></span><br><span class="line">    pack1.update_student(stu);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 同理如下</span></span><br><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      7 张章                                            42</span><br><span class="line">                                      5 zhangsan                                        12</span><br><span class="line">                                      1 Tom                                             31</span><br><span class="line">                                      2 Kite                                            32</span><br><span class="line">                                      3 Bob                                             33</span><br><span class="line">                                      4 Mike                                            34</span><br></pre></td></tr></table></figure><h2 id="3-程序包中的游标"><a href="#3-程序包中的游标" class="headerlink" title="3. 程序包中的游标"></a>3. 程序包中的游标</h2><p>程序包中使用游标与我们平常在 PL/SQL 块中游标的方式不太一样。在程序包中，游标的定义分为游标规范和游标主体两部分。在包规范中声明游标规范时必须使用 RETURN 子句<strong>指定游标的返回类型</strong>，RETURN子句指定的数据类型可以是：</p><ul><li>用 %ROWTYPE 属性引用表定义的记录类型</li><li>自定义的记录类型，例如 TYPE EMPRECTYP IS RECORD(emp_id INTEGER,salary REAL)来定义的。</li></ul><p>但是不可以是 number，varchar2， %TYPE等类型。 </p><p>下面我们介绍在程序包中使用显式游标，示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包头</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PACKAGE</span> cur_pack</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line">    <span class="keyword">CURSOR</span> stu_cur(stu_num <span class="built_in">number</span>) <span class="keyword">RETURN</span> student%rowtype; <span class="comment">-- 游标规范部分，需要带上 return 子句</span></span><br><span class="line">    PROCEDURE print_stu(stu_num number);</span><br><span class="line"><span class="keyword">end</span> cur_pack;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建包体</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PACKAGE</span> <span class="keyword">BODY</span> cur_pack</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">    <span class="comment">-- 记得参数名称需要与包头的对应上</span></span><br><span class="line">    <span class="keyword">CURSOR</span> stu_cur(stu_num <span class="built_in">number</span>) <span class="keyword">RETURN</span> student%ROWTYPE <span class="keyword">IS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sno = stu_num; <span class="comment">-- 游标主体部分</span></span><br><span class="line">    <span class="comment">-- 存储过程主体部分</span></span><br><span class="line"> PROCEDURE print_stu(stu_num number) </span><br><span class="line"> IS</span><br><span class="line"> stu student%ROWTYPE; <span class="comment">-- 声明变量</span></span><br><span class="line"> <span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">OPEN</span> stu_cur(stu_num);  <span class="comment">-- 打开游标</span></span><br><span class="line">  LOOP</span><br><span class="line">    FETCH stu_cur INTO stu; <span class="comment">-- 游标记录当前行记录</span></span><br><span class="line">    EXIT WHEN stu_cur%NOTFOUND;</span><br><span class="line">    DBMS_OUTPUT.PUT_LIne('当前学生信息：学号=' || stu.sno || ',姓名=' || stu.sname || ', 年龄=' || stu.sage);</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">  CLOSE stu_cur; <span class="comment">-- 关闭游标</span></span><br><span class="line"> <span class="keyword">END</span> print_stu;</span><br><span class="line"><span class="keyword">END</span> cur_pack;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>使用如下语句调用如上的程序包，结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec cur_pack.print_stu(2);</span><br><span class="line"></span><br><span class="line">当前学生信息：学号=2,姓名=Kite, 年龄=32</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed</span><br></pre></td></tr></table></figure><p>下面我们介绍在程序包中使用 REF 游标，示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建包头</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> pack_ref <span class="keyword">is</span></span><br><span class="line">    <span class="keyword">type</span> refcur <span class="keyword">is</span> <span class="keyword">ref</span> <span class="keyword">cursor</span>; <span class="comment">-- 此处只声明类型为参照游标的类型变量</span></span><br><span class="line">    procedure mycursor_use; <span class="comment">-- 声明存储过程</span></span><br><span class="line"><span class="keyword">end</span> pack_ref;</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建包体</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">package</span> <span class="keyword">body</span> pack_ref <span class="keyword">is</span></span><br><span class="line"><span class="keyword">procedure</span> mycursor_use <span class="keyword">is</span></span><br><span class="line">    mycursor refcur; <span class="comment">-- 此处声明类型为 refcur 的变量</span></span><br><span class="line">    stu_rec student%rowtype;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">open</span> mycursor <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line">    LOOP</span><br><span class="line">        fetch mycursor into stu_rec;</span><br><span class="line">        EXIT WHEN mycursor%NOTFOUND;</span><br><span class="line">        DBMS_OUTPUT.put_line('学号：' || stu_rec.sno || '，姓名：' || stu_rec.sname);</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    close mycursor;</span><br><span class="line"><span class="keyword">end</span> mycursor_use;</span><br><span class="line"><span class="keyword">end</span> pack_ref;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>使用如下语句调用如上的程序包，结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; exec pack_ref.mycursor_use();</span><br><span class="line"></span><br><span class="line">学号：7，姓名：张章</span><br><span class="line">学号：5，姓名：zhangsan</span><br><span class="line">学号：1，姓名：Tom</span><br><span class="line">学号：2，姓名：Kite</span><br><span class="line">学号：3，姓名：Bob</span><br><span class="line">学号：4，姓名：Mike</span><br><span class="line"></span><br><span class="line">PL/SQL procedure successfully completed</span><br></pre></td></tr></table></figure><h2 id="4-子程序和程序包的信息"><a href="#4-子程序和程序包的信息" class="headerlink" title="4. 子程序和程序包的信息"></a>4. 子程序和程序包的信息</h2><p><strong>USER_OBJECTS 视图包含用户创建的子程序和程序包的信息，通过如下语句查询：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> object_name, object_type</span><br><span class="line"><span class="keyword">FROM</span> USER_OBJECTS</span><br><span class="line"><span class="keyword">WHERE</span> object_type <span class="keyword">IN</span> (<span class="string">'PROCEDURE'</span>, <span class="string">'FUNCTION'</span>, <span class="string">'PACKAGE'</span>, <span class="string">'PACKAGE BODY'</span>);</span><br></pre></td></tr></table></figure><p>查询结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OBJECT_NAME                                                                      OBJECT_TYPE</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------- -------------------</span></span><br><span class="line">PROC_OUT                                                                         PROCEDURE</span><br><span class="line">FIND_EMP                                                                         PROCEDURE</span><br><span class="line">PROC_EXCHANGE                                                                    PROCEDURE</span><br><span class="line">FUN_HELLO                                                                        FUNCTION</span><br><span class="line">STUD_RANKING                                                                     FUNCTION</span><br><span class="line">PACK1                                                                            PACKAGE BODY</span><br><span class="line">PACK1                                                                            PACKAGE</span><br><span class="line">CUR_PACK                                                                         PACKAGE BODY</span><br><span class="line">CUR_PACK                                                                         PACKAGE</span><br><span class="line">PACK_REF                                                                         PACKAGE</span><br><span class="line">PACK_REF                                                                         PACKAGE BODY</span><br></pre></td></tr></table></figure><p><strong>USER_SOURCE 视图存储子程序和程序包的源代码，通过如下语句查询：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">text</span> <span class="keyword">FROM</span> USER_SOURCE <span class="keyword">WHERE</span> <span class="keyword">NAME</span>=<span class="string">'PACK_REF'</span>;     <span class="comment">---注意大写</span></span><br></pre></td></tr></table></figure><p>查询结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT text FROM USER_SOURCE WHERE NAME='PACK_REF';     ---注意大写</span><br><span class="line"></span><br><span class="line">TEXT</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">package pack_ref is</span><br><span class="line">    type refcur is ref cursor; <span class="comment">-- 此处只声明类型为参照游标的类型变量</span></span><br><span class="line">    procedure mycursor_use; <span class="comment">-- 声明存储过程</span></span><br><span class="line"><span class="keyword">end</span> pack_ref;</span><br><span class="line">package body pack_ref is</span><br><span class="line">procedure mycursor_use is</span><br><span class="line">    mycursor refcur; <span class="comment">-- 此处声明类型为 refcur 的变量</span></span><br><span class="line">    stu_rec student%rowtype;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">open</span> mycursor <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line">    LOOP</span><br><span class="line">        fetch mycursor into stu_rec;</span><br><span class="line">        EXIT WHEN mycursor%NOTFOUND;</span><br><span class="line">        DBMS_OUTPUT.put_line('学号：' || stu_rec.sno || '，姓名：' || stu_rec.sname);</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    close mycursor;</span><br><span class="line"><span class="keyword">end</span> mycursor_use;</span><br><span class="line"><span class="keyword">end</span> pack_ref;</span><br></pre></td></tr></table></figure><h2 id="5-内置程序包"><a href="#5-内置程序包" class="headerlink" title="5. 内置程序包"></a>5. 内置程序包</h2><p>oracle 内置有一些内置程序包，常用如下：</p><table><thead><tr><th><strong>程序包名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>STANDARD和DBMS_STANDARD</td><td>定义和扩展PL/SQL语言环境</td></tr><tr><td>DBMS_LOB</td><td>提供对 LOB数据类型进行操作的功能</td></tr><tr><td>DBMS_OUTPUT</td><td>处理PL/SQL块和子程序输出调试信息</td></tr><tr><td>DBMS_RANDOM</td><td>提供随机数生成器</td></tr><tr><td>DBMS_SQL</td><td>允许用户使用动态 SQL</td></tr><tr><td>DBMS_XMLDOM</td><td>用DOM模型读写XML类型的数据</td></tr><tr><td>DBMS_XMLPARSER</td><td>XML解析，处理XML文档内容和结构</td></tr><tr><td>DBMS_XMLQUERY</td><td>提供将数据转换为 XML 类型的功能</td></tr><tr><td>DBMS_XSLPROCESSOR</td><td>提供XSLT功能，转换XML文档</td></tr><tr><td>UTL_FILE</td><td>用 PL/SQL 程序来读写操作系统文本文件</td></tr></tbody></table><h3 id="5-1-DBMS-OUTPUT"><a href="#5-1-DBMS-OUTPUT" class="headerlink" title="5.1 DBMS_OUTPUT"></a>5.1 DBMS_OUTPUT</h3><p>该程序可以直接向控制台打印输出调试信息，类似于 Java 中的 <code>System.out.println(&quot;xxxx&quot;);</code>语句，这里不再过多说明。</p><h3 id="5-2-DBMS-RANDOM"><a href="#5-2-DBMS-RANDOM" class="headerlink" title="5.2 DBMS_RANDOM"></a>5.2 DBMS_RANDOM</h3><p>DBMS_RANDOM 包可用来生成随机整数。</p><p>示例1：</p><blockquote><p>产生随机数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SET SERVEROUTPUT ON</span><br><span class="line">SQL&gt; DECLARE</span><br><span class="line">   l_num   NUMBER;</span><br><span class="line">   counter NUMBER;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   counter:=<span class="number">1</span>;</span><br><span class="line">   WHILE counter &lt;= 10</span><br><span class="line">   LOOP</span><br><span class="line">     l_num := DBMS_RANDOM.RANDOM;</span><br><span class="line">     DBMS_OUTPUT.PUT_LINE(l_num);</span><br><span class="line">     counter:=counter+1;</span><br><span class="line">   <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 输出结果</span></span><br><span class="line">-1844779820</span><br><span class="line">2090599204</span><br><span class="line">46142221</span><br><span class="line">1419758385</span><br><span class="line">-1286235225</span><br><span class="line">-2065024678</span><br><span class="line">-1259274836</span><br><span class="line">-57157868</span><br><span class="line">1933458772</span><br><span class="line">-1037520283</span><br></pre></td></tr></table></figure><p>示例2：</p><blockquote><p>产生一个100以内的随机正整数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ABS</span>(<span class="keyword">MOD</span>(DBMS_RANDOM.RANDOM,<span class="number">100</span>)) <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><p>示例3：</p><blockquote><p>使用VALUE函数返回一个大于等于0但是小于1的数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBMS_RANDOM.VALUE <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><p>示例4：</p><blockquote><p>返回 [0, 100) 之间的值</p></blockquote><p>对于指定范围内的整数，要加入参数low_value和high_value，并从结果中截取小数（最大值<strong>不能</strong>被作为可能的值）。所以对于0到99之间的小数，可以使用下面的代码 ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">100</span>)  <span class="keyword">FROM</span>  DUAL;  <span class="comment">-- 返回区间内的小数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> TRUNC(DBMS_RANDOM.VALUE(<span class="number">0</span>, <span class="number">100</span>)) <span class="keyword">FROM</span>  DUAL; <span class="comment">-- 返回区间内的整数</span></span><br></pre></td></tr></table></figure><p>示例5：</p><blockquote><p>产生随机序列</p></blockquote><p>STRING函数生成随机文本字符串，可以指定字符串的类型和所希望的长度：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DBMS_RANDOM.STRING(<span class="string">'A'</span>, <span class="number">20</span>) rand_seq <span class="keyword">FROM</span> DUAL;  <span class="comment">-- 生成长度为 20 的大小写混合的字符序列</span></span><br></pre></td></tr></table></figure><p>第一个参数存在如下类型的代码：</p><p>‘U’用来生成大写字符，‘L’用来生成小写字符，‘A’用来生成大小写混合的字符，’P’ 表示 字符串由任意可打印字符构成， ’X’ 表示字符串由大写字符和数字构成。</p><p>输出结果示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT DBMS_RANDOM.STRING('A', 20) rand_seq FROM DUAL;  -- 生成长度为 20 的大小写混合的字符序列</span><br><span class="line"></span><br><span class="line">RAND_SEQ</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">iFvSXfHZMfNYIfffXDlo</span><br></pre></td></tr></table></figure><h3 id="5-3-UTL-FILE"><a href="#5-3-UTL-FILE" class="headerlink" title="5.3 UTL_FILE"></a>5.3 UTL_FILE</h3><p>UTL_FILE 包可用于读写操作系统文本文件，操作文件的一般过程是打开、读或写、关闭。UTL_FILE 包指定文件路径依赖于 DIRECTORY 对象。</p><p>首先需要登录管理员用户创建 DIRECTORY 对象，然后将该对象的读写权限授予指定用户，示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; CREATE DIRECTORY TEST_DIR AS 'F:\TEST';</span><br><span class="line">SQL&gt; GRANT READ, WRITE ON DIRECTORY TEST_DIR TO SCOTT;</span><br></pre></td></tr></table></figure><p>接下来我们就可以使用 SCOTT 用户来使用 UTL_FILE 来操作文件，使用示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  input_file   UTL_FILE.FILE_TYPE; <span class="comment">-- 声明文件类型</span></span><br><span class="line">  input_buffer VARCHAR2(4000);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  input_file := UTL_FILE.FOPEN(<span class="string">'TEST_DIR'</span>, <span class="string">'demo.txt'</span>, <span class="string">'r'</span>); <span class="comment">-- 以读的方式打开 TEST_DIR 目录对象下的 demo.txt 文件</span></span><br><span class="line">  LOOP</span><br><span class="line">    UTL_FILE.GET_LINE(input_file, input_buffer); <span class="comment">-- 每次读取一行</span></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(input_buffer);</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">  UTL_FILE.FCLOSE(input_file); <span class="comment">-- 关闭文件</span></span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN NO_DATA_FOUND THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('<span class="comment">------------------'); -- 读取到没有数据时打印</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="5-4-DBMS-JOB"><a href="#5-4-DBMS-JOB" class="headerlink" title="5.4 DBMS_JOB"></a>5.4 DBMS_JOB</h3><p> DBMS_JOB 可以创建定时任务调度程序，下面我们就简单的来使用 DBMS_JOB 程序包，关于更多的使用方法可以查阅官方文档。</p><ol><li>首先创建测试表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> a(a <span class="built_in">date</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个自定义过程：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> <span class="keyword">test</span> <span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> a <span class="keyword">values</span>(<span class="keyword">sysdate</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个定时任务 JOB：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">variable job1 number;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="comment">-- test; 表示调用的存储过程（需要分号），并将调用的结果返回给 job1 变量, : 指明 job1 是一个变量</span></span><br><span class="line">    <span class="comment">-- sysdate 参数是表示什么时候提交这个 job，这里我们使用当前时间</span></span><br><span class="line">    <span class="comment">-- 最后一个参数表示每天1440分钟，即一分钟运行test过程一次</span></span><br><span class="line">    dbms_job.submit(:job1,<span class="string">'test;'</span>, <span class="keyword">sysdate</span>, <span class="string">'sysdate + 1 / 1440'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ol start="4"><li>运行 job：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dbms_job.run(:job1);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><ol start="5"><li>检查结果，每隔一分钟 a 表就会插入一条记录：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select to_char(a,'yyyy/mm/dd hh24:mi:ss') 时间 from a;</span><br><span class="line"></span><br><span class="line">时间</span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line">2020/11/07 11:37:45</span><br><span class="line">2020/11/07 11:38:45</span><br></pre></td></tr></table></figure><ol start="6"><li>删除JOB：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dbms_job.remove(:job1);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的触发器</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>触发器是当特定事件出现时自动执行的存储过程，特定事件可以是执行更新的DML语句和DDL语句。触发器不能被显式调用，其有如下功能：</p><ul><li><p>自动生成数据</p></li><li><p>自定义复杂的安全权限</p></li><li><p>提供审计和日志记录</p></li><li><p>启用复杂的业务逻辑</p></li></ul><a id="more"></a><h2 id="2-创建"><a href="#2-创建" class="headerlink" title="2. 创建"></a>2. 创建</h2><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><p>触发器的创建语法如下，后面会以示例来说明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line"><span class="keyword">AFTER</span> | <span class="keyword">BEFORE</span> | INSTEAD <span class="keyword">OF</span></span><br><span class="line">[<span class="keyword">INSERT</span>] [[<span class="keyword">OR</span>] <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> column_list]] </span><br><span class="line">[[<span class="keyword">OR</span>] <span class="keyword">DELETE</span>]</span><br><span class="line"><span class="keyword">ON</span> table_or_view_name</span><br><span class="line">[<span class="keyword">REFERENCING</span> &#123;<span class="keyword">OLD</span> [<span class="keyword">AS</span>] <span class="keyword">old</span> / <span class="keyword">NEW</span> [<span class="keyword">AS</span>] <span class="keyword">new</span>&#125;]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span>]</span><br><span class="line">[<span class="keyword">WHEN</span> (condition)]</span><br><span class="line">pl/sql_block;</span><br></pre></td></tr></table></figure><h3 id="2-2-组成"><a href="#2-2-组成" class="headerlink" title="2.2 组成"></a>2.2 组成</h3><p>触发器由三部分组成：</p><ol><li><p>触发器语句（事件）</p><ul><li>定义激活触发器的 DML 事件和 DDL 事件</li></ul></li><li><p>触发器限制</p><ul><li>执行触发器的条件，该条件必须为真才能激活触发器</li></ul></li><li><p>触发器操作（主体）</p><ul><li>包含一些 SQL 语句和代码，它们在发出了触发器语句且触发限制的值为真时运行</li></ul></li></ol><p>如下语法，可以简单地表现触发器的三个组成部分：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line"><span class="keyword">AFTER</span> | <span class="keyword">BEFORE</span> | INSTEAD <span class="keyword">OF</span> [<span class="keyword">INSERT</span>] [[<span class="keyword">OR</span>] <span class="keyword">UPDATE</span> [<span class="keyword">OF</span> column_list]] [[<span class="keyword">OR</span>] <span class="keyword">DELETE</span>] <span class="comment">-- 1. 触发器事件</span></span><br><span class="line"><span class="keyword">ON</span> table_or_view_name</span><br><span class="line">[<span class="keyword">REFERENCING</span> &#123;<span class="keyword">OLD</span> [<span class="keyword">AS</span>] <span class="keyword">old</span> / <span class="keyword">NEW</span> [<span class="keyword">AS</span>] <span class="keyword">new</span>&#125;] [<span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span>][<span class="keyword">WHEN</span> (condition)] <span class="comment">-- 2. 触发器限制，在触发事件之上再做限制</span></span><br><span class="line">pl/sql_block; <span class="comment">-- 3. 触发器主体</span></span><br></pre></td></tr></table></figure><h3 id="2-3-示例说明"><a href="#2-3-示例说明" class="headerlink" title="2.3 示例说明"></a>2.3 示例说明</h3><p>现有如下 student 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><h4 id="2-3-1-触发事件"><a href="#2-3-1-触发事件" class="headerlink" title="2.3.1 触发事件"></a>2.3.1 触发事件</h4><p>现在我们对 student 表进行插入、更新或操作，其中触发事件设定为每次插入、删除或更新 student 的一条记录就会触发触发器执行。编写对应的触发器如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> trig1 </span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span> <span class="keyword">or</span> <span class="keyword">delete</span> <span class="comment">-- 插入、更新或删除表示触发器的触发事件，即在插入、更新或删除等事件之前（before）触发执行</span></span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"><span class="keyword">begin</span> <span class="comment">-- 触发器主体</span></span><br><span class="line">    dbms_output.put_line(<span class="string">'触发器 trig1 响应了》》》'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>执行如下语句，其中的插入、更新和删除都会触发触发器的执行，并答应<code>触发器 trig1 响应了》》》</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into student values (5, '李四', 52);</span><br><span class="line"></span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line"></span><br><span class="line">1 row inserted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; update student set sage = 25 where sno = 5;</span><br><span class="line"></span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line"></span><br><span class="line">1 row updated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; delete from student where sno = 5;</span><br><span class="line"></span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line"></span><br><span class="line">1 row deleted</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><h4 id="2-3-2-for-each-row"><a href="#2-3-2-for-each-row" class="headerlink" title="2.3.2 for each row"></a>2.3.2 for each row</h4><p>创建如下触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> trig1 </span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">or</span> <span class="keyword">update</span> <span class="keyword">or</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="comment">-- 新增该短语</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    dbms_output.put_line(<span class="string">'触发器 trig1 响应了》》》'</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>这里我们使用了<code>for each row</code> 短语，其作用是使表级触发器变为行级触发器。在没有增加该短语时，我们使用如下语句更新 student 的多条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> sage = sage + <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>触发器执行响应结果如下所示，由于是表级触发器，所以无论更新多少条记录，触发器只触发一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; update student set sage = sage + 10;</span><br><span class="line"></span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line"></span><br><span class="line">4 rows updated</span><br></pre></td></tr></table></figure><p>再增加了 <code>for each row</code> 短语之后，触发器的响应结果如下所示，即每更新一条记录都会触发一次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; update student set sage = sage + 10;</span><br><span class="line"></span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line">触发器 trig1 响应了》》》</span><br><span class="line"></span><br><span class="line">4 rows updated</span><br></pre></td></tr></table></figure><h4 id="2-3-3-before-amp-after"><a href="#2-3-3-before-amp-after" class="headerlink" title="2.3.3 before &amp; after"></a>2.3.3 before &amp; after</h4><p>before 的工作原理如下，简单地讲即是在数据入库之前触发触发器的执行：</p><p><img src="/2021/05/04/oracle-11g-的触发器/20201104232148440.png" alt></p><p>after 的工作原理如下，简单地讲即是在数据入库之后触发触发器的执行：</p><p><img src="/2021/05/04/oracle-11g-的触发器/20201104232200810.png" alt></p><p>现在我们创建如下触发器，即在对 student 表的 sage 列进行插入操作时，如果此时的学生记录的年龄若为负值则触发触发器执行，限制该记录入库，很明显我们应该需要使用 before 关键字，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> trig1</span><br><span class="line"><span class="keyword">before</span> <span class="keyword">insert</span> <span class="keyword">on</span> student <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> <span class="comment">-- 插入一条记录之前触发执行, 因为 NEW 或 OLD 引用不允许在表级触发器中，所以这里只能用行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> :new.sage &lt; <span class="number">0</span> <span class="keyword">then</span> <span class="comment">-- :new 表示新插入的记录，后面会进行介绍</span></span><br><span class="line">        raise_application_error(<span class="number">-20001</span>, <span class="string">'年龄错误，不能插入表中！'</span>); <span class="comment">-- 抛出自定义异常</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>插入执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into student values(5, 'lisi', -6);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">5</span>, <span class="string">'lisi'</span>, <span class="number">-6</span>)</span><br><span class="line"></span><br><span class="line">ORA<span class="number">-20001</span>: 年龄错误，不能插入表中！</span><br><span class="line">ORA<span class="number">-06512</span>: 在 <span class="string">"SCOTT.TRIG1"</span>, line <span class="number">3</span></span><br><span class="line">ORA<span class="number">-04088</span>: 触发器 <span class="string">'SCOTT.TRIG1'</span> 执行过程中出错</span><br></pre></td></tr></table></figure><h4 id="2-3-4-new-amp-old"><a href="#2-3-4-new-amp-old" class="headerlink" title="2.3.4 :new &amp; :old"></a>2.3.4 :new &amp; :old</h4><p>:new 表示一条新插入的记录，而 :old 表示原有的数据库数据记录。如果在触发器的 PL/SQL 块中使用 :new 或 :old，那么就必须是行级触发器，就是要有 for each row。很容易理解，因为 :new 和 :old 表示一行记录，所以触发器是需要作用于行的行级触发器，而不是作用于表的表级触发器。</p><p>需要说明的是，当执行 insert 的时候，:new 存在而 :old 不存在；当执行 delete 的时候，:new 不存在而:old 存在；当执行 update 的时候，:new 存在且 :old 也存在。由于 oracle 底层在执行 update 语句时，实质是先删除记录再插入新的记录的，所以才有:new 存在且:old 也存在的情况。</p><h2 id="3-类型"><a href="#3-类型" class="headerlink" title="3. 类型"></a>3. 类型</h2><p>触发器有如下类型：</p><p><img src="/2021/05/04/oracle-11g-的触发器/20201104232236933.png" alt></p><ul><li>DDL 触发器：在模式中执行 DDL 语句时执行，比如建表、修改表时触发的触发器；</li><li>数据库级触发器：在发生打开、关闭、登录和退出数据库等系统事件时执行；</li><li>DML 触发器：在对表或视图执行DML语句时执行，比如更新、插入时触发的触发器；</li><li>表级触发器：无论受影响的行数是多少，都只执行一次；</li><li>行级触发器：对DML语句修改的每个行执行一次；</li><li>INSTEAD OF 触发器：用于用户不能直接使用 DML 语句修改的视图；</li></ul><h2 id="4-INSTEAD-OF-触发器"><a href="#4-INSTEAD-OF-触发器" class="headerlink" title="4. INSTEAD OF 触发器"></a>4. INSTEAD OF 触发器</h2><p>现在有 student 表和 score 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from score;</span><br><span class="line"></span><br><span class="line">STUDENT_NO SCORE</span><br><span class="line"><span class="comment">---------- -----</span></span><br><span class="line">         1    56</span><br><span class="line">         2    82</span><br><span class="line">         3    90</span><br><span class="line">         </span><br><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      5 lisi                                            -6</span><br><span class="line">                                      1 Tom                                             31</span><br><span class="line">                                      2 Kite                                            32</span><br><span class="line">                                      3 Bob                                             33</span><br><span class="line">                                      4 Mike                                            34</span><br></pre></td></tr></table></figure><p>创建如下多表视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> v_stu_sco</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> stu.sno, stu.sname, stu.sage, sco.score</span><br><span class="line"><span class="keyword">from</span> student stu <span class="keyword">left</span> <span class="keyword">join</span> score sco</span><br><span class="line"><span class="keyword">on</span> stu.sno = sco.student_no;</span><br></pre></td></tr></table></figure><p>视图的查询结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from v_stu_sco;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE SCORE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- --------------------------------------- -----</span></span><br><span class="line">                                      1 Tom                                             31    56</span><br><span class="line">                                      2 Kite                                            32    82</span><br><span class="line">                                      3 Bob                                             33    90</span><br><span class="line">                                      4 Mike                                            34 </span><br><span class="line">                                      5 lisi                                            -6</span><br></pre></td></tr></table></figure><p>由于多表视图无法直接更新，我们可以使用 instead of 触发器来实现。示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> upd_stu_sco_view</span><br><span class="line">instead <span class="keyword">of</span> <span class="keyword">update</span> <span class="keyword">on</span> v_stu_sco <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> score <span class="keyword">set</span> score = :new.score <span class="keyword">where</span> student_no = :new.sno;</span><br><span class="line">    dbms_output.put_line('已激活触发器~');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>执行如下更新语句，将学号为 3 的学生的成绩由 90 变为 100，具体如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> v_stu_sco <span class="keyword">set</span> score = <span class="number">100</span> <span class="keyword">where</span> sno = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt;  update v_stu_sco set score = 100 where sno = 3;</span><br><span class="line"></span><br><span class="line">已激活触发器~</span><br><span class="line"></span><br><span class="line">1 row updated</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; select * from score;</span><br><span class="line"></span><br><span class="line">STUDENT_NO SCORE</span><br><span class="line"><span class="comment">---------- -----</span></span><br><span class="line">         1    56</span><br><span class="line">         2    82</span><br><span class="line">         3   100 <span class="comment">-- 发生更新</span></span><br></pre></td></tr></table></figure><h2 id="5-模式触发器"><a href="#5-模式触发器" class="headerlink" title="5. 模式触发器"></a>5. 模式触发器</h2><p>模式触发器也叫 DDL 触发器，即再对数据库对象进行操作的时所触发执行的触发器，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> log_drop_obj</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">DROP</span> <span class="keyword">ON</span> <span class="keyword">SCHEMA</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">INSERT</span> <span class="keyword">INTO</span> dropped_obj</span><br><span class="line">  <span class="keyword">VALUES</span>( ORA_DICT_OBJ_NAME, </span><br><span class="line">          ORA_DICT_OBJ_TYPE, <span class="keyword">SYSDATE</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>这里需要说明的是 ORA_DICT_OBJ_NAME 和 ORA_DICT_OBJ_TYPE 是 oracle 的系统变量，常用的系统变量如下所示：</p><ul><li><p>Ora_client_ip_address 返回客户端的ip地址</p></li><li><p>Ora_database_name 返回当前数据库名</p></li><li><p>Ora_login_user 返回登录用户名</p></li><li><p>Ora_dict_obj_name 返回ddl操作所对应的数据库对象名 </p></li><li><p>Ora_dict_obj_type 返回ddl操作所对应的数据库对象的类型 </p></li></ul><p>首先我们需要创建dropped_obj 表用于保存记录，创建语句如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dropped_obj (</span><br><span class="line">obj_name VARCHAR2(<span class="number">30</span>),   </span><br><span class="line">obj_type VARCHAR2(<span class="number">20</span>),</span><br><span class="line">drop_date <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure><p>再创建上述的模式触发器之后，我们把 score 删除，dropped_obj 表中的记录如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from dropped_obj;</span><br><span class="line"></span><br><span class="line">OBJ_NAME                       OBJ_TYPE             DROP_DATE</span><br><span class="line"><span class="comment">------------------------------ -------------------- -----------</span></span><br><span class="line">SCORE                          TABLE                2020/11/4 2</span><br></pre></td></tr></table></figure><h2 id="6-数据库级触发器"><a href="#6-数据库级触发器" class="headerlink" title="6. 数据库级触发器"></a>6. 数据库级触发器</h2><p> 数据库级触发器在发生打开、关闭、登录和退出数据库等系统事件时执行。下面通过示例说明，首先创建 log_table 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> log_table(username  varchar2(<span class="number">20</span>), logon_time  <span class="built_in">date</span>, logoff_time  <span class="built_in">date</span>, address varchar2(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>接着创建如下触发器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">trigger</span> tr_logon</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">logon</span> <span class="keyword">on</span> <span class="keyword">database</span> <span class="comment">-- 登录数据库后触发</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">   <span class="keyword">insert</span> <span class="keyword">into</span> log_table(username,logon_time, address ) <span class="keyword">values</span>(ora_login_user,  <span class="keyword">sysdate</span>, ora_client_ip_address);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>在登录用户之后，会往 log_table 插入一条记录，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from log_table;</span><br><span class="line"></span><br><span class="line">USERNAME             LOGON_TIME  LOGOFF_TIME ADDRESS</span><br><span class="line"><span class="comment">-------------------- ----------- ----------- --------------------</span></span><br><span class="line">SYSTEM               2020/11/4 2</span><br></pre></td></tr></table></figure><h2 id="7-启用和禁用"><a href="#7-启用和禁用" class="headerlink" title="7. 启用和禁用"></a>7. 启用和禁用</h2><p>示例如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; ALTER TRIGGER aiu_itemfile DISABLE;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; ALTER TRIGGER aiu_itemfile ENABLE;</span><br></pre></td></tr></table></figure><h2 id="8-删除"><a href="#8-删除" class="headerlink" title="8. 删除"></a>8. 删除</h2><p>示例如下所示：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; DROP TRIGGER aiu_itemfile;</span><br></pre></td></tr></table></figure><h2 id="9-触发器信息"><a href="#9-触发器信息" class="headerlink" title="9. 触发器信息"></a>9. 触发器信息</h2><p>USER_TRIGGERS 数据字典视图包含有关触发器的信息，查询示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; SELECT TRIGGER_NAME FROM USER_TRIGGERS</span><br><span class="line">WHERE TABLE_NAME='EMP';</span><br><span class="line"></span><br><span class="line">SQL&gt; SELECT TRIGGER_TYPE, TRIGGERING_EVENT, WHEN_CLAUSE</span><br><span class="line">FROM USER_TRIGGERS</span><br><span class="line">WHERE TRIGGER_NAME = 'BIU_EMP_DEPTNO';</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的游标</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E6%B8%B8%E6%A0%87/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E6%B8%B8%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在使用 select 语句查询数据时，查询返回的数据存放在结果集中，用户如何从查询得到的结果集中逐行逐列地获取存储的数据，从而在应用程序中使用这些值，就需要一种定位并控制结果集的机制，即游标。</p><p>游标是映射在结果集中<strong>一行</strong>数据上的位置实体，用来处理从数据库中检索的多行记录。利用游标，程序可以逐个地处理和便利一次检索返回的整个记录表，即可以对当前行数据进行操作。</p><a id="more"></a><h2 id="2-类型"><a href="#2-类型" class="headerlink" title="2. 类型"></a>2. 类型</h2><p>1，隐式游标：在 PL/SQL 程序中执行 DML SQL 语句时自动创建隐式游标，游标名字固定叫 sql。 </p><p>2，显式游标：显式游标用于处理返回多行的查询。</p><p>3，REF 游标：REF （参照）游标用于处理运行时才能确定的动态 SQL 查询的结果。</p><h2 id="3-隐式游标"><a href="#3-隐式游标" class="headerlink" title="3. 隐式游标"></a>3. 隐式游标</h2><p>在 PL/SQL 中使用 DML 语句时自动创建隐式游标。隐式游标自动声明、打开和关闭，其名为 sql。我们可以通过检查隐式游标的属性可以获得最近执行的 DML 语句的信息，隐式游标的属性有：</p><ul><li><p>%FOUND – SQL 语句影响了一行或多行时为 TRUE</p></li><li><p>%NOTFOUND – SQL 语句没有影响任何行时为TRUE</p></li><li><p>%ROWCOUNT – SQL 语句影响的行数</p></li><li><p>%ISOPEN - 游标是否打开，始终为FALSE，因为游标打开执行后会立即关闭。</p></li></ul><p>下面我们举例来说明隐式游标 sql 的存在，首先由如下 student 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><p>编写如下 pl/sql 执行块：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> serverout <span class="keyword">on</span>; <span class="comment">-- 开启控制台打印</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> sage = sage + <span class="number">10</span>;</span><br><span class="line">    if (sql%found) then <span class="comment">-- 判断时候影响多行</span></span><br><span class="line">        dbms_output.put_line('表已更新' || sql%rowcount || '行记录！'); <span class="comment">-- 影响的行数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">表已更新4行记录！ <span class="comment">-- 输出结果</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> student <span class="keyword">set</span> sage = sage + <span class="number">10</span> <span class="keyword">where</span> sno = <span class="number">5</span>; <span class="comment">-- sno = 5 的不存在</span></span><br><span class="line">    if (sql%notfound) then <span class="comment">-- 判断时候影响多行</span></span><br><span class="line">        dbms_output.put_line('表已更新' || sql%rowcount || '行记录！'); <span class="comment">-- 影响的行数</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">表已更新0行记录！ <span class="comment">-- 输出结果</span></span><br></pre></td></tr></table></figure><h2 id="4-显式游标"><a href="#4-显式游标" class="headerlink" title="4. 显式游标"></a>4. 显式游标</h2><p>显式游标在 PL/SQL 块的声明部分定义查询，该查询可以返回多行。显式游标的操作过程为声明游标、打开游标、使用游标取出记录和关闭游标。我们可以以下述的示例来体现说明，实现效果类似于上述使用隐式游标操作 student 一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    stud student%rowtype; <span class="comment">-- 表示一行 student 表记录类型标量</span></span><br><span class="line">    cursor stu_cur is <span class="keyword">select</span> * <span class="keyword">from</span> student; <span class="comment">-- 1. 声明游标</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">open</span> stu_cur; <span class="comment">-- 2. 打开游标</span></span><br><span class="line">    loop </span><br><span class="line">        fetch stu_cur into stud; <span class="comment">-- 3. 使用游标取出记录并保存到变量 stud 中</span></span><br><span class="line">        exit when stu_cur%notfound;</span><br><span class="line">        dbms_output.put_line('学号是：' || stud.sno || '，姓名是：' || stud.sname);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    close stu_cur; <span class="comment">-- 4. 关闭游标</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>输出结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学号是：1，姓名是：Tom</span><br><span class="line">学号是：2，姓名是：Kite</span><br><span class="line">学号是：3，姓名是：Bob</span><br><span class="line">学号是：4，姓名是：Mike</span><br></pre></td></tr></table></figure><h2 id="5-带参数显式游标"><a href="#5-带参数显式游标" class="headerlink" title="5. 带参数显式游标"></a>5. 带参数显式游标</h2><p>声明显式游标时可以带参数以提高灵活性。声明带参数的显式游标的语法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURSOR &lt;cursor_name&gt;(&lt;param_name&gt; &lt;param_type&gt;) IS select_statement;</span><br></pre></td></tr></table></figure><p>下述示例我们通过控制台输出序号打印输出执行学生信息，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    in_sno <span class="built_in">number</span>; <span class="comment">-- 记录输出的学生学号</span></span><br><span class="line">    stud student%rowtype; <span class="comment">-- 表示一行 student 表记录类型标量</span></span><br><span class="line">    cursor stu_cur(in_sno number) is <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno = in_sno; <span class="comment">-- 1. 声明游标，in_sno 为参数</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    in_sno := &amp;学生学号;</span><br><span class="line">    open stu_cur(in_sno); <span class="comment">-- 2. 打开游标，带上参数</span></span><br><span class="line">    loop </span><br><span class="line">        fetch stu_cur into stud; <span class="comment">-- 3. 使用游标取出记录并保存到变量 stud 中</span></span><br><span class="line">        exit when stu_cur%notfound;</span><br><span class="line">        dbms_output.put_line('学号是：' || stud.sno || '，姓名是：' || stud.sname);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    close stu_cur; <span class="comment">-- 4. 关闭游标</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>当我们输出学号 1 的时候，会打印输出如下结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学号是：1，姓名是：Tom</span><br></pre></td></tr></table></figure><h2 id="6-使用显式游标更新行"><a href="#6-使用显式游标更新行" class="headerlink" title="6. 使用显式游标更新行"></a>6. 使用显式游标更新行</h2><p>允许使用游标删除或更新活动集中的行，但是声明游标时必须使用 SELECT … FOR UPDATE语句。语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明游标时</span></span><br><span class="line">CURSOR &lt;cursor_name&gt; IS SELECT statement FOR UPDATE; -- 记得带上 for update</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新语句的语法</span></span><br><span class="line"><span class="keyword">UPDATE</span> &lt;table_name&gt; <span class="keyword">SET</span> &lt;set_clause&gt; <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> &lt;cursor_name&gt; <span class="comment">-- 记得带上 current of 游标名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除语句的语法</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;table_name&gt; <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> &lt;cursor_name&gt; <span class="comment">-- 记得带上 current of 游标名称</span></span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br><span class="line">                                      </span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    stud student%rowtype; <span class="comment">-- 表示一行 student 表记录类型标量</span></span><br><span class="line">    cursor stu_cur is <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">2</span> <span class="keyword">or</span> sno = <span class="number">3</span> <span class="keyword">for</span> <span class="keyword">update</span>; <span class="comment">-- 1. 声明游标，带上 for update</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">open</span> stu_cur; <span class="comment">-- 2. 打开游标</span></span><br><span class="line">    loop </span><br><span class="line">        fetch stu_cur into stud; <span class="comment">-- 3. 使用游标取出记录并保存到变量 stud 中</span></span><br><span class="line">        exit when stu_cur%notfound;</span><br><span class="line">        <span class="keyword">update</span> student <span class="keyword">set</span> sage = sage + <span class="number">100</span> <span class="keyword">where</span> <span class="keyword">current</span> <span class="keyword">of</span> stu_cur; <span class="comment">-- 带上 current of stu_cur</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    close stu_cur; <span class="comment">-- 4. 关闭游标</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>执行结果如下，其中学号为2 和 3 的学生的年龄增加了 100：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                           122</span><br><span class="line">                                      3 Bob                                            123</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><h2 id="7-循环游标"><a href="#7-循环游标" class="headerlink" title="7. 循环游标"></a>7. 循环游标</h2><blockquote><p>循环游标只适用于查询的情况，不适用于更新和删除的情况</p></blockquote><p>上面的示例中我们中用到了 loop 语句来循环访问游标，同时在访问前后分别需要打开和关闭游标，同时还需要取出游标的记录并赋值到指定的变量中。为了简化操作，我们可以直接使用循环游标。当用户需要从游标中提取所有记录时使用，循环游标的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOR &lt;record_index&gt; IN &lt;cursor_name&gt;</span><br><span class="line">LOOP</span><br><span class="line">    &lt;executable statements&gt;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p>示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    <span class="keyword">cursor</span> stu_cur <span class="keyword">is</span> <span class="keyword">select</span> * <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> cur_sub <span class="keyword">in</span> stu_cur <span class="keyword">loop</span> <span class="comment">-- cur_sub 表示游标指向的每一行记录</span></span><br><span class="line">        dbms_output.put_line(<span class="string">'学号是：'</span> || cur_sub.sno || <span class="string">'，姓名是：'</span> || cur_sub.sname);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">学号是：1，姓名是：Tom</span><br><span class="line">学号是：2，姓名是：Kite</span><br><span class="line">学号是：3，姓名是：Bob</span><br><span class="line">学号是：4，姓名是：Mike</span><br></pre></td></tr></table></figure><h2 id="8-批量处理"><a href="#8-批量处理" class="headerlink" title="8. 批量处理"></a>8. 批量处理</h2><p>可以使用 fetch … bulk collect into 语句来进行批量、快速提取数据，如下是使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">  <span class="keyword">cursor</span> my_cursor <span class="keyword">is</span> <span class="keyword">select</span> ename <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span>; <span class="comment">-- 声明名为 my_cursor 的游标</span></span><br><span class="line">  type  ename_table_type is table of varchar2(10); <span class="comment">-- 声明名为 ename_table_type 的表类型，该表类型由 varchar2(10) 字段类型组成</span></span><br><span class="line">  ename_table  ename_table_type; <span class="comment">-- 声明名为 ename_table 的 ename_table_type 表类型变量</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">open</span>  my_cursor; <span class="comment">-- 打开游标</span></span><br><span class="line">  fetch my_cursor bulk collect into  ename_table; <span class="comment">-- 批量取出游标执行的记录并设置到 ename_table 变量中，其实 ename_table 保存的即是</span></span><br><span class="line">  <span class="comment">-- select ename from emp where deptno = 10 的查询结果集，其中 ename 的类型就是 varchar2(10)</span></span><br><span class="line">  for  i in 1..ename_table.count  loop <span class="comment">-- 遍历打印 ename_table 的所有记录</span></span><br><span class="line">     dbms_output.put_line(ename_table(i));</span><br><span class="line">  <span class="keyword">end</span>  <span class="keyword">loop</span>;</span><br><span class="line">  close my_cursor; <span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>查看上述语句的第七行，我们这里使用<code>fetch my_cursor bulk collect into  ename_table;</code>，而不使用<code>fetch my_cursor into  ename_table;</code>是可以提高游标取书速度。</p><h2 id="9-REF-游标"><a href="#9-REF-游标" class="headerlink" title="9. REF 游标"></a>9. REF 游标</h2><p>REF 游标和游标变量用于处理运行时动态执行的 SQL 查询，创建游标变量需要两个步骤：</p><ul><li><p>声明 REF 游标类型</p></li><li><p>声明 REF 游标类型的变量</p></li></ul><p>用于声明 REF 游标类型的语法为：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE &lt;ref_cursor_name&gt; IS REF CURSOR [RETURN &lt;return_type&gt;];</span><br></pre></td></tr></table></figure><p>打开游标变量的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPEN cursor_name FOR select_statement;</span><br></pre></td></tr></table></figure><p>我们使用 REF 游标来实现通过对输入的学号参数打印输出指定学号的学生信息，由于在声明游标的时候我们无法知道要输出的是哪个学号的学生，因此我们需要使用 REF 游标来实现，示例如下：</p><p>student 表中的数据如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><p>如下是使用参照游标的具体实现 sql：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    <span class="keyword">type</span> refcur <span class="keyword">is</span> <span class="keyword">ref</span> <span class="keyword">cursor</span>; <span class="comment">-- 声明名称为 refcur 的参照游标类型变量</span></span><br><span class="line">    cursor2 refcur; <span class="comment">-- 声明名称为 cursor2 的 refcur 类型的变量</span></span><br><span class="line">    my_sno student.sno%type;</span><br><span class="line">    no2 student.sno%type;</span><br><span class="line">    name2 student.sname%type;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    my_sno := <span class="string">'&amp;学号'</span>; <span class="comment">-- 控制台输入学生学号</span></span><br><span class="line">    open cursor2 for <span class="keyword">select</span> sno, sname <span class="keyword">from</span> student <span class="keyword">where</span> sno = my_sno; <span class="comment">-- 打开游标，此处才绑定 select 语句，而不是在声明的时候</span></span><br><span class="line">    loop</span><br><span class="line">        fetch cursor2 into no2, name2; <span class="comment">-- 取出游标指定的值并设置到指定变量中</span></span><br><span class="line">        exit when cursor2%notfound;</span><br><span class="line">        dbms_output.put_line('学号是：' || no2 || '，姓名是：' || name2);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    close cursor2;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>当我们输入 4 的时候，执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学号是：4，姓名是：Mike</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的过程和函数</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-子程序"><a href="#1-子程序" class="headerlink" title="1. 子程序"></a>1. 子程序</h2><p>子程序即为命名的 PL/SQL 块，编译并存储在数据库中。子程序包含如下各个部分：</p><ul><li>声明部分</li><li>可执行部分</li><li>异常处理部分(可选)</li></ul><p><strong>子程序的分类：</strong></p><ul><li>过程 － 执行某些操作</li><li>函数 － 执行操作并返回值</li></ul><p>子程序的优点：</p><ul><li>模块化：将程序分解为逻辑模块</li><li>可重用性：可以被任意数目的程序调用</li><li>可维护性：简化维护操作</li><li>安全性：通过设置权限，使数据更安全</li></ul><a id="more"></a><h2 id="2-过程"><a href="#2-过程" class="headerlink" title="2. 过程"></a>2. 过程</h2><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">PROCEDURE</span> </span><br><span class="line">    &lt;<span class="keyword">procedure</span> <span class="keyword">name</span>&gt; [(&lt;parameter <span class="keyword">list</span>&gt;)] <span class="comment">-- parameter list 即为可指定需要的参数列表，可选</span></span><br><span class="line"><span class="keyword">IS</span>|<span class="keyword">AS</span> </span><br><span class="line">   [&lt;<span class="keyword">local</span> <span class="keyword">variable</span> declaration&gt;] <span class="comment">-- 声明需要的变量，可选</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   &lt;executable statements&gt; <span class="comment">-- 可指定部分</span></span><br><span class="line">[<span class="keyword">EXCEPTION</span></span><br><span class="line">   &lt;<span class="keyword">exception</span> handlers&gt;] <span class="comment">-- 异常处理部分，可选</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>过程指定示例如下所示：</p><p>emp 表的数据如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from emp;</span><br><span class="line"></span><br><span class="line">EMPNO ENAME      JOB         MGR HIREDATE          SAL      COMM DEPTNO</span><br><span class="line"><span class="comment">----- ---------- --------- ----- ----------- --------- --------- ------</span></span><br><span class="line"> 7369 SMITH      CLERK      7902 1980/12/17     800.00               20</span><br><span class="line"> 7499 ALLEN      SALESMAN   7698 1981/2/20     1600.00    300.00     30</span><br><span class="line"> 7521 WARD       SALESMAN   7698 1981/2/22     1250.00    500.00     30</span><br><span class="line"> 7566 JONES      MANAGER    7839 1981/4/2      2975.00               20</span><br><span class="line"> 7654 MARTIN     SALESMAN   7698 1981/9/28     1250.00   1400.00     30</span><br><span class="line"> 7698 BLAKE      MANAGER    7839 1981/5/1      2850.00               30</span><br><span class="line"> 7782 CLARK      MANAGER    7839 1981/6/9      2450.00               10</span><br><span class="line"> 7788 SCOTT      ANALYST    7566 1987/4/19     3000.00               20</span><br><span class="line"> 7839 KING       PRESIDENT       1981/11/17    5000.00               10</span><br><span class="line"> 7844 TURNER     SALESMAN   7698 1981/9/8      1500.00      0.00     30</span><br><span class="line"> 7876 ADAMS      CLERK      7788 1987/5/23     1100.00               20</span><br><span class="line"> 7900 JAMES      CLERK      7698 1981/12/3      950.00               30</span><br><span class="line"> 7902 FORD       ANALYST    7566 1981/12/3     3000.00               20</span><br><span class="line"> 7934 MILLER     CLERK      7782 1982/1/23     1300.00               10</span><br></pre></td></tr></table></figure><p>下面创建名为 find_emp 的存储过程，通过输入不同的员工编号入参来执行不同的操作和提示，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">PROCEDURE</span></span><br><span class="line">  find_emp(emp_no <span class="keyword">in</span> <span class="built_in">NUMBER</span>) <span class="comment">-- in 可不指明，默认表示 emp_no 为入参</span></span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">  empname VARCHAR2(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> ename <span class="keyword">INTO</span> empname</span><br><span class="line">  <span class="keyword">FROM</span> EMP <span class="keyword">WHERE</span> empno = emp_no;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE('雇员姓名是 '|| empname);</span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN NO_DATA_FOUND THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE ('雇员编号未找到');</span><br><span class="line"><span class="keyword">END</span> find_emp;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>参数列表为 IN 类型参数的存储过程，可以有 SQLPLUS 直接调用和通过 PL/SQL 块调用两种调用方式，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">exec find_emp(7782); <span class="comment">-- sqlplus 直接执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span> <span class="comment">-- PL/SQL 块执行</span></span><br><span class="line">    find_emp(<span class="number">7782</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="2-1-参数和调用"><a href="#2-1-参数和调用" class="headerlink" title="2.1 参数和调用"></a>2.1 参数和调用</h3><blockquote><p>参数不能有具体精度，比如 number(8) ，varchar(20) 等。</p></blockquote><p>存储过程参数的三种模式：</p><ul><li>IN <ul><li>用于接受调用程序的值</li><li>默认的参数模式</li></ul></li><li>OUT<ul><li>用于向调用程序返回值</li></ul></li><li>IN OUT<ul><li>用于接受调用程序的值，并向调用程序返回更新的值</li></ul></li></ul><p>由于前面已经举例了 IN 类型参数的示例，下面分别来举例 OUT 类型和 IN OUT 类型参数的示例。</p><h4 id="2-1-1-OUT-参数"><a href="#2-1-1-OUT-参数" class="headerlink" title="2.1.1 OUT 参数"></a>2.1.1 OUT 参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> proc_out(<span class="keyword">num</span> <span class="keyword">out</span> <span class="built_in">number</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">num</span> := <span class="number">100</span>;</span><br><span class="line">    <span class="comment">--DBMS_OUTPUT.PUT_LINE(num);</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>参数列表为 OUT 类型参数的存储过程不同于 IN 类型，只能通过 PL/SQL 块来调用执行，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    k <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    proc_out(k); <span class="comment">-- 调用存储过程，k 即为 proc_out 的 num 参数</span></span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('proc_out 存储过程的执行结果：' || k);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">proc_out 存储过程的执行结果：100 <span class="comment">-- 执行结果</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-IN-OUT-参数"><a href="#2-1-2-IN-OUT-参数" class="headerlink" title="2.1.2 IN OUT 参数"></a>2.1.2 IN OUT 参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 交换两个参数的值</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">procedure</span> proc_exchange(p1 <span class="keyword">in</span> <span class="keyword">out</span> <span class="built_in">number</span>, p2 <span class="keyword">in</span> <span class="keyword">out</span> <span class="built_in">number</span>)</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">    v_tmp <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    v_tmp := p2;</span><br><span class="line">    p2 := p1;</span><br><span class="line">    p1 := v_tmp;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><p>参数列表为 OUT 类型参数的存储过程与 OUT 类型的调用方式一样，只能通过 PL/SQL 块来调用执行，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    p1 <span class="built_in">number</span> := <span class="number">100</span>;</span><br><span class="line">    p2 number := 200;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    proc_exchange(p1, p2);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('p1 = ' || p1);</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('p2 = ' || p2);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 执行结果</span></span><br><span class="line">p1 = 200</span><br><span class="line">p2 = 100</span><br></pre></td></tr></table></figure><h3 id="2-2-授权"><a href="#2-2-授权" class="headerlink" title="2.2 授权"></a>2.2 授权</h3><p>将过程的执行权限授予其他用户示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; GRANT EXECUTE ON find_emp TO MARTIN;</span><br><span class="line">SQL&gt; GRANT EXECUTE ON swap TO PUBLIC;</span><br></pre></td></tr></table></figure><h3 id="2-3-删除"><a href="#2-3-删除" class="headerlink" title="2.3 删除"></a>2.3 删除</h3><p>删除过程示例如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; DROP PROCEDURE find_emp;</span><br></pre></td></tr></table></figure><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><p>函数是可以返回值的命名的 PL/SQL 子程序。 创建函数的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] <span class="keyword">FUNCTION</span> </span><br><span class="line">    &lt;<span class="keyword">function</span> <span class="keyword">name</span>&gt; [(param1,param2)] <span class="comment">-- 参数列表，可选</span></span><br><span class="line">    <span class="keyword">RETURN</span> &lt;datatype&gt;  <span class="comment">-- 返回类型</span></span><br><span class="line"><span class="keyword">IS</span>|<span class="keyword">AS</span> </span><br><span class="line">  [<span class="keyword">local</span> declarations] <span class="comment">-- 变量声明，可选</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  Executable Statements; <span class="comment">-- 可执行部分</span></span><br><span class="line">  RETURN result; <span class="comment">-- 返回具体值</span></span><br><span class="line">[EXCEPTION <span class="comment">-- 异常处理部分，可选</span></span><br><span class="line">  Exception handlers;]</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>定义函数的有如下限制：</p><ul><li><p>函数只能接受 IN 参数，而不能接受 IN OUT 或 OUT 参数</p></li><li><p>形参不能是 PL/SQL 类型，只能是数据库类型</p></li><li><p>函数的返回类型也必须是数据库类型</p></li></ul><p>访问函数的两种方式：</p><ul><li>使用 PL/SQL 块</li><li>使用 SQL 语句</li></ul><h3 id="3-1-创建"><a href="#3-1-创建" class="headerlink" title="3.1 创建"></a>3.1 创建</h3><p>函数创建示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> fun_hello</span><br><span class="line">  <span class="keyword">RETURN</span>  VARCHAR2</span><br><span class="line"><span class="keyword">IS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> <span class="string">'朋友，您好'</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h3 id="3-2-调用"><a href="#3-2-调用" class="headerlink" title="3.2 调用"></a>3.2 调用</h3><p>调用上述的 fun_hello 函数方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select fun_hello from dual;</span><br><span class="line"></span><br><span class="line">FUN_HELLO</span><br><span class="line"><span class="comment">--------------------------------------------------------------------------------</span></span><br><span class="line">朋友，您好</span><br></pre></td></tr></table></figure><h2 id="4-函数与过程的比较"><a href="#4-函数与过程的比较" class="headerlink" title="4. 函数与过程的比较"></a>4. 函数与过程的比较</h2><table><thead><tr><th><strong>过 程</strong></th><th><strong>函 数</strong></th></tr></thead><tbody><tr><td>作为 PL/SQL  语句执行</td><td>作为表达式的一部分调用</td></tr><tr><td>在规格说明中不包含 RETURN  子句</td><td>必须在规格说明中包含  RETURN  子句</td></tr><tr><td>不返回任何值</td><td>必须返回单个值</td></tr><tr><td>可以包含  RETURN  语句，但是与函数不同，它不能用于返回值</td><td>必须包含至少一条  RETURN  语句</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的 PLSQL 基础</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84-PLSQL-%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84-PLSQL-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-PL-SQL-简介"><a href="#1-PL-SQL-简介" class="headerlink" title="1. PL/SQL 简介"></a>1. PL/SQL 简介</h2><p>PL/SQL 是过程语言 (Procedural Language) 与结构化查询语言 (SQL) 结合而成的编程语言，PL/SQL 是对 SQL 的扩展。<br>PL/SQL 支持多种数据类型，如大对象和集合类型，可使用条件和循环等控制结构，可用于创建存储过程、触发器和程序包，给SQL语句的执行添加程序逻辑。并且与 Oracle 服务器和 Oracle 工具紧密集成，具备可移植性、灵活性和安全性。</p><a id="more"></a><h2 id="2-PL-SQL-优点"><a href="#2-PL-SQL-优点" class="headerlink" title="2. PL/SQL 优点"></a>2. PL/SQL 优点</h2><ol><li><p>支持 SQL，在 PL/SQL 中可以使用：</p><ul><li><p>数据操纵命令</p></li><li><p>事务控制命令</p></li><li><p>游标控制</p></li><li><p>SQL 函数和 SQL 运算符</p></li></ul></li><li><p>用户把PL/SQL块整个发送到服务器端，oracle服务器端编译、运行，再把结果返回给用户；</p></li><li><p>可移植性，可运行在任何操作系统和平台上的Oralce 数据库；</p></li><li><p>更佳的性能，PL/SQL 经过编译执行；</p></li><li><p>安全性，可以通过存储过程限制用户对数据的访问；</p></li><li><p>与 SQL 紧密集成，简化数据处理：</p><ul><li>支持所有 SQL 数据类型</li><li>支持 NULL 值</li><li>支持 %TYPE 和 %ROWTYPE 属性类型（%TYPE 表示某一列的类型，%ROWTYPE 表示某一行的类型）</li></ul></li></ol><h2 id="3-PL-SQL-体系结构"><a href="#3-PL-SQL-体系结构" class="headerlink" title="3. PL/SQL 体系结构"></a>3. PL/SQL 体系结构</h2><p><img src="/2021/05/04/oracle-11g-的-PLSQL-基础/20201031100050915.png" alt></p><p>执行步骤：</p><ol><li>首先用户将 PL/SQL 块发送给 oracle 服务器，并由 PL/SQL 引擎中的过程语句执行器执行过程语句，并转变称为 SQL 语句；</li><li>PL/SQL 引擎将 SQL 语句发往 SQL 引擎 SQL 语句执行器并执行 SQL 语句；</li><li>SQL 引擎将执行结果发给用户。</li></ol><h2 id="4-PL-SQL-块简介"><a href="#4-PL-SQL-块简介" class="headerlink" title="4. PL/SQL 块简介"></a>4. PL/SQL 块简介</h2><p>PL/SQL 块是构成 PL/SQL 程序的基本单元，将逻辑上相关的声明和语句组合在一起。PL/SQL 分为三个部分，声明部分、可执行部分和异常处理部分，具体如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">DECLARE</span> declarations] <span class="comment">-- 声明部分，如声明变量（可选）</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">executable statements  <span class="comment">-- 可执行部分</span></span><br><span class="line">[<span class="keyword">EXCEPTION</span> handlers]   <span class="comment">-- 异常处理部分（可选）</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="5-变量和常量"><a href="#5-变量和常量" class="headerlink" title="5. 变量和常量"></a>5. 变量和常量</h2><p>PL/SQL 块中可以使用变量和常量，需注意：</p><ul><li>在声明部分声明要使用的变量，且需要在使用前先声明；</li><li>声明时必须指定数据类型，每行声明一个标识符；</li><li>在可执行部分的 SQL 语句和过程语句中使用。</li></ul><p>声明变量和常量的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">identifier [CONSTANT] datatype [NOT NULL]   </span><br><span class="line">[:= | DEFAULT expr];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- identifier 表示变量名称</span></span><br><span class="line"><span class="comment">-- CONSTANT 为常量标识</span></span><br><span class="line"><span class="comment">-- datatype 为变量数据类型</span></span><br><span class="line"><span class="comment">-- NOT NULL 为非空标识</span></span><br><span class="line"><span class="comment">-- := 为赋值符号</span></span><br><span class="line"><span class="comment">-- DEFAULT expr 为设置默认值（表达式）</span></span><br></pre></td></tr></table></figure><p>给变量赋值有两种方法：</p><ul><li>使用赋值语句 :=</li><li>使用 SELECT INTO 语句</li></ul><p>示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  icode VARCHAR2(<span class="number">6</span>);</span><br><span class="line">  p_catg VARCHAR2(20);</span><br><span class="line">  p_rate NUMBER;</span><br><span class="line">  c_rate CONSTANT NUMBER := 0.10; <span class="comment">-- 常量赋值为 0.10</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  icode := <span class="string">'i205'</span>;</span><br><span class="line">  <span class="keyword">SELECT</span> p_category, itemrate * c_rate</span><br><span class="line">  <span class="keyword">INTO</span>  p_catg, p_rate</span><br><span class="line">  <span class="keyword">FROM</span> itemfile <span class="keyword">WHERE</span> itemcode = icode;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h2><p>PL/SQL 支持的内置数据类型有如下几种：</p><p><img src="/2021/05/04/oracle-11g-的-PLSQL-基础/2020103110012676.png" alt></p><h3 id="6-1-数字数据类型"><a href="#6-1-数字数据类型" class="headerlink" title="6.1 数字数据类型"></a>6.1 数字数据类型</h3><p><img src="/2021/05/04/oracle-11g-的-PLSQL-基础/20201031100140627.png" alt></p><h3 id="6-2-字符数据类型"><a href="#6-2-字符数据类型" class="headerlink" title="6.2 字符数据类型"></a>6.2 字符数据类型</h3><p>字符数据类型包括：CHAR、VARCHAR2、LONG、RAW 和 LONG RAW 五种。PL/SQL 的数据类型与 SQL数据类型的比较如下图所示：</p><p><img src="/2021/05/04/oracle-11g-的-PLSQL-基础/20201031100153660.png" alt></p><h3 id="6-3-日期时间和布尔数据类型"><a href="#6-3-日期时间和布尔数据类型" class="headerlink" title="6.3 日期时间和布尔数据类型"></a>6.3 日期时间和布尔数据类型</h3><ul><li>日期时间类型存储日期和时间数据，常用的两种日期时间类型有 DATE 和 TIMESTAMP；</li><li>布尔数据类型：<ul><li>此类别只有一种类型，即BOOLEAN类型</li><li>用于存储逻辑值(TRUE、FALSE和NULL)</li><li>不能向数据库中插入BOOLEAN数据</li><li>不能将列值保存到BOOLEAN变量中</li><li>只能对BOOLEAN变量执行逻辑操作</li></ul></li></ul><h3 id="6-4-LOB-数据类型"><a href="#6-4-LOB-数据类型" class="headerlink" title="6.4 LOB 数据类型"></a>6.4 LOB 数据类型</h3><p>用于存储大文本、图像、视频剪辑和声音剪辑等非结构化数据。LOB 数据类型可存储最大 4GB的数据。LOB 类型包括：</p><ul><li>BLOB  将大型二进制对象存储在数据库中</li><li>CLOB  将大型字符数据存储在数据库中</li><li>NCLOB  存储大型UNICODE字符数据</li><li>BFILE   将大型二进制对象存储在操作系统文件中</li></ul><p>LOB 类型的数据库列仅存储定位符，该定位符指向大型对象的存储位置。可以使用DBMS_LOB程序包来操纵 LOB 数据。下面我们尝试来操作 LOB 数据类型数据：</p><p>1）首先先创建一张 my_book_text 表，并插入测试数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_book_text (</span><br><span class="line">    chapter_id <span class="built_in">number</span>(<span class="number">8</span>) primary <span class="keyword">key</span>,</span><br><span class="line">    chapter_text <span class="keyword">clob</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> my_book_text <span class="keyword">values</span> (<span class="number">5</span>, <span class="string">'LOB 类型的数据库列仅存储定位符，该定位符指向大型对象的存储位置。可以使用DBMS_LOB程序包来操纵 LOB 数据。下面我们尝试来操作 LOB 数据类型数据'</span>);</span><br></pre></td></tr></table></figure><p>（2）编写如下的 PL/SQL 执行块：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> serveroutput <span class="keyword">on</span>; <span class="comment">-- 开启命令行输出</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line"> clob_var <span class="keyword">clob</span>;</span><br><span class="line"> amount integer;</span><br><span class="line"> offset integer;</span><br><span class="line"> output_var varchar2(100);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">select</span> chapter_text <span class="keyword">into</span> clob_var <span class="keyword">from</span> my_book_text <span class="keyword">where</span> chapter_id = <span class="number">5</span>;</span><br><span class="line"> amount := 24; <span class="comment">-- 要读取的字符数</span></span><br><span class="line"> offset := 1; <span class="comment">-- 起始位置</span></span><br><span class="line"> DBMS_LOB.READ(clob_var, amount, offset, output_var); <span class="comment">-- 读取 clob_var 指定位置的字符赋值到 output_var 中</span></span><br><span class="line"> DBMS_OUTPUT.PUT_LINE(output_var);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h2 id="7-属性类型"><a href="#7-属性类型" class="headerlink" title="7. 属性类型"></a>7. 属性类型</h2><p>属性类型用于引用数据库列的数据类型，以及表示表中一行的记录类型。属性类型有两种：</p><ul><li>%TYPE - 引用变量和数据库列的数据类型</li><li>%ROWTYPE - 提供表示表中一行的记录类型</li></ul><p>使用属性类型的优点：不需要知道被引用的表列的具体类型，且如果被引用对象的数据类型发生改变，PL/SQL 变量的数据类型也随之改变，健壮性强。</p><p>示例如下所示：</p><p>1）首先查看 student 表的数据如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><p>2）然后执行如下的 PL/SQL 语句，并输出学号为 1 的学生的年龄。可以发现即便不知道 student 表字段的类型，我们依旧可以声明对应类型的 my_sage 的变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> serveroutput <span class="keyword">on</span>; <span class="comment">-- 开启打印输出</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line"> my_sage student.sage%<span class="keyword">type</span>; <span class="comment">-- 此时不需要知道 student 表 sage 字段的类型</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">select</span> sage <span class="keyword">into</span> my_sage <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">1</span>;</span><br><span class="line"> dbms_output.put_line('学号为 1 的学生的年龄为 ' || my_sage);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">学号为 1 的学生的年龄为 21 <span class="comment">-- 执行结果</span></span><br></pre></td></tr></table></figure><h2 id="8-Oracle-11g-的-PL-SQL-序列改进"><a href="#8-Oracle-11g-的-PL-SQL-序列改进" class="headerlink" title="8. Oracle 11g 的 PL/SQL 序列改进"></a>8. Oracle 11g 的 PL/SQL 序列改进</h2><p>在PL/SQL中取出序列的nextval、currval时，可以不使用 select语句，如 <code>select seq1.nextval from dual;</code>，在 PL/SQL 可以简化如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">id</span> := seq1.nextval; <span class="comment">-- 直接赋值，而不用通过 select 获取</span></span><br><span class="line">    dbms_output.put_line('当前序列值：' || id);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h2 id="9-逻辑比较"><a href="#9-逻辑比较" class="headerlink" title="9. 逻辑比较"></a>9. 逻辑比较</h2><p>逻辑比较用于比较变量和常量的值，这些表达式称为布尔表达式。布尔表达式由关系运算符与变量或常量组成，布尔表达式的结果为TRUE、FALSE或NULL，通常由逻辑运算符AND、OR和NOT连接。</p><p>布尔表达式有三种类型：</p><ul><li>数字布尔型</li><li>字符布尔型</li><li>日期布尔型</li></ul><h2 id="10-控制结构"><a href="#10-控制结构" class="headerlink" title="10. 控制结构"></a>10. 控制结构</h2><p>PL/SQL 支持的流程控制结构：</p><ul><li><p>条件控制</p><ul><li><p>IF 语句</p></li><li><p>CASE 语句</p></li></ul></li><li><p>循环控制</p><ul><li><p>LOOP 循环</p></li><li><p>WHILE 循环</p></li><li><p>FOR 循环</p></li></ul></li><li><p>顺序控制</p><ul><li>GOTO 语句</li><li>NULL 语句</li></ul></li></ul><h3 id="10-1条件控制"><a href="#10-1条件控制" class="headerlink" title="10.1条件控制"></a>10.1条件控制</h3><h4 id="10-1-1-IF-语句"><a href="#10-1-1-IF-语句" class="headerlink" title="10.1.1 IF 语句"></a>10.1.1 IF 语句</h4><p>IF 语句根据条件执行一系列语句，有三种形式：IF-THEN、IF-THEN-ELSE 和 IF-THEN-ELSIF-THEN。示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from person;</span><br><span class="line"></span><br><span class="line">        ID NAME                 ADDRESS</span><br><span class="line"><span class="comment">---------- -------------------- --------------------</span></span><br><span class="line">         1 张三                 北京</span><br><span class="line">         2 李四                 广州</span><br><span class="line">         3 王五                 南宁</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. IF-THEN 语句</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    my_add person.address%<span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> address <span class="keyword">into</span> my_add <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">    if my_add = '北京'</span><br><span class="line">    then dbms_output.put_line('Beijing');</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">Beijing <span class="comment">-- 输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. IF-THEN-ELSE 语句</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    my_add person.address%<span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> address <span class="keyword">into</span> my_add <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">    if my_add = '广州'</span><br><span class="line">    then dbms_output.put_line('Guangzhou');</span><br><span class="line">    else</span><br><span class="line">    dbms_output.put_line('其他');</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">其他 <span class="comment">-- 输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- IF-THEN-ELSIF-THEN 语句</span></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    my_add person.address%<span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> address <span class="keyword">into</span> my_add <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">    if my_add = '广州'</span><br><span class="line">    then dbms_output.put_line('Guangzhou');</span><br><span class="line">    elsif my_add = '北京'</span><br><span class="line">    then dbms_output.put_line('Beijing');</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h4 id="10-1-2-CASE-语句"><a href="#10-1-2-CASE-语句" class="headerlink" title="10.1.2  CASE 语句"></a>10.1.2  CASE 语句</h4><p>示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    my_add person.address%<span class="keyword">type</span>;</span><br><span class="line">    out_add varchar2(10);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> address <span class="keyword">into</span> my_add <span class="keyword">from</span> person <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">    out_add := case my_add</span><br><span class="line">        when '北京' then 'Beijing'</span><br><span class="line">        when '广州' then 'Guangzhou'</span><br><span class="line">        when '天津' then 'Tianjin'</span><br><span class="line">        else 'other'</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    dbms_output.put_line(out_add);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">Beijing <span class="comment">-- 输出结果</span></span><br></pre></td></tr></table></figure><h3 id="10-2-循环控制"><a href="#10-2-循环控制" class="headerlink" title="10.2 循环控制"></a>10.2 循环控制</h3><p>循环控制用于重复执行一系列语句，循环控制语句包括：LOOP、EXIT 和 EXIT WHEN 、FOR 、WHILE。</p><h4 id="10-2-1-LOOP-循环"><a href="#10-2-1-LOOP-循环" class="headerlink" title="10.2.1 LOOP 循环"></a>10.2.1 LOOP 循环</h4><p>语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line"> sequence_of_statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p>由于 LOOP 循环是无条件循环，所以一般情况下我们需要在循环内部使用 EXIT WHEN 进行满足指定条件退出循环。示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    j <span class="built_in">number</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    j := <span class="number">1</span>;</span><br><span class="line">    loop</span><br><span class="line">        dbms_output.put_line(j || '<span class="comment">---');</span></span><br><span class="line">        exit when j &gt; 7; -- j 大于 7 时退出循环</span><br><span class="line">        j := j + 1;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    dbms_output.put_line('结束');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 输出结果如下所示</span></span><br><span class="line">1<span class="comment">---</span></span><br><span class="line">2<span class="comment">---</span></span><br><span class="line">3<span class="comment">---</span></span><br><span class="line">4<span class="comment">---</span></span><br><span class="line">5<span class="comment">---</span></span><br><span class="line">6<span class="comment">---</span></span><br><span class="line">7<span class="comment">---</span></span><br><span class="line">8<span class="comment">---</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><h4 id="10-2-2-WHILE-循环"><a href="#10-2-2-WHILE-循环" class="headerlink" title="10.2.2 WHILE 循环"></a>10.2.2 WHILE 循环</h4><p>语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE condition LOOP</span><br><span class="line">    sequence_of_statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    j <span class="built_in">number</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    j := <span class="number">1</span>;</span><br><span class="line">    while j &lt;= 7 -- j 大于 7 时退出循环</span><br><span class="line">    loop</span><br><span class="line">        dbms_output.put_line(j || '<span class="comment">---');</span></span><br><span class="line">        j := j + 1;</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    dbms_output.put_line('结束');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 输出结果如下所示</span></span><br><span class="line">1<span class="comment">---</span></span><br><span class="line">2<span class="comment">---</span></span><br><span class="line">3<span class="comment">---</span></span><br><span class="line">4<span class="comment">---</span></span><br><span class="line">5<span class="comment">---</span></span><br><span class="line">6<span class="comment">---</span></span><br><span class="line">7<span class="comment">---</span></span><br><span class="line">8<span class="comment">---</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><h4 id="10-2-3-FOR-循环"><a href="#10-2-3-FOR-循环" class="headerlink" title="10.2.3 FOR 循环"></a>10.2.3 FOR 循环</h4><p>语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FOR counter IN [REVERSE] value1..value2</span><br><span class="line">LOOP</span><br><span class="line">    sequence_of_statements</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    j <span class="built_in">number</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    j := <span class="number">1</span>;</span><br><span class="line">    for j in 1..8 <span class="comment">-- 默认对 j 进行 j++</span></span><br><span class="line">    loop</span><br><span class="line">        dbms_output.put_line(j || '<span class="comment">---');</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    dbms_output.put_line('结束');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 输出结果</span></span><br><span class="line">1<span class="comment">---</span></span><br><span class="line">2<span class="comment">---</span></span><br><span class="line">3<span class="comment">---</span></span><br><span class="line">4<span class="comment">---</span></span><br><span class="line">5<span class="comment">---</span></span><br><span class="line">6<span class="comment">---</span></span><br><span class="line">7<span class="comment">---</span></span><br><span class="line">8<span class="comment">---</span></span><br><span class="line">结束</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    j <span class="built_in">number</span> := <span class="number">8</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">REVERSE</span> <span class="number">1.</span><span class="number">.8</span> <span class="comment">-- 默认对 j 进行 j--</span></span><br><span class="line">    <span class="keyword">loop</span></span><br><span class="line">        dbms_output.put_line(j || <span class="string">'---'</span>);</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">    dbms_output.put_line('结束');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 输出结果</span></span><br><span class="line">8<span class="comment">---</span></span><br><span class="line">7<span class="comment">---</span></span><br><span class="line">6<span class="comment">---</span></span><br><span class="line">5<span class="comment">---</span></span><br><span class="line">4<span class="comment">---</span></span><br><span class="line">3<span class="comment">---</span></span><br><span class="line">2<span class="comment">---</span></span><br><span class="line">1<span class="comment">---</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><h3 id="10-3-oracle-11g-的-continue"><a href="#10-3-oracle-11g-的-continue" class="headerlink" title="10.3 oracle 11g 的 continue"></a>10.3 oracle 11g 的 continue</h3><p>oracle11g新增了continue语句，可在循环中使用。该语句可将逻辑移到循环结尾，然后再移到循环开头。 例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">  j <span class="built_in">number</span>:=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">loop</span></span><br><span class="line">      j:=j+<span class="number">1</span>;</span><br><span class="line">      exit      when j&gt;8;</span><br><span class="line">      continue  when j&gt;4; -- 开始新的循环</span><br><span class="line">      dbms_output.put_line(to_char(j)||'<span class="comment">---');</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 输出结果</span></span><br><span class="line">2<span class="comment">---</span></span><br><span class="line">3<span class="comment">---</span></span><br><span class="line">4<span class="comment">---</span></span><br></pre></td></tr></table></figure><h3 id="10-3-顺序结构"><a href="#10-3-顺序结构" class="headerlink" title="10.3 顺序结构"></a>10.3 顺序结构</h3><p>顺序控制用于按顺序执行语句，顺序控制语句包括：</p><ul><li><p>GOTO 语句 - 无条件地转到标签指定的语句</p></li><li><p>NULL 语句 - 什么也不做的空语句</p></li></ul><p>示例如下，使用 goto 语句来实现循环的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">    j <span class="built_in">number</span> := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    j := <span class="number">1</span>;</span><br><span class="line">    &lt;&lt;aa&gt;&gt;</span><br><span class="line">        dbms_output.put_line(j || '<span class="comment">---');</span></span><br><span class="line">        j := j + 1;</span><br><span class="line">        if j &lt;= 7 then goto aa; end if;</span><br><span class="line">        if j &gt; 7 then goto bb; end if;</span><br><span class="line">    &lt;&lt;bb&gt;&gt; null; -- 空语句，什么都不做</span><br><span class="line">    dbms_output.put_line('结束');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line"><span class="comment">-- 执行结果</span></span><br><span class="line">1<span class="comment">---</span></span><br><span class="line">2<span class="comment">---</span></span><br><span class="line">3<span class="comment">---</span></span><br><span class="line">4<span class="comment">---</span></span><br><span class="line">5<span class="comment">---</span></span><br><span class="line">6<span class="comment">---</span></span><br><span class="line">7<span class="comment">---</span></span><br><span class="line">结束</span><br></pre></td></tr></table></figure><h2 id="11-动态-SQL"><a href="#11-动态-SQL" class="headerlink" title="11. 动态 SQL"></a>11. 动态 SQL</h2><p>动态 SQL 是指在PL/SQL程序执行时生成的 SQL 语句。编译程序对动态 SQL 不做处理，而是在程序运行时动态构造语句、对语句进行语法分析并执行。<strong>DDL 语句命令和会话控制语句不能在 PL/SQL 中直接使用，但是可以通过动态 SQL 来执行。</strong></p><p>执行动态 SQL 的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">IMMEDIATE</span> dynamic_sql_string</span><br><span class="line">[<span class="keyword">INTO</span>  define_variable_list] <span class="comment">-- 上述 sql 指定结果赋值到指定 define_variable_list 变量中</span></span><br><span class="line">[<span class="keyword">USING</span> bind_argument_list]; <span class="comment">-- 绑定变量</span></span><br></pre></td></tr></table></figure><p>示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">execute</span> <span class="keyword">immediate</span> <span class="string">'create table T(t1 int)'</span>; <span class="comment">-- create 为 ddl 语句，普通 plsql 无法做到</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br></pre></td></tr></table></figure><h2 id="12-错误处理"><a href="#12-错误处理" class="headerlink" title="12. 错误处理"></a>12. 错误处理</h2><p>在运行程序时出现的错误叫做异常。在发生异常后，语句将停止执行，控制权转移到 PL/SQL 块的异常处理部分。异常有两种类型：</p><ul><li>预定义异常 - 当 PL/SQL 程序违反 Oracle 规则或超越系统限制时隐式引发</li><li>用户定义异常 - 用户可以在 PL/SQL 块的声明部分定义异常，自定义的异常通过 RAISE 语句显式引发</li></ul><h3 id="12-1-预定义异常"><a href="#12-1-预定义异常" class="headerlink" title="12.1 预定义异常"></a>12.1 预定义异常</h3><p>示例表数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">                                    SNO SNAME                                         SAGE</span><br><span class="line"><span class="comment">--------------------------------------- ---------- ---------------------------------------</span></span><br><span class="line">                                      1 Tom                                             21</span><br><span class="line">                                      2 Kite                                            22</span><br><span class="line">                                      3 Bob                                             23</span><br><span class="line">                                      4 Mike                                            24</span><br></pre></td></tr></table></figure><p>查询学号为 5 的学生，若找不到该学生则进行相应的异常处理和提示，具体示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">  out_sname student.sname%<span class="keyword">type</span>;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">select</span> sname <span class="keyword">into</span> out_sname <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">5</span>;</span><br><span class="line">  dbms_output.put_line(out_sname);</span><br><span class="line">exception</span><br><span class="line">  when no_data_found then</span><br><span class="line">     dbms_output.put_line('该学生不存在！');</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">/</span><br><span class="line">该学生不存在！<span class="comment">-- 输出结果</span></span><br></pre></td></tr></table></figure><p>需要说明的是 no_data_found 是 oracle 预定义异常，类似于 Java 中的 ClassNotFoundException。对应的异常编号为 ORA-01403，具体说明可查阅官方文档。</p><h3 id="12-2-用户自定义异常"><a href="#12-2-用户自定义异常" class="headerlink" title="12.2 用户自定义异常"></a>12.2 用户自定义异常</h3><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">  invalidCATEGORY <span class="keyword">EXCEPTION</span>; <span class="comment">-- 自定义 无效类别异常</span></span><br><span class="line">  category VARCHAR2(10);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">category</span> := <span class="string">'&amp;Category'</span>; <span class="comment">-- 控制台输入值</span></span><br><span class="line">  IF category NOT IN ('附件','顶盖','备件') THEN</span><br><span class="line">    RAISE invalidCATEGORY; <span class="comment">-- 抛出异常</span></span><br><span class="line">  ELSE</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('您输入的类别是'|| category);</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN invalidCATEGORY THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('无法识别该类别');</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br><span class="line">无法识别该类别 <span class="comment">-- 输出结果，当控制台输入的类型不在指定集合时</span></span><br></pre></td></tr></table></figure><h3 id="12-3-引发应用程序错误"><a href="#12-3-引发应用程序错误" class="headerlink" title="12.3 引发应用程序错误"></a>12.3 引发应用程序错误</h3><p>我们可以使用 RAISE_APPLICATION_ERROR 来引发程序发生错误。该语句可以用于创建用户定义的错误信息，且可以在可执行部分和异常处理部分使用。RAISE_APPLICATION_ERROR 抛出的异常可带有自定义异常编号和异常信息。</p><p>修改上述用户自定义异常的示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">  invalidCATEGORY <span class="keyword">EXCEPTION</span>; <span class="comment">-- 自定义 无效类别异常</span></span><br><span class="line">  category VARCHAR2(10);</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">category</span> := <span class="string">'&amp;Category'</span>; <span class="comment">-- 控制台输入值</span></span><br><span class="line">  IF category NOT IN ('附件','顶盖','备件') THEN</span><br><span class="line">    RAISE invalidCATEGORY; <span class="comment">-- 抛出异常</span></span><br><span class="line">  ELSE</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('您输入的类别是'|| category);</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">EXCEPTION</span><br><span class="line">  WHEN invalidCATEGORY THEN</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE('无法识别该类别');</span><br><span class="line">    raise_application_error(-20001, '无法识别的类别！'); <span class="comment">-- 抛出异常，程序停止，带有异常编号和异常信息</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">/</span><br><span class="line">ORA-20001: 无法识别的类别！ <span class="comment">-- 输出结果，当控制台输入的类型不在指定集合时</span></span><br></pre></td></tr></table></figure><p>需要说明的，异常错误编号必须介于 –20000 和 –20999 之间，且错误消息的长度最大可长达 2048 个字节。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的索引</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h2><p>索引是与表相关的一个可选结构，索引可用以提高 SQL 语句执行的性能，并较少磁盘 I/O。索引在逻辑上和物理上都独立于表的数据，oaracle 会自动维护索引。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><p>索引大体上可以分为：B树索引（平衡树索引）、位图索引。其中 B 树索引分为：唯一索引、组合索引、反向键索引、基于函数的索引。</p><p><img src="/2021/05/04/oracle-11g-的索引/20201023152408493.png" alt></p><a id="more"></a><h2 id="3-创建和分析"><a href="#3-创建和分析" class="headerlink" title="3. 创建和分析"></a>3. 创建和分析</h2><h3 id="3-1-创建标准索引"><a href="#3-1-创建标准索引" class="headerlink" title="3.1 创建标准索引"></a>3.1 创建标准索引</h3><p>首先创建一张普通表，具体 sql 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    sno <span class="built_in">number</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    sname varchar2(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>为 student 表的学号 sno 创建普通标准索引，具体如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> stu_sno_idx <span class="keyword">on</span> student(sno) [<span class="keyword">tablespace</span> <span class="keyword">default</span>]; <span class="comment">-- 表空间可选</span></span><br></pre></td></tr></table></figure><h3 id="3-2-分析索引"><a href="#3-2-分析索引" class="headerlink" title="3.2 分析索引"></a>3.2 分析索引</h3><p>索引只有经过分析之后，才能准确的查看索引的信息。因为对表的每次操作，oracle 都会自动维护索引。也就是索引的结构等信息都会变化。为了查看准确的索引信息，那么就需要索引进行分析。索引分析语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">index</span> &lt;index_name&gt; <span class="keyword">validate</span> structure;</span><br></pre></td></tr></table></figure><p>分析完索引之后，可以查看index_stats表中的pct_used列的值，如果pct_used的值过低，说明在索引中存在碎片，可以重建索引，来提高pct_used的值，减少索引中的碎片。pct_used 一般最高值是 90%。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询名称为 STU_SNO_IDX 的索引的 pct_used 使用率</span></span><br><span class="line"><span class="keyword">select</span> t.pct_used <span class="keyword">from</span> index_stats <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'STU_SNO_IDX'</span>;</span><br></pre></td></tr></table></figure><h2 id="4-唯一索引"><a href="#4-唯一索引" class="headerlink" title="4. 唯一索引"></a>4. 唯一索引</h2><p>唯一索引确保在定义索引的列中没有重复值，Oracle 自动在表的主键列上创建唯一索引。使用CREATE UNIQUE INDEX语句创建唯一索引。同样的，我们在上述的 student 表创建唯一索引，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> stu_sno_idx <span class="keyword">on</span> student(sno);</span><br></pre></td></tr></table></figure><p>由于我们在 sno 列创建的是唯一索引，所以第三条 insert 是无法执行成功的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'lisi'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'wangwu'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'zhaoliu'</span>); <span class="comment">-- 插入失败</span></span><br></pre></td></tr></table></figure><h2 id="5-组合索引"><a href="#5-组合索引" class="headerlink" title="5. 组合索引"></a>5. 组合索引</h2><p>组合索引是在表的多个列上创建的索引，索引中列的顺序是任意的。如果 SQL 语句的 WHERE 子句中引用了组合索引的所有列或大多数列，则可以提高检索速度。创建示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 sno 和 sname 创建组合索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> stu_sno_sname_idx <span class="keyword">on</span> student(sno, sname);</span><br></pre></td></tr></table></figure><h2 id="6-反向键索引"><a href="#6-反向键索引" class="headerlink" title="6. 反向键索引"></a>6. 反向键索引</h2><p>举个例子来说明反向键索引的用途。比如现在 student 表的学号列的值一般都是 16251104101，16251104102，16251104103…也就是前面大部分是固定的序列，后面几位是递增的序列。由于 B 树索引（相对于位图，B 树索引更为常用）的特性，在对上述规则的 sno 列上建立索引，可能会导致 B 树不平衡。</p><p>为了避免这种情况，可以反转 sno 列的值，也就是变为 30140115261，20140115261，10140115261…，这样便可以使数据均匀地分布在整个索引上。</p><p>可以使用关键字 REVERSE 来创建反向键索引，创建实例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> rev_sno_idx <span class="keyword">on</span> student(sno) <span class="keyword">reverse</span>;</span><br></pre></td></tr></table></figure><h2 id="7-位图索引"><a href="#7-位图索引" class="headerlink" title="7. 位图索引"></a>7. 位图索引</h2><p>位图索引适合创建在低基数列上，所谓的低基数列即类似于性别这种列，列上只有男或者女两种值。位图索引不直接存储ROWID，而是存储字节位到ROWID的映射。位图索引可以节省空间占用。如果索引列被经常更新的话，不适合建立位图索引。</p><p>总体来说，位图索引适合于数据仓库中，不适合日常的开发使用中。位图索引的创建示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意关键字 bitmap</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">bitmap</span> <span class="keyword">index</span> stu_sgender_idx <span class="keyword">on</span> student(sgender);</span><br></pre></td></tr></table></figure><h2 id="8-基于函数的索引"><a href="#8-基于函数的索引" class="headerlink" title="8. 基于函数的索引"></a>8. 基于函数的索引</h2><p>基于一个或多个列上的函数或表达式创建的索引，且表达式中不能出现聚合函数。基于函数的索引不能在LOB类型的列上创建，且必须具有 QUERY REWRITE 权限。创建实例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> lowercase_idx <span class="keyword">on</span> student(<span class="keyword">lower</span>(sname));</span><br></pre></td></tr></table></figure><p>这样我们在通过函数作为查询条件进行查询的时候，速度会更加快，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">lower</span>(sname) = <span class="string">'lisi'</span>;</span><br></pre></td></tr></table></figure><h2 id="9-重建索引"><a href="#9-重建索引" class="headerlink" title="9. 重建索引"></a>9. 重建索引</h2><p>语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> index_name <span class="keyword">REBUILD</span> [<span class="keyword">ONLINE</span>] [NOLOGGING] [<span class="keyword">COMPUTE</span> <span class="keyword">STATISTICS</span>];</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>ONLINE使得在重建索引过程中，用户可用对原来的索引进行修改；</li><li>NOLOGGING表示在重建过程中产生最少的重做条目redo Entry；</li><li>COMPUTE STATISTICS表示在重建过程中就生成了oracle 优化器所需的统计信息，避免了索引重建之后再进行analyze 或dbms_stats来收集统计信息。</li></ul><h2 id="10-删除索引"><a href="#10-删除索引" class="headerlink" title="10. 删除索引"></a>10. 删除索引</h2><p>删除示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name;</span><br></pre></td></tr></table></figure><h2 id="11-索引信息"><a href="#11-索引信息" class="headerlink" title="11. 索引信息"></a>11. 索引信息</h2><p>与索引有关的数据字典视图有：</p><ul><li>USER_INDEXES 用户创建的索引的信息</li><li>USER_IND_PARTITIONS 用户创建的分区索引的信息</li><li>USER_IND_COLUMNS 与索引相关的表列的信息</li></ul><p>例如查询索引作用的列的信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INDEX_NAME, TABLE_NAME, COLUMN_NAME</span><br><span class="line"><span class="keyword">FROM</span> USER_IND_COLUMNS</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> INDEX_NAME, COLUMN_POSITION;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>merge into 的用法</title>
      <link href="/2021/05/04/merge-into-%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/2021/05/04/merge-into-%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h2><p>merge into 的语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MERGE</span> <span class="keyword">INTO</span> [target-<span class="keyword">table</span>] T <span class="keyword">USING</span> [<span class="keyword">source</span>-<span class="keyword">table</span> <span class="keyword">sql</span>] S <span class="keyword">ON</span>([conditional expression] <span class="keyword">and</span> [...]...)</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">MATCHED</span></span><br><span class="line"><span class="keyword">THEN</span> [<span class="keyword">UPDATE</span> <span class="keyword">sql</span>]</span><br><span class="line"><span class="keyword">WHEN</span> <span class="keyword">NOT</span> <span class="keyword">MATCHED</span></span><br><span class="line"><span class="keyword">THEN</span> [<span class="keyword">INSERT</span> <span class="keyword">sql</span>]</span><br></pre></td></tr></table></figure><p>判断源表 S 和目标表 T 是否满足 ON 中的条件，如果满足则用 S 表去更新 T 表，如果不满足，则将 S 表数据插入 T 表中。但是有很多可选项，如下：</p><ul><li>普通模式</li><li>只 update 或者只 insert</li><li>无条件 insert 实现</li><li>带 delete 的 update</li></ul><a id="more"></a><h2 id="2-测试表"><a href="#2-测试表" class="headerlink" title="2. 测试表"></a>2. 测试表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 目标表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> target</span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">NUMBER</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">name</span> VARCHAR2(<span class="number">12</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">year</span> <span class="built_in">NUMBER</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 源表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">source</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">NUMBER</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">aid <span class="built_in">NUMBER</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">name</span> VARCHAR2(<span class="number">12</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">year</span> <span class="built_in">NUMBER</span>,</span><br><span class="line">city VARCHAR2(<span class="number">12</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> target <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'liuwei'</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> target <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'zhangbin'</span>,<span class="number">21</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> target <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'fuguo'</span>,<span class="number">20</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">source</span> <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="string">'zhangbin'</span>,<span class="number">30</span>,<span class="string">'吉林'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">source</span> <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="string">'yihe'</span>,<span class="number">33</span>,<span class="string">'黑龙江'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">source</span> <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="string">'fuguo'</span>,<span class="string">''</span>,<span class="string">'山东'</span>);</span><br></pre></td></tr></table></figure><p>两表的的查询结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20</span><br><span class="line">         2 zhangbin             21</span><br><span class="line">         3 fuguo                20</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from source;</span><br><span class="line"></span><br><span class="line">        ID        AID NAME               YEAR CITY</span><br><span class="line"><span class="comment">---------- ---------- ------------ ---------- ------------</span></span><br><span class="line">         1          2 zhangbin             30 吉林</span><br><span class="line">         2          4 yihe                 33 黑龙江</span><br><span class="line">         3          3 fuguo                   山东</span><br></pre></td></tr></table></figure><h2 id="3-普通模式"><a href="#3-普通模式" class="headerlink" title="3.  普通模式"></a>3.  普通模式</h2><p>现在简单的使用 merge into 来实现当符合 on 中的条件时则进行更新操作，否则进行插入操作的功能。查看 target 和 source 表，其中 target 表中的 id 和 source 和 aid 是关联的，现在我们要实现当 target 表的 id 与 source 的 aid 匹配时，使用 source 表的 year 去更新 target 表的 year，否则将 source 中的记录插入到 target 表中，具体实现 sql 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> target t <span class="keyword">using</span> <span class="keyword">source</span> s <span class="keyword">on</span> (t.id = s.aid)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> t.year = s.year</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">values</span>(s.aid, s.name, s.year);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20 <span class="comment">-- 原有记录</span></span><br><span class="line">         2 zhangbin             30 <span class="comment">-- 更新为 30</span></span><br><span class="line">         3 fuguo                   <span class="comment">-- 更新为 空</span></span><br><span class="line">         4 yihe                 33 <span class="comment">-- 新插入记录</span></span><br></pre></td></tr></table></figure><h2 id="4-只-update"><a href="#4-只-update" class="headerlink" title="4. 只 update"></a>4. 只 update</h2><p>还原 target 表的数据，现在来实现当 target 表的 id 与 source 的 aid 匹配时，使用 source 表的 year 去更新 target 表的 year 的操作，具体实现 sql 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> target t <span class="keyword">using</span> (<span class="keyword">select</span> aid, <span class="keyword">name</span>, <span class="keyword">year</span> <span class="keyword">from</span> <span class="keyword">source</span>) s <span class="keyword">on</span> (t.id = s.aid)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> t.year = s.year;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20 <span class="comment">-- 原有记录</span></span><br><span class="line">         2 zhangbin             30 <span class="comment">-- 更新为 30</span></span><br><span class="line">         3 fuguo               <span class="comment">-- 更新为 空</span></span><br></pre></td></tr></table></figure><p>还原 target 表的数据，我们也可以在 update 子句添加限定条件，比如使用 source 表的 year 去更新 target 表的 year 的操作时，限定 source 表的记录除了与 target 是匹配的条件之外，city 必须是吉林的，具体实现 sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> target t <span class="keyword">using</span> <span class="keyword">source</span> s <span class="keyword">on</span> (t.id = s.aid)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">set</span> t.year = s.year <span class="keyword">where</span> s.city = <span class="string">'吉林'</span>;</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20 <span class="comment">-- 原有记录</span></span><br><span class="line">         2 zhangbin             30 <span class="comment">-- 更新为 30</span></span><br><span class="line">         3 fuguo                20 <span class="comment">-- 原有记录</span></span><br></pre></td></tr></table></figure><h2 id="5-只-insert"><a href="#5-只-insert" class="headerlink" title="5. 只 insert"></a>5. 只 insert</h2><p>还原 target 表的数据，现在来实现当 target 表的 id 与 source 的 aid 不匹配时，将 source 中的记录插入到 target 表中，具体实现 sql 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> target t <span class="keyword">using</span> <span class="keyword">source</span> s <span class="keyword">on</span> (t.id = s.aid)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">insert</span>(t.id, t.name, t.year) <span class="keyword">values</span>(s.aid, s.name, s.year);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20 <span class="comment">-- 原有记录</span></span><br><span class="line">         2 zhangbin             21 <span class="comment">-- 原有记录</span></span><br><span class="line">         3 fuguo                20 <span class="comment">-- 原有记录</span></span><br><span class="line">         4 yihe                 33 <span class="comment">-- 新增记录</span></span><br></pre></td></tr></table></figure><p> insert 子句也可以添加限定条件，类似 update，这里不再赘述。</p><h2 id="6-无条件-insert"><a href="#6-无条件-insert" class="headerlink" title="6. 无条件 insert"></a>6. 无条件 insert</h2><p>还原 target 表的数据。有时我们需要将一张表中所有的数据插入到另外一张表，此时就可以添加常量过滤谓词来实现，让其只满足匹配和不匹配，这样就只有update或者只有insert。这里我们要无条件全插入，则只需将on中条件设置为永假即可。用 source 表来更新 target 代码如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> target t <span class="keyword">using</span> <span class="keyword">source</span> s <span class="keyword">on</span>(<span class="number">1</span> = <span class="number">0</span>) <span class="comment">-- 设置永假匹配条件</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">not</span> <span class="keyword">matched</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">insert</span>(t.id, t.name, t.year) <span class="keyword">values</span>(s.aid, s.name, s.year);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20</span><br><span class="line">         2 zhangbin             21</span><br><span class="line">         3 fuguo                20</span><br><span class="line">         2 zhangbin             30 <span class="comment">-- 新增记录</span></span><br><span class="line">         4 yihe                 33 <span class="comment">-- 新增记录</span></span><br><span class="line">         3 fuguo           <span class="comment">-- 新增记录</span></span><br></pre></td></tr></table></figure><h2 id="7-带-delete-的-update"><a href="#7-带-delete-的-update" class="headerlink" title="7. 带 delete 的 update"></a>7. 带 delete 的 update</h2><p>还原 target 表的数据。删除 target 表中与 source 表匹配的符合指定条件的记录。需要注意的是，delete 子句附属于 update 子句，也就是要有 delete 子句必须有 update 子句。如下语句使用 source 表的记录来匹配更新 target 表中的记录。同时删除匹配的记录中 target 表中 id 为2 的记录，具体实现 sql 如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">merge</span> <span class="keyword">into</span> target t <span class="keyword">using</span> <span class="keyword">source</span> s <span class="keyword">on</span>(t.id = s.aid)</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">matched</span> <span class="keyword">then</span> <span class="keyword">update</span> <span class="keyword">set</span> t.year = s.year</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">where</span>(t.id = <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 为 2 的记录被删除</span></span><br><span class="line">SQL&gt; select * from target;</span><br><span class="line"></span><br><span class="line">        ID NAME               YEAR</span><br><span class="line"><span class="comment">---------- ------------ ----------</span></span><br><span class="line">         1 liuwei               20 <span class="comment">-- 原有记录</span></span><br><span class="line">         3 fuguo                   <span class="comment">-- year 被更新</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的视图</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E8%A7%86%E5%9B%BE/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h3><p>视图以经过定制的方式显示来自一个或多个表的数据，视图可以视为“虚拟表”或“存储的查询”，创建视图所依据的表称为“基表”。</p><p>视图的有如下优点：</p><ul><li>提供了另外一种级别的表安全性</li><li>隐藏的数据的复杂性</li><li>简化的用户的SQL命令</li><li>隔离基表结构的改变</li><li>通过重命名列，从另一个角度提供数据</li></ul><a id="more"></a><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [<span class="keyword">FORCE</span>] <span class="keyword">VIEW</span> view_name [(<span class="keyword">alias</span>[, <span class="keyword">alias</span>]...)] </span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span>];</span><br></pre></td></tr></table></figure><ul><li>force 参数表示强制创建视图，例如下面的示例，视图 view1 的基表 address 并不存在。但是在使用 force 参数后依旧可以创建。但是此时视图并不可以使用，只有当基表 address 创建完成后才可以使用视图。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 强制创建视图，即是视图的基表 address 不存在。</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">force</span> <span class="keyword">view</span> view1</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> address;</span><br></pre></td></tr></table></figure><ul><li>with check option 顾名思义即是对视图的数据进行校验。视图是可以进行 update 等更新操作的，因此可能会由于更新操作而导致原有的视图失效。</li></ul><p>首先创建如下 student 基表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(</span><br><span class="line">    sno <span class="built_in">number</span> primary <span class="keyword">key</span>,</span><br><span class="line">    sname varchar2(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'李四'</span>);</span><br></pre></td></tr></table></figure><p>然后创建如下视图，注意我们对查询语句加了 where sno = 1 的限定条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view1</span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>视图 view1 创建完成之后，执行如下更新语句。下述的更新语句会导致对视图 view1 的查询结果变为空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> view1 <span class="keyword">set</span> sno = <span class="number">3</span> <span class="keyword">where</span> sno = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>为了避免上述的情况发生，可以在创建视图语句的后面加上 with check option 来对视图的数据更新进行校验，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view2</span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno = <span class="number">1</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> <span class="keyword">option</span></span><br></pre></td></tr></table></figure><p>此时在进行上述的更新操作，则会报如下的错误：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORA-01402: view <span class="keyword">WITH</span> <span class="keyword">CHECK</span> <span class="keyword">OPTION</span> <span class="keyword">where</span>-clause violation</span><br></pre></td></tr></table></figure><ul><li>with read only  标识只允许创建一个可读的视图，视图不可进行增删改操作。</li></ul><h3 id="3-连接"><a href="#3-连接" class="headerlink" title="3. 连接"></a>3. 连接</h3><p>视图也可以进行连接查询，具体使用方法大体与表的连接查询一致，这里不再赘述。</p><h3 id="4-视图的-DML"><a href="#4-视图的-DML" class="headerlink" title="4. 视图的 DML"></a>4. 视图的 DML</h3><p>在视图上也可以使用修改数据的DML语句，如INSERT、UPDATE和DELETE。视图上的DML语句有如下限制：</p><ul><li>只能修改一个底层的基表</li><li>如果修改违反了基表的约束条件，则无法更新视图</li><li>如果视图包含连接操作符、DISTINCT 关键字、集合操作符、聚合函数或 GROUP BY 子句，则将无法更新视图</li><li>如果视图包含伪列或表达式，则将无法更新视图</li></ul><h3 id="5-键保留表"><a href="#5-键保留表" class="headerlink" title="5. 键保留表"></a>5. 键保留表</h3><p>前面说过，在对视图的 DML 操作是只能修改一个底层的基表，那么如果视图是多表视图的时候，进行更新操作会发生怎样的情况呢？查看如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建基表 student1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student1 (sno <span class="built_in">number</span>(<span class="number">6</span>), birthday <span class="built_in">date</span>, sname varchar2(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'11-1月-81'</span>, <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'10-3月-82'</span>, <span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student1 <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'06-1月-83'</span>, <span class="string">'王五'</span>);</span><br><span class="line"><span class="comment">-- 创建基表 address1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> address1(sno <span class="built_in">number</span>(<span class="number">6</span>), zz varchar2(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> address1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'郑州'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> address1 <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'开封'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> address1 <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'洛阳'</span>);</span><br><span class="line"><span class="comment">-- 创建多表视图</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_student1_address1</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line">    <span class="keyword">select</span> s.sno sno1, s.sname, a.sno sno2, a.zz</span><br><span class="line">    <span class="keyword">from</span> student1 s, address1 a</span><br><span class="line">    <span class="keyword">where</span> s.sno = a.sno;</span><br><span class="line"><span class="comment">--查询多表视图</span></span><br><span class="line">SQL&gt; select * from   view_student1_address1;</span><br><span class="line"></span><br><span class="line">   SNO1 SNAME         SNO2 ZZ</span><br><span class="line"><span class="comment">------- ---------- ------- ----------</span></span><br><span class="line">      1 张三             1 郑州</span><br><span class="line">      2 李四             2 开封</span><br><span class="line">      3 王五             3 洛阳</span><br><span class="line"><span class="comment">-- 更新 sno1 为 1 的记录</span></span><br><span class="line"><span class="keyword">update</span> view_student1_address1 <span class="keyword">set</span> sno1 = <span class="number">11</span> <span class="keyword">where</span> sno1 = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>执行上述更新语句之后，会报如下的错误。也就是说不能修改非键保留表的视图的列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORA-01779: cannot modify a column which maps to a non key-preserved table</span><br></pre></td></tr></table></figure><p>为了能够修改多表视图的一个底层的基表（DML 的限制条件，只能是一个基表），我们可以通过建立键保留表来实现。具体查看如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(sno <span class="built_in">number</span>(<span class="number">6</span>) primary <span class="keyword">key</span>, sname varchar2(<span class="number">10</span>), deptno <span class="built_in">char</span>(<span class="number">3</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'张三'</span>, <span class="string">'001'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'李四'</span>, <span class="string">'001'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'王五'</span>, <span class="string">'002'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(deptno <span class="built_in">char</span>(<span class="number">3</span>) primary <span class="keyword">key</span>, deptname varchar2(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="string">'001'</span>, <span class="string">'中文系'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="string">'001'</span>, <span class="string">'数学系'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="string">'002'</span>, <span class="string">'英语系'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_stu_dept <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">select</span>  s.sno, s.sname, s.deptno, d.deptname</span><br><span class="line"><span class="keyword">from</span>  student s, department d  <span class="keyword">where</span> s.deptno = d.deptno;</span><br></pre></td></tr></table></figure><p>不同与上述的示例，此时建立的 student 和 department 表都包含主键，此时建立的视图可以通过更新语句对保留表的列进行更新操作。</p><p>上述视图建立的键保留表即为 stdent，也就是我们仅能对视图 view_stu_dept 中来自 student 表的列进行更新操作，对于来自 department 表的列则不可以进行相应的操作。</p><h3 id="6-视图中的函数"><a href="#6-视图中的函数" class="headerlink" title="6. 视图中的函数"></a>6. 视图中的函数</h3><p>视图中可以使用单行函数、分组函数和表达式，不过必须为使用函数或者表达式的字段设置别名，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> item_view <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> itemcode, <span class="keyword">LOWER</span>(itemdesc) item_desc <span class="comment">-- 设置别名</span></span><br><span class="line"><span class="keyword">FROM</span> itemfile;</span><br></pre></td></tr></table></figure><h3 id="7-删除视图"><a href="#7-删除视图" class="headerlink" title="7. 删除视图"></a>7. 删除视图</h3><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的序列</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E5%BA%8F%E5%88%97/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h3><p>序列是用于生成唯一、连续序号的对象，序列可以是升序的，也可以是降序的。</p><h3 id="2-创建序列"><a href="#2-创建序列" class="headerlink" title="2. 创建序列"></a>2. 创建序列</h3><p>使用CREATE SEQUENCE语句创建序列，创建示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">sequence</span> stu_seq</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">with</span> <span class="number">1</span> <span class="comment">-- 从 1 开始，可选，默认为1</span></span><br><span class="line"><span class="keyword">increment</span> <span class="keyword">by</span> <span class="number">1</span> <span class="comment">-- 每次增加 1，支持正负数，可选，默认为1</span></span><br><span class="line">maxvalue <span class="number">2000</span> <span class="comment">-- 序列最大数，可选</span></span><br><span class="line"><span class="keyword">minvalue</span> <span class="number">1</span> <span class="comment">--序列最小值，可选，默认为1</span></span><br><span class="line"><span class="keyword">nocycle</span> <span class="comment">-- 序列不循环，即取到最大值不再从起始值继续开始，可选，默认不循环</span></span><br><span class="line"><span class="keyword">cache</span> <span class="number">10</span>; <span class="comment">-- 指定内存中预先分配的序号数。缓存 10 条序列值，避免取序列时 oracle 都要计算获取一次，可选，默认20</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="3-查询序列信息"><a href="#3-查询序列信息" class="headerlink" title="3. 查询序列信息"></a>3. 查询序列信息</h3><p>普通用户可以通过查询 user_sequences 表来查询序列定义信息，具体示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from user_sequences where sequence_name = 'STU_SEQ';</span><br><span class="line"></span><br><span class="line">SEQUENCE_NAME                   MIN_VALUE  MAX_VALUE INCREMENT_BY CYCLE_FLAG ORDER_FLAG CACHE_SIZE LAST_NUMBER</span><br><span class="line"><span class="comment">------------------------------ ---------- ---------- ------------ ---------- ---------- ---------- -----------</span></span><br><span class="line">STU_SEQ                                 1       2000            1 N          N                  10           1</span><br></pre></td></tr></table></figure><h3 id="4-使用序列"><a href="#4-使用序列" class="headerlink" title="4. 使用序列"></a>4. 使用序列</h3><p>通过序列的伪列来访问序列的值，NEXTVAL 返回序列的下一个值，CURRVAL 返回序列的当前值。第一次使用序列中的值的时候，要使用 NEXTVAL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select stu_seq.nextval from dual;</span><br><span class="line"></span><br><span class="line">   NEXTVAL</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">         1</span><br></pre></td></tr></table></figure><h3 id="5-修改序列"><a href="#5-修改序列" class="headerlink" title="5. 修改序列"></a>5. 修改序列</h3><p>使用ALTER SEQUENCE语句修改序列，但是不能更改序列的START WITH参数。具体示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; alter sequence stu_seq maxvalue 5000 cycle;</span><br><span class="line"></span><br><span class="line">Sequence altered</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SQL&gt; select * from user_sequences;</span><br><span class="line"></span><br><span class="line">SEQUENCE_NAME                   MIN_VALUE  MAX_VALUE INCREMENT_BY CYCLE_FLAG ORDER_FLAG CACHE_SIZE LAST_NUMBER</span><br><span class="line"><span class="comment">------------------------------ ---------- ---------- ------------ ---------- ---------- ---------- -----------</span></span><br><span class="line">STU_SEQ                                 1       5000            1 Y          N                  10           2</span><br></pre></td></tr></table></figure><h3 id="6-删除序列"><a href="#6-删除序列" class="headerlink" title="6. 删除序列"></a>6. 删除序列</h3><p>使用DROP SEQUENCE语句删除序列，具体示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">sequence</span> stu_seq;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的同义词</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E5%90%8C%E4%B9%89%E8%AF%8D/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E5%90%8C%E4%B9%89%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h3><p>同义词是现有对象的一个别名。主要是用于简化SQL语句、隐藏对象的名称和所有者和提供对对象的公共访问。</p><p>同义词存在私有同义词和公有同义词两种类型。公有同义词可被所有的数据库用户访问，而私有同义词只能在其模式内访问，且不能与当前模式的对象同名。</p><a id="more"></a><h3 id="2-创建"><a href="#2-创建" class="headerlink" title="2. 创建"></a>2. 创建</h3><blockquote><p>创建同义词的用户需要有创建对应私有同义词或公有同义词的权限</p></blockquote><h4 id="2-1-私有同义词"><a href="#2-1-私有同义词" class="headerlink" title="2.1 私有同义词"></a>2.1 私有同义词</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 scott 模式的 emp 的同义词 syn_emp</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">synonym</span> syn_emp <span class="keyword">for</span> scott.emp;</span><br></pre></td></tr></table></figure><p>创建完上述的私有同义词后，在 scott 用户下，便可以使用 syn_emp 代替查询 scott.emp 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 同 select * from scott.emp</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> syn_emp;</span><br></pre></td></tr></table></figure><h4 id="2-2-公有同义词"><a href="#2-2-公有同义词" class="headerlink" title="2.2 公有同义词"></a>2.2 公有同义词</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建公有同义词，所有具备查询 scott.emp 表权限的模式都可以使用该同义词</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">public</span> <span class="keyword">synonym</span> pub_emp <span class="keyword">for</span> scott.emp;</span><br></pre></td></tr></table></figure><h3 id="3-创建或替换"><a href="#3-创建或替换" class="headerlink" title="3. 创建或替换"></a>3. 创建或替换</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建同义词 syn_dept 或替换 syn_dept</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">synonym</span> syn_dept <span class="keyword">for</span> scott.dept;</span><br></pre></td></tr></table></figure><h3 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除私有同义词</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">synonym</span> syn_dept;</span><br><span class="line"><span class="comment">-- 删除公有同义词</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">public</span> <span class="keyword">synonym</span> pub_emp;</span><br></pre></td></tr></table></figure><h3 id="5-TAB"><a href="#5-TAB" class="headerlink" title="5. TAB"></a>5. TAB</h3><p>我们常常会使用如下语句查询当前用户下具备有哪些表，现在来一探究竟 tab 究竟是什么…</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tab;</span><br></pre></td></tr></table></figure><p>查看下述第一个查询示例，可以发现 tab 属于 public 用户的一个同义词。从第二个查询示例可以发现，public 用户的 tab 属于 sys 用户。综上，tab 本质是 sys 用户的一个视图对象，也是 public 用户的一个同义词。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select OWNER, OBJECT_NAME, OBJECT_TYPE from all_objects t where t.OBJECT_NAME = 'TAB';</span><br><span class="line"></span><br><span class="line">OWNER                          OBJECT_NAME                    OBJECT_TYPE</span><br><span class="line"><span class="comment">------------------------------ ------------------------------ -------------------</span></span><br><span class="line">SYS                            TAB                            VIEW</span><br><span class="line">PUBLIC                         TAB                            SYNONYM</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select OWNER, SYNONYM_NAME, TABLE_OWNER, TABLE_NAME from all_synonyms t where t.TABLE_NAME = 'TAB';</span><br><span class="line"></span><br><span class="line">OWNER                          SYNONYM_NAME                   TABLE_OWNER                    TABLE_NAME                     </span><br><span class="line"><span class="comment">------------------------------ ------------------------------ ------------------------------ ------------------------------</span></span><br><span class="line">PUBLIC                         TAB                            SYS                            TAB                            </span><br><span class="line">SYSTEM                         TAB                            SYS                            TAB</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的表分区</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E8%A1%A8%E5%88%86%E5%8C%BA/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E8%A1%A8%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ul><li>表分区允许用户将一个表分为多个分区；</li><li>用户可以执行查询，只访问表中的特定分区；</li><li>将不同的分区存储在不同的磁盘，提高访问性能和安全性；</li><li>可以独立地备份和恢复每个分区。</li></ul><a id="more"></a><h2 id="2-传统的表分区"><a href="#2-传统的表分区" class="headerlink" title="2. 传统的表分区"></a>2. 传统的表分区</h2><p>传统表分区指的是 oracle 10g 及之前版本的表分区。传统的表分区有四种类型，分别为范围分区、散列分区、列表分区和复合分区四种。我们可以使用如下语句查看指定表的分区信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_tab_partitions u <span class="keyword">where</span> u.table_name = <span class="string">'全大写表名'</span>;</span><br></pre></td></tr></table></figure><h3 id="2-1-范围分区"><a href="#2-1-范围分区" class="headerlink" title="2.1 范围分区"></a>2.1 范围分区</h3><h4 id="2-1-1-含义"><a href="#2-1-1-含义" class="headerlink" title="2.1.1 含义"></a>2.1.1 含义</h4><p>范围分区是以表中的一个列或一组列的值的范围分区。范围分区的缺点很明显，即可能存在大量相同范围的记录存在特定的分区的现象，从而导致分区分配不均的情况。</p><h4 id="2-1-2-语法"><a href="#2-1-2-语法" class="headerlink" title="2.1.2 语法"></a>2.1.2 语法</h4><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PARTITION BY RANGE (column_name)</span><br><span class="line">(</span><br><span class="line">  PARTITION part1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(range1),</span><br><span class="line">  <span class="keyword">PARTITION</span> part2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(range2),</span><br><span class="line">  ...</span><br><span class="line">  [<span class="keyword">PARTITION</span> partN <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(MAXVALUE)]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-1-3-示例"><a href="#2-1-3-示例" class="headerlink" title="2.1.3 示例"></a>2.1.3 示例</h4><p>创建一个产品表，按照价格字段 price 的范围分为三个分区，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表并分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(pno <span class="built_in">number</span>, price <span class="built_in">number</span>)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(price) (</span><br><span class="line">    <span class="keyword">partition</span> p1 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">1000</span>), <span class="comment">-- 存储 price &lt; 1000 的记录</span></span><br><span class="line">    <span class="keyword">partition</span> p2 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">2000</span>), <span class="comment">-- 存储 price &gt;= 1000 and price &lt; 2000 的记录</span></span><br><span class="line">    <span class="keyword">partition</span> p3 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(maxvalue) <span class="comment">-- 存储 price &gt;= 2000 的记录</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> product <span class="keyword">values</span>(<span class="number">3</span>, <span class="number">2020</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分区查询结果</span></span><br><span class="line">SQL&gt; select * from product partition(p1);</span><br><span class="line"></span><br><span class="line">       PNO      PRICE</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         1        200</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from product partition(p2);</span><br><span class="line"></span><br><span class="line">       PNO      PRICE</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         2       1000</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from product partition(p3);</span><br><span class="line"></span><br><span class="line">       PNO      PRICE</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         3       2020</span><br></pre></td></tr></table></figure><p><span style="color: red">提示：对表建立分区之后，查询语句会发生变化，即要对某个分区进行查询的时候需要在后面带 partition；而对于更新删除操作则仍然保持普通的写法。</span></p><h3 id="2-2-散列分区"><a href="#2-2-散列分区" class="headerlink" title="2.2 散列分区"></a>2.2 散列分区</h3><h4 id="2-2-1-含义"><a href="#2-2-1-含义" class="headerlink" title="2.2.1 含义"></a>2.2.1 含义</h4><p>散列分区允许用户对不具有逻辑范围的数据进行分区，通过在分区键上执行HASH函数决定存储的分区。不同于范围分区，散列分区可以有效地避免分区数据分配不均的情况发生，散列分区可以将数据平均地分布到不同的分区中。</p><h4 id="2-2-2-语法"><a href="#2-2-2-语法" class="headerlink" title="2.2.2 语法"></a>2.2.2 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- number_of_partitions 表示分区数量</span></span><br><span class="line">PARTITION BY HASH (column_name)</span><br><span class="line">PARTITIONS number_of_partitions;</span><br><span class="line">或</span><br><span class="line">PARTITION BY HASH (column_name)</span><br><span class="line">( PARTITION part1 [TABLESPACE tbs1],</span><br><span class="line">  PARTITION part2 [TABLESPACE tbs2],</span><br><span class="line">  ...</span><br><span class="line">  PARTITION partN [TABLESPACE tbsN]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-2-3-示例"><a href="#2-2-3-示例" class="headerlink" title="2.2.3 示例"></a>2.2.3 示例</h4><p>创建一个 person 表，按人员的姓名分为四个散列分区，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建散列分区，仅指定分区数量</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(<span class="keyword">name</span> varchar2(<span class="number">50</span>), age <span class="built_in">number</span>)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(<span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建散列分区，指定具体分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(<span class="keyword">name</span> varchar2(<span class="number">50</span>), age <span class="built_in">number</span>)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(<span class="keyword">name</span>) (</span><br><span class="line">    <span class="keyword">partition</span> p1,</span><br><span class="line">    <span class="keyword">partition</span> p2,</span><br><span class="line">    <span class="keyword">partition</span> p3,</span><br><span class="line">    <span class="keyword">partition</span> p4</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'张三'</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'李四'</span>, <span class="number">36</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'王五'</span>, <span class="number">45</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'赵六'</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分区查询结果</span></span><br><span class="line">SQL&gt; select * from person partition(p1);</span><br><span class="line"></span><br><span class="line">NAME                                                      AGE</span><br><span class="line"><span class="comment">-------------------------------------------------- ----------</span></span><br><span class="line"></span><br><span class="line">SQL&gt; select * from person partition(p2);</span><br><span class="line"></span><br><span class="line">NAME                                                      AGE</span><br><span class="line"><span class="comment">-------------------------------------------------- ----------</span></span><br><span class="line">张三                                                       22</span><br><span class="line">王五                                                       45</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from person partition(p3);</span><br><span class="line"></span><br><span class="line">NAME                                                      AGE</span><br><span class="line"><span class="comment">-------------------------------------------------- ----------</span></span><br><span class="line">李四                                                       36</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from person partition(p4);</span><br><span class="line"></span><br><span class="line">NAME                                                      AGE</span><br><span class="line"><span class="comment">-------------------------------------------------- ----------</span></span><br><span class="line">赵六                                                       12</span><br></pre></td></tr></table></figure><h3 id="2-3-列表分区"><a href="#2-3-列表分区" class="headerlink" title="2.3 列表分区"></a>2.3 列表分区</h3><h4 id="2-3-1-含义"><a href="#2-3-1-含义" class="headerlink" title="2.3.1 含义"></a>2.3.1 含义</h4><p>列表分区允许用户将不相关的数据组织在一起。列表分区支持对字段的具体值进行分区，不同于范围限定一个范围，列表分区是限定在具体的值。</p><h4 id="2-3-2-语法"><a href="#2-3-2-语法" class="headerlink" title="2.3.2 语法"></a>2.3.2 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PARTITION BY LIST (column_name)</span><br><span class="line">(</span><br><span class="line">  PARTITION part1 <span class="keyword">VALUES</span> (values_list1),</span><br><span class="line">  <span class="keyword">PARTITION</span> part2 <span class="keyword">VALUES</span> (values_list2),</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">PARTITION</span> partN <span class="keyword">VALUES</span> (<span class="keyword">DEFAULT</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-3-3-示例"><a href="#2-3-3-示例" class="headerlink" title="2.3.3 示例"></a>2.3.3 示例</h4><p>创建一个 person 表，并按地市字段 city 对表进行分区，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(<span class="keyword">name</span> varchar2(<span class="number">50</span>), city varchar2(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">list</span>(city)(</span><br><span class="line">    <span class="keyword">partition</span> p1 <span class="keyword">values</span> (<span class="string">'广州'</span>),</span><br><span class="line">    <span class="keyword">partition</span> p2 <span class="keyword">values</span> (<span class="string">'深圳'</span>),</span><br><span class="line">    <span class="keyword">partition</span> p3 <span class="keyword">values</span> (<span class="keyword">default</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'李四'</span>, <span class="string">'深圳'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'李四'</span>, <span class="string">'广州'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">values</span>(<span class="string">'李四'</span>, <span class="string">'南昌'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询分区数据信息</span></span><br><span class="line">SQL&gt; select * from person partition(p1);</span><br><span class="line"></span><br><span class="line">NAME                                               CITY</span><br><span class="line"><span class="comment">-------------------------------------------------- --------------------</span></span><br><span class="line">李四                                               广州</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from person partition(p2);</span><br><span class="line"></span><br><span class="line">NAME                                               CITY</span><br><span class="line"><span class="comment">-------------------------------------------------- --------------------</span></span><br><span class="line">李四                                               深圳</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from person partition(p3);</span><br><span class="line"></span><br><span class="line">NAME                                               CITY</span><br><span class="line"><span class="comment">-------------------------------------------------- --------------------</span></span><br><span class="line">李四                                               南昌</span><br></pre></td></tr></table></figure><h3 id="2-4-复合分区"><a href="#2-4-复合分区" class="headerlink" title="2.4 复合分区"></a>2.4 复合分区</h3><h4 id="2-4-1-含义"><a href="#2-4-1-含义" class="headerlink" title="2.4.1  含义"></a>2.4.1  含义</h4><p>复合分区指的是范围分区与散列分区或列表分区的组合，即复合只存在两种组合方式：范围分区 + 散列分区与范围分区 + 列表分区。</p><h4 id="2-4-2-语法"><a href="#2-4-2-语法" class="headerlink" title="2.4.2 语法"></a>2.4.2 语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- number_of_partitions 表示子分区数量</span></span><br><span class="line">PARTITION BY RANGE (column_name1)</span><br><span class="line">SUBPARTITION BY HASH (column_name2)</span><br><span class="line">SUBPARTITIONS number_of_partitions</span><br><span class="line">(</span><br><span class="line">  PARTITION part1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(range1),</span><br><span class="line">  <span class="keyword">PARTITION</span> part2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(range2),</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">PARTITION</span> partN <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span>(MAXVALUE)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-4-3-示例"><a href="#2-4-3-示例" class="headerlink" title="2.4.3 示例"></a>2.4.3 示例</h4><p>创建一个 student 表并进行复合分区，先按 sno 进行范围分区，在对 sname 进行散列分区，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(sno <span class="built_in">number</span>, sname varchar2(<span class="number">50</span>))</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(sno)</span><br><span class="line"><span class="keyword">subpartition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(sname)</span><br><span class="line"><span class="keyword">subpartitions</span> <span class="number">4</span> (</span><br><span class="line">    <span class="keyword">partition</span> p1 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">1000</span>),</span><br><span class="line">    <span class="keyword">partition</span> p2 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">partition</span> p3 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">3000</span>),</span><br><span class="line">    <span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(maxvalue)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">20</span>, <span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">2020</span>, <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">3020</span>, <span class="string">'王五'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询分区数据</span></span><br><span class="line">SQL&gt; select * from student partition(p1);</span><br><span class="line"></span><br><span class="line">       SNO SNAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------</span></span><br><span class="line">        20 李四</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from student partition(p2);</span><br><span class="line"></span><br><span class="line">       SNO SNAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">SQL&gt; select * from student partition(p3);</span><br><span class="line"></span><br><span class="line">       SNO SNAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------</span></span><br><span class="line">      2020 张三</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from student partition(p4);</span><br><span class="line"></span><br><span class="line">       SNO SNAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------</span></span><br><span class="line">      3020 王五</span><br></pre></td></tr></table></figure><h2 id="3-11g-新增表分区"><a href="#3-11g-新增表分区" class="headerlink" title="3. 11g 新增表分区"></a>3. 11g 新增表分区</h2><h3 id="3-1-引用分区"><a href="#3-1-引用分区" class="headerlink" title="3.1 引用分区"></a>3.1 引用分区</h3><h4 id="3-1-1-含义"><a href="#3-1-1-含义" class="headerlink" title="3.1.1 含义"></a>3.1.1 含义</h4><p>引用分区是基于由外键引用父表的分区的方法，它依赖已有的父表子表的关系，子表通过外键关联到父表，进而继承了父表的分区方式而不需自己创建，子表还继承了父表的维护操作。</p><p>主表是无论是范围、散列还是列表分区，子表都是引用分区。</p><h4 id="3-1-2-示例"><a href="#3-1-2-示例" class="headerlink" title="3.1.2 示例"></a>3.1.2 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建父表，并按名称创建两个分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> father(</span><br><span class="line">    fid <span class="built_in">number</span> primary <span class="keyword">key</span>,</span><br><span class="line">    fname varchar2(<span class="number">50</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">hash</span>(fname) (</span><br><span class="line">    <span class="keyword">partition</span> p1,</span><br><span class="line">    <span class="keyword">partition</span> p2</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建子表，并设置外键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> son(</span><br><span class="line">    <span class="keyword">sid</span> <span class="built_in">number</span> primary <span class="keyword">key</span>,</span><br><span class="line">    sname varchar2(<span class="number">50</span>),</span><br><span class="line">    fid <span class="built_in">number</span> <span class="keyword">not</span> <span class="literal">null</span>, <span class="comment">-- 引用的外键必须非空，否则报 ORA-14652 错误</span></span><br><span class="line">    <span class="keyword">constraint</span> fk_fid <span class="keyword">foreign</span> <span class="keyword">key</span>(fid) <span class="keyword">references</span> father(fid)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">reference</span>(fk_fid); <span class="comment">-- 设置引用分区，不可或缺</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询分区定义信息，可以发现 SON 表也存在两个和父表一样的分区</span></span><br><span class="line">SQL&gt; select TABLE_NAME, COMPOSITE, PARTITION_NAME  from user_tab_partitions;</span><br><span class="line"></span><br><span class="line">TABLE_NAME                     COMPOSITE PARTITION_NAME</span><br><span class="line"><span class="comment">------------------------------ --------- ------------------------------</span></span><br><span class="line">FATHER                         NO        P1</span><br><span class="line">FATHER                         NO        P2</span><br><span class="line">SON                            NO        P1</span><br><span class="line">SON                            NO        P2</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试用例</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> father <span class="keyword">values</span>(<span class="number">1</span>, <span class="string">'张三'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> father <span class="keyword">values</span>(<span class="number">2</span>, <span class="string">'李四'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> father <span class="keyword">values</span>(<span class="number">3</span>, <span class="string">'王五'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> son <span class="keyword">values</span>(<span class="number">11</span>, <span class="string">'张三三'</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> son <span class="keyword">values</span>(<span class="number">22</span>, <span class="string">'李四四'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> son <span class="keyword">values</span>(<span class="number">33</span>, <span class="string">'王五五'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询分区数据信息</span></span><br><span class="line">SQL&gt; select * from father partition(p1);</span><br><span class="line"></span><br><span class="line">       FID FNAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------</span></span><br><span class="line">         2 李四</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from father partition(p2);</span><br><span class="line"></span><br><span class="line">       FID FNAME</span><br><span class="line"><span class="comment">---------- --------------------------------------------------</span></span><br><span class="line">         1 张三</span><br><span class="line">         3 王五</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from son partition(p1);</span><br><span class="line"></span><br><span class="line">       SID SNAME                                                     FID</span><br><span class="line"><span class="comment">---------- -------------------------------------------------- ----------</span></span><br><span class="line">        22 李四四                                                      2</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from son partition(p2);</span><br><span class="line"></span><br><span class="line">       SID SNAME                                                     FID</span><br><span class="line"><span class="comment">---------- -------------------------------------------------- ----------</span></span><br><span class="line">        11 张三三                                                      1</span><br><span class="line">        33 王五五                                                      3</span><br></pre></td></tr></table></figure><h3 id="3-2-间隔分区"><a href="#3-2-间隔分区" class="headerlink" title="3.2 间隔分区"></a>3.2 间隔分区</h3><h4 id="3-2-1-含义"><a href="#3-2-1-含义" class="headerlink" title="3.2.1 含义"></a>3.2.1 含义</h4><p>间隔分区可以完全自动地根据间隔阈值创建范围分区，它是范围分区的扩展 。间隔分区在数据仓库中有广泛的应用。</p><h4 id="3-2-2-示例"><a href="#3-2-2-示例" class="headerlink" title="3.2.2 示例"></a>3.2.2 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建间隔分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sale_detail (</span><br><span class="line">    sale_detail_id <span class="built_in">number</span>,</span><br><span class="line">    product_id <span class="built_in">number</span>,</span><br><span class="line">    quantity <span class="built_in">number</span>,</span><br><span class="line">    sale_date <span class="built_in">date</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(sale_date) <span class="comment">-- 对 sale_date 进行范围分区</span></span><br><span class="line"><span class="built_in">interval</span> (numtoyminterval(<span class="number">1</span>, <span class="string">'MONTH'</span>)) <span class="comment">-- 对范围分区进行扩展变为间隔分区，自定义扩展规则，即按月份每次扩展一个分区</span></span><br><span class="line">(</span><br><span class="line">    <span class="comment">-- 自定义的初始分区，所有小于 20200601 日期的记录都存在这个分区中</span></span><br><span class="line">    <span class="keyword">partition</span> p_201006 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="keyword">to_date</span>(<span class="string">'20200601'</span>, <span class="string">'yyyymmdd'</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询分区信息，此时可以发现只有一个初始自定义分区</span></span><br><span class="line">SQL&gt; select TABLE_NAME, PARTITION_NAME, HIGH_VALUE from user_tab_partitions where table_name = 'SALE_DETAIL';</span><br><span class="line"></span><br><span class="line">TABLE_NAME                     PARTITION_NAME                 HIGH_VALUE</span><br><span class="line"><span class="comment">------------------------------ ------------------------------ --------------------------------------------------------------------------------</span></span><br><span class="line">SALE_DETAIL                    P_201006                       TO_DATE(' 2020-06-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIA</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale_detail <span class="keyword">values</span> (<span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="keyword">to_date</span>(<span class="string">'20200501'</span>, <span class="string">'yyyymmdd'</span>)); <span class="comment">-- 此时只有 p_201006 分区</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale_detail <span class="keyword">values</span> (<span class="number">2</span>, <span class="number">22</span>, <span class="number">20</span>, <span class="keyword">to_date</span>(<span class="string">'20200711'</span>, <span class="string">'yyyymmdd'</span>)); <span class="comment">-- 此时 oracle 自动创建一个上界为 202007801 的分区</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale_detail <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">33</span>, <span class="number">30</span>, <span class="keyword">to_date</span>(<span class="string">'20200805'</span>, <span class="string">'yyyymmdd'</span>)); <span class="comment">-- 此时 oracle 自动创建一个上界为 202000901 的分区</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale_detail <span class="keyword">values</span> (<span class="number">3</span>, <span class="number">33</span>, <span class="number">30</span>, <span class="keyword">to_date</span>(<span class="string">'20200803'</span>, <span class="string">'yyyymmdd'</span>)); <span class="comment">-- 存储在上界为 202000901 的分区</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale_detail <span class="keyword">values</span> (<span class="number">4</span>, <span class="number">44</span>, <span class="number">40</span>, <span class="keyword">to_date</span>(<span class="string">'20201212'</span>, <span class="string">'yyyymmdd'</span>)); <span class="comment">-- 此时 oracle 自动创建一个上界为 20210101 的分区</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale_detail <span class="keyword">values</span> (<span class="number">5</span>, <span class="number">55</span>, <span class="number">50</span>, <span class="keyword">to_date</span>(<span class="string">'20200913'</span>, <span class="string">'yyyymmdd'</span>)); <span class="comment">-- 此时 oracle 自动创建一个上界为 202001001 的分区</span></span><br></pre></td></tr></table></figure><h3 id="3-3-虚拟列分区"><a href="#3-3-虚拟列分区" class="headerlink" title="3.3 虚拟列分区"></a>3.3 虚拟列分区</h3><h4 id="3-3-1-含义"><a href="#3-3-1-含义" class="headerlink" title="3.3.1 含义"></a>3.3.1 含义</h4><p>基于虚拟列的分区：把分区建立在某个虚拟列上，即建立在函数或表达式的计算结果上，来完成某种任务。</p><h4 id="3-3-2-示例"><a href="#3-3-2-示例" class="headerlink" title="3.3.2 示例"></a>3.3.2 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表，并定义虚拟列，根据虚拟列进行分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> sale(</span><br><span class="line">    sale_id <span class="built_in">number</span> primary <span class="keyword">key</span>,</span><br><span class="line">    product_id <span class="built_in">number</span>,</span><br><span class="line">    price <span class="built_in">number</span>,</span><br><span class="line">    quantity <span class="built_in">number</span>,</span><br><span class="line">    sale_date <span class="built_in">date</span>,</span><br><span class="line">    total_price <span class="keyword">as</span> (price * quantity) <span class="keyword">virtual</span> <span class="comment">-- 创建虚拟列</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(total_price)(</span><br><span class="line">    <span class="keyword">partition</span> p_1000 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">1000</span>),</span><br><span class="line">    <span class="keyword">partition</span> p_2000 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(<span class="number">2000</span>),</span><br><span class="line">    <span class="keyword">partition</span> p_max <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span>(maxvalue)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale(sale_id, product_id, price, quantity, sale_date) <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="keyword">sysdate</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> sale(sale_id, product_id, price, quantity, sale_date) <span class="keyword">values</span>(<span class="number">2</span>, <span class="number">22</span>, <span class="number">2000</span>, <span class="number">5</span>, <span class="keyword">sysdate</span>);</span><br></pre></td></tr></table></figure><h3 id="3-4-系统分区"><a href="#3-4-系统分区" class="headerlink" title="3.4 系统分区"></a>3.4 系统分区</h3><h4 id="3-4-1-含义"><a href="#3-4-1-含义" class="headerlink" title="3.4.1 含义"></a>3.4.1 含义</h4><p>系统分区不指定分区列，由ORACLE来完成分区的控制和管理，它没有了范围分区或列表分区的界限。</p><h4 id="3-4-2-示例"><a href="#3-4-2-示例" class="headerlink" title="3.4.2 示例"></a>3.4.2 示例</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建系统分区表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">number</span>,</span><br><span class="line">    <span class="keyword">name</span> varchar2(<span class="number">20</span>),</span><br><span class="line">    address varchar2(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">system</span> (</span><br><span class="line">    <span class="keyword">partition</span> p1, <span class="keyword">partition</span> p2, <span class="keyword">partition</span> p3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据时，需要指明插入的分区</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">partition</span>(p1) <span class="keyword">values</span> (<span class="number">1</span>, <span class="string">'张三'</span>, <span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">partition</span>(p2) <span class="keyword">values</span> (<span class="number">2</span>, <span class="string">'李四'</span>, <span class="string">'广州'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> person <span class="keyword">partition</span>(p3) <span class="keyword">values</span> (<span class="number">3</span>, <span class="string">'王五'</span>, <span class="string">'南宁'</span>);</span><br></pre></td></tr></table></figure><h2 id="4-维护分区"><a href="#4-维护分区" class="headerlink" title="4. 维护分区"></a>4. 维护分区</h2><h3 id="4-1-添加分区"><a href="#4-1-添加分区" class="headerlink" title="4.1 添加分区"></a>4.1 添加分区</h3><blockquote><p>在最后一个分区之后添加新分区</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向 sales 表添加一个 p4分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SALES <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> P4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">4000</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-删除分区"><a href="#4-2-删除分区" class="headerlink" title="4.2 删除分区"></a>4.2 删除分区</h3><blockquote><p>删除一个指定的分区，分区的数据也随之删除，不保留分区结构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 sales 表的 p4 分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SALES <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> P4;</span><br></pre></td></tr></table></figure><h3 id="4-3-截断分区"><a href="#4-3-截断分区" class="headerlink" title="4.3 截断分区"></a>4.3 截断分区</h3><blockquote><p>删除指定分区中的所有记录，保留分区结构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 截断 sales 表的 p3 分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SALES <span class="keyword">TRUNCATE</span> <span class="keyword">PARTITION</span> P3;</span><br></pre></td></tr></table></figure><h3 id="4-4-合并分区"><a href="#4-4-合并分区" class="headerlink" title="4.4 合并分区"></a>4.4 合并分区</h3><blockquote><p>将范围分区或复合分区的两个相邻分区连接起来</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将 sales 表的 s1、s2 分区合并为 s2 分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SALES <span class="keyword">MERGE</span> <span class="keyword">PARTITIONS</span> S1, S2 <span class="keyword">INTO</span> <span class="keyword">PARTITION</span> S2;</span><br></pre></td></tr></table></figure><h3 id="4-5-拆分分区"><a href="#4-5-拆分分区" class="headerlink" title="4.5 拆分分区"></a>4.5 拆分分区</h3><blockquote><p>将一个大分区中的记录拆分到两个分区中</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 已 1500 为临界将 sales 表的 p2 拆分为 p21 和 p22 两个分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> SALES <span class="keyword">SPLIT</span> <span class="keyword">PARTITION</span> P2 <span class="keyword">AT</span> (<span class="number">1500</span>) <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> P21, <span class="keyword">PARTITION</span> P22);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的表</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E8%A1%A8/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-高水位线"><a href="#1-高水位线" class="headerlink" title="1. 高水位线"></a>1. 高水位线</h2><p>高水位线（high-water mark，HWM）是一个很有趣的概念，但是也是一个非常重要的概念。顾名思义，高水位线有点类型于水文监测站里测水深度的标杆一样，当水涨的时候，水位线随之上升，并在标杆留下一个水印痕，这个水印痕就是高水位线。</p><p>在数据库中，上述比喻很恰当。如果把表想象成一个平面结构，或者想象成从左到右依次排开的一系列块，高水位线就是包含了数据的最右边的块。如下图所示：</p><p><img src="/2021/05/04/oracle-11g-的表/20201018111926511.png" alt="在这里插入图片描述"></p><a id="more"></a><p>当表刚创建时，HWM 位于表的第一个块中。过一段时间后，随着在这个表中放入数据，而且使用了越来越多的块，HWM会升高。但当我们删除了表中的一些（甚至全部）行，可能就会出现许多块不再包含数据，但仍然处于 HWM 之下，而且会一直保持在 HWM 之下。记住：HWM 永远不会下降，除非使用 rebuild、truncated 或 shrunk 这个对象（shrinking是 10g 的一个新特性，仅 ASSM即自动段存储管理支持）。</p><p><strong>HWM很重要，因为Oracle在全表 扫描时会扫描HWM之下的所有块，即使其中不包括任何数据。这会影响full scan的性能，特别是当HWM之下的绝大多数块都为空时。</strong></p><h2 id="2-PCTFREE"><a href="#2-PCTFREE" class="headerlink" title="2. PCTFREE"></a>2. PCTFREE</h2><p>为一个块保留的空间百分比，表示数据块在什么情况下可以被insert，默认是10，表示当数据块的可用空间低于10%后，就不可以被insert了，只能被用于update；即：</p><p>当使用一个block时，在达到pctfree之前，该block是一直可以被插入的，这个时候处在上升期。</p><p><strong>预留的空间主要是为了用户进行 update 操作而导致占存空间变大时，可以方便地使用这部分预留空间进行存储数据。</strong></p><p><img src="/2021/05/04/oracle-11g-的表/20201018111953903.png" alt></p><h2 id="3-PCTUSED"><a href="#3-PCTUSED" class="headerlink" title="3. PCTUSED"></a>3. PCTUSED</h2><p>PCTUSED 是指当块里的数据低于多少百分比时，又可以重新被 insert，一般默认是40，即40%，即：当数据低于 40% 时，又可以写入新的数据，这个时候处在下降期。</p><p><img src="/2021/05/04/oracle-11g-的表/20201018112016107.png" alt></p><p>假设你一个块可以存放100个数据，而且PCTFREE 是10， PCTUSED是40，则：不断的向块中插入数据，如果当存放到90个时，就不能存放新的数据，这是受pctfree来控制，预留的空间是给UPDATE用的。</p><p>当你删除一个数据后，再想插入个新数据行不行？不行，必须是删除41个，即低于40个以后才能插入新的数据的，这是受 pctused来控制的。</p><p> 注意：如果表空间上启用了ASSM，在建立表的时候，只能指定PCTFREE，否则可用指定PCTFREE和PCTUSED。</p><h2 id="4-普通表"><a href="#4-普通表" class="headerlink" title="4. 普通表"></a>4. 普通表</h2><h3 id="4-1-移动表"><a href="#4-1-移动表" class="headerlink" title="4.1 移动表"></a>4.1 移动表</h3><p>移动表move，从一个表空间移动到另一个表空间，可以清除表里的碎片。  优点是可以清除数据块中的碎片，降低HWM；缺点则是在 move 过程中，表上不能有应用。move之后，表上的索引需要重建。语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">move</span> [<span class="keyword">tablespace</span> 表空间名字];</span><br></pre></td></tr></table></figure><h3 id="4-2-收缩表"><a href="#4-2-收缩表" class="headerlink" title="4.2 收缩表"></a>4.2 收缩表</h3><p>收缩表shrink，将数据行从一个数据块移动到另一个数据块，分为2个阶段：收缩、降低HWM；在收缩阶段，可以对表进行DML操作，在降低HWM阶段，不能对表进行DML操</p><p>作。</p><p>前提：1. 表所在的表空间使用了ASSM（默认启用）； 表上启用了 row movement。</p><p>语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 启用 row movement</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">enable</span> <span class="keyword">row</span> <span class="keyword">movement</span></span><br><span class="line"><span class="comment">-- 收缩表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">shrink</span> <span class="keyword">space</span> [<span class="keyword">cascade</span>];</span><br></pre></td></tr></table></figure><h3 id="4-3-截断表"><a href="#4-3-截断表" class="headerlink" title="4.3 截断表"></a>4.3 截断表</h3><p>截断表truncate，将表中的记录全部删除，保留表的结构。释放表所占用的全部数据块，并把HWM调整到最低，而且<strong>不能回滚</strong>。</p><h3 id="4-4-删除表"><a href="#4-4-删除表" class="headerlink" title="4.4 删除表"></a>4.4 删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- purge 表示不存储到回收站</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名 [<span class="keyword">cascade</span> <span class="keyword">constraints</span>] [<span class="keyword">purge</span>];</span><br></pre></td></tr></table></figure><h3 id="4-5-删除列"><a href="#4-5-删除列" class="headerlink" title="4.5 删除列"></a>4.5 删除列</h3><p>当数据量比较大的时候，使用 drop columns 语句来删除列速度会比较慢。这个时候推荐使用如下语句来删除指定列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先失效掉指定列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">set</span> <span class="keyword">unused</span> <span class="keyword">column</span> 列名;</span><br><span class="line"><span class="comment">-- 删除无效的列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">unused</span> <span class="keyword">columns</span>;</span><br></pre></td></tr></table></figure><h2 id="5-索引组织表-IOT"><a href="#5-索引组织表-IOT" class="headerlink" title="5. 索引组织表 IOT"></a>5. 索引组织表 IOT</h2><pre><code>区别于普通表的无序组织方式，IOT(Index Organized Table)表必须有主键，是有序的表，其中的数据按照主键进行存储和排序。使用堆组织表（普通表）时，我们必须为表和表主键上的索引分别留出空间。而IOT不存在主键的空间开销，因为IOT的数据存储在与其关联的索引中，索引就是数据，数据就是索引，二者已经合二为一。IOT表中，表的数据存放在索引块中，所以如果通过主键索引访问表时，只需要读取一个块即可。而如果通过主键索引访问普通表，至少需要读取两个块，一个是索引块、一个是数据块。对于经常通过主键访问数据的表来说，适合使用IOT表。</code></pre><p>如下是索引表的创建示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表是使用 organization index 指定是 IOT 表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> iot_student(     </span><br><span class="line">    sno <span class="built_in">int</span>, </span><br><span class="line">    sname varchar2(<span class="number">100</span>),</span><br><span class="line">    sage <span class="built_in">int</span>,     <span class="keyword">constraint</span> pk_student primary <span class="keyword">key</span>(sno)</span><br><span class="line">) <span class="keyword">organization</span> <span class="keyword">index</span> </span><br><span class="line">[ <span class="keyword">pctthreshold</span>  <span class="number">30</span> <span class="keyword">overflow</span> <span class="keyword">tablespace</span> <span class="keyword">users</span> ];</span><br></pre></td></tr></table></figure><p>因为所有数据都放入索引，所以当表的数据量很大时，会降低索引组织表的查询性能。此时设置溢出段将主键和溢出数据分开来存储以提高效率。</p><p>说明： pctthreshold制定一个数据块的百分比，当行数据占用大小超出时，该行的其他列数据放入溢出段，即overflow指定存储空间中去， 所以pctthreshold是保留在索引块里的数据量占整个索引块的大小百分比，从0到50%。默认的 pctthreshold的值是50，即50%。</p><h2 id="6-簇表"><a href="#6-簇表" class="headerlink" title="6. 簇表"></a>6. 簇表</h2><p>两个相互关联的表的数据，同时放到一个簇数据块中，当以后进行关联读取时，只需要扫描一个数据块就可以了，极大的提高了效率。簇表分为索引簇表和哈希簇表两类。</p><p>索引簇表的创建步骤：</p><ol><li><p>建立簇段 cluster segment；</p></li><li><p>基于簇，创建两个相关表，每个表都关联到cluster segment上；</p></li><li><p>为簇创建索引。</p></li></ol><p>簇表创建示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建簇</span></span><br><span class="line"><span class="keyword">create</span> cluster scott.cluster1(code_key <span class="built_in">number</span>);</span><br><span class="line"><span class="comment">-- sno1 的类型与 cluster 簇的 code_key 对应</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.student (sno1 <span class="built_in">number</span>, sname  varchar2(<span class="number">10</span>)) cluster scott.cluster1(sno1);</span><br><span class="line"><span class="comment">-- sno2 的类型与 cluster 簇的 code_key 对应</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> scott.address (sno2 <span class="built_in">number</span>, zz varchar2(<span class="number">10</span>)) cluster scott.cluster1(sno2);</span><br><span class="line"><span class="comment">-- 为簇创建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index1 <span class="keyword">on</span> cluster scott.cluster1;</span><br></pre></td></tr></table></figure><h2 id="7-临时表"><a href="#7-临时表" class="headerlink" title="7. 临时表"></a>7. 临时表</h2><p>存放临时数据，可以使用临时表；<strong>临时表被每个session 单独使用，即：不同session看到的临时表中的数据可能不一样。</strong>如果在退出session时删除临时表中的<strong>数据</strong>，可以在创建临时表的时候使用on commit preserve rows；如果在用户commit或rollback时删除临时表中的数据，则可以使用on commit delete rows；</p><p>如下是创建临时表的示例语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">global</span> <span class="keyword">temporary</span> <span class="keyword">table</span> tmp_student(sno <span class="built_in">int</span>, sname varchar2(<span class="number">10</span>)) <span class="keyword">on</span> <span class="keyword">commit</span> <span class="keyword">preserve</span> <span class="keyword">rows</span>;</span><br></pre></td></tr></table></figure><p>如何理解临时表被每个 session 单独使用呢？假设现在使用开启 cmd 窗口登录 scott 账号创建一个临时表 tmp_student，然后再另起一个 cmd 窗口登录 scott 账号。显然这属于两个 session 会话。</p><p>虽然两个会话都可以访问到临时表 tmp_student，但是会话1向临时表插入的数据其他会话是无法访问到的。这就是临时表被每个 session 会话单独使用的意思。</p><p>从v$sort_usage中查看正在使用临时表空间的session信息和SQL语句的ID号，从v$sort_segment中查看临时表空间中的段的使用情况。临时表在临时表空间中保存。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看临时表信息</span></span><br><span class="line"><span class="comment">-- 表名，是否是临时表，on commit preserve rows 或 on commit delete rows 模式标识</span></span><br><span class="line"><span class="keyword">select</span> u.table_name, u.temporary, u.duration <span class="keyword">from</span> user_tables u <span class="keyword">where</span> u.table_name = <span class="string">'TMP_STUDENT'</span>;</span><br></pre></td></tr></table></figure><p>其中使用 on commit preserve rows 创建的临时表，duration 字段的值为 SYS$SESSION，否则是 SYS$TRANSACTION。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的完整性约束</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-完整性简介"><a href="#1-完整性简介" class="headerlink" title="1. 完整性简介"></a>1. 完整性简介</h2><p>定义：就是正确性、准确性，包含三种：实体完整性、参照完整性、用户自定义完整性。Oracle中主要通过约束、触发器、过程函数实现的。维护数据的完整性，有not null、unique、check、primary key、foreign key五种。not null 只能在列内定义，其他4种约束可以在列定义结束后，在表内定义。</p><p>需要说明的是：当使用 unique 唯一约束时，根据NULL的定义，NULL表示的是<strong>未知</strong>，因此<strong>两个NULL比较的结果既不相等，也不不等</strong>，<strong>结果仍然是未知</strong>。根据这个定义，多个NULL值的存在应该不违反唯一约束。</p><a id="more"></a><h2 id="2-约束示例"><a href="#2-约束示例" class="headerlink" title="2. 约束示例"></a>2. 约束示例</h2><ul><li>not null 非空</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> yg(bh <span class="built_in">number</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="literal">null</span>, xm varchar2(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><ul><li>unique 唯一（可以为空）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> yg1(bh <span class="built_in">number</span>(<span class="number">8</span>) <span class="keyword">unique</span>, xm varchar2(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><ul><li>check 自定义约束</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> yg2(bh <span class="built_in">number</span>(<span class="number">8</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">check</span>(bh &gt; <span class="number">0</span> <span class="keyword">and</span> bh &lt; <span class="number">1000</span>), xm varchar2(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><ul><li>primary key  主键（非空且唯一，自动创建索引）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> yg3(bh <span class="built_in">number</span>(<span class="number">8</span>) primary <span class="keyword">key</span>, xm varchar2(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><ul><li>default 外键（不插入时默认为指定值，插入 null 时不会显示默认值）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> yg4(bh <span class="built_in">number</span>(<span class="number">8</span>) primary <span class="keyword">key</span>, xm varchar2(<span class="number">20</span>), age <span class="built_in">number</span>(<span class="number">3</span>) <span class="keyword">default</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入示例如下：</span></span><br><span class="line">SQL&gt; insert into yg4(bh, xm) values(2, '李四');</span><br><span class="line">SQL&gt; select * from yg4;</span><br><span class="line"></span><br><span class="line">        BH XM                                              AGE</span><br><span class="line"><span class="comment">---------- ---------------------------------------- ----------</span></span><br><span class="line">         2 李四                                              1</span><br></pre></td></tr></table></figure><ul><li>foreign key 外键（外键只能取<strong>主键</strong>已经有的值）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如下创建表时，bh 字段引用自 yg3 表的 bh 字段</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> addr(bh <span class="built_in">number</span>(<span class="number">8</span>), zz varchar2(<span class="number">50</span>), <span class="keyword">foreign</span> <span class="keyword">key</span>(bh) <span class="keyword">references</span> yg3(bh));</span><br></pre></td></tr></table></figure><h2 id="3-查看约束"><a href="#3-查看约束" class="headerlink" title="3. 查看约束"></a>3. 查看约束</h2><p>用户的约束在user_constraints表、和user_cons_columns表中查看，如下所示：</p><p><img src="/2021/05/04/oracle-11g-的完整性约束/20201018111746746.png" alt></p><p>其中 constraint_name 表示约束名，由于我们创建约束的时候没有自定义名称，所以 oracle 自动进行命名。constraint_type 表示约束类型，其中 not null 和 check 属于 C 类型，foreign key 属于 R 类型，primary key 属于 P 类型，unique 属于 U 类型。</p><p>在 user_cons_columns 表中我们可以查看具体约束作用的字段，如下所示：</p><p><img src="/2021/05/04/oracle-11g-的完整性约束/20201018111758750.png" alt></p><h2 id="4-建立主键方式"><a href="#4-建立主键方式" class="headerlink" title="4. 建立主键方式"></a>4. 建立主键方式</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 默认系统名称</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">10</span>) primary <span class="keyword">key</span>);</span><br><span class="line"><span class="comment">-- 2. 自定义名称</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">10</span>) <span class="keyword">constraint</span> pk_id primary <span class="keyword">key</span>;</span><br><span class="line"><span class="comment">-- 3. 列外定义主键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">10</span>), primary <span class="keyword">key</span>(<span class="keyword">id</span>));</span><br><span class="line"><span class="comment">-- 4. 列外自定义名称定义主键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t4(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">10</span>), <span class="keyword">constraint</span> pk_id_ot primary <span class="keyword">key</span>(<span class="keyword">id</span>));</span><br><span class="line"><span class="comment">-- 5. 建表后定义主键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t5(<span class="keyword">id</span> <span class="built_in">number</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t5 <span class="keyword">add</span> <span class="keyword">constraint</span> pk_id_ot2 primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(deptNo <span class="built_in">number</span>(<span class="number">20</span>) primary <span class="keyword">key</span>, deptName varchar2(<span class="number">50</span>));</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> stuInfo(</span><br><span class="line">    sno <span class="built_in">number</span>(<span class="number">11</span>) primary <span class="keyword">key</span>, </span><br><span class="line">    sname varchar2(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span>, </span><br><span class="line">    sage <span class="built_in">number</span>(<span class="number">3</span>) <span class="keyword">check</span>(sage &gt;= <span class="number">18</span> <span class="keyword">and</span> sage &lt;= <span class="number">50</span>), </span><br><span class="line">    smale varchar2(<span class="number">4</span>)  <span class="keyword">default</span> <span class="string">'男'</span> <span class="keyword">check</span>(smale = <span class="string">'男'</span> <span class="keyword">or</span> smale = <span class="string">'女'</span>), </span><br><span class="line">    deptNo <span class="built_in">number</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">foreign</span> <span class="keyword">key</span>(deptNo) <span class="keyword">references</span> department(deptNo)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="5-给已有表添加约束"><a href="#5-给已有表添加约束" class="headerlink" title="5. 给已有表添加约束"></a>5. 给已有表添加约束</h2><p>除了添加 not null 需要使用 modify 命令，其他都是类似 alter table tablename add CONSTRAINTS 的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改编号列不可为空</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> yg1 <span class="keyword">modify</span> bh <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">-- 在姓名列添加唯一约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> yg1 <span class="keyword">add</span> <span class="keyword">constraints</span> xm_unique <span class="keyword">unique</span>(xm);</span><br><span class="line"><span class="comment">-- 在姓名列添加自定义约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> yg1 <span class="keyword">add</span> contraints xm_check <span class="keyword">check</span>(<span class="keyword">length</span>(xm) &gt; <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h2 id="6-删除约束"><a href="#6-删除约束" class="headerlink" title="6. 删除约束"></a>6. 删除约束</h2><p>语法如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除约束</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">constraint</span> 约束名;</span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure><p>如果删除主键约束时，发生了主键被引用的情况，可以通过如下语句进行删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> primary <span class="keyword">key</span> <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure><p>如果删除一个主键被引用的表，可以通过如下语句进行删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名 <span class="keyword">cascade</span> <span class="keyword">constraints</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的用户和权限管理</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用户"><a href="#1-用户" class="headerlink" title="1. 用户"></a>1. 用户</h1><h2 id="1-1-默认用户"><a href="#1-1-默认用户" class="headerlink" title="1.1 默认用户"></a>1.1 默认用户</h2><ul><li>SYS：数据库中所有数据字典表和视图都存储在 SYS 模式中。SYS 用户主要用来维护系统信息和管理实例；</li><li>SYSTEM：SYSTEM 是默认的系统管理员，该用户拥有 Oracle 管理工具使用的内部表和视图。<strong>通常通过 SYSTEM 用户管理数据库用户、权限和存储等</strong>；</li><li>SCOTT：SCOTT 用户是 Oracle 数据库的一个示范账户，在数据库安装时创建。</li></ul><a id="more"></a><h2 id="1-2-创建用户"><a href="#1-2-创建用户" class="headerlink" title="1.2 创建用户"></a>1.2 创建用户</h2><p>要连接到Oracle数据库，就需要创建一个用户帐户，每个用户都有一个默认表空间和一个临时表空间。CREATE USER命令用于创建新用户，语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建指定用户名和密码的用户</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> [username] <span class="keyword">identified</span> <span class="keyword">by</span> [<span class="keyword">password</span>];</span><br></pre></td></tr></table></figure><h2 id="1-3-profile-管理用户"><a href="#1-3-profile-管理用户" class="headerlink" title="1.3 profile 管理用户"></a>1.3 profile 管理用户</h2><p>profile 即为概要文件，每个用户都会属于一个概要文件。概要文件记录着当前用户会话存储空间大小、口令有效期等信息。当创建用户的时候，如果没有指定 <strong>profile</strong>，那么 Oracle 把名字叫 <strong>default</strong> 的 <strong>profile</strong> 赋予给用户。</p><h3 id="1-3-1-profile-创建"><a href="#1-3-1-profile-创建" class="headerlink" title="1.3.1 profile 创建"></a>1.3.1 profile 创建</h3><p>下面我们创建一个 profile，并对口令进行指定的限制。比如用户只能最多输入 3 次密码，超过限制则会锁定 2 天：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> profile [profile <span class="keyword">name</span>] <span class="keyword">limit</span> <span class="keyword">failed_login_attempts</span> <span class="number">3</span> <span class="keyword">password_lock_time</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>当然能够锁定，也就可以进行解锁，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> [username] <span class="keyword">account</span> <span class="keyword">unlock</span>;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-设置-profile"><a href="#1-3-2-设置-profile" class="headerlink" title="1.3.2 设置 profile"></a>1.3.2 设置 profile</h3><p>第一种方式是在创建用户的时候设置指定的 profile，可以通过如下语句指定 profile：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定 profile</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> [username] <span class="keyword">identified</span> <span class="keyword">by</span> [<span class="keyword">password</span>] profile [profile <span class="keyword">name</span>];</span><br></pre></td></tr></table></figure><p>第二种方式则修改用户的 profile，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> [username] profile [profile <span class="keyword">name</span>];</span><br></pre></td></tr></table></figure><h3 id="1-3-3-删除-profile"><a href="#1-3-3-删除-profile" class="headerlink" title="1.3.3 删除 profile"></a>1.3.3 删除 profile</h3><p>删除 profile 之后，用户的 profile 会变回名为 default 的 profile：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> profile [profile <span class="keyword">name</span>] <span class="keyword">cascade</span>;</span><br></pre></td></tr></table></figure><h2 id="1-4-更改和删除用户"><a href="#1-4-更改和删除用户" class="headerlink" title="1.4 更改和删除用户"></a>1.4 更改和删除用户</h2><ul><li>ALTER USER 命令可用于更改口令</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> [username] <span class="keyword">identified</span> <span class="keyword">by</span> [<span class="keyword">password</span>]</span><br></pre></td></tr></table></figure><ul><li>DROP USER 命令用于删除用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> [username]</span><br></pre></td></tr></table></figure><h1 id="2-权限"><a href="#2-权限" class="headerlink" title="2. 权限"></a>2. 权限</h1><p>权限指的是执行特定命令或访问数据库对象的权利。权限有两种类型，系统权限和对象权限。</p><ul><li><p>系统权限允许用户执行某些数据库操作，如创建表就是一个系统权限；</p></li><li><p>对象权限允许用户对数据库对象（如表、视图、序列等）执行特定操作。</p></li></ul><h2 id="2-1-系统权限"><a href="#2-1-系统权限" class="headerlink" title="2.1 系统权限"></a>2.1 系统权限</h2><h3 id="2-1-1-语法"><a href="#2-1-1-语法" class="headerlink" title="2.1.1 语法"></a>2.1.1 语法</h3><p><strong>授予权限语法如下</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> privilege [,privilege…]</span><br><span class="line"><span class="keyword">TO</span> <span class="keyword">user</span> [, <span class="keyword">user</span>|<span class="keyword">role</span>, <span class="keyword">PUBLIC</span>…] </span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">ADMIN</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><p>说明：包含了<strong>WITH ADMIN OPTION</strong>，只能是系统权限。</p><p><strong>收回权限语法如下(不支持级联收回)</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege [,privilege…]</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">user</span> [, <span class="keyword">user</span>|<span class="keyword">role</span>, <span class="keyword">PUBLIC</span>…]</span><br></pre></td></tr></table></figure><h3 id="2-1-2-示例"><a href="#2-1-2-示例" class="headerlink" title="2.1.2 示例"></a>2.1.2 示例</h3><p>常用示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 授予用户登录权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">session</span> <span class="keyword">to</span> [username];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 授予创建表的权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> [username];</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. 授予表空间内的所用权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">unlimited</span> <span class="keyword">tablespace</span> <span class="keyword">to</span> [username];</span><br></pre></td></tr></table></figure><h2 id="2-2-对象权限"><a href="#2-2-对象权限" class="headerlink" title="2.2 对象权限"></a>2.2 对象权限</h2><h3 id="2-2-1-语法"><a href="#2-2-1-语法" class="headerlink" title="2.2.1 语法"></a>2.2.1 语法</h3><p><strong>授予权限语法如下：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> object_privilege [<span class="keyword">columns</span>…]</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">object</span> <span class="keyword">TO</span> <span class="keyword">user</span> [,<span class="keyword">user</span>|<span class="keyword">role</span>, <span class="keyword">PUBLIC</span>…]</span><br><span class="line">[<span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>];</span><br></pre></td></tr></table></figure><p><strong>回收权限语法如下(支持级联收回)：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> privilege <span class="keyword">ON</span> <span class="keyword">object</span> <span class="keyword">FROM</span> <span class="keyword">user</span> [,<span class="keyword">user</span>|<span class="keyword">role</span>, <span class="keyword">PUBLIC</span>…]</span><br></pre></td></tr></table></figure><h3 id="2-2-2-示例"><a href="#2-2-2-示例" class="headerlink" title="2.2.2 示例"></a>2.2.2 示例</h3><p>常用示例如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 授予用户查询指定表的权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> [username];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予用户更新指定表的权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> [username];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予用户所有表操作权限</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> scott.emp <span class="keyword">to</span> [username];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授予精确到列上的权限</span></span><br><span class="line"><span class="comment">-- 允许用户更新 emp 表中的ename、sal列</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">update</span>(ename, sal) <span class="keyword">on</span> scott.emp <span class="keyword">to</span> [username]</span><br></pre></td></tr></table></figure><h1 id="3-角色"><a href="#3-角色" class="headerlink" title="3. 角色"></a>3. 角色</h1><p>角色是一组相关权限的组合，可以将权限授予角色，再把角色授予用户，以简化权限管理。</p><ul><li>创建角色，创建角色CREATE ROLE，应该具有CREATE ROLE系统权限：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">role</span> [<span class="keyword">role</span> <span class="keyword">name</span>]</span><br></pre></td></tr></table></figure><ul><li>授予角色权限，可以是系统权限或者对象权限：</li></ul><blockquote><p>GRANT privilege TO ROLE</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span> <span class="keyword">session</span>, <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">to</span> [rolename]</span><br></pre></td></tr></table></figure><ul><li>将角色授予用户：</li></ul><blockquote><p>GRANT role to USER</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> [rolename] <span class="keyword">to</span> [username]</span><br></pre></td></tr></table></figure><ul><li>从用户收回角色</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> [rolename] <span class="keyword">from</span> [username]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g 的复杂 SQL 语句</title>
      <link href="/2021/05/04/oracle-11g-%E7%9A%84%E5%A4%8D%E6%9D%82-SQL-%E8%AF%AD%E5%8F%A5/"/>
      <url>/2021/05/04/oracle-11g-%E7%9A%84%E5%A4%8D%E6%9D%82-SQL-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SQL-的执行顺序"><a href="#1-SQL-的执行顺序" class="headerlink" title="1. SQL 的执行顺序"></a>1. SQL 的执行顺序</h2><ul><li><p>常见的select、from、where的顺序：1, from 2, where 3, select</p></li><li><p>完整的select、from、where、group by、having、order by的顺序：1, from 2, where 3, group by 4,having 5, select 6, order by</p></li></ul><h2 id="2-EXISTS-的使用"><a href="#2-EXISTS-的使用" class="headerlink" title="2. EXISTS 的使用"></a>2. EXISTS 的使用</h2><p>EXISTS用来判断查询所得的结果中，是否有满足条件的纪录存在。存在返回 true， 否则返回 false。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *　<span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> * <span class="keyword">from</span> address <span class="keyword">where</span> zz=<span class="string">'郑州'</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="3-SELECT-CASE-WHEN的使用"><a href="#3-SELECT-CASE-WHEN的使用" class="headerlink" title="3. SELECT CASE WHEN的使用"></a>3. SELECT CASE WHEN的使用</h2><h3 id="3-1-语法1"><a href="#3-1-语法1" class="headerlink" title="3.1 语法1"></a>3.1 语法1</h3><p>如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE  </span><br><span class="line">    WHEN 条件1 THEN action1</span><br><span class="line">    WHEN 条件2 THEN action2</span><br><span class="line">    WHEN 条件3 THEN action3</span><br><span class="line">    ...</span><br><span class="line">    ELSE actionN</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">CASE</span>]</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>  <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span>  <span class="keyword">substr</span>(<span class="string">'20090310'</span>,<span class="number">5</span>,<span class="number">2</span>) = <span class="string">'01'</span>  <span class="keyword">then</span>  <span class="string">'一月份'</span></span><br><span class="line">        <span class="keyword">when</span>  <span class="keyword">substr</span>(<span class="string">'20090310'</span>,<span class="number">5</span>,<span class="number">2</span>) = <span class="string">'02'</span>  <span class="keyword">then</span>  <span class="string">'二月份'</span></span><br><span class="line">        <span class="keyword">when</span>  <span class="keyword">substr</span>(<span class="string">'20090310'</span>,<span class="number">5</span>,<span class="number">2</span>) = <span class="string">'03'</span>  <span class="keyword">then</span>  <span class="string">'三月份'</span></span><br><span class="line">        <span class="keyword">when</span>  <span class="keyword">substr</span>(<span class="string">'20090310'</span>,<span class="number">5</span>,<span class="number">2</span>) = <span class="string">'04'</span>  <span class="keyword">then</span>  <span class="string">'四月份'</span></span><br><span class="line">        <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">month</span></span><br><span class="line">  <span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">MONTH</span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line">三月份</span><br></pre></td></tr></table></figure><h3 id="3-2-语法2"><a href="#3-2-语法2" class="headerlink" title="3.2 语法2"></a>3.2 语法2</h3><p>如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CASE SELECTOR</span><br><span class="line">    WHEN value1 THEN action1</span><br><span class="line">    WHEN value2 THEN action2</span><br><span class="line">    WHEN value3 THEN action3</span><br><span class="line">    ...</span><br><span class="line">    ELSE actionN</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">CASE</span>]</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">case</span> <span class="keyword">substr</span>(<span class="string">'20200310'</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">when</span> <span class="string">'01'</span> <span class="keyword">then</span> <span class="string">'一月份'</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">'02'</span> <span class="keyword">then</span> <span class="string">'二月份'</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">'03'</span> <span class="keyword">then</span> <span class="string">'三月份'</span></span><br><span class="line">    <span class="keyword">when</span> <span class="string">'04'</span> <span class="keyword">then</span> <span class="string">'四月份'</span></span><br><span class="line">    <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">month</span></span><br><span class="line"><span class="keyword">from</span> dual;</span><br><span class="line"></span><br><span class="line">MONTH</span><br><span class="line"><span class="comment">------------------</span></span><br><span class="line">三月份</span><br></pre></td></tr></table></figure><h2 id="4-分析函数"><a href="#4-分析函数" class="headerlink" title="4. 分析函数"></a>4. 分析函数</h2><p>分析函数用于计算完成聚集的累计排名、序号等，分析函数为每组记录返回多个行。以下三个分析函数用于计算一个行在一组有序行中的排位，序号从1开始：</p><ul><li><p>ROW_NUMBER 返回连续的排序，不论值是否相等</p></li><li><p>RANK 具有相等值的行排序相同，序数随后跳跃</p></li><li><p>DENSE_RANK 具有相等值的行排序相同，序号是连续的</p></li></ul><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据源</span></span><br><span class="line">SQL&gt; select * from 成绩;</span><br><span class="line"></span><br><span class="line">       SNO KM                        SCORE</span><br><span class="line"><span class="comment">---------- -------------------- ----------</span></span><br><span class="line">         1 语文                         60</span><br><span class="line">         1 数学                         60</span><br><span class="line">         1 英语                         60</span><br><span class="line">         2 语文                         70</span><br><span class="line">         2 数学                         70</span><br><span class="line">         3 英语                         80</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ROW_NUMBER 的使用</span></span><br><span class="line">SQL&gt; select a.*, row_number() over(order by a.score) rang from 成绩 a;</span><br><span class="line"></span><br><span class="line">       SNO KM                        SCORE       RANG</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">         1 语文                         60          1</span><br><span class="line">         1 数学                         60          2</span><br><span class="line">         1 英语                         60          3</span><br><span class="line">         2 语文                         70          4</span><br><span class="line">         2 数学                         70          5</span><br><span class="line">         3 英语                         80          6</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先按学科分组，然后在按分数排序获取排序序号</span></span><br><span class="line">SQL&gt; select a.*, row_number() over(partition by km order by a.score) rang from 成绩 a;</span><br><span class="line">       SNO KM                        SCORE       RANG</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">        2数学701</span><br><span class="line">        1数学602</span><br><span class="line">        3英语801</span><br><span class="line">        1英语602</span><br><span class="line">        2语文701</span><br><span class="line">        1语文602</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- RANK 的使用</span></span><br><span class="line">SQL&gt; select a.*, rank() over(order by a.score) rang from 成绩 a;</span><br><span class="line"></span><br><span class="line">       SNO KM                        SCORE       RANG</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">         1 语文                         60          1</span><br><span class="line">         1 数学                         60          1</span><br><span class="line">         1 英语                         60          1</span><br><span class="line">         2 语文                         70          4</span><br><span class="line">         2 数学                         70          4</span><br><span class="line">         3 英语                         80          6</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DENSE_RANK</span></span><br><span class="line">SQL&gt; select a.*, dense_rank() over(order by a.score) rang from 成绩 a;</span><br><span class="line"></span><br><span class="line">       SNO KM                        SCORE       RANG</span><br><span class="line"><span class="comment">---------- -------------------- ---------- ----------</span></span><br><span class="line">         1 语文                         60          1</span><br><span class="line">         1 数学                         60          1</span><br><span class="line">         1 英语                         60          1</span><br><span class="line">         2 语文                         70          2</span><br><span class="line">         2 数学                         70          2</span><br><span class="line">         3 英语                         80          3</span><br></pre></td></tr></table></figure><h2 id="5-DECODE-的使用"><a href="#5-DECODE-的使用" class="headerlink" title="5. DECODE 的使用"></a>5. DECODE 的使用</h2><h3 id="5-1-语法"><a href="#5-1-语法" class="headerlink" title="5.1 语法"></a>5.1 语法</h3><p>在逻辑编程中，经常用到If – Then –Else 进行逻辑判断。在DECODE的语法中，实际上就是这样的逻辑处理过程。它的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECODE(value, if1, then1, if2,then2, if3,then3, . . . else )</span><br></pre></td></tr></table></figure><p>Value 代表某个表的任何类型的任意列或一个通过计算所得的任何结果。当每个value值被测试，如果value的值为if1，Decode 函数的结果是then1；如果value等于if2，Decode函数结果是then2；等等。事实上，可以给出多个if/then 配对。如果value结果不等于给出的任何配对时，Decode 结果就返回else 。需要注意的是，这里的if、then及else 都可以是函数或计算表达式。</p><h3 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h3><p>示例 1 ：实现 SEX 如果是 1 则显示 男，如果为 2 则显示 2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from student;</span><br><span class="line"></span><br><span class="line">        ID NAME                 SEX</span><br><span class="line"><span class="comment">---------- -------------------- --</span></span><br><span class="line">         1 张                   1</span><br><span class="line">         2 王                   2</span><br><span class="line">         3 李                   1</span><br><span class="line">        </span><br><span class="line"><span class="comment">--  decode 函数实现结果</span></span><br><span class="line">SQL&gt; Select name ,decode(sex, '1','男生', '2','女生')  sex from student;</span><br><span class="line"></span><br><span class="line">NAME                 SEX</span><br><span class="line"><span class="comment">-------------------- ------------</span></span><br><span class="line">张                   男生</span><br><span class="line">王                   女生</span><br><span class="line">李                   男生</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case when then 实现</span></span><br><span class="line">SQL&gt; select name,</span><br><span class="line">  2  case sex</span><br><span class="line">  3  when '1' then '男生'</span><br><span class="line">  4  when '2' then '女生'</span><br><span class="line">  5  <span class="keyword">end</span> sex</span><br><span class="line">  <span class="number">6</span>  <span class="keyword">from</span> student;</span><br><span class="line"></span><br><span class="line">NAME                 SEX</span><br><span class="line"><span class="comment">-------------------- ------------</span></span><br><span class="line">张                   男生</span><br><span class="line">王                   女生</span><br><span class="line">李                   男生</span><br></pre></td></tr></table></figure><h4 id="5-2-1-decode-实现行列转换"><a href="#5-2-1-decode-实现行列转换" class="headerlink" title="5.2.1 decode 实现行列转换"></a>5.2.1 decode 实现行列转换</h4><p>如下，由格式1转为格式2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 格式1</span></span><br><span class="line">商品名称   季度        销售额</span><br><span class="line"><span class="comment">---------- ---- ----------</span></span><br><span class="line">电视机     01          100</span><br><span class="line">电视机     02          200</span><br><span class="line">电视机     03          300</span><br><span class="line">空调       01           50</span><br><span class="line">空调       02          150</span><br><span class="line">空调       03          180</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 格式2</span></span><br><span class="line">商品名称          一季度        二季度        三季度        四季度</span><br><span class="line"><span class="comment">---------- ---------- ---------- ---------- ----------</span></span><br><span class="line">电视机            100        200        300          0</span><br><span class="line">空调               50        150        180          0</span><br></pre></td></tr></table></figure><p>实现方法如下（善用聚合函数）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">商品名称,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(季度, <span class="string">'01'</span>, 销售额, <span class="string">'0'</span>)) 一季度,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(季度, <span class="string">'02'</span>, 销售额, <span class="string">'0'</span>)) 二季度,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(季度, <span class="string">'03'</span>, 销售额, <span class="string">'0'</span>)) 三季度,</span><br><span class="line"><span class="keyword">sum</span>(<span class="keyword">decode</span>(季度, <span class="string">'04'</span>, 销售额, <span class="string">'0'</span>)) 四季度</span><br><span class="line"><span class="keyword">from</span> 销售</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 商品名称;</span><br></pre></td></tr></table></figure><h2 id="6-ROWNUM-的使用"><a href="#6-ROWNUM-的使用" class="headerlink" title="6. ROWNUM 的使用"></a>6. ROWNUM 的使用</h2><blockquote><p>常用于分页，作用是对查询结果，输出前若干条记录。</p></blockquote><p>注意：只能与&lt;、&lt;=、between and 连用</p><h3 id="6-1-示例"><a href="#6-1-示例" class="headerlink" title="6.1 示例"></a>6.1 示例</h3><h4 id="6-1-1-分页示例"><a href="#6-1-1-分页示例" class="headerlink" title="6.1.1 分页示例"></a>6.1.1 分页示例</h4><p>数据源表如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from yggz;</span><br><span class="line"></span><br><span class="line">        BH         GZ</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">         1       1000</span><br><span class="line">         2       1100</span><br><span class="line">         3        900</span><br><span class="line">         4       2000</span><br><span class="line">         5       1500</span><br><span class="line">         6       3000</span><br><span class="line">         7       1400</span><br><span class="line">         8       1200</span><br></pre></td></tr></table></figure><p>需要实现的查出该表中第3行到第5行的数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为了实现 &gt; 的效果，不能直接使用 rownum 字段，所以需要取别名</span></span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> yggz.*, <span class="keyword">rownum</span> rn</span><br><span class="line"><span class="keyword">from</span> yggz ) a</span><br><span class="line"><span class="keyword">where</span> a.rn &gt;= <span class="number">3</span> <span class="keyword">and</span> a.rn &lt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="7-GROUP-BY-GROUPING-SETS-的使用"><a href="#7-GROUP-BY-GROUPING-SETS-的使用" class="headerlink" title="7. GROUP BY GROUPING SETS 的使用"></a>7. GROUP BY GROUPING SETS 的使用</h2><h3 id="7-1-语法"><a href="#7-1-语法" class="headerlink" title="7.1 语法"></a>7.1 语法</h3><p>可以用 GROUP BY GROUPING SETS 来进行<strong>分组自定义汇总</strong>，可以应用它来指定你需要的总数组合。==使用GROUPING SETS 的 GROUP BY 子句可以生成一个等效于由多个简单 GROUP BY 子句的 UNION ALL 生成的结果集。==</p><p>其格式为： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY GROUPING SETS ((list1), (list2) ... )</span><br><span class="line"><span class="comment">-- 相当于</span></span><br><span class="line">group by list1</span><br><span class="line">union all</span><br><span class="line">group by list2</span><br><span class="line">union all</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里（list）是圆括号中的一个列序列，这个组合生成一个总数。要增加一个总和，必须增加一个(NULL)分组集。 </p><h3 id="7-2-示例"><a href="#7-2-示例" class="headerlink" title="7.2 示例"></a>7.2 示例</h3><p>对于scott.emp表，如果要查询：各部门sal大于2000的员工，进行汇总，得到各部门的sal总和、以及总共的sal总和。实现如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">case</span> <span class="keyword">when</span> </span><br><span class="line">a.deptno <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">then</span> <span class="string">'合计'</span></span><br><span class="line"><span class="keyword">WHEN</span> a.deptno <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> a.empno <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="string">'小计'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">''</span> || a.deptno</span><br><span class="line"><span class="keyword">END</span> deptno,</span><br><span class="line">a.empno,</span><br><span class="line">a.ename,</span><br><span class="line"><span class="keyword">SUM</span>(a.sal) total_sal</span><br><span class="line"><span class="keyword">from</span> scott.emp a</span><br><span class="line"><span class="keyword">WHERE</span> a.sal &gt; <span class="number">2000</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">grouping</span> <span class="keyword">sets</span>((a.deptno), (a.deptno, a.empno, a.ename), ());</span><br><span class="line"></span><br><span class="line">DEPTNO                                                                                EMPNO ENAME                 TOTAL_SAL</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------- ---------- -------------------- ----------</span></span><br><span class="line">10                                                                                     7782 CLARK                      2450</span><br><span class="line">10                                                                                     7839 KING                       5000</span><br><span class="line">小计                                                                                                                   7450</span><br><span class="line">20                                                                                     7566 JONES                      2975</span><br><span class="line">20                                                                                     7788 SCOTT                      3000</span><br><span class="line">20                                                                                     7902 FORD                       3000</span><br><span class="line">小计                                                                                                                   8975</span><br><span class="line">30                                                                                     7698 BLAKE                      2850</span><br><span class="line">小计                                                                                                                   2850</span><br><span class="line">合计                                                                                                                  19275</span><br></pre></td></tr></table></figure><h2 id="8-ROLLUP-的使用"><a href="#8-ROLLUP-的使用" class="headerlink" title="8. ROLLUP 的使用"></a>8. ROLLUP 的使用</h2><p>ROLLUP 函数可以同时实现 GROUP BY 与 UNION ALL 两者累加的效果，效果同 group by grouping sets 方法。</p><p>比如进行 <code>group by rollup(A, B, C)</code> 操作时，相当于进行了 <code>group by (A, B, C)</code>，<code>group by (A, B)</code>，<code>group by A</code> 和<code>获取全表合计</code>四步操作。</p><p>下面我们将与普通 group by  语句进行对比说明。首先如下是数据源信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from scott.emp;</span><br><span class="line"></span><br><span class="line">     EMPNO ENAME                JOB                       MGR HIREDATE              SAL       COMM     DEPTNO</span><br><span class="line"><span class="comment">---------- -------------------- ------------------ ---------- -------------- ---------- ---------- ----------</span></span><br><span class="line">      7369 SMITH                CLERK                    7902 17-12月-80            800                    20</span><br><span class="line">      7499 ALLEN                SALESMAN                 7698 20-2月 -81           1600        300         30</span><br><span class="line">      7521 WARD                 SALESMAN                 7698 22-2月 -81           1250        500         30</span><br><span class="line">      7566 JONES                MANAGER                  7839 02-4月 -81           2975                    20</span><br><span class="line">      7654 MARTIN               SALESMAN                 7698 28-9月 -81           1250       1400         30</span><br><span class="line">      7698 BLAKE                MANAGER                  7839 01-5月 -81           2850                    30</span><br><span class="line">      7782 CLARK                MANAGER                  7839 09-6月 -81           2450                    10</span><br><span class="line">      7788 SCOTT                ANALYST                  7566 19-4月 -87           3000                    20</span><br><span class="line">      7839 KING                 PRESIDENT                     17-11月-81           5000                    10</span><br><span class="line">      7844 TURNER               SALESMAN                 7698 08-9月 -81           1500          0         30</span><br><span class="line">      7876 ADAMS                CLERK                    7788 23-5月 -87           1100                    20</span><br><span class="line">      7900 JAMES                CLERK                    7698 03-12月-81            950                    30</span><br><span class="line">      7902 FORD                 ANALYST                  7566 03-12月-81           3000                    20</span><br><span class="line">      7934 MILLER               CLERK                    7782 23-1月 -82           1300                    10</span><br></pre></td></tr></table></figure><p><strong>1. 首先对 emp 进行普通的 group by 分组操作：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select deptno, sum(sal) from scott.emp group by deptno;</span><br><span class="line"></span><br><span class="line">    DEPTNO   SUM(SAL)</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">        30       9400</span><br><span class="line">        20      10875</span><br><span class="line">        10       8750</span><br></pre></td></tr></table></figure><p><strong>2. 接着使用 rollup 操作，可以同时求出合计值：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select deptno, sum(sal) from scott.emp group by rollup(deptno);</span><br><span class="line"></span><br><span class="line">    DEPTNO   SUM(SAL)</span><br><span class="line"><span class="comment">---------- ----------</span></span><br><span class="line">        10       8750</span><br><span class="line">        20      10875</span><br><span class="line">        30       9400</span><br><span class="line">                29025</span><br></pre></td></tr></table></figure><p>上述实现效果同如下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, <span class="keyword">sum</span>(sal) <span class="keyword">from</span> scott.emp <span class="keyword">group</span> <span class="keyword">by</span> deptno</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="literal">null</span>, <span class="keyword">sum</span>(sal) <span class="keyword">from</span> scott.emp;</span><br></pre></td></tr></table></figure><p><strong>3. 下面再看一下 rollup 两列的情况：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select  deptno, empno, sum(sal) from scott.emp group by rollup(deptno, empno);</span><br><span class="line"></span><br><span class="line">    DEPTNO      EMPNO   SUM(SAL)</span><br><span class="line"><span class="comment">---------- ---------- ----------</span></span><br><span class="line">        10       7782       2450</span><br><span class="line">        10       7839       5000</span><br><span class="line">        10       7934       1300</span><br><span class="line">        10                  8750</span><br><span class="line">        20       7369        800</span><br><span class="line">        20       7566       2975</span><br><span class="line">        20       7788       3000</span><br><span class="line">        20       7876       1100</span><br><span class="line">        20       7902       3000</span><br><span class="line">        20                 10875</span><br><span class="line">        30       7900        950</span><br><span class="line">        30       7499       1600</span><br><span class="line">        30       7521       1250</span><br><span class="line">        30       7654       1250</span><br><span class="line">        30       7698       2850</span><br><span class="line">        30       7844       1500</span><br><span class="line">        30                  9400</span><br><span class="line">                           29025</span><br></pre></td></tr></table></figure><p>可以发现除了统计出了所有部门的合计，还统计除了各个部门的小计。效果是不是和 group by grouping sets 很相像呢。我们可以用一般的 group by 实现上述的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">sum</span>(sal) <span class="keyword">from</span> scott.emp <span class="comment">-- 合计</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> deptno, <span class="literal">null</span>, <span class="keyword">sum</span>(sal) <span class="keyword">from</span> scott.emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="comment">-- 小计</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> deptno, empno, <span class="keyword">sum</span>(sal) <span class="keyword">from</span> scott.emp <span class="keyword">group</span> <span class="keyword">by</span> deptno, empno <span class="comment">-- 员工</span></span><br></pre></td></tr></table></figure><h2 id="9-GROUPING-的使用"><a href="#9-GROUPING-的使用" class="headerlink" title="9. GROUPING 的使用"></a>9. GROUPING 的使用</h2><p>介绍完 rollup 函数，就不得不说 grouping 函数了。grouping 函数一般是与 rollup 进行搭配使用的。废话不多说，直接看效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptno, empno, <span class="keyword">grouping</span>(deptno), <span class="keyword">grouping</span>(empno), <span class="keyword">sum</span>(sal)</span><br><span class="line"><span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>(deptno, empno);</span><br><span class="line"></span><br><span class="line">    DEPTNO      EMPNO GROUPING(DEPTNO) GROUPING(EMPNO)   SUM(SAL)</span><br><span class="line"><span class="comment">---------- ---------- ---------------- --------------- ----------</span></span><br><span class="line">        10       7782                0               0       2450</span><br><span class="line">        10       7839                0               0       5000</span><br><span class="line">        10       7934                0               0       1300</span><br><span class="line">        10                           0               1       8750</span><br><span class="line">        20       7369                0               0        800</span><br><span class="line">        20       7566                0               0       2975</span><br><span class="line">        20       7788                0               0       3000</span><br><span class="line">        20       7876                0               0       1100</span><br><span class="line">        20       7902                0               0       3000</span><br><span class="line">        20                           0               1      10875</span><br><span class="line">        30       7900                0               0        950</span><br><span class="line">        30       7499                0               0       1600</span><br><span class="line">        30       7521                0               0       1250</span><br><span class="line">        30       7654                0               0       1250</span><br><span class="line">        30       7698                0               0       2850</span><br><span class="line">        30       7844                0               0       1500</span><br><span class="line">        30                           0               1       9400</span><br><span class="line">                                     1               1      29025</span><br></pre></td></tr></table></figure><p>可以发现原本使用 <code>select  deptno, empno, sum(sal) from scott.emp group by rollup(deptno, empno);</code>查询出来的有值的列，在使用了 grouping 函数之后则会返回0，否则就返回 1。</p><p>换个说法即是：如果显示“1”表示GROUPING函数对应的列（例如empno字段）是由于ROLLUP函数所产生的空值对应的信息，即对此列进行汇总计算后的结果。如果显示“0”表示此行对应的这列参未与ROLLUP函数分组汇总活动。</p><h2 id="10-CUBE-的使用"><a href="#10-CUBE-的使用" class="headerlink" title="10. CUBE 的使用"></a>10. CUBE 的使用</h2><p>假设使用 <code>group by cube(A,B,C)</code>，首先会对 <code>(A,B,C)</code> 进行 group by ，然后对 <code>(A, B)</code>，<code>(A, C)</code> 和 <code>A</code>进行 group by ，然后对 <code>(B, C)</code> 和 <code>B</code> 进行 group by ，然后再对 <code>C</code> 进行 group by。最后对全表进行 group by 操作。可以看出 cube 会列出所有可能的分组。</p><p>假设现在有表 t_fruit 有如下原始数据：</p><p><img src="/2021/05/04/oracle-11g-的复杂-SQL-语句/image-20210919235102048.png" alt></p><p>如下 SQL 使用 cube 函数来统计对应数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">grouping</span>(fruit_name) + <span class="keyword">grouping</span>(fruit_type) = <span class="number">2</span> <span class="keyword">THEN</span>   <span class="string">'合计'</span></span><br><span class="line">            <span class="keyword">WHEN</span> <span class="keyword">grouping</span>(fruit_name) = <span class="number">1</span> <span class="keyword">THEN</span>    <span class="string">'小计'</span></span><br><span class="line">            <span class="keyword">ELSE</span> to_char(fruit_name)</span><br><span class="line">            <span class="keyword">END</span> fruit_name,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">grouping</span>(fruit_name) + <span class="keyword">grouping</span>(fruit_type) = <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'合计'</span></span><br><span class="line">             <span class="keyword">WHEN</span> <span class="keyword">grouping</span>(fruit_type) = <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'小计'</span></span><br><span class="line">             <span class="keyword">ELSE</span> to_char(fruit_type)</span><br><span class="line">             <span class="keyword">END</span> fruit_type,</span><br><span class="line">        <span class="keyword">sum</span>(fruit_stock) fruit_stock    </span><br><span class="line"><span class="keyword">FROM</span> t_fruit</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">cube</span> ( fruit_type, fruit_name)</span><br></pre></td></tr></table></figure><p>查询结果如下图所示，可以发现 <code>GROUP BY cube ( fruit_type, fruit_name)</code> 可以分为四步操作得到的结果值，分别是 <code>group by fruit_type, fruit_name</code>，<code>group by fruit_name</code>，<code>group by fruit_type</code> 和全表统计。</p><p><img src="/2021/05/04/oracle-11g-的复杂-SQL-语句/image-20210919235800557.png" alt></p><p>因此可以拆分为如下四条 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'合计'</span> fruit_name, <span class="string">'合计'</span> fruit_type,<span class="keyword">sum</span>(fruit_stock) fruit_stock <span class="keyword">from</span> t_fruit</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> to_char(fruit_name) fruit_name, <span class="string">'小计'</span> fruit_type,  <span class="keyword">sum</span>(fruit_stock) fruit_stock <span class="keyword">from</span> t_fruit <span class="keyword">group</span> <span class="keyword">by</span> fruit_name</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">'小计'</span> fruit_name, to_char(fruit_type) fruit_type, <span class="keyword">sum</span>(fruit_stock) fruit_stock <span class="keyword">from</span> t_fruit <span class="keyword">group</span> <span class="keyword">by</span> fruit_type</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> to_char(fruit_name) fruit_name, to_char(fruit_type) fruit_type, <span class="keyword">sum</span>(fruit_stock) fruit_stock <span class="keyword">from</span> t_fruit <span class="keyword">group</span> <span class="keyword">by</span> fruit_type,fruit_name</span><br></pre></td></tr></table></figure><h2 id="11-GROUPING-ID-的使用"><a href="#11-GROUPING-ID-的使用" class="headerlink" title="11. GROUPING_ID 的使用"></a>11. GROUPING_ID 的使用</h2><p>可以使用GROUPING_ID函数借助HAVING子句对记录进行过滤，<strong>将不包含小计或者总计的记录除去</strong>。GROUPING_ID()函数可以接受一列或多列，<strong>返回GROUPING 位向量的十进制值</strong>。GROUPING位向量的计算方法是将按照顺序对每一列调用GROUPING 函数的结果组合起来。</p><p><strong>1. 首先看一下 grouping_id 的使用示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在上述 grouping 的基础上添加 having 过滤条件，即过滤掉合计和小计，结果如下所示</span></span><br><span class="line"><span class="keyword">select</span> deptno, empno, <span class="keyword">grouping</span>(deptno), <span class="keyword">grouping</span>(empno), <span class="keyword">sum</span>(sal)</span><br><span class="line"><span class="keyword">from</span> scott.emp</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">rollup</span>(deptno, empno)</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">grouping_id</span>(empno) &lt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    DEPTNO      EMPNO <span class="keyword">GROUPING</span>(DEPTNO) <span class="keyword">GROUPING</span>(EMPNO)   <span class="keyword">SUM</span>(SAL)</span><br><span class="line"><span class="comment">---------- ---------- ---------------- --------------- ----------</span></span><br><span class="line">        <span class="number">10</span>       <span class="number">7782</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">2450</span></span><br><span class="line">        <span class="number">10</span>       <span class="number">7839</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">5000</span></span><br><span class="line">        <span class="number">10</span>       <span class="number">7934</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">1300</span></span><br><span class="line">        <span class="number">20</span>       <span class="number">7369</span>                <span class="number">0</span>               <span class="number">0</span>        <span class="number">800</span></span><br><span class="line">        <span class="number">20</span>       <span class="number">7566</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">2975</span></span><br><span class="line">        <span class="number">20</span>       <span class="number">7788</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">3000</span></span><br><span class="line">        <span class="number">20</span>       <span class="number">7876</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">1100</span></span><br><span class="line">        <span class="number">20</span>       <span class="number">7902</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">3000</span></span><br><span class="line">        <span class="number">30</span>       <span class="number">7900</span>                <span class="number">0</span>               <span class="number">0</span>        <span class="number">950</span></span><br><span class="line">        <span class="number">30</span>       <span class="number">7499</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">1600</span></span><br><span class="line">        <span class="number">30</span>       <span class="number">7521</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">1250</span></span><br><span class="line">        <span class="number">30</span>       <span class="number">7654</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">1250</span></span><br><span class="line">        <span class="number">30</span>       <span class="number">7698</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">2850</span></span><br><span class="line">        <span class="number">30</span>       <span class="number">7844</span>                <span class="number">0</span>               <span class="number">0</span>       <span class="number">1500</span></span><br></pre></td></tr></table></figure><p><strong>2. GOURPING位向量计算规则如下所示：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">非空 非空 0 0 0</span><br><span class="line"></span><br><span class="line">非空 空   0 1 1</span><br><span class="line"></span><br><span class="line">空   非空 1 0 2</span><br><span class="line"></span><br><span class="line">空   空   1 1 3</span><br></pre></td></tr></table></figure><p>说明一下，在 group by 或者 rollup 之后， 如果该列的值为空，那么 grouping_id(col) 的值为0，否则就为 1。这点同 grouping 函数是同样的效果的。而 grouping_id(col1, col2) 的值则遵循上述的位向量计算规则。即 grouping(col1) 的值为0，grouping(col2) 的值 1，那么 grouping(col1, col2) 的值即为1。其他同理。</p><h2 id="12-WITH-AS-语句"><a href="#12-WITH-AS-语句" class="headerlink" title="12. WITH AS 语句"></a>12. WITH AS 语句</h2><p>with as 的语法如下，其相当创建了一个临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 临时数据集名称 <span class="keyword">as</span> (<span class="keyword">select</span> ....)</span><br><span class="line"><span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure><p>当执行 sql 查询时需要对有规律的一批数据进行分析处理而又不想将这批数据存入实体表时，我们可以使用with关键字临时构建一个虚拟的数据集，以便对其进行与实体表相似的 sql 操作，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建 student 表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line">  sno <span class="built_in">number</span>(<span class="number">8</span>) primary <span class="keyword">key</span>,</span><br><span class="line">  sname varchar2(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">120</span>, <span class="string">'aa'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1630</span>, <span class="string">'bb'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1200</span>, <span class="string">'cc'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">999</span>, <span class="string">'dd'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 with as 语句，建立了一个名为 tab1 的临时数据集</span></span><br><span class="line"><span class="keyword">with</span> tab1 <span class="keyword">as</span> (</span><br><span class="line">     <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno &gt; <span class="number">1000</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tab1;</span><br></pre></td></tr></table></figure><p>上述的 with as 语句的执行结果如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; with tab1 as(</span><br><span class="line">  2       <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> sno &gt; <span class="number">1000</span></span><br><span class="line">  <span class="number">3</span>  )</span><br><span class="line">  <span class="number">4</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tab1;</span><br><span class="line"></span><br><span class="line">      SNO SNAME</span><br><span class="line"><span class="comment">--------- --------------------------------------------------</span></span><br><span class="line">     1630 bb</span><br><span class="line">     1200 cc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oracle 11g SQL 语句和函数</title>
      <link href="/2021/05/04/oracle-11g-SQL-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/2021/05/04/oracle-11g-SQL-%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SQL-简介"><a href="#1-SQL-简介" class="headerlink" title="1. SQL 简介"></a>1. SQL 简介</h2><p>SQL 支持下列类别的命令：</p><ul><li><p>数据定义语言（DDL）：create, alter, drop</p></li><li><p>数据操纵语言（DML）：insert,  delete,  update,  select</p></li><li><p>事务控制语言（TCL）: commit, rollback, savepoint</p></li><li><p>数据控制语言（DCL）: grant, revoke</p></li></ul><a id="more"></a><h2 id="2-Oracle-数据类型"><a href="#2-Oracle-数据类型" class="headerlink" title="2. Oracle 数据类型"></a>2. Oracle 数据类型</h2><p>如下是 Oracle 数据类型的类别：<br><img src="/2021/05/04/oracle-11g-SQL-语句和函数/20201018111204417.png" alt></p><h3 id="2-1-字符数据类型"><a href="#2-1-字符数据类型" class="headerlink" title="2.1 字符数据类型"></a>2.1 字符数据类型</h3><p>常用的字符类型有 CHAR，BARCHAR2 和 LONG 类型：</p><h4 id="2-1-1-CHAR-类型"><a href="#2-1-1-CHAR-类型" class="headerlink" title="2.1.1 CHAR 类型"></a>2.1.1 CHAR 类型</h4><ul><li>当需要固定长度的字符串时，使用 CHAR 数据类型</li><li>CHAR 数据类型存储字母数字值</li><li>CHAR 数据类型的列长度可以是 1 到 2000 个字节</li><li>oracle 同样支持 NCHAR 类型</li></ul><h4 id="2-1-2-VARCHAR2-类型"><a href="#2-1-2-VARCHAR2-类型" class="headerlink" title="2.1.2 VARCHAR2 类型"></a>2.1.2 VARCHAR2 类型</h4><ul><li>VARCHAR2 数据类型支持<strong>可变长度字符串</strong></li><li>VARCHAR2 数据类型存储字母数字值</li><li>VARCHAR2 数据类型的大小在 1 至 4000 个字节范围内</li><li>Oracle 同样支持 VARCHAR 类型，不过并<strong>不推荐使用</strong></li></ul><h4 id="2-1-3-LONG-类型"><a href="#2-1-3-LONG-类型" class="headerlink" title="2.1.3 LONG 类型"></a>2.1.3 LONG 类型</h4><ul><li>LONG 数据类型存储可变长度字符数据</li><li>LONG 数据类型最多能存储 2GB</li></ul><h3 id="2-2-数值数据类型"><a href="#2-2-数值数据类型" class="headerlink" title="2.2 数值数据类型"></a>2.2 数值数据类型</h3><p>数值数据类型可以存储整数、浮点数和实数。最高精度则是 38 位，范围：负的 10<sup>-38</sup> 到 10<sup>38</sup> 之间。</p><p>数值数据类型的声明语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NUMBER[(p[,s])] <span class="comment">-- P 表示精度， S 表示小数点的位数</span></span><br></pre></td></tr></table></figure><ul><li><input checked disabled type="checkbox"> 示例1：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create table t2(sid number(3, 2));</span><br><span class="line"></span><br><span class="line">SQL&gt; insert into t2 values(123.22);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">123.22</span>)</span><br><span class="line">                      *</span><br><span class="line">第 <span class="number">1</span> 行出现错误:</span><br><span class="line">ORA<span class="number">-01438</span>: 值大于为此列指定的允许精度</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1.22</span>);</span><br><span class="line"></span><br><span class="line">已创建 1 行。</span><br></pre></td></tr></table></figure><p>由上述示例可以说明，P 并非表示小数点前面的位数，而是表示总体数值的位数，也就是精度。</p><ul><li><input checked disabled type="checkbox"> 示例2：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; insert into t2 values(1.569);</span><br><span class="line"></span><br><span class="line">已创建 1 行。</span><br><span class="line"></span><br><span class="line">SQL&gt; select * from t2;</span><br><span class="line"></span><br><span class="line">       SID</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">      1.22</span><br><span class="line">      1.57</span><br></pre></td></tr></table></figure><p>还是使用示例1创建的表，这里我们插入数 1.569，可以发现 Oracle 会自动进行四舍五入的操作。</p><p>需要说明的是，如果没有设置小数点的位数，此时只能插入整数。若插入了浮点数，则会进行四舍五入并进行截断处理。</p><h3 id="2-3-日期数据类型"><a href="#2-3-日期数据类型" class="headerlink" title="2.3 日期数据类型"></a>2.3 日期数据类型</h3><p>日期时间数据类型存储日期和时间值，包括年、月、日，小时、分钟和秒。主要的日期类型有：</p><ul><li>DATE：存储日期和时间部分，精确到整个的秒</li><li>TIMESTAMP：存储日期、时间和时区信息，秒值精确到小数段后 6 位。</li></ul><p>示例如下（24小时制时间输出）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select to_char( sysdate, 'yyyy-mm-dd hh24:mi:ss' ) from dual;</span><br><span class="line"></span><br><span class="line">TO_CHAR(SYSDATE,'YYYY-MM-DDHH24:MI:SS'</span><br><span class="line"><span class="comment">--------------------------------------</span></span><br><span class="line">2020-09-22 22:26:46</span><br><span class="line">        </span><br><span class="line">SQL&gt; select to_char( systimestamp, 'yyyy-mm-dd hh24:mi:ssxff6' ) from dual;</span><br><span class="line"></span><br><span class="line">TO_CHAR(SYSTIMESTAMP,'YYYY-MM-DDHH24:MI:SSXFF6')</span><br><span class="line"><span class="comment">----------------------------------------------------------</span></span><br><span class="line">2020-09-22 22:27:48.818000</span><br></pre></td></tr></table></figure><h3 id="2-4-二进制数据类型"><a href="#2-4-二进制数据类型" class="headerlink" title="2.4 二进制数据类型"></a>2.4 二进制数据类型</h3><ul><li>RAW 数据类型用于存储二进制数据</li><li>RAW 数据类型最多能存储 2000 字节</li><li>LONG RAW 数据类型用于存储可变长度的二进制数据</li><li>LONG RAW 数据类型最多能存储 2GB</li></ul><h3 id="2-5-大对象数据类型"><a href="#2-5-大对象数据类型" class="headerlink" title="2.5 大对象数据类型"></a>2.5 大对象数据类型</h3><p>LOB 称为“大对象”数据类型，可以存储多达 128TB 的非结构化信息，例如声音剪辑和视频文件等（LOB 类型的容量从原来的 4G 增加到了最大 128T）。LOB 数据类型允许对数据进行高效、随机和分段的访问。</p><p>类型主要有：</p><ul><li>CLOB：用于存储大量字符数据</li><li>BLOB ：存储较大的二进制对象，如图形、视频剪辑和声音文件</li><li>BFILE ：用于将二进制数据存储在数据库外部的操作系统文件中</li></ul><h3 id="2-6-伪列"><a href="#2-6-伪列" class="headerlink" title="2.6 伪列"></a>2.6 伪列</h3><p>Oracle 中伪列就像一个表列，但是它并没有存储在表中，伪列可以从表中查询，但不能插入、更新和删除它们的值。常用的伪列有ROWID和ROWNUM。</p><ul><li>ROWID 是表中行的存储地址，该地址可以唯一地标识数据库中的一行，可以使用 ROWID 伪列快速地定位表中的一行</li><li>ROWNUM 是查询返回的结果集中行的序号，可以使用它来限制查询返回的行数</li></ul><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select a.*, rowid, rownum from t2 a;</span><br><span class="line"></span><br><span class="line">       SID ROWID                  ROWNUM</span><br><span class="line"><span class="comment">---------- ------------------ ----------</span></span><br><span class="line">      1.22 AAASNlAAEAAAAIfAAA          1</span><br><span class="line">      1.57 AAASNlAAEAAAAIfAAB          2</span><br></pre></td></tr></table></figure><h2 id="3-数据语言"><a href="#3-数据语言" class="headerlink" title="3. 数据语言"></a>3. 数据语言</h2><h3 id="3-1-数据定义语言"><a href="#3-1-数据定义语言" class="headerlink" title="3.1 数据定义语言"></a>3.1 数据定义语言</h3><blockquote><p>数据定义语言用于改变数据库结构，包括创建、更改和删除数据库对象。</p></blockquote><p>用于操纵表结构的数据定义语言命令有：</p><ul><li><p>CREATE TABLE：创建表</p></li><li><p>ALTER TABLE：修改表</p></li><li><p>TRUNCATE TABLE：删除表数据，但是不删除表结构。删除后不记录进日志，谨慎使用</p></li><li><p>DROP TABLE：删除表，包括数据和结构。删除后记录进日志。</p></li></ul><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(<span class="keyword">sid</span> varchar2(<span class="number">11</span>), <span class="keyword">name</span> varchar2(<span class="number">20</span>));</span><br><span class="line"><span class="comment">-- 添加列，注意不需要 column</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">add</span> age <span class="built_in">number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 修改列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">modify</span> <span class="keyword">name</span> varchar2(<span class="number">50</span>);</span><br><span class="line"><span class="comment">-- 删除列，注意需要 column</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">drop</span> <span class="keyword">column</span> age;</span><br><span class="line"><span class="comment">-- 重命名列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> student <span class="keyword">rename</span> <span class="keyword">column</span> <span class="keyword">name</span> <span class="keyword">to</span> sname;</span><br><span class="line"><span class="comment">-- 重命名表</span></span><br><span class="line"><span class="keyword">rename</span> student <span class="keyword">to</span> students;</span><br></pre></td></tr></table></figure><h3 id="3-2-数据操纵语言"><a href="#3-2-数据操纵语言" class="headerlink" title="3.2 数据操纵语言"></a>3.2 数据操纵语言</h3><blockquote><p>数据操纵语言用于检索、插入和修改数据</p></blockquote><h4 id="3-2-1-select-命令"><a href="#3-2-1-select-命令" class="headerlink" title="3.2.1 select 命令"></a>3.2.1 select 命令</h4><ul><li>利用现有的表创建表:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法：<span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;new_table_name&gt; <span class="keyword">AS</span> <span class="keyword">SELECT</span> column_names <span class="keyword">FROM</span> &lt;old_table_name&gt; [<span class="keyword">where</span> 子句];</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 利用现有的表创建表，包含指定数据</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> newstudent <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br><span class="line"><span class="comment">-- 如若只想利用现有的表创建表，且不包含数据的话，可参考如下语句</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> newstudent <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> students <span class="keyword">where</span> <span class="number">1</span> &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-insert-命令"><a href="#3-2-2-insert-命令" class="headerlink" title="3.2.2 insert 命令"></a>3.2.2 insert 命令</h4><p>这里需要说明的是，Oracle 的时间默认格式为 “DD-MON-RR”。所以在插入时间的值时，有如下两种方法:</p><ul><li>使用日期的默认格式</li><li>使用TO_DATE函数转换</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">20200102</span>, <span class="string">'李四'</span>, <span class="string">'22-9月-20'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> students <span class="keyword">values</span>(<span class="number">20200102</span>, <span class="string">'李四'</span>, <span class="keyword">to_date</span>(<span class="string">'20200923'</span>,<span class="string">'yyyymmdd'</span>));</span><br></pre></td></tr></table></figure><ul><li>插入来自其它表中的记录：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> newstudents <span class="keyword">select</span> * <span class="keyword">from</span> students;</span><br></pre></td></tr></table></figure><h2 id="4-操作符"><a href="#4-操作符" class="headerlink" title="4. 操作符"></a>4. 操作符</h2><h3 id="4-1-连接操作符"><a href="#4-1-连接操作符" class="headerlink" title="4.1 连接操作符"></a>4.1 连接操作符</h3><p>连接操作符用于将多个字符串或数据值合并成一个字符串，示例如下。由示例结果可以看出通过使用连接操作符可以将表中的多个列合并成逻辑上的一行列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * from newstudents;</span><br><span class="line"></span><br><span class="line">SID                    SNAME                                                                                                BITRH</span><br><span class="line"><span class="comment">---------------------- ---------------------------------------------------------------------------------------------------- --------------</span></span><br><span class="line">20200101               zhangsan</span><br><span class="line">20200102               李四                                                                                                 23-9月 -20</span><br><span class="line">20200101               zhangsan</span><br><span class="line"></span><br><span class="line">SQL&gt; select (sname || '的学号为' || sid || ', 生日是在' || birth) info from students;</span><br><span class="line"></span><br><span class="line">INFO</span><br><span class="line"><span class="comment">---------------------------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line">李四的学号为20200102, 生日是在23-9月 -20</span><br><span class="line">zhangsan的学号为20200101, 生日是在</span><br></pre></td></tr></table></figure><h2 id="5-Oracle-函数"><a href="#5-Oracle-函数" class="headerlink" title="5. Oracle 函数"></a>5. Oracle 函数</h2><p>Oracle 提供一系列用于执行特定操作的函数，SQL 函数带有一个或多个参数并返回一个值。SQL 函数包含单行函数、分组函数和分析函数三种。</p><h3 id="5-1-单行函数"><a href="#5-1-单行函数" class="headerlink" title="5.1 单行函数"></a>5.1 单行函数</h3><p>单行函数对于从表中查询的每一行只返回一个值，可以出现在 SELECT 子句中和 <strong>WHERE</strong> 子句中 。单行函数可以大致划分为：</p><ul><li>字符函数</li><li>日期时间函数</li><li>数字函数</li><li>转换函数</li><li>混合函数</li></ul><h4 id="5-1-1-字符函数"><a href="#5-1-1-字符函数" class="headerlink" title="5.1.1 字符函数"></a>5.1.1 字符函数</h4><table><thead><tr><th><strong>函数</strong></th><th><strong>输入</strong></th><th><strong>输出</strong></th><th>描述</th></tr></thead><tbody><tr><td>Initcap(char)</td><td>Select initcap(‘hello’) from dual;</td><td>Hello</td><td>首字母大写</td></tr><tr><td>Lower(char)</td><td>Select lower(‘FUN’) from dual;</td><td>fun</td><td>全小写</td></tr><tr><td>Upper(char)</td><td>Select upper(‘sun’) from dual;</td><td>SUN</td><td>全大写</td></tr><tr><td>Ltrim(char,set)</td><td>Select ltrim( ‘xyzadams’,’xyz’) from  dual;</td><td>adams</td><td>切掉左侧首次连续出现的指定字符</td></tr><tr><td>Rtrim(char,set)</td><td>Select rtrim(‘xyzadams’,’ams’) from  dual;</td><td>xyzad</td><td>切掉右侧首次连续出现的指定字符</td></tr><tr><td>Translate(char, from, to)</td><td>Select translate(‘jack’,’j’ ,’b’) from  dual;</td><td>back</td><td>字符替换</td></tr><tr><td>Replace(char, searchstring,[rep  string])</td><td>Select replace(‘jack and jue’  ,’j’,’bl’) from dual;</td><td>black and blue</td><td>字符替换</td></tr><tr><td>Instr (char, m, n)</td><td>Select instr (‘worldwide’,’d’) from  dual;</td><td>5</td><td>字符出现的坐标，从1开始计算</td></tr><tr><td>Substr (char, m, n)</td><td>Select substr(‘abcdefg’,3,2) from dual;</td><td>cd</td><td>获取子串</td></tr><tr><td>Concat (expr1, expr2)</td><td>Select concat (‘Hello’,’ world’) from  dual;</td><td>Hello world</td><td>拼接子串</td></tr><tr><td>CHR(n)</td><td>select chr(97) from dual;</td><td>a</td><td>返回 ASCII 值对应的字符</td></tr><tr><td>ASCII(char)</td><td>select ascii(‘a’) from dual;</td><td>97</td><td>返回字符对应的 ASCII 值</td></tr><tr><td>LENGTH(char)</td><td>select length(‘你好’) cn, length(‘aa’)en from dual;</td><td>2 , 2</td><td>返回字符长度，不区分中文和英文</td></tr><tr><td>[ { { LEADING | TRAILING | BOTH } [ trim_character ]</td><td>select trim(9 from 999987996799999) from dual;</td><td>879967</td><td>删除两侧或某一侧指定字符，无参数则默认删除空格</td></tr></tbody></table><p>其他：</p><p>lpad( string1, padded_length, [ pad_string ] ) 函数：</p><ul><li><p>string1：源字符串；</p></li><li><p>padded_length: 即最终结果返回的字符串的长度；如果最终返回的字符串的长度比源字符串的小，那么此函数实际上对源串进行截取处理，与substr(string,number1,number2)的作用完全相同，如果padded_length比源字符串的长度长，则用pad_string进行填充，确保返回的最终字符串的长度为padded_length；</p></li><li><p>pad_string:用于填充的字符，可以不填，默认为空字符。</p></li></ul><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(<span class="string">'123456'</span>,<span class="number">2</span>) <span class="keyword">from</span> dual <span class="comment">--结果为 12</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">lpad</span>(<span class="string">'123456'</span>,<span class="number">7</span>,<span class="string">'0'</span>) <span class="keyword">from</span> dual <span class="comment">--结果为 0123456</span></span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">'123456'</span>,<span class="number">2</span>,<span class="string">'0'</span>) <span class="keyword">from</span> dual <span class="comment">--结果为 12</span></span><br><span class="line"><span class="keyword">select</span> rpad(<span class="string">'123456'</span>,<span class="number">7</span>,<span class="string">'0'</span>) <span class="keyword">from</span> dual <span class="comment">--结果为 1234560</span></span><br></pre></td></tr></table></figure><p>可以看到，当string1源字符串的长度小于padded_length时，lpad、rpad的作用是相同的，都是相当于substr截取字符串，当padded_length大于string1源字符串的长度时，lpad为在源字符串的左侧填充指定字符或者空格，rpad为在源字符串的右侧填充指定字符或者空格；</p><h4 id="5-1-2-日期时间函数"><a href="#5-1-2-日期时间函数" class="headerlink" title="5.1.2 日期时间函数"></a>5.1.2 日期时间函数</h4><p>日期函数对日期值进行运算，并生成日期数据类型或数值类型的结果。日期函数包括：</p><ul><li>ADD_MONTHS(date, num)：进行月份的增加或减少</li><li>MONTHS_BETWEEN：计算两个日期之间有几个月</li><li>LAST_DAY：获取指定月的最后一天的日期</li><li>ROUND：对日期进行四舍五入</li><li>NEXT_DAY：从当前日期开始得到未来  星期几  的日期</li><li>TRUNC：见如下示例</li><li>EXTRACT：语法如下：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXTRACT (  </span><br><span class="line">        &#123; YEAR | MONTH | DAY | HOUR | MINUTE | SECOND &#125;  </span><br><span class="line">        | &#123; TIMEZONE_HOUR | TIMEZONE_MINUTE &#125;  </span><br><span class="line">        | &#123; TIMEZONE_REGION | TIMEZONE_ABBR &#125;  </span><br><span class="line">FROM &#123; date_value | interval_value &#125; )</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. add_months方法</span></span><br><span class="line"><span class="keyword">select</span> add_months(<span class="keyword">sysdate</span>, <span class="number">-1</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 2. months_between 方法</span></span><br><span class="line">SQL&gt; select months_between(to_date('2020-08-21', 'yyyy-mm-dd'), to_date('2020-10-23', 'yyyy-mm-dd')) mulmonth from dual;</span><br><span class="line"></span><br><span class="line">  MULMONTH</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line">-2.0645161</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 3. last_day 方法</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">last_day</span>(<span class="keyword">sysdate</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--4. round 方法</span></span><br><span class="line"><span class="comment">-- 根据月份对年进行四舍五入, 1-6 月舍，7-12 月入</span></span><br><span class="line">SQL&gt; select round(to_date('2020-09-12', 'yyyy-mm-dd'), 'year') from dual;</span><br><span class="line"></span><br><span class="line">ROUND(TO_DATE(</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">01-1月 -21</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 根据日对月份进行四舍五入， 1-15 日舍，16-31 月入</span></span><br><span class="line">SQL&gt; select round(to_date('2020-09-16', 'yyyy-mm-dd'), 'month') from dual;</span><br><span class="line"></span><br><span class="line">ROUND(TO_DATE(</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">01-10月-20</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 5. next_day 方法</span></span><br><span class="line"><span class="keyword">select</span> next_day(<span class="keyword">to_date</span>(<span class="string">'2020-09-26'</span>,<span class="string">'yyyy-mm-dd'</span>),<span class="string">'星期日'</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 6. trunc 方法</span></span><br><span class="line"><span class="comment">-- 日期时间处理</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-06 今天的日期为2013-01-06</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>, <span class="string">'mm'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-01 返回当月第一天.</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>,<span class="string">'yy'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-01 返回当年第一天</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>,<span class="string">'dd'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-06 返回当前年月日</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>,<span class="string">'yyyy'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-01 返回当年第一天</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>,<span class="string">'d'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-06 (星期天)返回当前星期的第一天</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>, <span class="string">'hh'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-06 17:00:00 当前时间为17:35</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="keyword">sysdate</span>, <span class="string">'mi'</span>) <span class="keyword">from</span> dual <span class="comment">--2013-01-06 17:35:00 TRUNC()函数没有秒的精确  </span></span><br><span class="line"><span class="comment">-- 数字处理</span></span><br><span class="line">TRUNC(<span class="built_in">number</span>, num_digits)：函数截取时不进行四舍五入</span><br><span class="line"><span class="built_in">Number</span> 需要截尾取整的数字。</span><br><span class="line">Num_digits 用于指定取整精度的数字。Num_digits 的默认值为 <span class="number">0</span>。</span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>) <span class="keyword">from</span> dual <span class="comment">--123</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,<span class="number">0</span>) <span class="keyword">from</span> dual <span class="comment">--123</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,<span class="number">1</span>) <span class="keyword">from</span> dual <span class="comment">--123.4</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,<span class="number">-1</span>) <span class="keyword">from</span> dual <span class="comment">--120</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,<span class="number">-4</span>) <span class="keyword">from</span> dual <span class="comment">--0</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123.458</span>,<span class="number">4</span>) <span class="keyword">from</span> dual <span class="comment">--123.458</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123</span>) <span class="keyword">from</span> dual <span class="comment">--123</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123</span>,<span class="number">1</span>) <span class="keyword">from</span> dual <span class="comment">--123</span></span><br><span class="line"><span class="keyword">select</span> trunc(<span class="number">123</span>,<span class="number">-1</span>) <span class="keyword">from</span> dual <span class="comment">--120</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取截断的日期时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">year</span> <span class="keyword">from</span> <span class="built_in">date</span><span class="string">'2011-05-17'</span>) <span class="keyword">year</span> <span class="keyword">from</span> dual;  </span><br><span class="line">      YEAR  </span><br><span class="line"><span class="comment">----------  </span></span><br><span class="line">      2011  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">month</span> <span class="keyword">from</span> <span class="built_in">date</span><span class="string">'2011-05-17'</span>) <span class="keyword">month</span> <span class="keyword">from</span> dual;  </span><br><span class="line">     MONTH  </span><br><span class="line"><span class="comment">----------  </span></span><br><span class="line">         5  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> <span class="built_in">date</span><span class="string">'2011-05-17'</span>) <span class="keyword">day</span> <span class="keyword">from</span> dual;  </span><br><span class="line">       DAY  </span><br><span class="line"><span class="comment">----------  </span></span><br><span class="line">        17 </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取时间间隔</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">extract</span>(<span class="keyword">day</span> <span class="keyword">from</span> dt2-dt1) <span class="keyword">day</span>, <span class="keyword">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> dt2-dt1) <span class="keyword">hour</span>, <span class="keyword">extract</span>(<span class="keyword">minute</span> <span class="keyword">from</span> dt2-dt1) <span class="keyword">minute</span>, <span class="keyword">extract</span>(<span class="keyword">second</span> <span class="keyword">from</span> dt2-dt1) <span class="keyword">second</span>  </span><br><span class="line"><span class="keyword">from</span> (  </span><br><span class="line">     <span class="keyword">select</span> to_timestamp(<span class="string">'2011-02-04 15:07:00'</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) dt1  </span><br><span class="line">           ,to_timestamp(<span class="string">'2011-05-17 19:08:46'</span>,<span class="string">'yyyy-mm-dd hh24:mi:ss'</span>) dt2  </span><br><span class="line">     <span class="keyword">from</span> dual);  </span><br><span class="line"> </span><br><span class="line">       DAY       HOUR     MINUTE     SECOND  </span><br><span class="line"><span class="comment">---------- ---------- ---------- ----------  </span></span><br><span class="line">       102          4          1         46</span><br></pre></td></tr></table></figure><h4 id="5-1-3-数字函数"><a href="#5-1-3-数字函数" class="headerlink" title="5.1.3 数字函数"></a>5.1.3 数字函数</h4><table><thead><tr><th>函数</th><th>输入</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>Abs(n)</td><td>Select abs(-15) from dual;</td><td>15</td><td>取绝对值</td></tr><tr><td>Ceil(n)</td><td>Select ceil(44.778) from dual;</td><td>45</td><td>向上取整</td></tr><tr><td>Cos(n)</td><td>Select cos(180) from dual;</td><td>-.5984601</td><td>求 cos 函数值</td></tr><tr><td>Cosh(n)</td><td>Select cosh(0) from dual;</td><td>1</td><td>求双曲函数值</td></tr><tr><td>Floor(n)</td><td>Select floor(100.2) from dual;</td><td>100</td><td>向下取整</td></tr><tr><td>Power(m,n)</td><td>Select power(4,2) from dual;</td><td>16</td><td>求 m<sup>n</sup> 的值</td></tr><tr><td>Mod(m,n)</td><td>Select mod(10,3) from dual;</td><td>1</td><td>取余</td></tr><tr><td>Round(m,n)</td><td>Select round(100.256,2) from dual;</td><td>100.26</td><td>指定精度四舍五入</td></tr><tr><td>Trunc(m,n)</td><td>Select trunc(100.256,2) from dual;</td><td>100.25</td><td>截断不四舍五入</td></tr><tr><td>Sqrt(n)</td><td>Select sqrt(4) from dual;</td><td>2</td><td>求平方根</td></tr><tr><td>Sign(n)</td><td>Select  sign(-30) from dual;</td><td>-1</td><td>函数返回一个数字的正负标志，负数返回-1，正数返回1，0 返 0</td></tr></tbody></table><h4 id="5-1-4-转换函数"><a href="#5-1-4-转换函数" class="headerlink" title="5.1.4 转换函数"></a>5.1.4 转换函数</h4><p>转换函数将值从一种数据类型转换为另一种数据类型，常用的转换函数有：to_char, to_date 和 to_number。</p><h3 id="5-2-集合操作符"><a href="#5-2-集合操作符" class="headerlink" title="5.2 集合操作符"></a>5.2 集合操作符</h3><ul><li>UNION：求两个集合的并集</li><li>UNION ALL：求两个集合的并集（包含重复的记录）</li><li>INTERSECT：求两个集合的交集</li><li>MINUS：求两个集合的差集</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 创建 Maven 子项目的 java 和 resource 一直是灰色的解决办法</title>
      <link href="/2021/05/04/IDEA-%E5%88%9B%E5%BB%BA-Maven-%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%9A%84-java-%E5%92%8C-resource-%E4%B8%80%E7%9B%B4%E6%98%AF%E7%81%B0%E8%89%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/2021/05/04/IDEA-%E5%88%9B%E5%BB%BA-Maven-%E5%AD%90%E9%A1%B9%E7%9B%AE%E7%9A%84-java-%E5%92%8C-resource-%E4%B8%80%E7%9B%B4%E6%98%AF%E7%81%B0%E8%89%B2%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>如图：</p><p><img src="/2021/05/04/IDEA-创建-Maven-子项目的-java-和-resource-一直是灰色的解决办法/20210221160612576.png" alt></p><a id="more"></a><p>解决办法：<br>settings &gt;&gt;&gt; ignoreFiles 将选中的pom文件的勾取消。<br><img src="/2021/05/04/IDEA-创建-Maven-子项目的-java-和-resource-一直是灰色的解决办法/20210221160626929.png" alt><br>再 rebuild项目即可<br><img src="/2021/05/04/IDEA-创建-Maven-子项目的-java-和-resource-一直是灰色的解决办法/20210221160642631.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js 和 jQuery 学习</title>
      <link href="/2020/09/09/js%E5%92%8C-jQuery-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/09/09/js%E5%92%8C-jQuery-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JS-基础学习"><a href="#1-JS-基础学习" class="headerlink" title="1. JS 基础学习"></a>1. JS 基础学习</h2><blockquote><p>  学习资料：<a href="https://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/js/index.asp</a></p></blockquote><h3 id="1-1-JS-函数"><a href="#1-1-JS-函数" class="headerlink" title="1.1 JS 函数"></a>1.1 JS 函数</h3><blockquote><p>  JavaScript 函数是被设计为执行特定任务的代码块，会在某代码调用它时被执行。</p></blockquote><h4 id="1-1-1-实例"><a href="#1-1-1-实例" class="headerlink" title="1.1.1 实例"></a>1.1.1 实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1 * p2;              <span class="comment">// 该函数返回 p1 和 p2 的乘积</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="1-1-2-语法"><a href="#1-1-2-语法" class="headerlink" title="1.1.2 语法"></a>1.1.2 语法</h4><p>JavaScript 函数通过 function 关键词进行定义，其后是函数名和括号 ()，圆括号可包括由逗号分隔的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(参数 <span class="number">1</span>, 参数 <span class="number">2</span>, ...)</span><br></pre></td></tr></table></figure><p>由函数执行的代码被放置在花括号中：<em>{}</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">参数 <span class="number">1</span>, 参数 <span class="number">2</span>, 参数 <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-JS-对象"><a href="#1-2-JS-对象" class="headerlink" title="1.2 JS 对象"></a>1.2 JS 对象</h3><p>js 对象包含属性和方法，JavaScript 对象中的<strong>名称:值</strong>对被称为<strong>属性</strong>，方法以<strong>函数定义</strong>被<strong>存储在属性</strong>中。</p><h4 id="1-2-1-实例"><a href="#1-2-1-实例" class="headerlink" title="1.2.1 实例"></a>1.2.1 实例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person 即为对象名</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">"Bill"</span>,</span><br><span class="line">  lastName : <span class="string">"Gates"</span>,</span><br><span class="line">  id       : <span class="number">678</span>,</span><br><span class="line">  <span class="comment">// fullName是方法名，其值存储函数定义</span></span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params">p1,p2</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName + p1 + p2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-属性访问"><a href="#1-2-2-属性访问" class="headerlink" title="1.2.2 属性访问"></a>1.2.2 属性访问</h4><p>能够以两种方式访问属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.firstName 或 person[<span class="string">'firtName'</span>]</span><br></pre></td></tr></table></figure><h4 id="1-2-3-方法访问"><a href="#1-2-3-方法访问" class="headerlink" title="1.2.3 方法访问"></a>1.2.3 方法访问</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.fullName(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="1-2-4-属性添加"><a href="#1-2-4-属性添加" class="headerlink" title="1.2.4 属性添加"></a>1.2.4 属性添加</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname:<span class="string">"Bill"</span>,</span><br><span class="line">  lastname:<span class="string">"Gates"</span>,</span><br><span class="line">  age:<span class="number">62</span>,</span><br><span class="line">  eyecolor:<span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 向 person 对象添加 nationality 属性</span></span><br><span class="line">person.nationality = <span class="string">"English"</span>;</span><br></pre></td></tr></table></figure><h4 id="1-2-5-方法添加"><a href="#1-2-5-方法添加" class="headerlink" title="1.2.5 方法添加"></a>1.2.5 方法添加</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstname:<span class="string">"Bill"</span>,</span><br><span class="line">  lastname:<span class="string">"Gates"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 向 person 对象添加 say 方法</span></span><br><span class="line">person.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-JS-对象原型"><a href="#1-3-JS-对象原型" class="headerlink" title="1.3 JS 对象原型"></a>1.3 JS 对象原型</h3><blockquote><p>  向对象构造器动态添加属性和方法等</p></blockquote><p>所有 JavaScript 对象都从原型继承属性和方法。日期对象继承自 Date.prototype。Person 对象继承自 Person.prototype，Object.prototype 位于原型继承链的顶端，日期等对象都继承自 Object.prototype。<strong>JavaScript prototype 属性允许为对象构造器添加新属性和方法：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">first, last</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = first;</span><br><span class="line">    <span class="keyword">this</span>.lastName = last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 Person 构造器中动态添加值为 12 的 age 属性，缺点是 new 出来的所有 Person 的 age 初始值都是 12</span></span><br><span class="line">Person.prototype.age = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 向 Person 构造器动态添加方法</span></span><br><span class="line">Person.prototype.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-JS-提升"><a href="#1-4-JS-提升" class="headerlink" title="1.4 JS 提升"></a>1.4 JS 提升</h3><blockquote><p>  提升（Hoisting）是 JavaScript 将声明移至顶部的默认行为。推荐变量声明都写在顶部！</p></blockquote><p>在 JavaScript 中，可以在使用变量之后对其进行声明。换句话说，可以在声明变量之前使用它。例子 1 与例子 2 的结果相同：</p><p><strong>例子 1 ：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span>; <span class="comment">// 把 5 赋值给 x</span></span><br><span class="line"> </span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x;                     <span class="comment">// 在元素中显示 x(先使用变量 x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x; <span class="comment">// 后声明 x</span></span><br></pre></td></tr></table></figure><p><strong>例子2：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x; <span class="comment">// 声明 x</span></span><br><span class="line">x = <span class="number">5</span>; <span class="comment">// 把 5 赋值给 x</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x;</span><br></pre></td></tr></table></figure><p>需要注意的是，JavaScript 只提升声明，而非初始化。例子 3 与例子 4 的结果不相同：</p><p><strong>例子3：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y</span></span><br><span class="line"></span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x + <span class="string">" "</span> + y;           <span class="comment">// 显示 '5 7'</span></span><br></pre></td></tr></table></figure><p><strong>例子4 ：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>; <span class="comment">// 初始化 x</span></span><br><span class="line"> </span><br><span class="line">elem = <span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>); <span class="comment">// 查找元素</span></span><br><span class="line">elem.innerHTML = x + <span class="string">" "</span> + y;           <span class="comment">// 显示 '5 undefined'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> y = <span class="number">7</span>; <span class="comment">// 初始化 y,无法被提升，因此第 4 行使用 y 时是没有定义的</span></span><br></pre></td></tr></table></figure><h3 id="1-5-this-关键字"><a href="#1-5-this-关键字" class="headerlink" title="1.5 this 关键字"></a>1.5 this 关键字</h3><h4 id="1-5-1-方法中的-this"><a href="#1-5-1-方法中的-this" class="headerlink" title="1.5.1 方法中的 this"></a>1.5.1 方法中的 this</h4><p>对象方法中的 this 指的是该方法的拥有者对象，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">"Bill"</span>,</span><br><span class="line">  lastName : <span class="string">"Gates"</span>,</span><br><span class="line">  id       : <span class="number">678</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指方法的拥有者 person 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">" "</span> + <span class="keyword">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-5-2-单独的-this"><a href="#1-5-2-单独的-this" class="headerlink" title="1.5.2 单独的 this"></a>1.5.2 单独的 this</h4><p>在单独使用时，拥有者是<strong>全局对象</strong>，因此 this 指的是全局对象。在浏览器窗口中，全局对象是 <strong>[object Window]</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> x = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="javascript"><span class="comment">// this 指的是全局对象 [object Window]</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">"demo"</span>).innerHTML = x;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-5-3-函数中的-this"><a href="#1-5-3-函数中的-this" class="headerlink" title="1.5.3 函数中的 this"></a>1.5.3 函数中的 this</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这里 this 依旧指的是全局对象 [object Window]</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 严格模式下 this 是没有定义的</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="keyword">this</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-6-JS-调试"><a href="#1-6-JS-调试" class="headerlink" title="1.6 JS 调试"></a>1.6 JS 调试</h3><h4 id="3-6-1-debugger-关键词"><a href="#3-6-1-debugger-关键词" class="headerlink" title="3.6.1 debugger 关键词"></a>3.6.1 debugger 关键词</h4><p>除了使用基本的 console 类打印日志信息进行调试之外，还可以在 Js 代码中使用 debugger 关键字来进行 JS 代码的调试，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">15</span> * <span class="number">5</span>;</span><br><span class="line"><span class="keyword">debugger</span>;<span class="comment">// 运行到这里会暂停，类似打断点</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h2 id="2-jQuery-学习"><a href="#2-jQuery-学习" class="headerlink" title="2. jQuery 学习"></a>2. jQuery 学习</h2><h3 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h3><p>jQuery 语法是为 HTML 元素的选取编制的，可以对元素执行某些操作。</p><p>基础语法是：<code>$(selector).action()</code></p><ul><li>美元符号定义 jQuery</li><li>选择符（selector）“查询”和“查找” HTML 元素</li><li>jQuery 的 action() 执行对元素的操作</li></ul><p><strong>示例：</strong></p><p>$(this).hide() - 隐藏当前元素</p><p>$(“p”).hide() - 隐藏所有段落</p><p>$(“.test”).hide() - 隐藏所有 class=”test” 的所有元素</p><p>$(“#test”).hide() - 隐藏所有 id=”test” 的元素</p><p><strong>文档就绪函数：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//防止文档在完全加载（就绪）之前运行 jQuery 代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-选择器"><a href="#2-2-选择器" class="headerlink" title="2.2 选择器"></a>2.2 选择器</h3><p>参考：<a href="https://www.w3school.com.cn/jquery/jquery_ref_selectors.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jquery/jquery_ref_selectors.asp</a></p><h3 id="2-3-HTML-操作"><a href="#2-3-HTML-操作" class="headerlink" title="2.3 HTML 操作"></a>2.3 HTML 操作</h3><p>如需有关 jQuery HTML 方法的完整内容，请访问以下参考手册：</p><ul><li><a href="https://www.w3school.com.cn/jquery/jquery_ref_manipulation.asp" target="_blank" rel="noopener">jQuery 文档操作</a></li><li><a href="https://www.w3school.com.cn/jquery/jquery_ref_attributes.asp" target="_blank" rel="noopener">jQuery 属性操作</a></li><li><a href="https://www.w3school.com.cn/jquery/jquery_ref_css.asp" target="_blank" rel="noopener">jQuery CSS 操作</a></li></ul><h4 id="2-3-1-获取"><a href="#2-3-1-获取" class="headerlink" title="2.3.1 获取"></a>2.3.1 获取</h4><p>三个简单实用的用于 DOM 操作的 jQuery 方法：</p><ul><li>text() - 设置或返回所选元素的文本内容</li><li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li><li>val() - 设置或返回表单字段的值</li><li>attr() - 设置或返回属性值</li></ul><p>代码示例如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/jquery/jquery-1.11.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 显示文本内容，不包含 html 标签,这是段落中的粗体文本。</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"Text: "</span> + $(<span class="string">"#test"</span>).text());</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  $(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="xml">  // 显示文本内容，包含 html 元素,这是段落中的<span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span>文本。</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"HTML: "</span> + $(<span class="string">"#test"</span>).html());</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  $(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 显示表单属性值，shoto</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"VAL: "</span> + $(<span class="string">"#aaa"</span>).val());</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  $(<span class="string">"#btn4"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 显示标签属性值，abcdefg</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"ATTR: "</span> + $(<span class="string">"#ahh"</span>).attr(<span class="string">"href"</span>));</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>这是段落中的<span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体<span class="tag">&lt;/<span class="name">b</span>&gt;</span>文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn1"</span>&gt;</span>显示文本<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn2"</span>&gt;</span>显示 HTML<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn3"</span>&gt;</span>显示 value<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn4"</span>&gt;</span>显示属性值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"abcdefg"</span> <span class="attr">id</span>=<span class="string">"ahh"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"aaa"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"shoto"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-设置"><a href="#2-3-2-设置" class="headerlink" title="2.3.2 设置"></a>2.3.2 设置</h4><p>使用四个相同的方法来设置内容：</p><ul><li>text() - 设置或返回所选元素的文本内容</li><li>html() - 设置或返回所选元素的内容（包括 HTML 标记）</li><li>val() - 设置或返回表单字段的值</li><li>attr()-设置或返回属性值</li></ul><p>代码示例如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#btn1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#test1"</span>).text(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#test2"</span>).html(<span class="string">"&lt;b&gt;Hello world!&lt;/b&gt;"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">"#btn3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#test3"</span>).val(<span class="string">"Dolly Duck"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// attr 方法支持同时设置多个属性值</span></span><br><span class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  $(<span class="string">"#w3s"</span>).attr(<span class="string">"href"</span>,<span class="string">"http://www.w3school.com.cn/jquery"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-3-3-遍历"><a href="#2-3-3-遍历" class="headerlink" title="2.3.3 遍历"></a>2.3.3 遍历</h4><p>参考资料：<a href="https://www.w3school.com.cn/jquery/jquery_ref_traversing.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/jquery/jquery_ref_traversing.asp</a></p><p><strong>$.each() 方法：</strong></p><p>$.each()是对数组、json和dom结构等的遍历，比如对数组的遍历示例如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1=[<span class="string">'aa'</span>,<span class="string">'bb'</span>,<span class="string">'cc'</span>,<span class="string">'dd'</span>];</span><br><span class="line"><span class="comment">// 两个参数，第一个参数表示遍历的数组的下标，第二个参数表示下标对应的值</span></span><br><span class="line">$.each(arr1,<span class="function"><span class="keyword">function</span>(<span class="params">i,val</span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i+<span class="string">'...'</span>+val);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">0...aa</span></span><br><span class="line"><span class="comment">1...bb</span></span><br><span class="line"><span class="comment">2...cc</span></span><br><span class="line"><span class="comment">3...dd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-4-ajax-提交"><a href="#2-4-ajax-提交" class="headerlink" title="2.4 ajax 提交"></a>2.4 ajax 提交</h3><blockquote><p>  AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</p></blockquote><p>关于 Ajax 的提交可以参考<a href="https://www.w3school.com.cn/jquery/ajax_ajax.asp" target="_blank" rel="noopener">jQuery ajax - ajax() 方法</a>，平时开发也会经常遇到 form 表单的 Ajax 方式的提交，可以参考<a href="http://www.lmwlove.com/ae/ID383" target="_blank" rel="noopener">Form（表单）</a>该文。</p><h2 id="3-jQuery-easyUI"><a href="#3-jQuery-easyUI" class="headerlink" title="3. jQuery easyUI"></a>3. jQuery easyUI</h2><p>广东联通价值管理平台前端方法使用到了 jQuery easyUI 的技术，比如使用到了 TreeGrid 和 Tree 组件。对于该部分内容可以查看<a href="http://www.jeasyui.net/plugins" target="_blank" rel="noopener">jQuery EasyUI 文档</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>layui 模块引用方法</title>
      <link href="/2020/09/09/layui-%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2020/09/09/layui-%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  官方文档地址：<a href="https://www.layui.com/doc/base/modules.html" target="_blank" rel="noopener">https://www.layui.com/doc/base/modules.html</a></p></blockquote><h2 id="1-引入方式"><a href="#1-引入方式" class="headerlink" title="1. 引入方式"></a>1. 引入方式</h2><h3 id="1-1-预先加载方法"><a href="#1-1-预先加载方法" class="headerlink" title="1.1 预先加载方法"></a>1.1 预先加载方法</h3><blockquote><p>  推荐使用方式</p></blockquote><p>Layui的模块加载采用核心的 <em>layui.use(mods, callback)</em>方法，当你的JS 需要用到Layui模块的时候，我们更推荐你采用预先加载，因为这样可以避免到处写layui.use的麻烦。你应该在最外层如此定义：</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  使用Layui的form和layer模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">layui.use([<span class="string">'form'</span>, <span class="string">'layer'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//如果只加载一个模块，可以不填数组。如：layui.use('form')</span></span><br><span class="line">  <span class="keyword">var</span> form = layui.form <span class="comment">//获取form模块</span></span><br><span class="line">  ,layer = layui.layer; <span class="comment">//获取layer模块</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 这是你的 js 代码</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>简单地讲：就是将你的 js 代码包含在一个大大的 use 方法里面，虽然这会让习惯原生 js 代码的开发人员多少有些不习惯。</p><h3 id="1-2-全模块加载方法"><a href="#1-2-全模块加载方法" class="headerlink" title="1.2 全模块加载方法"></a>1.2 全模块加载方法</h3><p>全模块加载简单地讲即是一次性加载所有模块，此时我们需要引入一个较大的layui.all.js文件。然后，layUI 中的所有模块将会暴露出来，即我们不在需要写一个 use 方法将需要的模块加载进来。</p><p>但你必须知道，这种使用方式，意味着Layui的模块化已经失去了它的意义。但不可否认，它比什么都来的简单。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"static/layui/css/layui.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"static/layui/lay/dest/layui.all.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//获得模块的引用</span></span><br><span class="line">    <span class="keyword">var</span> layer = layui.layer;</span><br><span class="line">    <span class="comment">// 直接使用</span></span><br><span class="line">    layer.msg(<span class="string">"Hello World"</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h2><h3 id="2-1-注意点：加载方式"><a href="#2-1-注意点：加载方式" class="headerlink" title="2.1 注意点：加载方式"></a>2.1 注意点：加载方式</h3><p>了解了预加载的模式之后，为了避免将代码写在 use 方法中，可能会觉得如下方式是可行，但是这种方式是不可行的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强烈不推荐下面的做法</span></span><br><span class="line"><span class="keyword">var</span> laypage, laydate;</span><br><span class="line">layui.use([<span class="string">'laypage'</span>, <span class="string">'laydate'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  laypage = layui.laypage;</span><br><span class="line">  laydate = layui.laydate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为如果一旦你的业务代码是在模块加载完毕之前执行，你的全局对象将获取不到模块接口，因此这样用不仅不符合规范，还存在报错风险。</p><h3 id="2-2-注意点：方法调用方式"><a href="#2-2-注意点：方法调用方式" class="headerlink" title="2.2 注意点：方法调用方式"></a>2.2 注意点：方法调用方式</h3><p>js 存在两种常用调用方法的方式，一种是监听事件然后执行具体的代码，另一种则是直接使用方法名调用。由于我们是将 js 代码写在 use 方法中的，因此当 html 想直接调用 use 方法中的自定义方法的时候，会与平常的稍许不同。示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">layui.use([<span class="string">'layer'</span>, <span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> layer = layui.layer;</span><br><span class="line">    <span class="comment">// 使用 layUI 自身集成的 jquery</span></span><br><span class="line">    <span class="keyword">var</span> $ = layui.$;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式1：监听事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    $(<span class="string">'#btn'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 方法体....</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方式2：方法名调用方式，html 可直接以 test() 的方式调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">window</span>.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 方法体...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方式3：html 不能直接以 test2() 的方式调用，此方法为内部方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 方法体...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> layUI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> layUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr全文搜索服务器的使用</title>
      <link href="/2020/03/06/Solr%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/06/Solr%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Solr-简介"><a href="#1-Solr-简介" class="headerlink" title="1. Solr 简介"></a>1. Solr 简介</h2><p>Solr 是一个独立的企业级搜索应用服务器，它对外提供类似于 web-service 的 API接口。用户可以通过 http 请求，向搜索引擎服务器提交一定格式的 XML 文件，生成索引。也可以通过 Http Get 操作提出查找请求，并得到  XML 或者 JSON 格式的返回结果。<strong>本文以使用 solr 全文搜索服务来实现站内搜索的功能。</strong></p><a id="more"></a><h2 id="2-Solr-下载安装"><a href="#2-Solr-下载安装" class="headerlink" title="2. Solr 下载安装"></a>2. Solr 下载安装</h2><p>由于本人是在 Windows 下使用 Solr 全文搜索服务器的，因此这里仅介绍 Solr 在 Windows 下的安装以及配置等操作。首先需要前往官网下载 Solr，我下载的版本是 solr 6.2.0，具体的下载位置可以访问该<a href="http://archive.apache.org/dist/lucene/solr/6.2.0" target="_blank" rel="noopener">网址</a>。具体的下载位置如下所示。解压安装的时候一直 next 即可。</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583472109002.png" alt="1583472109002"></p><p>需要注意的是，Solr 与 JDK 之间在版本上是存在对应关系的，比如我本人所使用的 solr 6.2.0 仅支持 JDK1.8 及以上的版本，不然在启动 Solr 服务器的时候是会报错的，这一点需要格外注意。solr 、jdk 和 tomcat 之间版本的对应关系可以参考该<a href="https://www.cnblogs.com/gaoxu007/p/7210581.html" target="_blank" rel="noopener">文章</a>，这里不再赘述。</p><h2 id="3-运行-Solr"><a href="#3-运行-Solr" class="headerlink" title="3. 运行 Solr"></a>3. 运行 Solr</h2><p>solr 的运行有两种方式，一种是集群方式一种是单机方式，其对应的命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 集群方式</span><br><span class="line">solr start -e cloud –noprompt</span><br><span class="line">## 单机方式</span><br><span class="line">solr start</span><br></pre></td></tr></table></figure><p>下面我们就以单机的方式来启动 solr 全文搜索服务器。首先需要进入 solr 的 bin 目录下，然后在命令行窗口中输入如下命令用于启动 Solr 服务器：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solr <span class="keyword">start</span></span><br></pre></td></tr></table></figure><p>启动完成之后即可以在浏览器使用 ‘<a href="http://localhost:8983/solr/#/&#39;" target="_blank" rel="noopener">http://localhost:8983/solr/#/&#39;</a>  访问 Solr 全文搜索服务器的后台管理页面了，具体如下所示：</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583472396275.png" alt="1583472396275"></p><p>另外，solr 服务器有许多常用的命令，具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">## 单机版启动solr服务，端口号可以不指明</span><br><span class="line">solr start –p 端口号</span><br><span class="line">## 重启solr服务</span><br><span class="line">solr restart –p 端口号 </span><br><span class="line">## 关闭solr服务</span><br><span class="line">solr stop –p 端口号</span><br><span class="line">## 创建一个core实例(core概念后面介绍)</span><br><span class="line">solr create –c name</span><br></pre></td></tr></table></figure><h2 id="4-core-实例创建"><a href="#4-core-实例创建" class="headerlink" title="4. core 实例创建"></a>4. core 实例创建</h2><h3 id="4-1-core-简介"><a href="#4-1-core-简介" class="headerlink" title="4.1 core 简介"></a>4.1 core 简介</h3><p>简单说 core 就是 solr 的一个实例，一个 solr 服务下可以有多个 core，每个 core 下都有自己的索引库和与之相应的配置文件，所以在操作solr 创建索引之前要创建一个 core，因为索引都存在 core 下面。</p><h3 id="4-2-core-创建"><a href="#4-2-core-创建" class="headerlink" title="4.2 core 创建"></a>4.2 core 创建</h3><p>core 的创建同样存在两种方式，一种是通过命令的方式，一种则是在 solr 的后台管理页面进行创建。</p><p>1）命令方式：首先我们可以在命令行中运行如下命令来创建名为 cqa 的 core 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">solr create -c cqa</span><br></pre></td></tr></table></figure><p>创建完成之后，则可以在 solr-6.2.0/server/solr 下生成 cqa 的目录文件，具体如下图所示：</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583474024339.png" alt="1583474024339"></p><p>后续我们需要进行索引文件和中文分词器的配置，具体的配置文件在 cqa/conf 目录下，关于配置后面我们在进行介绍。</p><p>2）界面方式：按照下图的指示，可以直接在 solr 的后台管理界面上进行 core 实例的创建。</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583474289113.png" alt="1583474289113"></p><h2 id="5-中文分词器配置"><a href="#5-中文分词器配置" class="headerlink" title="5.  中文分词器配置"></a>5.  中文分词器配置</h2><p>首先需要明白分词的概念，比如我们在使用百度搜索 “你好” 的时候，那么在进行查询分词的时候可能会分为 “你”，“好” 和 “你好”，然后在搜索包含这三个关键词的文档。当然这是在使用的了中文分词器的情况下，但是如果在没有使用中文分词器的时候，“你好” 仅会被分词为 “你” 和 “好”，显然这样是满足不了我们具体的需求的。由于 solr 默认仅支持部分中文分词，因此需要我们自己去配置第三方中文分词器。</p><p>1）首先我们需要在自定义的 core 实例 cqa/conf 目录下的 managed-schema 文件中进行如下中文分词器的配置。需要配置索引分词器和查询分词器，两者的实现效果是不一样的。索引分词器的分词粒度更细，比如可以对将 “你好” 进行 “你”、“好” 和 “你好” 的分词，以此我们在输入“你好”进行查询的时候，我们可以查找更多数据。而查询分词器的分词粒度较粗而且更为只能，比如使用查询分词器的时候，“你好” 只能被分词为 “你好”，以此我们可以以关键字“你好”去查询，而不会以关键“你”或“好”去查询，这就是查询分词器的好处。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">"text_ik"</span> <span class="attr">class</span>=<span class="string">"solr.TextField"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--索引分词器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.util.IKTokenizerFactory"</span> <span class="attr">useSmart</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"solr.LowerCaseFilterFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--查询分词器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">analyzer</span> <span class="attr">type</span>=<span class="string">"query"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tokenizer</span> <span class="attr">class</span>=<span class="string">"org.wltea.analyzer.util.IKTokenizerFactory"</span> <span class="attr">useSmart</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">analyzer</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，这里需要说明的是 IKTokenizerFactory 引用的是 Ik-analyzer 的源码类文件，后续我们需要在 solr 引用包含该文件的 jar 包。</p><p>除了上述的配置之外，我们还需要进行如下配置。由于我们的需求是可以通过站内搜索问题的标题（title）和问题的描述内容（content），因此我们需要对两者进行索引。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对问题标题建立索引--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"question_title"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--对问题内容建立索引--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"question_content"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>2）然后我们需要在 solr-6.2.0 下创建 ext/ikanalyzer 目录，然后在该目录下存放 ikanalyzer-6.2.0.jar，该 jar 即为中文分词器的源码 jar，以此上面的配置便可以使用该 jar 中的类文件。ikanalyzer-6.2.0.jar 该 jar 包可以访问该链接进行下载 <a href="https://pan.baidu.com/s/1JIQBFQ-wCN6PLwiBkGVB2g，提取码为" target="_blank" rel="noopener">https://pan.baidu.com/s/1JIQBFQ-wCN6PLwiBkGVB2g，提取码为</a> zgey。</p><p>接着我们还需要在 solr-6.2.0\server\solr\cqa\conf\solrconfig.xml 中指明该 jar 包的位置，具体配置如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:../../../..&#125;/ext/ikanalyzer"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>3）在配置完成中文分词器之后，并进行下述数据库数据的导入之后，我们可以验证中文分词器是否配置成功，具体验证步骤如下图所示：</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583478102392.png" alt="1583478102392"></p><h2 id="6-数据库数据导入"><a href="#6-数据库数据导入" class="headerlink" title="6. 数据库数据导入"></a>6. 数据库数据导入</h2><p>由于我们需要对问题标题和问题描述建立索引，因为我们需要将问题的数据从数据库中导入到 solr 服务器中，以此让 solr 服务器进行索引的创建。下面开始进行相关的配置。</p><p>1）首先需要引入 mysql 的 jar 包，需要在 solr-6.2.0\ext 目录下创建 mysql 目录，然后将 mysql-connector-java-8.0.12.jar（根据自身使用的 mysql 版本来定）存放进去。</p><p>接着在 solr-6.2.0\server\solr\cqa\conf\solrconfig.xml 中指明该 jar 包的位置，具体配置如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:../../../..&#125;/ext/mysql"</span> <span class="attr">regex</span>=<span class="string">".*\.jar"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">"$&#123;solr.install.dir:../../../..&#125;/dist/"</span> <span class="attr">regex</span>=<span class="string">"solr-dataimporthandler-\d.*\.jar"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>2）然后需在 solr-6.2.0\server\solr\cqa\conf 目录创建 solr-data-config.xml 配置文件，用于配置连接 mysql 数据库的信息，具体内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"JdbcDataSource"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">driver</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost/izhihu?useSSL=false&amp;amp;characterEncoding=utf-8&amp;amp;serverTimezone=Asia/Shanghai"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">user</span>=<span class="string">"root"</span> </span></span><br><span class="line"><span class="tag">              <span class="attr">password</span>=<span class="string">"abc123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">document</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entity</span> <span class="attr">name</span>=<span class="string">"question"</span>  <span class="attr">query</span>=<span class="string">"select id,title,content from question"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"content"</span> <span class="attr">name</span>=<span class="string">"question_content"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"title"</span> <span class="attr">name</span>=<span class="string">"question_title"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着需要同样需要在 solr-6.2.0\server\solr\cqa\conf\solrconfig.xml 中指明该 xml 配置文件的位置，具体配置内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"/dataimport"</span> <span class="attr">class</span>=<span class="string">"solr.DataImportHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span>solr-data-config.xml<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">lst</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后按下图所示，完成数据的导入：<br><img src="/2020/03/06/Solr全文搜索服务器的使用/1583477358541.png" alt="1583477358541"></p><h2 id="7-运行-core-实例"><a href="#7-运行-core-实例" class="headerlink" title="7. 运行 core 实例"></a>7. 运行 core 实例</h2><p>在 solr 配置完毕之后，下面就需要运行 core 实例，验证其是否能够正确返回我们的数据，具体验证步骤和执行结果如下所示：</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583479095676.png" alt="1583479095676"></p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583479149410.png" alt="1583479149410"></p><p>另外，我们也可以对查询出来匹配的关键词进行高亮显示，具体执行步骤和执行结果如下所示：</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583479557454.png" alt="1583479557454"></p><h2 id="8-整合-Java-项目"><a href="#8-整合-Java-项目" class="headerlink" title="8. 整合 Java 项目"></a>8. 整合 Java 项目</h2><p>与 Redis 类似，Solr 全文搜索服务器同样可以与 Java 进行整合，下面我们具体来介绍一下 solr 是如何与 Java （SpringBoot 项目）进行整合的吧。</p><h3 id="8-1-导入依赖"><a href="#8-1-导入依赖" class="headerlink" title="8.1 导入依赖"></a>8.1 导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- solr 相关依赖导入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.solr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>solr-solrj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2-Service-层实现"><a href="#8-2-Service-层实现" class="headerlink" title="8.2 Service 层实现"></a>8.2 Service 层实现</h3><p>如下代码所示，是与  Java 调用 solr 全文搜索服务器的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Solr 服务器访问地址*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SOLR_URL = <span class="string">"http://127.0.0.1:8983/solr/cqa"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 连接 Solr 服务器*/</span></span><br><span class="line">    <span class="keyword">private</span> HttpSolrClient client = <span class="keyword">new</span> HttpSolrClient.Builder(SOLR_URL).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUESTION_TITLE_FIELD = <span class="string">"question_title"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUESTION_CONTENT_FIELD = <span class="string">"question_content"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Question&gt; <span class="title">searchQuestion</span><span class="params">(String keyword, <span class="keyword">int</span> offset, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         String hlPre, String hlPos)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Question&gt; questionList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以搜索关键词为参数新建 solr 查询对象</span></span><br><span class="line">        SolrQuery query = <span class="keyword">new</span> SolrQuery(keyword);</span><br><span class="line">        <span class="comment">// 设置搜索行数 + 偏移</span></span><br><span class="line">        query.setRows(count);</span><br><span class="line">        query.setStart(offset);</span><br><span class="line">        <span class="comment">// 启动高亮，并设置匹配关键词的前后标签，如&lt;em&gt;和&lt;/em&gt;</span></span><br><span class="line">        query.setHighlight(<span class="keyword">true</span>);</span><br><span class="line">        query.setHighlightSimplePre(hlPre);</span><br><span class="line">        query.setHighlightSimplePost(hlPos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 hl.fl，以支持索引问题标题和问题内容</span></span><br><span class="line">        query.set(<span class="string">"hl.fl"</span>, QUESTION_TITLE_FIELD + <span class="string">","</span> + QUESTION_CONTENT_FIELD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行 solr 查询，查询结果存储在 QueryResponse 对象中</span></span><br><span class="line">        QueryResponse response = client.query(query);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取和封装 solr 高亮查询的结果</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Map&lt;String, List&lt;String&gt;&gt;&gt; entry : response.getHighlighting().entrySet()) &#123;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> questionList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高亮查询结果在前端的显示结果如下所示：</p><p><img src="/2020/03/06/Solr全文搜索服务器的使用/1583481539199.png" alt="1583481539199"></p>]]></content>
      
      
      <categories>
          
          <category> Solr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Solr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyspider爬虫框架使用</title>
      <link href="/2020/02/12/Pyspider%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/12/Pyspider%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>PySpider 是一个基于 Python 的爬虫框架，也就是使用该框架需要懂得一定的 Python 语言。关于 PySpider 的中文文档可以访问 <a href="https://www.cntofu.com/book/156/index.html" target="_blank" rel="noopener">pyspider中文文档</a>。</p><p>我们可以在 PySpider 提供的界面上编写和运行 Python 脚本，同时也支持 MySQL, MongoDB, Redis, SQLite, Elasticsearch各种数据库引擎。本文档将实现将 v2ex 中爬取的数据存放在 MySQL 数据库中。下面就先开始从 PySpider 的环境安装开始吧。</p><a id="more"></a><h2 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2. 环境安装"></a>2. 环境安装</h2><p>下面介绍一下在 Windows 10 中 PySpider 的安装，当然由于 PySpider 是基于 Python 的，所以也自然需要先安装 Python，这里我们选择 Python 2.7  32bit。在安装 PySpider 的安装过程中还会涉及到许多插件的安装以及配置的修改。下面就开始一步一步的安装 PySpider 吧。 </p><h3 id="2-1-Python-2-7-安装"><a href="#2-1-Python-2-7-安装" class="headerlink" title="2.1 Python 2.7 安装"></a>2.1 Python 2.7 安装</h3><ol><li><p>首先是到<a href="https://www.python.org/downloads/release/python-2712" target="_blank" rel="noopener">官网</a>中下载对应的 Python 安装包，具体位置如下所示：</p><p> <img src="/2020/02/12/Pyspider爬虫框架使用/1581499599686.png" alt></p></li><li><p>然后运行一直 next 即可，然后就是进行环境变量的配置。在 path 中添加如下环境变量，具体路径根据具体情况而定。</p><p> <img src="/2020/02/12/Pyspider爬虫框架使用/1581499780494.png" alt></p></li><li><p>打开命令行窗口，输入 ‘python -V’，如果可以打印版本号，说明 Python 已经安装成功。如下所示：</p></li></ol><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581499922917.png" alt></p><h3 id="2-2-PySpider-安装"><a href="#2-2-PySpider-安装" class="headerlink" title="2.2 PySpider 安装"></a>2.2 PySpider 安装</h3><ol><li><p><strong>pip 安装</strong>：pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。Python 2.7.9 +  或 Python 3.4+  以上版本都自带 pip 工具。我们可以通过如下命令判断 pip 是否已经安装。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure><p> 如果没有进行 pip 的安装，可以通过如下命令进行安装。用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py   # 下载安装脚本</span><br><span class="line">$ sudo python get-pip.py    # 运行安装脚本</span><br></pre></td></tr></table></figure></li><li><p><strong>pycURL 安装</strong>：一般情况下在安装 python 的时候会自动安装好 pycURL。如果没有，那么首先需要到该<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">网站</a>中下载与 python 对应版本的安装文件，具体如下所示。这里我们选择  2.7 32bit 的版本。</p><p> <img src="/2020/02/12/Pyspider爬虫框架使用/1581501330882.png" alt></p><p> 然后在 cmd 窗口中输入如下命令完成 pycURL 的安装：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install 文件全路径</span><br><span class="line">比如：</span><br><span class="line">pip install D:\pycurl-7.43.0.3-cp27-cp27m-win32.whl</span><br></pre></td></tr></table></figure></li><li><p><strong>lxml 安装</strong>：同安装 pycURL 一样，我们需要安装 lxml。先到该<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">网站</a>中下载与 python 对应版本的安装文件，具体如下所示。这里我们同样选择  2.7 32bit 的版本。</p><p> <img src="/2020/02/12/Pyspider爬虫框架使用/1581504896133.png" alt></p></li><li><p><strong>VCForPython27.msi 和 mysql-connector-c-6.0.2-winx64.msi 安装</strong>，windows 直接双击运行即可。</p></li><li><p><strong>mysql-python 安装</strong>：安装的具体命令如下所示：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-python</span><br></pre></td></tr></table></figure></li><li><p><strong>phantomjs 安装</strong>：从<a href="http://phantomjs.org/download.html" target="_blank" rel="noopener">官网</a>中下载安装包，解压后将phantomjs.exe文件放到python根目录。</p></li><li><p>pyspider 安装：如下所示，我们可以使用如下命令安装 pyspider，具体命令如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyspider</span><br></pre></td></tr></table></figure><p> 安装的时候，发生了如下的错误：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deprecated option &apos;domaincontroller&apos;: use &apos;http_authenticator.domain_controller&apos; instead.</span><br></pre></td></tr></table></figure><p> 解决的方法是找到 pyspider 的安装位置（’Python27\Lib\site-packages\pyspider\webui\webdav.py’），修改文件的第 209 行即可。即把’’domaincontroller’: NeedAuthController(app),’ 改为如下语句：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'http_authenticator'</span>:&#123;</span><br><span class="line">    <span class="string">'HTTPAuthenticator'</span>:NeedAuthController(app),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p> 修改完成之后，还发生了如下的错误。本人目前在 Github 项目中的 issues 中或者在网上并没有找到相关的解决办法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ImportError: cannot import name DispatcherMiddleware</span><br></pre></td></tr></table></figure><p> 根据报错信息，修改了 ‘Python27\Lib\site-packages\pyspider\webui\app.py’ 该文件，将发生错误的地方使用 try catch 进行捕获，这并不会影响 PySpider 框架的运行。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> .webdav <span class="keyword">import</span> dav_app</span><br><span class="line"><span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">    logger.warning(<span class="string">'WebDav interface not enabled: %r'</span>, e)</span><br><span class="line">    dav_app = <span class="literal">None</span></span><br><span class="line"><span class="comment"># 第 63 行的位置</span></span><br><span class="line"><span class="keyword">if</span> dav_app:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> werkzeug.wsgi <span class="keyword">import</span> DispatcherMiddleware</span><br><span class="line">        application = DispatcherMiddleware(application, &#123;</span><br><span class="line">            <span class="string">'/dav'</span>: dav_app</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="keyword">except</span> ImportError <span class="keyword">as</span> e:</span><br><span class="line">        logger.warning(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><p> 至此，PySpider 框架的安装终于完成了，我们可以在命令行窗口中输入 ‘pyspider all’ 运行 PySpider 框架，并在浏览器上输入如下 URL 访问 PySpider：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://localhost:5000</span><br></pre></td></tr></table></figure><p> 访问后，浏览器会显示如下界面，下面我们开始介绍 PySpider 框架的使用。</p><p> <img src="/2020/02/12/Pyspider爬虫框架使用/1581519090597.png" alt></p></li></ol><h2 id="3-PySpider-使用"><a href="#3-PySpider-使用" class="headerlink" title="3. PySpider 使用"></a>3. PySpider 使用</h2><h3 id="3-1-项目创建"><a href="#3-1-项目创建" class="headerlink" title="3.1 项目创建"></a>3.1 项目创建</h3><p>如下所示，进行爬虫项目的创建，具体步骤如下所示：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581519393116.png" alt></p><p>项目创建完成之后，会进入如下页面，左侧是查看运行结果的地方，右侧则是编写具体的 python 脚本位置。</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581519623677.png" alt></p><h3 id="3-2-PySpider-语法"><a href="#3-2-PySpider-语法" class="headerlink" title="3.2 PySpider 语法"></a>3.2 PySpider 语法</h3><h4 id="3-2-1-PySpider-原生示例"><a href="#3-2-1-PySpider-原生示例" class="headerlink" title="3.2.1 PySpider 原生示例"></a>3.2.1 PySpider 原生示例</h4><p>查看上图，右侧是有默认生成的脚本代码。对于代码的含义具体如下的注释说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 告诉操作系统到 usr/bin/env 里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># python 脚本支持的编码</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Created on 2020-02-12 22:56:46</span></span><br><span class="line"><span class="comment"># Project: test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspider.libs.base_handler <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line">    crawl_config = &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 注解表明每 24 * 60 分钟即一天只爬取一次</span></span><br><span class="line"><span class="meta">    @every(minutes=24 * 60)</span></span><br><span class="line">    <span class="comment"># crawl方法中的第一个参数是爬取网站的入口地址，第二个参数则是调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span> </span><br><span class="line">        self.crawl(<span class="string">'https://www.v2ex.com'</span>, callback=self.index_page)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @config(age=10 * 24 * 60 * 60)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="comment"># doc 内的参数是爬取网站的第二个入口位置，比如 a[href^="https://v2ex.com/?tab="]</span></span><br><span class="line">        <span class="comment"># a[href^="http"]表示 href 属性以 http 开头的 a 元素</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="http"]'</span>).items():</span><br><span class="line">            <span class="comment"># 调用 detail_page 方法</span></span><br><span class="line">            self.crawl(each.attr.href, callback=self.detail_page)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @config(priority=2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment"># 返回爬取出来的 url 和 title 值</span></span><br><span class="line">            <span class="string">"url"</span>: response.url,</span><br><span class="line">            <span class="string">"title"</span>: response.doc(<span class="string">'title'</span>).text(),</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-PyQuery-之-Response"><a href="#3-2-2-PyQuery-之-Response" class="headerlink" title="3.2.2 PyQuery 之 Response"></a>3.2.2 PyQuery 之 Response</h4><p><a href="https://pythonhosted.org/pyquery/api.html" target="_blank" rel="noopener">PyQuery</a> 库是 JQuery 的 Python 实现，能够以 JQuery 的语法来操作解析 HTML 文档，易用性和解析速度都很好，和它差不多的还有BeautifulSoup，都是用来解析的。</p><p>在 PySpider 的使用中，Response 对象的使用是比较频繁的。PySpider 的<a href="http://docs.pyspider.org/en/latest/apis/Response/" target="_blank" rel="noopener">官网</a>就有关于 Response 的使用。下面我们仅列出 Response 常用的几个方法，具体如下所示：</p><table><thead><tr><th>方法/属性</th><th>描述</th></tr></thead><tbody><tr><td>doc</td><td>Html 查找 PyQuery 对象</td></tr><tr><td>url</td><td>对应链接</td></tr><tr><td>text</td><td>文本</td></tr><tr><td>header</td><td>返回的header</td></tr><tr><td>cookies</td><td>下发cookie</td></tr></tbody></table><h4 id="3-2-3-CSS-选择器"><a href="#3-2-3-CSS-选择器" class="headerlink" title="3.2.3 CSS 选择器"></a>3.2.3 CSS 选择器</h4><p>使用 PySpider 编写 Python 爬虫脚本的时候，需要使用到 CSS 选择器，CSS 选择器的作用即是用于解析页面上的 html 元素，关于 CSS 选择器的参考资料可以访问该<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">网站</a>。 下面我罗列了常用 CSS 选择器语法，具体如下所示：</p><table><thead><tr><th>选择器</th><th>描述</th></tr></thead><tbody><tr><td>.class</td><td>class=“class”</td></tr><tr><td>#id</td><td>&lt;p id=”id”&gt;</td></tr><tr><td>div.inner</td><td>&lt;div class=”inner”&gt;</td></tr><tr><td>a[href^=“http://”]</td><td>带http开头href的a元素</td></tr><tr><td>p div</td><td>p元素下的div元素（不必父子）</td></tr><tr><td>p&gt;div&gt;span</td><td>p元素下的div元素下的span</td></tr><tr><td>[target=_blank]</td><td>Target=_blank</td></tr></tbody></table><h3 id="3-3-爬虫实例"><a href="#3-3-爬虫实例" class="headerlink" title="3.3 爬虫实例"></a>3.3 爬虫实例</h3><p>下面我们将爬取 v2ex 网站中帖子的标题和内容，爬虫的代码具体如下所示，具体的爬虫实现需要参考爬取的网页 HTML 结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Created on 2020-02-11 22:30:08</span></span><br><span class="line"><span class="comment"># Project: v2ex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pyspider.libs.base_handler <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line">    crawl_config = &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化连接数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 参数分别为本地IP、数据库用户名、数据库密码、数据库名称、编码</span></span><br><span class="line">        self.db = MySQLdb.connect(<span class="string">'localhost'</span>, <span class="string">'root'</span>, <span class="string">'abc123'</span>, <span class="string">'izhihu'</span>, charset=<span class="string">'utf8'</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 添加问题</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_question</span><span class="params">(self, title, content)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">## 获取数据库游标</span></span><br><span class="line">            cursor = self.db.cursor()</span><br><span class="line">            sql = <span class="string">'insert into question(title, content, user_id, created_date, comment_count) values("%s", "%s", %d, now(), 0)'</span> % (title, content, random.randint(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">            <span class="keyword">print</span> sql</span><br><span class="line">            cursor.execute(sql)</span><br><span class="line">            self.db.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            <span class="keyword">print</span> e</span><br><span class="line">            self.db.rollback()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @every(minutes=24 * 60) # 限制每天只执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># validate_cert=False 避免因为 SSL 安全机制导致的访问限制</span></span><br><span class="line">        self.crawl(<span class="string">'https://v2ex.com/'</span>, callback=self.index_page,validate_cert=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @config(age=10 * 24 * 60 * 60)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="https://v2ex.com/?tab="]'</span>).items():</span><br><span class="line">            self.crawl(each.attr.href, callback=self.tab_page, validate_cert=<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line"><span class="meta">    @config(priority=2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tab_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="https://v2ex.com/go/"]'</span>).items():</span><br><span class="line">            self.crawl(each.attr.href, callback=self.board_page, validate_cert=<span class="literal">False</span>)</span><br><span class="line">            </span><br><span class="line"><span class="meta">    @config(priority=2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">board_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="https://v2ex.com/t/"]'</span>).items():</span><br><span class="line">            <span class="comment"># 去掉路径形如 #reply12 的后缀</span></span><br><span class="line">            url = each.attr.href</span><br><span class="line">            <span class="keyword">if</span> (url.find(<span class="string">'#reply'</span>) &gt; <span class="number">0</span>):</span><br><span class="line">                url = url[<span class="number">0</span>:url.find(<span class="string">'#'</span>)] <span class="comment"># 类似 Java 的 subString 方法</span></span><br><span class="line">            self.crawl(url, callback=self.detail_page, validate_cert=<span class="literal">False</span>)</span><br><span class="line">        <span class="comment">## 翻页,然后回调本身的方法</span></span><br><span class="line">        <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a.page_normal'</span>).items():</span><br><span class="line">            self.crawl(each.attr.href, callback = self.board_page, validate_cert=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @config(priority=2)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detail_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">        title = response.doc(<span class="string">'h1'</span>).text()</span><br><span class="line">        content = response.doc(<span class="string">"div.markdown_body"</span>).html()</span><br><span class="line">        <span class="comment">## 添加问题</span></span><br><span class="line">        self.add_question(title, content)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">"url"</span> : response.url,</span><br><span class="line">            <span class="string">"title"</span>: response.doc(<span class="string">'title'</span>).text()</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>下面我们结合这 v2ex 网站来分析一下上述脚本的具体作用，查看如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@config(age=10 * 24 * 60 * 60)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="https://v2ex.com/?tab="]'</span>).items():</span><br><span class="line">        self.crawl(each.attr.href, callback=self.tab_page, validate_cert=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>‘a[href^=”<a href="https://v2ex.com/?tab=&quot;]&#39;" target="_blank" rel="noopener">https://v2ex.com/?tab=&quot;]&#39;</a> 表示爬取页面的第二个入口，即 v2ex 主页上的一个标签栏，具体如下图所示：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581561253385.png" alt></p><p>观察如下代码，同上面的一样，’a[href^=”<a href="https://v2ex.com/go/&quot;]&#39;是爬虫的第三个入口，以" target="_blank" rel="noopener">https://v2ex.com/go/&quot;]&#39;是爬虫的第三个入口，以</a> go 开头。具体如下图所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@config(priority=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tab_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="https://v2ex.com/go/"]'</span>).items():</span><br><span class="line">        self.crawl(each.attr.href, callback=self.board_page, validate_cert=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581561399620.png" alt></p><p>观察如下代码，’a[href^=”<a href="https://v2ex.com/t/&quot;]&#39;" target="_blank" rel="noopener">https://v2ex.com/t/&quot;]&#39;</a> 为第四个入口，这里已经到达具体的文章链接了，如下图所示。对于文章链接我们这里需要将形如 #reply12 的后缀去掉，然后在调用 detail_page 方法获取我们需要的数据，即帖子的标题和内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@config(priority=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">board_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a[href^="https://v2ex.com/t/"]'</span>).items():</span><br><span class="line">        <span class="comment"># 去掉路径形如 #reply12 的后缀</span></span><br><span class="line">        url = each.attr.href</span><br><span class="line">        <span class="keyword">if</span> (url.find(<span class="string">'#reply'</span>) &gt; <span class="number">0</span>):</span><br><span class="line">            url = url[<span class="number">0</span>:url.find(<span class="string">'#'</span>)] <span class="comment"># 类似 Java 的 subString 方法</span></span><br><span class="line">        self.crawl(url, callback=self.detail_page, validate_cert=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment">## 翻页,然后回调本身的方法</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> response.doc(<span class="string">'a.page_normal'</span>).items():</span><br><span class="line">        self.crawl(each.attr.href, callback = self.board_page, validate_cert=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581561492558.png" alt></p><p>观察上面涉及翻页然后回调本身的方法的代码，这里涉及到翻页的操作，具体体现如下图所示。每一页都是由 p = 页码 来表示。要进行具体的翻页操作，自然需要获取翻页的链接。我们可以查看页面元素，如图2所示。我们发现翻页链接都是存放在 a 标签 calss 名为 page_normal 下的，因此我们可以通过 ‘response.doc(‘a.page_normal’)’ 来获取。</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581562027881.png" alt="图1"></p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581562276252.png" alt="图2"></p><p>观察如下代码，这是爬虫的最后一步，在该方法中可以获取帖子的标题和内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@config(priority=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail_page</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    title = response.doc(<span class="string">'h1'</span>).text()</span><br><span class="line">    content = response.doc(<span class="string">"div.markdown_body"</span>).html()</span><br><span class="line">    <span class="comment">## 添加问题，然后插入数据库中</span></span><br><span class="line">    self.add_question(title, content)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">"url"</span> : response.url,</span><br><span class="line">        <span class="string">"title"</span>: response.doc(<span class="string">'title'</span>).text()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中我们可以通过 response.doc(‘h1’).text() 获取帖子的标题，这需要根据具体的页面元素而定。v2ex 的页面定义如下图所示：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581563817457.png" alt></p><p>同理我们通过 response.doc(“div.markdown_body”).html() 获取帖子的内容，帖子的内容具体即存放在 class 为 markdown_body 的 div 下中，具体如下图所示：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564006425.png" alt></p><h3 id="3-4-数据爬取"><a href="#3-4-数据爬取" class="headerlink" title="3.4 数据爬取"></a>3.4 数据爬取</h3><p>在 python 爬虫脚本编写完成之后，需要进行界面的操作，以此进行数据的爬取。在 PySpider 界面操作的时候，可以分为手动点击数据爬取和自动的爬取。下面就讲解一下相关的内容。</p><h4 id="3-4-1-手动操作"><a href="#3-4-1-手动操作" class="headerlink" title="3.4.1 手动操作"></a>3.4.1 手动操作</h4><p>如下所示，点击 run 之后，界面下方会出现 follows 的红点标识：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564452748.png" alt></p><p>接着点击 follows ，然后点击执行，具体如下图所示：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564525041.png" alt></p><p>如下图所示，页面显示的内容是根据我们编写的爬虫脚本代码进行的，当进入的具体的帖子页面的时候，则完成数据的入库操作。</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564556595.png" alt></p><p>如下图所示，数据完成入库操作，打印出执行的 SQL 语句。</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564674701.png" alt></p><h4 id="3-4-2-自动操作"><a href="#3-4-2-自动操作" class="headerlink" title="3.4.2 自动操作"></a>3.4.2 自动操作</h4><p>当然我们也可以让 PySpider 进行数据的自动爬取，如下图所示，更改执行状态，然后点击 run 进行执行，并点击 Active Tasks 查看具体的执行过程。</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564828345.png" alt></p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564978045.png" alt="执行过程任务列表"></p><p>我们还可以更改爬取的频率，如下图所示，我将频率更改为每秒钟 0.1 次：</p><p><img src="/2020/02/12/Pyspider爬虫框架使用/1581564947116.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）MyBatis学习笔记-HelloWorld</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HelloWorld/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HelloWorld/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p><img src="/2020/01/05/（二）MyBatis学习笔记-HelloWorld/20190117152522817.png" alt="在这里插入图片描述"><br>创建项目MyBatis_01，然后创建源码包config用来存放项目所用到的配置文件并首先创建日志文件log4j.xml。创建lib文件夹用来存放所需用到的Jar。</p><a id="more"></a><p>其中log4j.xml的内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">"http://jakarta.apache.org/log4j/"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m  (%F:%L) \n"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"info"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-数据库表创建"><a href="#2-数据库表创建" class="headerlink" title="2. 数据库表创建"></a>2. 数据库表创建</h2><p>使用MySQL创建如下数据库表<br><img src="/2020/01/05/（二）MyBatis学习笔记-HelloWorld/20190117152930698.png" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl_employee (</span><br><span class="line">  id int(11) PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  last_name varchar(255) ,</span><br><span class="line">  gender char(1) ,</span><br><span class="line">  email varchar(255) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-POJO编写"><a href="#3-POJO编写" class="headerlink" title="3. POJO编写"></a>3. POJO编写</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;<span class="comment">//该属性和数据库表的对应字段名last_name不同</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String lastName, String gender, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Employee [id="</span> + id + <span class="string">", lastName="</span> + lastName + <span class="string">", gender="</span> + gender + <span class="string">", email="</span> + email + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-MyBatis全局配置文件创建"><a href="#4-MyBatis全局配置文件创建" class="headerlink" title="4. MyBatis全局配置文件创建"></a>4. MyBatis全局配置文件创建</h2><p>mybatis-config.xml主要是配置一些最基本的上下文参数和运行环境。内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 配置事务管理器，采用的是JDBC的管理器方式 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--  POOLED代表采用MyBatis内部提供的连接池方式 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"abc123!"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--  引入映射器 包名+文件名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"EmployeeMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-映射器创建"><a href="#5-映射器创建" class="headerlink" title="5. 映射器创建"></a>5. 映射器创建</h2><p>映射器实现将SQL查询到的结果映射为一个POJO，或者将POJO的数据插入到数据库中，并定义一些关于缓存等的重要内容。</p><p>首先先编写映射器接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mybatis.bean.Employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步则是编写XML映射文件EmployeeMapper.xml，内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">1.namespace为命名空间,为映射接口的全类名</span></span><br><span class="line"><span class="comment">2.id为唯一标识，与EmployeeMapper接口中的对应方法名相同</span></span><br><span class="line"><span class="comment">3.resultType为查询后的返回类型</span></span><br><span class="line"><span class="comment">4.#&#123;id&#125;指从传递过来的参数中取出id值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.atguigu.mybatis.mapper.EmployeeMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpById"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">    select id,lastName, gender, email from tbl_employee where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">        SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">        <span class="comment">//2.获取session实例开启会话，其能直接执行*已经映射的SQL语句*</span></span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">            EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">            <span class="comment">//4.执行查询操作</span></span><br><span class="line">            Employee employee = employeeMapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭会话session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（二）MyBatis学习笔记-HelloWorld/2019011716144699.png" alt="在这里插入图片描述"><br>注意：运行后lastName的值为空，这是因为我们在Employee类中的lastName属性和数据库的last_name字段名称不同，这里我们可以更改EmployeeMapper文件中的select语句为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125;</span><br></pre></td></tr></table></figure><p>后面讲到配置文件时可以用标签属性的设置来更为方便地处理这个问题。</p><hr><p>补充：我们也可以使用<strong>注解</strong>来实现映射器<br>使用注解的方式只需要一个接口就可以注入SQL。首先编写EmployeeMapperAnnoation接口文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapperAnnoation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select id,last_name lastName, gender, email from tbl_employee where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">selectEmp</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在基本配置文件中引入映射器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.atguigu.mybatis.mapper.EmployeeMapperAnnoation"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapperAnnoation employeeMapper = session.getMapper(EmployeeMapperAnnoation.class);</span><br><span class="line">        <span class="comment">//4.执行查询操作</span></span><br><span class="line">        Employee employee = employeeMapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）MyBatis学习笔记-MyBatis配置</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>全局配置文件的元素顺序：</strong><br>properties, settings, typeAliases, typeHandlers, objectFactory, objectWrapperFactory, reflectorFactory, plugins, environments, databaseIdProvider, mappers</p><h2 id="1-properties属性"><a href="#1-properties属性" class="headerlink" title="1. properties属性"></a>1. properties属性</h2><p>properties属性可以给系统配置一些运行参数，可以放在XML文件或者properties文件中。</p><p>在上一次学习笔记中，我们是将MySQL数据库的一些信息直接写在全局配置文件中，下面我们将这些数据库的一些信息抽取出来。</p><p>首先编写properties文件dbconfig.properties：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## MySQL数据库配置</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=abc123!</span><br><span class="line"></span><br><span class="line">## Oracle数据库配置</span><br><span class="line">orcl.driver=oracle.jdbc.OracleDriver</span><br><span class="line">orcl.url=jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class="line">orcl.username=scott</span><br><span class="line">orcl.password=tiger</span><br></pre></td></tr></table></figure><p>全局配置文件mybatis-config.xml的部分内容如下：<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117174131382.png" alt="在这里插入图片描述"><br>注意：properties元素的resource用于引入properties文件；url则用于引入网络路径或磁盘路径下的文件。</p><h2 id="2-settings设置"><a href="#2-settings设置" class="headerlink" title="2. settings设置"></a>2. settings设置</h2><p>settings是MyBatis中最复杂的配置，它能深刻影响MyBatis底层的运行，但是在大部分情况下使用默认便可以运行，所以在大部分情况下不需要大量配置它，值需要修改一下一些常用的规则即可，比如自动映射、驼峰命名映射、级联规则、是否启动缓存和执行器类型等。以下是一些配置项说明：<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117191936736.png" alt="在这里插入图片描述"><br>在上一篇笔记中，在编写POJO类Employee类的lastName属性时命名与数据库表的字段last_name不同而造成在查询所有时lastName属性为空。下面通过在全局配置文件中使用settings的mapUnderscoreToCamelCase配置项来处理这个问题。<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/2019011719292546.png" alt="在这里插入图片描述"><br>其中name为配置项名称，value为对应的值。</p><h2 id="3-typeAliases别名"><a href="#3-typeAliases别名" class="headerlink" title="3. typeAliases别名"></a>3. typeAliases别名</h2><p>由于类的全限定名称很长，需要大量使用的时候，总写那么长的名称不方便。比如在如下的映射文件中，全限定名称是比较长的。<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117193430875.png" alt="在这里插入图片描述"><br>在MyBatis中允许定义一个简写来代表这个类，这就是别名。注意，在MyBatis中别名是不去等大小写的。</p><h3 id="3-1-自定义别名"><a href="#3-1-自定义别名" class="headerlink" title="3.1 自定义别名"></a>3.1 自定义别名</h3><h4 id="3-1-1-单个起别名"><a href="#3-1-1-单个起别名" class="headerlink" title="3.1.1 单个起别名"></a>3.1.1 单个起别名</h4><p>比如，我需要为上方的com.atgui.mubatis.bean.Employee类起个别名，可以采用如下操作。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置自定义别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也就是在Mybatis的全局配置文件mybatis-config.xml添加如上的配置语句。其中type的内容时需要起别名的类的全定限名。上面的配置默认其别名为Employee的小写，也就是employee。</p><p>进行如上配置后，在映射文件就可以进行如下编写了。<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117194747290.png" alt="在这里插入图片描述"><br>另外typeAlias还有一个alias属性，其内容为自定义别名。如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置自定义别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span> <span class="attr">alias</span>=<span class="string">"emp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-1-2-批量起别名"><a href="#3-1-2-批量起别名" class="headerlink" title="3.1.2 批量起别名"></a>3.1.2 批量起别名</h4><p>批量起别名即可以为当前包以及下面所有后带包的每一类都起一个<strong>默认别名</strong>（类名小写）。具体应用如下示：<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117195725241.png" alt="在这里插入图片描述"><br>name中的值为需要进行起别名的包名。</p><p>假设在该包及其子包内有相同的类，那么只使用package进行配置是不够的，因为这样会有出现别名冲突。这个时候可以使用MyBatis提供的注解@Alias(“emp”)来进行区分。如下示：<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117200218647.png" alt="在这里插入图片描述"></p><h3 id="3-2-系统定义别名"><a href="#3-2-系统定义别名" class="headerlink" title="3.2 系统定义别名"></a>3.2 系统定义别名</h3><p>系统定义别名为系统自定义号的别名，因此我们自定义的别名是不可以和这些系统定义别名相同的，它们都是大小写不敏感的。如下展示一些系统定义别名。<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/2019011720053628.png" alt="在这里插入图片描述"></p><h2 id="4-typeHandlers类型处理器简介"><a href="#4-typeHandlers类型处理器简介" class="headerlink" title="4. typeHandlers类型处理器简介"></a>4. typeHandlers类型处理器简介</h2><p>在JDBC中，需要在PreparedStatement对象中设置哪些已经预编译的SQL语句的参数。执行SQL后，会通过ResultSet对象获取得到数据库的数据，而这些MyBatis是根据数据的类型typeHandler来实现的。在typeHandler中，分为jdbcType和javaType，其中jdbcType用于定义数据库类型，而javaType用于定义Java类型，那么typeHandler的作用就是承担jdbcType和javaType之间的相互转换。具体的内容后续在讲。</p><h2 id="5-plugins插件简介"><a href="#5-plugins插件简介" class="headerlink" title="5. plugins插件简介"></a>5. plugins插件简介</h2><p>插件是MyBatis中最强大和灵活的组件，同时也是最复杂和最难以使用的组件，因为它将覆盖MyBatis底层对象的核心方法和属性。后续讲了MyBatis的底层构成和运行机制后才能讲解这部分内容。</p><h2 id="6-environments环境"><a href="#6-environments环境" class="headerlink" title="6. environments环境"></a>6. environments环境</h2><p>表示运行环境，主要作用是配置数据库的信息，它可以配置多个数据库，不过一般而言只需要配置其中一个就可以了。</p><p>假设我使用MySQL数据进行开发，而测试人员则使用ORACLE数据库进行测试，那么我就可以定义如下两套环境来进行对应的操作。<br><img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117203000142.png" alt="在这里插入图片描述"><br>environments标签中的default属性是用来指定使用某种环境的，比如上面的配置信息中的defafault的值是development说明使用的是MySQL数据库的环境。通过改变default的值可以快速的切换环境。</p><h3 id="6-1-transactionManager事务管理器"><a href="#6-1-transactionManager事务管理器" class="headerlink" title="6.1 transactionManager事务管理器"></a>6.1 transactionManager事务管理器</h3><p>在MyBatis中，transactionManager提供了两个实现类，它需要实现接口Transaction（org.apache.ibatis.transaction）。Transaction有两个实现类：JdbcTransaction和ManagerTransaction。于是它对应两种工厂：JdbcTransactionFactory和ManagerTransactionFactory，这两个工厂实现TransactionFactory接口，通过他们会生成对应的Transaction对象。因此事务管理器有如下两种方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"MANAGED"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>JDBC对应的类为JdbcTransaction，它是以JDBC的方式对数据库的提交和回滚进行操作。</li><li>MANAGED对应的类为ManagedTransaction，它将事务交由容器处理。</li></ul><p>另外可以通过实现TransactionFactory接口来自定义事务管理器。其中的type为全类名。</p><h3 id="6-2-dataSource数据源"><a href="#6-2-dataSource数据源" class="headerlink" title="6.2 dataSource数据源"></a>6.2 dataSource数据源</h3><p>数据源类型主要有三种：UNPOOLED(UnpooledDataSourceFactory)，POOLED(PooledDataSourceFactory)和JNDI(JndiDataSourceFactory)。</p><p>自定义数据源需要实现DataSourceFactory接口，其中type是全类名。</p><h3 id="6-4-databaseIdProvider数据库提供商"><a href="#6-4-databaseIdProvider数据库提供商" class="headerlink" title="6.4 databaseIdProvider数据库提供商"></a>6.4 databaseIdProvider数据库提供商</h3><p>databaseIdProvider的作用就是得到数据库厂商的标识（由驱动提供），mybatis就能根据数据库厂商的标识来执行不同的sql。tyep的为DB_VENDOR，对应的类为VendorDatabaseIdProvider。</p><p>下面来实现一下根据不同的数据库厂商来执行不同的代码</p><ol><li><p>首先在全局配置文件做如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置数据库厂商标识 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"MySQL"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Oracle"</span> <span class="attr">value</span>=<span class="string">"oracle"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"DB2"</span> <span class="attr">value</span>=<span class="string">"db2"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>properties元素的属性name是数据库的名称，属性value是它的一个别名。</p></li><li><p>在映射文件作如下操作<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117212716283.png" alt="在这里插入图片描述"><br> 就是添加一个databaseId属性，其中的值mysql即为之前在全局配置文件中的别名。添加这个属性之后，说明这个SQL语句对应的是MySQL数据库执行的。</p></li></ol><h3 id="6-5-mappers映射注册"><a href="#6-5-mappers映射注册" class="headerlink" title="6.5 mappers映射注册"></a>6.5 mappers映射注册</h3><p>这个标签就是用来引入映射器的。</p><ol><li><p>用文件路径引入映射器，形如：<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117222206599.png" alt="在这里插入图片描述"></p></li><li><p>引用网络路径或磁盘路径下的SQL映射文件，形如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">uri</span>=<span class="string">"file:///var/mappers/AuthorMapper.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用注册接口，比如通过注解来实现的映射接口，形如：<br> 其中使用注解注册的接口即为如下形式的接口：<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117222725105.png" alt="在这里插入图片描述"><br> 对应的引入方式为：<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117222837660.png" alt="在这里插入图片描述"> </p></li><li><p>用包名引入映射器，形如：<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117223215245.png" alt="在这里插入图片描述"><br> 注意：使用包名来实现批量映射器的引入，一般情况下需要将映射文件放在对应的包下，<strong>且映射器文件名与映射接口名必须相同，这可能也就是mybatis逆向工程自动生成接口和映射文件自动命名为*Mapper的原因。</strong> 如下示：<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117223443287.png" alt="在这里插入图片描述"><br> 但是这样又会导致java文件和xml文件放在一个包下，容易混乱也不容易维护。我们可以使用如下的方法来解决这个问题，也就是在config下创建一个一样的包来存放EmployeeMapper.xml映射文件。如下所示：<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/2019011722382449.png" alt="在这里插入图片描述"><br> 因为源码文件夹下的文件都会合并在类路径下。<br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117224041100.png" alt="在这里插入图片描述"><br> <img src="/2020/01/05/（三）MyBatis学习笔记-MyBatis配置/20190117224110484.png" alt="在这里插入图片描述"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）MyBatis学习笔记-MyBatis映射器</title>
      <link href="/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis%E6%98%A0%E5%B0%84%E5%99%A8/"/>
      <url>/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis%E6%98%A0%E5%B0%84%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>下面显示的是元素的一些属性：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118113710970.png" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="1-update元素和delete元素"><a href="#1-update元素和delete元素" class="headerlink" title="1. update元素和delete元素"></a>1. update元素和delete元素</h2><ol><li><p>首先在映射接口中添加用于更新和删除的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateEmp</span><span class="params">(Employee emp)</span></span>;</span><br><span class="line"><span class="comment">//删除方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteEmpById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后在映射器文件中添加对应的sql配置信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 参数类型可以省略 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmp"</span> <span class="attr">parameterType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line"> update tbl_employee set last_name=#&#123;lastName&#125;,gender=#&#123;gender&#125;,email=#&#123;email&#125; where id=#&#123;id&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteEmpById"</span>&gt;</span></span><br><span class="line"> delete from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);<span class="comment">//设置默认不提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.测试删除方法</span></span><br><span class="line">        <span class="keyword">boolean</span> isDelete = employeeMapper.deleteEmpById(<span class="number">3</span>);<span class="comment">//输出true或者false</span></span><br><span class="line">        System.out.println(isDelete);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.手动提交</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-insert元素-插入语句"><a href="#2-insert元素-插入语句" class="headerlink" title="2. insert元素-插入语句"></a>2. insert元素-插入语句</h2><h3 id="2-1-简单应用"><a href="#2-1-简单应用" class="headerlink" title="2.1 简单应用"></a>2.1 简单应用</h3><ol><li><p>首先在映射接口中添加用于插入的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmp</span><span class="params">(Employee emp)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后在映射器文件中添加对应的sql配置信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmp"</span>&gt;</span></span><br><span class="line"> insert into tbl_employee(last_name,gender,email) values(#&#123;lastName&#125;,#&#123;gender&#125;,#&#123;email&#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);<span class="comment">//设置默认不提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="comment">//4.测试添加</span></span><br><span class="line">        Employee emp = <span class="keyword">new</span> Employee(<span class="keyword">null</span>, <span class="string">"张三"</span>, <span class="string">"1"</span>, <span class="string">"zhangsan@gmail.com"</span>);</span><br><span class="line">        employeeMapper.addEmp(emp);</span><br><span class="line">        <span class="comment">//5.手动提交</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-获取自增主键的值"><a href="#2-2-获取自增主键的值" class="headerlink" title="2.2 获取自增主键的值"></a>2.2 获取自增主键的值</h3><p>MySQL支持自增主键，自增主键值的获取，MyBatis也是利用statement.getGenreatedKey();</p><p>MyBatis使用insert元素的useGenreatedKeys=”true”来使用自增主键获取主键值策略；<br>使用insert元素的keyProperty来指定对应的主键属性，也就是MyBatis获取到主键值以后，将这个值封装给javaBean的对应属性。</p><ol><li><p>修改映射器文件中的insert元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmp"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"> insert into tbl_employee(last_name,gender,email) values(#&#123;lastName&#125;,#&#123;gender&#125;,#&#123;email&#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);<span class="comment">//设置默认不提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="comment">//4.测试添加</span></span><br><span class="line">        Employee emp = <span class="keyword">new</span> Employee(<span class="keyword">null</span>, <span class="string">"张三"</span>, <span class="string">"1"</span>, <span class="string">"zhangsan@gmail.com"</span>);</span><br><span class="line">        employeeMapper.addEmp(emp);</span><br><span class="line">        <span class="comment">//输出员工的id</span></span><br><span class="line">        System.out.println(emp.getId());</span><br><span class="line">        <span class="comment">//5.手动提交</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-select元素-查询语句"><a href="#3-select元素-查询语句" class="headerlink" title="3. select元素-查询语句"></a>3. select元素-查询语句</h2><h3 id="3-1-参数处理"><a href="#3-1-参数处理" class="headerlink" title="3.1 参数处理"></a>3.1 参数处理</h3><h4 id="3-1-1单个参数"><a href="#3-1-1单个参数" class="headerlink" title="3.1.1单个参数"></a>3.1.1单个参数</h4><p>比如我要根据employee的id值来查询对应的员工，这时候对应的查询方法的参数只有一个，就是id值。在映射器中的对应SQL语句中，#{参数名}中的参数名MyBatis不做特殊处理，也就是该参数名可以随便取名。<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118090938321.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-多个参数"><a href="#3-1-2-多个参数" class="headerlink" title="3.1.2 多个参数"></a>3.1.2 多个参数</h4><h5 id="3-1-2-1-使用注解传递多个参数"><a href="#3-1-2-1-使用注解传递多个参数" class="headerlink" title="3.1.2.1 使用注解传递多个参数"></a>3.1.2.1 使用注解传递多个参数</h5><ol><li><p>首先在映射接口中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据员工id和姓名查询员工</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">gerEmpByIdAndName</span><span class="params">(Integer id, String lastName)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后在映射器文件中配置如下SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"gerEmpByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line"> select id,last_name,gender,email from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试之后会报如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cause: org.apache.ibatis.binding.BindingException: Parameter &apos;id&apos; not found. Available parameters are [0, 1, param1, param2]</span><br></pre></td></tr></table></figure><p>MyBatis在处理传入的多个参数时，会将多个参数封装成一个Map集合，对应的键值为：<br>key：param1…paramN，或者参数的索引0…N<br>value：我们传入的参数值<br>#{}就是从map中获取指定的key值，所以我们应该传入key值而不是value值。</p></li></ol><p>解决：<br>使用命名参数，即明确指定封装参数时map的key，封装后的map集合的key值为使用@Param注解指定的值，value为参数值。</p><p>修改映射接口，指定map集合的键即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据员工id和姓名查询员工</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">gerEmpByIdAndName</span><span class="params">(@Param(<span class="string">"id"</span>)</span>Integer id, @<span class="title">Param</span><span class="params">(<span class="string">"lastName"</span>)</span>String lastName)</span>;</span><br></pre></td></tr></table></figure><h5 id="3-1-2-2-通过POJO传递多个参数"><a href="#3-1-2-2-通过POJO传递多个参数" class="headerlink" title="3.1.2.2 通过POJO传递多个参数"></a>3.1.2.2 通过POJO传递多个参数</h5><ol><li><p>存在一个POJO-Employee<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118095129429.png" alt="在这里插入图片描述"></p></li><li><p>此时在映射接口定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据POJO查询员工</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByBean</span><span class="params">(Employee emp)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器配置如下SQL语句，这里是通过传入的Java Bean的id和lastName来查询。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByBean"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line"> select id,last_name,gender,email from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118095934798.png" alt="在这里插入图片描述"></p><h5 id="3-1-2-3-通过Map集合传递多个参数"><a href="#3-1-2-3-通过Map集合传递多个参数" class="headerlink" title="3.1.2.3 通过Map集合传递多个参数"></a>3.1.2.3 通过Map集合传递多个参数</h5></li><li><p>在映射接口定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据Map集合来查询员工</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByMap</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器中配置SQL信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByMap"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">  select id,last_name,gender,email from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118100810622.png" alt="在这里插入图片描述"></p><h5 id="3-1-2-4-混合使用"><a href="#3-1-2-4-混合使用" class="headerlink" title="3.1.2.4 混合使用"></a>3.1.2.4 混合使用</h5><p><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118101635841.png" alt="在这里插入图片描述"><br>注意：集合和数组都有默认的key。</p><h3 id="3-2-与-的异同"><a href="#3-2-与-的异同" class="headerlink" title="3.2 #{}与${}的异同"></a>3.2 #{}与${}的异同</h3><p>相同点：两者都可以获取map中的值或者pojo对象属性的值。<br>不同点：</p></li><li><p>#{}是以预编译的形式，将参数设置到sql语句中，类似于PreparedStatement，它可以防止sql注入。</p></li><li><p>${}是直接将取出的值拼接在sql语句中，类似于Statement，可能引发安全问题。</p><p>下面演示一下：</p><ol><li>映射器文件的sql配置如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByMap"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">  select id,last_name,gender,email from tbl_employee where id=#&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line"><span class="comment">//4.测试查询方法</span></span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"id"</span>, <span class="string">"1"</span>);</span><br><span class="line">map.put(<span class="string">"lastName"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">Employee emp = employeeMapper.getEmpByMap(map);</span><br><span class="line">System.out.println(emp);</span><br></pre></td></tr></table></figure></li><li><p>运行结果<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/2019011811235849.png" alt="在这里插入图片描述"><br> 从输出的sql语句可以看出占位符?是存在的。</p></li></ol><p>下面我们修改一下映射器文件的配置信息，更改为id=${id}：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByMap"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line"> select id,last_name,gender,email from tbl_employee where id=$&#123;id&#125; and last_name=#&#123;lastName&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次测试的输出结果为：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/2019011811270421.png" alt="在这里插入图片描述"></p><h3 id="3-3-的更多用法"><a href="#3-3-的更多用法" class="headerlink" title="3.3 ${}的更多用法"></a>3.3 ${}的更多用法</h3><p>比如我们需要按照年份进行分表拆分，然后使用传入的年份生成对应的表名，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from $&#123;year&#125;_salary where xxx;</span><br></pre></td></tr></table></figure><p>又比如我们通过字段名来对表的字段进行排序，那么我们也可以通过$来实现。如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from tbl_employee order by $&#123;last_name&#125; $&#123;order&#125;</span><br></pre></td></tr></table></figure><p>显然，原生JDBC不支持占位符的地方我们就可以使用${}来进行取值。</p><h3 id="3-4-的更多用法"><a href="#3-4-的更多用法" class="headerlink" title="3.4 #{}的更多用法"></a>3.4 #{}的更多用法</h3><p>#{}还可以规定参数的一些规则，比如javaType、 jdbcType、 mode、 numericScale、<br>resultMap、 typeHandler、 jdbcTypeName。</p><p>下面来讲一下jdbcType的用法。</p><p>在我们数据为null的时候，有些数据库可能不能识别mybatis对null的<strong>默认处理</strong>（MyBatis默认将null设置为OTHER类型），比如Oracle数据库就无法识别OTHER类型。</p><p>我们可以在某个插入为null的数据来使用jdbcType设置。比如我要进入如下数据库操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmp"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"> insert into tbl_employee(last_name,gender,email) values(#&#123;lastName&#125;,#&#123;gender&#125;,#&#123;email&#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是我在传入数据的时候，email的值是null，那么Oracle数据库是无法识别而报错的。我们可以更改为如下语句则可以解决这个问题：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118114725199.png" alt="在这里插入图片描述"><br>上面的配置只使用单条sql语句。我们可以在全局配置文件设置settings来实现全局配置，即：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118115056705.png" alt="在这里插入图片描述"></p><h3 id="3-5-查询返回数据封装"><a href="#3-5-查询返回数据封装" class="headerlink" title="3.5 查询返回数据封装"></a>3.5 查询返回数据封装</h3><h4 id="3-5-1-List封装查询到的数据"><a href="#3-5-1-List封装查询到的数据" class="headerlink" title="3.5.1 List封装查询到的数据"></a>3.5.1 List封装查询到的数据</h4><ol><li><p>在映射接口编写查询方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用List封装查询到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByLastNameLike</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器文件中编写指定的SQL配置，注意：<strong>返回类型是Employee对象</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByLastNameLike"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">  select id,last_name,gender,email from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);<span class="comment">//设置默认不提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="comment">//4.查询</span></span><br><span class="line">        List&lt;Employee&gt; empsList = employeeMapper.getEmpsByLastNameLike(<span class="string">"%张%"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : empsList) &#123;</span><br><span class="line">            System.out.println(employee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.手动提交</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-5-2-Map封装查询到的数据"><a href="#3-5-2-Map封装查询到的数据" class="headerlink" title="3.5.2 Map封装查询到的数据"></a>3.5.2 Map封装查询到的数据</h4><p>需求1：将Employee中的属性封装到一个Map中，其中key为Employee中的属性名，value为对应的值。</p><ol><li><p>编写映射接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Map封装查询到的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getEmpsByIdReturnMap</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器文件编写对应的SQL配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  返回类型是Map集合，map是系统自定义的别名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByIdReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EmployeeMapper employeeMapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line"><span class="comment">//4.查询</span></span><br><span class="line">Map&lt;String, Object&gt; empMap = employeeMapper.getEmpsByIdReturnMap(<span class="number">1</span>);</span><br><span class="line">System.out.println(empMap);</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;gender=<span class="number">1</span>, last_name=Tom, id=<span class="number">1</span>, email=shotozheng<span class="meta">@gmail</span>.com&#125;</span><br></pre></td></tr></table></figure><p>需求2：将多个Employee对象封装到Map集合中，其中key为Employee中的id属性值，value为Employee对象。</p></li><li><p>同样需要在映射接口编写方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Integer,Employee&gt; <span class="title">getEmpsByLastNameLikeReturnMap</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>注意：MapKey在于指定返回的Map集合的key为Employee的属性id</strong></p></li><li><p>在映射器接口编写SQL配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  注意：这里的返回类型是Employee对象 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByLastNameLikeReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line"> select * from tbl_employee where last_name like #&#123;lastName&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试即可，不再赘述。</p></li></ol><h2 id="4-resultMap元素"><a href="#4-resultMap元素" class="headerlink" title="4. resultMap元素"></a>4. resultMap元素</h2><p>比如我们在定义Java Bean时，POJO的属性名若与数据库表的字段名不一样则会导致查询出来的数据为null。我们之前是用通过给SQL的的字段命和POJO对应属性一样的名称或者通过驼峰命名法来处理这个问题。但是这些可能会导致SQL语句不好理解或者POJO中的属性名不符合驼峰命名法规范等问题。</p><p>那么现在我们可以使用resultMap来定义映射规则来处理这个问题，当然它还可以进行级联更新和定制类型转化器等功能。定义映射规则就是SQL到Java Bean的映射关系定义。</p><p>下面演示一下resultMap自定义结果的功能：</p><ol><li><p>创建一个POJO类Employee</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String lastName, String gender, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：类中lastName属性对应的数据库表tbl_employee字段last_name</strong></p></li><li><p>在映射接口EmployeePlus中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器文件EmployeePlus.xml文件定义如下SQL配置<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118162111237.png" alt="在这里插入图片描述"></p></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);<span class="comment">//设置默认不提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapperPlus mapper = session.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">        <span class="comment">//4.查询</span></span><br><span class="line">        Employee emp = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">        <span class="comment">//5.手动提交</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118162346688.png" alt="在这里插入图片描述"><br> 在进行了自定义映射配置之后，即使Java Bean的属性名与数据库表的字段不一样，也可以形成映射关系。</p></li></ol><h2 id="5-关联查询"><a href="#5-关联查询" class="headerlink" title="5. 关联查询"></a>5. 关联查询</h2><p>需求：在查询出员工对象的同时，查询出该员工所在的部门。</p><h3 id="5-1-级联属性封装结果集"><a href="#5-1-级联属性封装结果集" class="headerlink" title="5.1 级联属性封装结果集"></a>5.1 级联属性封装结果集</h3><ol><li><p>创建两个Java Bean，分别为员工类Employee和部门类Department</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Department dept; <span class="comment">//引用部门对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String lastName, String gender, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;<span class="comment">//部门编号</span></span><br><span class="line">    <span class="keyword">private</span> String departmentName;<span class="comment">//部门名称</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(Integer id, String departmentName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.departmentName = departmentName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建对应的数据库表tbl_employee和tbl_dept</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_employee (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  last_name <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  gender <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  email <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  d_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> FK_tbl_employee (d_id),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> FK_tbl_employee <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (d_id) <span class="keyword">REFERENCES</span> tbl_dept (<span class="keyword">id</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_dept(</span><br><span class="line"> <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line"> dept_name <span class="built_in">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>映射接口EmployeeMapperPlus中定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpAndDept</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>映射器文件EmployeeMapperPlus.xml进行如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 联合查询，**级联属性封装结果集** --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MyDifEmp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面的是关于部门表的内容，可以使用Employee的属性dept来引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"dept.id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"dept.departmentName"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询两个表的所有字段的值 resultMap的值即为上方resultMap元素的id--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpAndDept"</span> <span class="attr">resultMap</span>=<span class="string">"MyDifEmp"</span>&gt;</span></span><br><span class="line">    SELECT e.id id, e.last_name last_name,e.gender gender, e.email email,</span><br><span class="line">    e.d_id d_id, d.id did, d.dept_name dept_name FROM tbl_employee e, tbl_dept d</span><br><span class="line">    WHERE e.d_id=d.id AND e.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);<span class="comment">//设置默认不提交</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapperPlus mapper = session.getMapper(EmployeeMapperPlus.class);</span><br><span class="line">        <span class="comment">//4.查询</span></span><br><span class="line">        Employee emp = mapper.getEmpAndDept(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp);<span class="comment">//连同部门信息也会打印出来</span></span><br><span class="line">        <span class="comment">//5.手动提交</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚才对映射器文件EmployeeMapperPlus.xml进行配置时使用的是<strong>级联属性封装结果集</strong> 的方式，下面我们也可以使用<strong>association的方式</strong>来定义关联的单个对象的封装规则。</p><h3 id="5-2-association元素"><a href="#5-2-association元素" class="headerlink" title="5.2 association元素"></a>5.2 association元素</h3><h4 id="5-2-1-association嵌套结果集"><a href="#5-2-1-association嵌套结果集" class="headerlink" title="5.2.1 association嵌套结果集"></a>5.2.1 association嵌套结果集</h4><p>在原有的基础上，对映射器文件EmployeeMapperPlus.xml的resultMap元素进行如下更改配置：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118174753484.png" alt="在这里插入图片描述"></p><h4 id="5-2-2-association分步查询"><a href="#5-2-2-association分步查询" class="headerlink" title="5.2.2 association分步查询"></a>5.2.2 association分步查询</h4><p>我们还可以<strong>使用association来进行分步查询。</strong></p></li></ol><p>具体思路：</p><ol><li>先按照员工的id去查询员工的信息</li><li>根据查询员工信息中的d_id值去部门表查出部门信息  </li><li>将查询到的部门信息设置到员工信息中</li></ol><p>具体步骤：</p><ol><li><p>为了根据员工的id去查询员工的信息，我们需要先在映射接口EmployeeMapperPlus中定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmpByIdStep</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后需要在映射器文件EmployeeMapperPlus.xml文件进行如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查出员工的信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpByIdStep"</span> <span class="attr">resultMap</span>=<span class="string">"MyEmpByStep"</span>&gt;</span></span><br><span class="line">    select * from tbl_employee where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>因为需要根据员工信息中的d_id值去部门表查出部门信息 ，所以现在需要在映射接口DepartmentMapper中定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDeptById</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>同样地，在映射器文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.atguigu.mybatis.mapper.DepartmentMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptById"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Department"</span>&gt;</span></span><br><span class="line">        select id,dept_name departmentName from tbl_dept where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>对映射器文件EmployeeMapperPlus.xml做如下的resultMap元素配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span> <span class="attr">id</span>=<span class="string">"MyEmpByStep"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 员工基本属性信息映射配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- association定义关联对象的封装规则</span></span><br><span class="line"><span class="comment">property的内容的Employee关联的对象属性名dept</span></span><br><span class="line"><span class="comment">select表明当前属性调用select指定的方法查出的结果,内容的namespace+方法id</span></span><br><span class="line"><span class="comment">column指定将哪一列的值传给这个方法，这里要根据d_id去查询部门信息，所以为d_id</span></span><br><span class="line"><span class="comment">流程：使用select指定的方法并通过传入column指定的这列参数的值去查出对象，</span></span><br><span class="line"><span class="comment">并封装给property指定的属性,即dept</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"dept"</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">"com.atguigu.mybatis.mapper.DepartmentMapper.getDeptById"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">"d_id"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118202443754.png" alt="在这里插入图片描述"></p><h4 id="5-2-3-延迟加载问题"><a href="#5-2-3-延迟加载问题" class="headerlink" title="5.2.3 延迟加载问题"></a>5.2.3 延迟加载问题</h4><p>从以上的输出结果可以知道，系统会进行通过员工id查询员工信息，并且通过员工的id去查询对应的部门号。但是如果我们在未使用到部门的信息时，也就是我们只输出员工本身的一些与部门无关的信息，系统依旧会进行部门信息的查询。这样会浪费系统资源，我们可以通过设置延迟加载来处理这个问题。</p></li></ol><p>在全局配置文件进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启延迟加载和关闭属性按需加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"aggressiveLazyLoading"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-3-collection元素"><a href="#5-3-collection元素" class="headerlink" title="5.3 collection元素"></a>5.3 collection元素</h3><p>需求：根据id查询部门的时候，同时查询出该部门的<strong>所有员工。</strong></p><h4 id="5-3-1-collection嵌套结果集"><a href="#5-3-1-collection嵌套结果集" class="headerlink" title="5.3.1 collection嵌套结果集"></a>5.3.1 collection嵌套结果集</h4><ol><li><p>更改JavaBean类Department，增加字段以及对应的getter和setter方法。具体如下所示：<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118212716485.png" alt="在这里插入图片描述"></p></li><li><p>在映射接口DepartmentMapper中添加如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDeptAndEmpsByDeptId</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器文件DepartmentMapper.xml进行如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- type的内容即为返回值类型，即查询到的部门对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"com.atguigu.mybatis.bean.Department"</span> <span class="attr">id</span>=<span class="string">"MyDept"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection定义关联集合类型的属性的封装规则</span></span><br><span class="line"><span class="comment">ofType指定集合里面的元素类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"emps"</span> <span class="attr">ofType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义这个集合中元素的封装规则，这里的是员工 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"eid"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptAndEmpsByDeptId"</span> <span class="attr">resultMap</span>=<span class="string">"MyDept"</span>&gt;</span></span><br><span class="line">    select d.id did,d.dept_name,e.id eid,e.last_name,e.email,e.gender</span><br><span class="line">    from tbl_dept d </span><br><span class="line">    LEFT JOIN tbl_employee e </span><br><span class="line">    ON d.id=e.d_id </span><br><span class="line">    WHERE d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118215543404.png" alt="在这里插入图片描述"></p><h4 id="5-3-2-collection分步查询"><a href="#5-3-2-collection分步查询" class="headerlink" title="5.3.2 collection分步查询"></a>5.3.2 collection分步查询</h4><p>具体思路：</p></li><li><p>先按照部门的id去查询部门的信息</p></li><li><p>根据查询到的部门信息中的id值去查询员工表的员工信息</p></li><li><p>将查询到的员工信息设置到部门信息的属性集合中</p></li></ol><p>具体步骤：</p><ol><li><p>在映射接口文件DepartmentMapper中定义如下方法，即根据部门id查询部门信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Department <span class="title">getDeptByIdStep</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器文件DepartmentMapper.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDeptByIdStep"</span> <span class="attr">resultMap</span>=<span class="string">"MyDeptStep"</span>&gt;</span></span><br><span class="line">        select id,dept_name departmentName from tbl_dept where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在映射接口EmployeeMapperPlus中定义如下方法，即根据部门id查询所有员工：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByDeptId</span><span class="params">(Integer deptId)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器EmployeeMapperPlus.xml中配置如下信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注意:如果Employee中的字段与数据库表的字段名不一样，需要给字段命和POJO中对应属性一样的名称，</span></span><br><span class="line"><span class="comment">比如下面的last_name字段必须需命名为lastName，否则无法完成一一映射。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByDeptId"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">        select id,last_name lastName,gender,email from tbl_employee where d_id=#&#123;deptId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在映射器文件DepartmentMapper.xml中配置resultMapper信息，完成关联对象的封装规则：<br> <img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118223234768.png" alt="在这里插入图片描述"></p></li></ol><p>补充：我们上面的例子只在column属性中传递了一个部门的id值。如下图示：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118223819667.png" alt="在这里插入图片描述"><br>我们在分步查询时也可以进行多列传值，MyBatis会将多列的值封装为map进行传递。<br>格式为column=”{key1=column1,key2=column2}”</p><p>比如可以写成如下形式：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118224103581.png" alt="在这里插入图片描述"><br>其中的键deptId对应映射器EmployeeMapperPlus.xml中的SQL的传入的id名称。即<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190118224300809.png" alt="在这里插入图片描述"></p><h2 id="6-sql-元素"><a href="#6-sql-元素" class="headerlink" title="6. sql 元素"></a>6. sql 元素</h2><p>sql元素的作用在于可以定义一条SQL的一部分，方便后面的SQL引用它。假设映射器文件中有如下配置信息：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190119165149425.png" alt="在这里插入图片描述"><br>我们可以使用sql将其中的id，last_name lastName，gender，email抽取出来。如下所示：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190119165321942.png" alt="在这里插入图片描述"><br>更改原有的配置信息，引用sql标签的配置。<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190119165504999.png" alt="在这里插入图片描述"><br>sql元素还支持变量的传递，映射器的配置信息如下：<br><img src="/2020/01/05/（四）MyBatis学习笔记-MyBatis映射器/20190119170315143.png" alt="在这里插入图片描述"><br>在include元素中定义了一个命名为e的变量，其值是SQL中标tbl_employee的别名emp，然后sql元素就能够使用这个变量名了。<strong>这个用法常用于多表查询并需要给不同表起别名的情况。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）MyBatis学习笔记-动态SQL</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81SQL/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8A%A8%E6%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>如果使用JDBC或者类似于Hibernate的其他框架，很多时候要根据需要去拼装SQL。比如我要查询角色，可以根据角色名称或者备注等信息查新，但是当我们不输入名称时原本使用名称做查询条件的情况就不适用了。而MaBatis提供了对SQL语句动态的组装能力，MyBatis 采用功能强大的基于 <strong>OGNL 表达式</strong>来简化操作。</p><p>MyBatis的动态SQL包括以下几种元素，如下所示：</p><table><thead><tr><th align="left">元素</th><th align="left">作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">if</td><td align="left">判断语句</td><td align="left">单条件复分支判断</td></tr><tr><td align="left">choose( when, otherwise)</td><td align="left">相当于Java中的switch和case语句</td><td align="left">多条件分支判断</td></tr><tr><td align="left">tirm ( where, set)</td><td align="left">辅助元素，用于处理特定的SQL拼装问题，比如去掉多余的and、or等</td><td align="left">用于处理SQL拼装问题</td></tr><tr><td align="left">foreach</td><td align="left">循环语句</td><td align="left">在in语句等列举条件常用</td></tr></tbody></table><a id="more"></a><h2 id="2-if-元素"><a href="#2-if-元素" class="headerlink" title="2. if 元素"></a>2. if 元素</h2><p>需求：根据员工对象Employee来查询对应的员工，传入的员工对象Employee带有哪个属性，就将其作为查询条件。</p><ol><li><p>我们先在映射接口EmployeeMapperDynamicSQL定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByConditionIf</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后在映射器文件EmployeeMapperDynamicSQL.xml中配置如下信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionIf"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">    select id,last_name lastName, gender, email from tbl_employee</span><br><span class="line">    where</span><br><span class="line">    <span class="comment">&lt;!-- test中的值必须符合OGNL规范 </span></span><br><span class="line"><span class="comment">在OGNL中and与&amp;&amp;是一样的意思，但是&amp;&amp;是特殊符号，而应该换成其转义字符，即&amp;amp;&amp;amp</span></span><br><span class="line"><span class="comment">同理，''可以换成转义字符&amp;quot;&amp;quot</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null and lastName!=''"</span>&gt;</span></span><br><span class="line">        and last_name like #&#123;lastName&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- gender的类型为字符串，这里的test没有写成gender=='0'的格式</span></span><br><span class="line"><span class="comment">是因为OGNL会进行字符串与数字的判断转换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender==0 or gender==1"</span>&gt;</span></span><br><span class="line">        and gender = #&#123;gender&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email!=''"</span>&gt;</span></span><br><span class="line">        and email = #&#123;email&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119112743274.png" alt="在这里插入图片描述"><br> 这里在Employee对象中设置了id，lastName，gender和email属性，那么数据库会将这些属性作为条件来查询符合的员工。我们可以从运行结果输出的信息看出来，如下所示：<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119113026296.png" alt="在这里插入图片描述"><br> 当我们对email传入null时，是不会将email作为查询条件的，因为我们使用if 元素进行了判断。测试代码如下：<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119113343164.png" alt="在这里插入图片描述"><br> 输出的SQL信息<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119113154388.png" alt="在这里插入图片描述"></p><h2 id="3-where-元素"><a href="#3-where-元素" class="headerlink" title="3. where 元素"></a>3. where 元素</h2><p>在刚才演示if 元素的例子的基础上，假设我们传入的员工id值为null，测试代码如下示：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119130153615.png" alt="在这里插入图片描述"><br>这时如果还是如下的SQL配置，那么就会发生错误。<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119130437914.png" alt="在这里插入图片描述"><br>输出的错误的SQL信息如下：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/2019011913061580.png" alt="在这里插入图片描述"></p></li></ol><p><strong>第一种解决办法</strong>是在where语句后面加上1=1，后面if元素中要拼装成SQL语句的内容全部写成and xxx的内容，如下所示：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119130842744.png" alt="在这里插入图片描述"><br><strong>第二种解决方法</strong>是通过where元素，MyBatis使用where标签来将所有的查询条件包括在内，将标签中的内容拼装成sql，其会把多出来的and或者or自动去掉。使用where元素的映射器中配置如下：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119131331971.png" alt="在这里插入图片描述"><br>再次测试传入的员工id为null时，则不会引发错误。输出的SQL语句信息为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,last_name lastName, gender, email <span class="keyword">from</span> tbl_employee <span class="keyword">WHERE</span> last_name <span class="keyword">like</span> ? <span class="keyword">and</span> gender = ?</span><br></pre></td></tr></table></figure><h2 id="4-trim-元素"><a href="#4-trim-元素" class="headerlink" title="4. trim 元素"></a>4. trim 元素</h2><p>上面演示where标签时，if 标签内的语句都是以and开头的，那么现在将and 放在尾部，且传入的email为null时，则又会发生错误。<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119131939161.png" alt="在这里插入图片描述"><br>输出的错误SQL语句信息为：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119132030462.png" alt="在这里插入图片描述"><br>明显SQL语句中多了一个and，这就说明<strong>where标签只能去掉头部的and或者or，却不能去掉尾部的and或者or。</strong> 下面我们通过trim元素来解决这个问题。</p><p>我们另外写一个方法来演示该标签的使用，映射接口的方法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByConditionTrim</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure><p>映射器文件中的SQL配置，这里通过Trim元素来处理;<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/2019011913332851.png" alt="在这里插入图片描述"><br>这时即便email的传入的值为null也不会发生错误。<strong>不过这里还是推荐使用where标签并将and置于前面来解决这个问题，where标签更加明了</strong></p><h2 id="5-choose-、when、otherwise元素"><a href="#5-choose-、when、otherwise元素" class="headerlink" title="5. choose 、when、otherwise元素"></a>5. choose 、when、otherwise元素</h2><p>需求：假设现在传入的Employee对象如果有id值，那么就将其作为查询条件，如果有lastName值，那么就将lastName作为查询条件，且只使用其中一个作为查询条件。如果都为null的话就查询所有。</p><ol><li><p>在映射接口中编写如下方法，用来演示这些元素的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByConditionChoose</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>映射器文件进行如下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByConditionChoose"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">        select id,last_name lastName, gender, email from tbl_employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                    id = #&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"lastName!=null and lastName!=''"</span>&gt;</span></span><br><span class="line">                    last_name like #&#123;lastName&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    1=1</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在id为空，lastName不为null的条件下，测试代码如下：<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119135459836.png" alt="在这里插入图片描述"></p></li><li><p>输出的结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEBUG 01-19 13:54:09,600 ==&gt;  Preparing: select id,last_name lastName, gender, email from tbl_employee WHERE last_name like ?   (BaseJdbcLogger.java:145) </span><br><span class="line">DEBUG 01-19 13:54:09,657 ==&gt; Parameters: %张%(String)  (BaseJdbcLogger.java:145) </span><br><span class="line">DEBUG 01-19 13:54:09,693 &lt;==      Total: 2  (BaseJdbcLogger.java:145) </span><br><span class="line">Employee [id=4, lastName=张三, gender=1, email=zhangsan@gmail.com]</span><br><span class="line">Employee [id=5, lastName=张三, gender=1, email=zhangsan@gmail.com]</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-set-元素"><a href="#6-set-元素" class="headerlink" title="6. set 元素"></a>6. set 元素</h2><p>需求：假设现在对于传入的Employee对象的属性，如果属性值非空则进行更新操作，否则不进行更新。</p><ol><li><p>首先依旧在映射接口文件中定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateEmpByConditonSet</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后在映射器文件中进行如下配置，注意：这里没有使用set标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmpByConditonSet"</span>&gt;</span></span><br><span class="line">    update tbl_employee</span><br><span class="line">    set</span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">            last_name = #&#123;lastName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">            gender = #&#123;gender&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">            email = #&#123;email&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试，传入的Employee对象的lastName属性的值为”zs”，gender和email为null，这时会输出如下错误的SQL信息。<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119141918342.png" alt="在这里插入图片描述"><br> if标签中的sql语句实现了拼接，但是后面却带有，的分隔符。这是我们可以使用set标签来处理这个问题，<strong>映射器文件的配置信息如下</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmpByConditonSet"</span>&gt;</span></span><br><span class="line">        update tbl_employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">                last_name = #&#123;lastName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">                gender = #&#123;gender&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然我们也可以使用tirm元素来处理这个问题，以下为核心的映射器配置信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateEmpByConditonSet"</span>&gt;</span></span><br><span class="line">        update tbl_employee</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"set"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">                last_name = #&#123;lastName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">                gender = #&#123;gender&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">                email = #&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">        where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="7-foreach-元素"><a href="#7-foreach-元素" class="headerlink" title="7. foreach 元素"></a>7. foreach 元素</h2><p>foreach元素是一个循环语句，它的作用是遍历集合，它能够很好地支持数组和List、Set接口的集合，对比提供遍历功能。它往往用于SQL中的in关键字。</p><h3 id="7-1-批量查询"><a href="#7-1-批量查询" class="headerlink" title="7.1 批量查询"></a>7.1 批量查询</h3><p>我们如果需要根据多个员工id去查询多个对应的员工信息，原始的SQL语句可以以下面的方式来编写：</p><pre><code>select id,last_name lastName, gender, email from tbl_employee where id in(1,2,3) </code></pre><p>但是查询的id是固定的，我们可以利用foreach标签来实现根据id的List集合来动态的查询获取员工的信息。</p><ol><li><p>在映射接口中定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用注解给List集合命名为idList (List集合的系统自定义别名为list)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByIdForeach</span><span class="params">(@Param(<span class="string">"idList"</span>)</span>List&lt;Integer&gt; idList)</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后在映射器文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原始查询语句：select id,last_name lastName, gender, email</span></span><br><span class="line"><span class="comment">from tbl_employee where id in(1,2,3) </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">collection属性的内容为要遍历的集合，</span></span><br><span class="line"><span class="comment">List集合类型的参数MyBatis会进行特殊处理，会将List集合封装在Map集合中，</span></span><br><span class="line"><span class="comment">Map的key就叫list。但是我们在定义getEmpsByIdForeach方法时给参数命名为idList</span></span><br><span class="line"><span class="comment">所以在这里collection属性的内容就为idList</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">item指当前遍历出来的元素赋值给定的变量，也就指当前的元素。</span></span><br><span class="line"><span class="comment">separator指各个元素的分隔符，即where id in(1,2,3) 中1,2,3之间的逗号</span></span><br><span class="line"><span class="comment">open和close表示是什么符号将这些集合元素包装起来</span></span><br><span class="line"><span class="comment">index配置的是当前元素在集合的位置的下标</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByIdForeach"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">    select id,last_name lastName, gender, email from tbl_employee where id in</span><br><span class="line">    <span class="comment">&lt;!-- 下面foreach的部分相当于(1,2,3)这一部分，不过里面的值是可变的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"idList"</span> <span class="attr">item</span>=<span class="string">"item_id"</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item_id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试<br> <img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119150349286.png" alt="在这里插入图片描述"></p><h3 id="7-2-批量插入"><a href="#7-2-批量插入" class="headerlink" title="7.2 批量插入"></a>7.2 批量插入</h3><h4 id="7-2-1-方式一"><a href="#7-2-1-方式一" class="headerlink" title="7.2.1 方式一"></a>7.2.1 方式一</h4><p>第一种批量插入基于MySQL的如下插入语句，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_employee(last_name, gender, email, d_id) <span class="keyword">values</span></span><br><span class="line">(<span class="string">"钱七"</span>,<span class="string">"1"</span>,<span class="string">"qianqi@gmail.com"</span>,<span class="number">2</span>),(<span class="string">"郑一"</span>,<span class="string">"0"</span>,<span class="string">"zhengyi@gmail.com"</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>下面我们使用foreach标签来实现这个SQL语句的批量插入。</p><ol><li><p>在映射接口定义如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmps</span><span class="params">(@Param(<span class="string">"empList"</span>)</span>List&lt;Employee&gt; empList)</span>;</span><br></pre></td></tr></table></figure></li><li><p>在映射器文件中配置如下信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"addEmps"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">        insert into tbl_employee(last_name, gender, email, d_id) </span><br><span class="line">        values</span><br><span class="line">        <span class="comment">&lt;!-- 注意一下：emp.dept.id表示emp中的属性dept对象中的id属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"empList"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            (#&#123;emp.lastName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">SqlSession openSession = sqlSessionFactory.openSession(<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    EmployeeMapperDynamicSQL mapper = openSession.getMapper(EmployeeMapperDynamicSQL.class);</span><br><span class="line">    Employee emp1 = <span class="keyword">new</span> Employee(<span class="keyword">null</span>,<span class="string">"钱七"</span>,<span class="string">"1"</span>,<span class="string">"qianqi@gmail.com"</span>,<span class="keyword">new</span> Department(<span class="number">2</span>));</span><br><span class="line">    Employee emp2 = <span class="keyword">new</span> Employee(<span class="keyword">null</span>,<span class="string">"郑一"</span>,<span class="string">"0"</span>,<span class="string">"zhengyi@gmail.com"</span>,<span class="keyword">new</span> Department(<span class="number">1</span>));</span><br><span class="line">    List&lt;Employee&gt; empList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    empList.add(emp1);</span><br><span class="line">    empList.add(emp2);</span><br><span class="line">    mapper.addEmps(empList);</span><br><span class="line">    openSession.commit();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    openSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-2-2-方式二"><a href="#7-2-2-方式二" class="headerlink" title="7.2.2 方式二"></a>7.2.2 方式二</h4><p>第二种批量插入基于MySQL的如下插入语句，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_employee(last_name, gender, email, d_id) <span class="keyword">values</span> (<span class="string">"钱七"</span>,<span class="string">"1"</span>,<span class="string">"qianqi@gmail.com"</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_employee(last_name, gender, email, d_id) <span class="keyword">values</span> (<span class="string">"郑一"</span>,<span class="string">"0"</span>,<span class="string">"zhengyi@gmail.com"</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中的映射器进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"addEmps2"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"empList"</span> <span class="attr">item</span>=<span class="string">"emp"</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">        insert into tbl_employee(last_name, gender, email, d_id) </span><br><span class="line">        values (#&#123;emp.lastName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，还需要在数据库的properties配置文件的url中添加allowMultiQueries=true以实现一次性执行多条插入语句。<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119153634506.png" alt="在这里插入图片描述"></p><h2 id="8-内置参数"><a href="#8-内置参数" class="headerlink" title="8. 内置参数"></a>8. 内置参数</h2><h3 id="8-1-databaseId-参数"><a href="#8-1-databaseId-参数" class="headerlink" title="8.1 _databaseId 参数"></a>8.1 _databaseId 参数</h3><p>在配置了databaseIdProvider标签的情况下，_databaseId 代表<strong>当前数据库</strong>的别名。它可以实现在select等标签中根据不同的if条件种的不同数据库别名来指定不同SQL语句。</p><p>假设MySQL数据中有tbl_employee表，而Oracle数据库中的是EMP表。下面演示一下其具体的用法。</p><ol><li><p>先在映射接口中定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmpsByInnerParam</span><span class="params">(Employee employee)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>然后全局配置文件配置databaseIdProvider的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置数据库厂商标识 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"MySQL"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Oracle"</span> <span class="attr">value</span>=<span class="string">"oracle"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"DB2"</span> <span class="attr">value</span>=<span class="string">"db2"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>接着在映射器文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmpsByInnerParam"</span> <span class="attr">resultType</span>=<span class="string">"com.atguigu.mybatis.bean.Employee"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId=='mysql'"</span>&gt;</span></span><br><span class="line">        select id,last_name lastName, gender, email from tbl_empployee</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId=='oracle'"</span>&gt;</span></span><br><span class="line">        select id,last_name lastName, gender, email from emp</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>它实现如果当前数据库是MySQL时，会执行select * from tbl_empployee语句，而当前数据库是Oracle时则执行select * from emp。</strong></p></li></ol><h3 id="8-2-parameter-参数"><a href="#8-2-parameter-参数" class="headerlink" title="8.2 _parameter 参数"></a>8.2 _parameter 参数</h3><p>上面我们利用_databaseId来查询对应数据库的所有员工数据，<strong>假如我们现在的需求是根据传递过来的员工Employee对象的lastName属性来查询获取对应的员工信息。但是假如现在传递过来的员工Employee对象是null时，我们则不用lastName做查询条件，而是查询所有员工。</strong> 我们可以使用_parameter参数来实现非空检查以处理这个问题。</p><p>我们将映射器文件的信息更改如下：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/2019011916214364.png" alt="在这里插入图片描述"><br><strong>注意：</strong> 此时_parameter代表的是getEmpsByInnerParam方法传递过来的Employee对象。假设传递过来的是id和lastName，MyBatis会将这两个参数封装到一个Map中，而_parameter则代表这个Map集合。</p><p>测试代码：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119163656524.png" alt="在这里插入图片描述"></p><h2 id="9-bind-元素"><a href="#9-bind-元素" class="headerlink" title="9. bind 元素"></a>9. bind 元素</h2><p>bind元素可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值。比如上面_parameter 参数的测试代码中，Employee的第二个参数为”%张%”，也就是按照lastName进行模糊查询。现在我只想传入参数”张”就能实现模糊查询，这时我就要在映射器文件中使用bind元素来实现变量lastName与%的绑定了。更改_parameter 参数那一部分的映射器配置信息，如下所示：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/20190119163402863.png" alt="在这里插入图片描述"><br>这时再进行测试：<br><img src="/2020/01/05/（五）MyBatis学习笔记-动态SQL/2019011916373132.png" alt="在这里插入图片描述"><br><strong>不过不太推荐这种绑定方式，指定传入带%的参数更好些。</strong></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）MyBatis学习笔记-缓存</title>
      <link href="/2020/01/05/%EF%BC%88%E5%85%AD%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BC%93%E5%AD%98/"/>
      <url>/2020/01/05/%EF%BC%88%E5%85%AD%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在MyBatis中允许使用缓存，缓存一般都放置在可高速读/写的存储器上，比如服务器的内存，它能够有效提高系统的性能。因为数据库大部分场景下是把存储在磁盘上的数据索引出来。从硬件的角度分析，索引磁盘是一个较为缓慢的过程，读取内存或者高速缓存在处理器上得速度要比读取磁盘快得多。<strong>缓存就是将那些常用的数据放在内存中，以便将来使用，以此提高系统性能。</strong></p><p>MyBatis系统中默认定义了<strong>一级缓存和二级缓存</strong>两级缓存。</p><ul><li>默认情况下，只有一级缓存（SqlSession级别的缓存，也称为本地缓存）开启。</li><li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li><li>为了提高扩展性。 MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</li></ul><a id="more"></a><h2 id="2-一级缓存"><a href="#2-一级缓存" class="headerlink" title="2. 一级缓存"></a>2. 一级缓存</h2><p>一级缓存(local cache), 即本地缓存, <strong>本地缓存不能被关闭，作用域默认为sqlSession。</strong></p><h3 id="2-1-验证一级缓存的存在"><a href="#2-1-验证一级缓存的存在" class="headerlink" title="2.1 验证一级缓存的存在"></a>2.1 验证一级缓存的存在</h3><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sessionFactory = getSqlSessionFactory();</span><br><span class="line">SqlSession session = sessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">    <span class="comment">//通过id为1去查询获取员工对象</span></span><br><span class="line">    Employee emp01 = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp01);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再次通过id为1去查询获取员工对象</span></span><br><span class="line">    Employee emp02 = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp02);</span><br><span class="line">    </span><br><span class="line">    System.out.println(emp01 == emp02);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/2019012008552858.png" alt="在这里插入图片描述"><br>从运行结果可以知道，虽然调用了两次查询，但是只发送了一条SQL语句，且两次获取的员工对象是同一个。显示，MyBatis没有再次查询数据库，而是从一级缓存中获取已有的员工对象。</p><h3 id="2-2-失效情况"><a href="#2-2-失效情况" class="headerlink" title="2.2 失效情况"></a>2.2 失效情况</h3><p>所谓失效情况就是没有使用到<strong>当前</strong>一级缓存的情况，效果就是还需要再向数据库发出SQL。</p><h4 id="2-2-1-sqlSession不同"><a href="#2-2-1-sqlSession不同" class="headerlink" title="2.2.1 sqlSession不同"></a>2.2.1 sqlSession不同</h4><p>假设我分别用两个不同的sqlSession进行员工的查询，这时会发送两条相同的查询SQL，也就是没有使用到一级缓存的情形。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sessionFactory = getSqlSessionFactory();</span><br><span class="line"><span class="comment">//创建两个不同的session</span></span><br><span class="line">SqlSession session1 = sessionFactory.openSession();</span><br><span class="line">SqlSession session2 = sessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用session1去查询id为1的员工对象</span></span><br><span class="line">    EmployeeMapper mapper1 = session1.getMapper(EmployeeMapper.class);</span><br><span class="line">    Employee emp01 = mapper1.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp01);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用session2去查询id为1的员工对象</span></span><br><span class="line">    EmployeeMapper mapper2 = session2.getMapper(EmployeeMapper.class);</span><br><span class="line">    Employee emp02 = mapper2.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp02);</span><br><span class="line">    </span><br><span class="line">    System.out.println(emp01 == emp02);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session1.close();</span><br><span class="line">    session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120090815459.png" alt="在这里插入图片描述"><br>这是很好理解的，因为一级缓存的默认作用域是sqlSession，所以不同的sqlSession有不同的一级缓存。</p><h4 id="2-2-2-sqlSession相同，查询条件不同"><a href="#2-2-2-sqlSession相同，查询条件不同" class="headerlink" title="2.2.2  sqlSession相同，查询条件不同"></a>2.2.2  sqlSession相同，查询条件不同</h4><p>这个也很好理解，既然两次数据库操作是不一样的，显然当前一级缓存是没有保存相同的数据，还是会访问数据库。</p><h4 id="2-2-3-sqlSession相同，两次查询之间存在增删改操作"><a href="#2-2-3-sqlSession相同，两次查询之间存在增删改操作" class="headerlink" title="2.2.3 sqlSession相同，两次查询之间存在增删改操作"></a>2.2.3 sqlSession相同，两次查询之间存在增删改操作</h4><p>在进行了增删改操作之后，数据库中的数据可能会发生改变。为了保持数据的一致性，在第二次查询的时候，必须在此访问数据库获取最新的数据。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sessionFactory = getSqlSessionFactory();</span><br><span class="line">SqlSession session = sessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//去查询id为1的员工对象</span></span><br><span class="line">    EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">    Employee emp01 = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp01);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两次查询之间存在增删改操作</span></span><br><span class="line">    Employee emp = <span class="keyword">new</span> Employee(<span class="number">1</span>,<span class="string">"郑楚"</span>,<span class="string">"1"</span>,<span class="string">"zhengchu@gmail.com"</span>);</span><br><span class="line">    mapper.addEmp(emp);</span><br><span class="line">    <span class="comment">//查询id为1的员工对象</span></span><br><span class="line">    Employee emp02 = mapper.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp02);</span><br><span class="line">    </span><br><span class="line">    System.out.println(emp01 == emp02);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120092313382.png" alt="在这里插入图片描述"></p><h4 id="2-2-4-sqlSession相同，手动清空一级缓存"><a href="#2-2-4-sqlSession相同，手动清空一级缓存" class="headerlink" title="2.2.4 sqlSession相同，手动清空一级缓存"></a>2.2.4 sqlSession相同，手动清空一级缓存</h4><p>测试代码：<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120092622801.png" alt="在这里插入图片描述"><br>运行结果：<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120092659719.png" alt="在这里插入图片描述"></p><h2 id="3-二级缓存"><a href="#3-二级缓存" class="headerlink" title="3. 二级缓存"></a>3. 二级缓存</h2><p>二级缓存需要<strong>手动开启和配置</strong>，它是<strong>基于namespace级别的缓存</strong>，在 <strong>SqlSession 关闭或提交之后才会生效</strong></p><p>我们知道一级缓存的作用为sqlSession，但是当这个会话关闭的时候，我们又不得不重新访问数据库进行一些查询等操作。但是使用二级缓存，如果<strong>当前namespace下</strong>的会话关闭，一级缓存中的数据就会被保存到二级缓存中，因此新的会话查询信息，就可以参照二级缓存中的内容。<strong>不同的namesapce查出的数据会放在自己对应的缓存中</strong>。另外，底层中缓存数据是用Map集合封装的。</p><h3 id="3-1-二级缓存的使用"><a href="#3-1-二级缓存的使用" class="headerlink" title="3.1 二级缓存的使用"></a>3.1 二级缓存的使用</h3><ol><li>开启全局二级缓存配置。<br> <img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120094041179.png" alt="在这里插入图片描述"></li><li>在映射器文件EmployeeMapper.xml中配置使用二级缓存。提醒一下：不同的映射器有着不一样的namespace。<br> <img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120094622375.png" alt="在这里插入图片描述"><br> cache标签里的属性不进行配置，也就是采用默认也是可以的。</li></ol><p>cache标签有许多属性，下面讲一下这些属性的作用：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th><th align="left">取值</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">eviction</td><td align="left">缓存回收策略<br>1. LRU – 最近最少使用的：移除最长时间不被使用的对象。<br>2. FIFO – 先进先出：按对象进入缓存的顺序来移除它们<br> 3. SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。<br>4. WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</td><td align="left">默认的是 LRU。</td><td align="left">-</td></tr><tr><td align="left">flushInterval</td><td align="left">刷新间隔，单位毫秒，默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</td><td align="left">正整数</td><td align="left">超过中整数后缓存失效，不再读取缓存，而是执行SQL取回数据</td></tr><tr><td align="left">size</td><td align="left">引用数目，代表缓存最多可以存储多少个对象，太大容易导致内存溢出</td><td align="left">正整数，默认取值1024</td><td align="left">-</td></tr><tr><td align="left">readOnly</td><td align="left">缓存内容是否只读<br>true：只读缓存；会给所有调用者返回缓存对不能被修改。这提供了很重要的性能优势 <br>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是 false。</td><td align="left">true/false，默认为false</td><td align="left">-</td></tr><tr><td align="left">type</td><td align="left">自定义缓存类，要求实现接口org.apache.ibatis.cache.Cache</td><td align="left">用于自定义的缓存类</td><td align="left">-</td></tr><tr><td align="left">blocking</td><td align="left">是否使用阻塞性缓存，在读/写时它会加入JNI的锁进行操作</td><td align="left">true/false，默认为false</td><td align="left">可保证读/写安全性，但加锁后性能不佳。</td></tr></tbody></table><ol start="3"><li><p>readOnly默认是false的，因此需要给涉及到的POJO类实现序列化接口。<br> <img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120100558891.png" alt="在这里插入图片描述"></p></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sessionFactory = getSqlSessionFactory();</span><br><span class="line"><span class="comment">//创建两个不同的session</span></span><br><span class="line">SqlSession session1 = sessionFactory.openSession();</span><br><span class="line">SqlSession session2 = sessionFactory.openSession();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//使用session1去查询id为1的员工对象</span></span><br><span class="line">    EmployeeMapper mapper1 = session1.getMapper(EmployeeMapper.class);</span><br><span class="line">    Employee emp01 = mapper1.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp01);</span><br><span class="line">    <span class="comment">//关闭session1</span></span><br><span class="line">    session1.close();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用session2去查询id为1的员工对象</span></span><br><span class="line">    <span class="comment">//第二次查询是从二级缓存中查询的数据，并没有发送SQL</span></span><br><span class="line">    EmployeeMapper mapper2 = session2.getMapper(EmployeeMapper.class);</span><br><span class="line">    Employee emp02 = mapper2.getEmpById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(emp02);</span><br><span class="line">    </span><br><span class="line">    System.out.println(emp01 == emp02);</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭session2</span></span><br><span class="line">    session2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120101510488.png" alt="在这里插入图片描述"><br>从运行结果可以知道，第一次查询时会先查询二级缓存，查询不到数据所以发送SQL语句进行数据库访问。第二次查询还是先查询二级缓存，这次查询到了数据便直接返回输出数据。因为二级缓存会进行对象的克隆（序列化与反序列化），所以两次查询的员工对象是不相等的。</p></li></ol><p><strong>注意：我们上面在进行代码测试测试时，在进行第二次查询之前是先关闭session1会话的，因为二级缓存是在SqlSession 关闭或提交之后才会生效。</strong></p><h3 id="3-2-缓存有关设置和属性"><a href="#3-2-缓存有关设置和属性" class="headerlink" title="3.2 缓存有关设置和属性"></a>3.2 缓存有关设置和属性</h3><ul><li>全局二级缓存开启和关闭。true为开启，false则为关闭。<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120102706966.png" alt="在这里插入图片描述"></li><li>select标签中的useCache属性，默认为true。true则使用二级缓存（全局二级缓存得开），false则不使用二级缓存。<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120102847670.png" alt="在这里插入图片描述"></li><li>增删改标签中的flushCache属性，默认为true。true则每次增删改会清空一级缓存和二级缓存，false则不会清空二级缓存，但是会清空一级缓存。<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120104546152.png" alt="在这里插入图片描述"></li><li>select标签中的flushCache标签，默认值为false。true则每次查询都清空一级缓存和二级缓存，false则不会清空一级缓存和二级缓存。<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/2019012010470635.png" alt="在这里插入图片描述"><h2 id="4-EhCache整合"><a href="#4-EhCache整合" class="headerlink" title="4. EhCache整合"></a>4. EhCache整合</h2>EhCache 第三方缓存框架是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。我们可以使用MyBatis定义得Cache接口来进行自定义扩展。<h3 id="4-1-整合步骤"><a href="#4-1-整合步骤" class="headerlink" title="4.1 整合步骤"></a>4.1 整合步骤</h3></li></ul><ol><li><p>导入ehcache包，以及整合包，日志包<br> <img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120105624711.png" alt="在这里插入图片描述"><br> <a href="http://www.mybatis.org/ehcache-cache/" target="_blank" rel="noopener">官方文档即相关包下载</a></p></li><li><p>编写ehcache.xml配置文件，一般情况下直接拿来用即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"D:\44\ehcache"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">defaultCache</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">maxElementsInMemory</span>=<span class="string">"1"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">eternal</span>=<span class="string">"false"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">overflowToDisk</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">属性说明：</span></span><br><span class="line"><span class="comment">l diskStore：指定数据在磁盘中的存储位置。</span></span><br><span class="line"><span class="comment">l defaultCache：当借助CacheManager.add("demoCache")创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">以下属性是必须的：</span></span><br><span class="line"><span class="comment">l maxElementsInMemory - 在内存中缓存的element的最大数目 </span></span><br><span class="line"><span class="comment">l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大</span></span><br><span class="line"><span class="comment">l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断</span></span><br><span class="line"><span class="comment">l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">以下属性是可选的：</span></span><br><span class="line"><span class="comment">l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大</span></span><br><span class="line"><span class="comment">l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</span></span><br><span class="line"><span class="comment"> diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.</span></span><br><span class="line"><span class="comment">l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</span></span><br><span class="line"><span class="comment">l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作</span></span><br><span class="line"><span class="comment">l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置cache标签，type中的值为类路径。<br> <img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120110924979.png" alt="在这里插入图片描述"></p></li></ol><p>若想在命名空间中共享相同的缓存配置和实例。可以使用 cache-ref 元素来引用另外一个缓存。</p><p>比如我在DepartmentMapper.xml中引用EmployeeMapper.xml相同的第三方缓存，可以进行如下配置。<br><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/20190120111434966.png" alt="在这里插入图片描述"></p><h2 id="5-缓存原理"><a href="#5-缓存原理" class="headerlink" title="5. 缓存原理"></a>5. 缓存原理</h2><p><img src="/2020/01/05/（六）MyBatis学习笔记-缓存/2019012011174654.png" alt="在这里插入图片描述"></p><ol><li>在二级缓存关闭的状态下，第一次查询id为1的员工数据时，会先访问数据库，然后将查询到的数据放在一级缓存中。当该会话关闭，那么下次查询又会重新访问数据库。</li><li>若二级缓存处于开启状态，新会话会先查询对应表空间的二级缓存是否有要查询的数据，否则访问数据库并将查询到的数据放在一级缓存中，当该会话关闭时则再将该数据拷贝到二级缓存中。该表空间的新会话要查询同样的数据时，将会查询二级缓存并获取数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）MyBatis学习笔记-逆向工程</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%83%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%83%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>MyBatis Generator：简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，<strong>可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及QBC风格的条件查询。</strong>  但是表连接、存储过程等这些复杂sql的定义需要我们手工编写。</p><ul><li><a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">官方文档地址</a> </li><li><a href="https://github.com/mybatis/generator/releases" target="_blank" rel="noopener">官方工程地址</a> </li></ul><p>可以到官方工程地址中下载需要的Jar包。</p><a id="more"></a><p><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120191715572.png" alt="在这里插入图片描述"></p><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><h3 id="2-1-mbg-xml-编写"><a href="#2-1-mbg-xml-编写" class="headerlink" title="2.1 mbg.xml 编写"></a>2.1 mbg.xml 编写</h3><p>在最常见的用例中，MyBatis Generator（MBG）由XML配置文件驱动，我们这里使用XML的方式。本地的项目的结构如下：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/2019012019404140.png" alt="在这里插入图片描述"><br>根据本地工程项目结构，编写配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 引入外部的properties文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"dbconfig.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--  context标签用来指定生的项目的环境 </span></span><br><span class="line"><span class="comment">  targetRuntime="MyBatis3Simple":生成简单版的CRUD</span></span><br><span class="line"><span class="comment">  MyBatis3:豪华版</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"DB2Tables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3Simple"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jdbcConnection：指定如何连接到目标数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">connectionURL</span>=<span class="string">"$&#123;jdbc.url&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">userId</span>=<span class="string">"$&#123;jdbc.username&#125;"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">password</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- &lt;javaTypeResolver&gt;元素用于定义Java类型解析器的属性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">      <span class="comment">&lt;!--   此属性用于指定MyBatis Generator是否应强制</span></span><br><span class="line"><span class="comment">           对DECIMAL和NUMERIC字段使用java.math.BigDecimal --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- javaModelGenerator：指定javaBean的生成策略 </span></span><br><span class="line"><span class="comment">targetPackage指定目标包名</span></span><br><span class="line"><span class="comment">targetProject指定目标工程</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.atguigu.mybatis.bean"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- sqlMapGenerator：sql映射生成策略： --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.atguigu.mybatis.mapper"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">targetProject</span>=<span class="string">".\config"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- javaClientGenerator:指定mapper接口所在的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"com.atguigu.mybatis.mapper"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定要逆向分析哪些表：根据表要创建javaBean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tbl_dept"</span> <span class="attr">domainObjectName</span>=<span class="string">"Department"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"tbl_employee"</span> <span class="attr">domainObjectName</span>=<span class="string">"Employee"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：详细地XML标签和内容等使用和了解，详见 <a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">官方文档地址</a> 。<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120194429100.png" alt="在这里插入图片描述"></p><h3 id="2-2-Jar包引入"><a href="#2-2-Jar包引入" class="headerlink" title="2.2 Jar包引入"></a>2.2 Jar包引入</h3><p><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120194705198.png" alt="在这里插入图片描述"></p><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>测试代码可以引用<a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">官方文档地址</a> 的快速运行代码。如下所示：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120195251534.png" alt="在这里插入图片描述"><br>本地的测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMbg</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//使用mbg.xml配置文件生成File对象</span></span><br><span class="line">    File configFile = <span class="keyword">new</span> File(<span class="string">"mbg.xml"</span>);</span><br><span class="line">    ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">    Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">    DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">    MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">    myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120195647155.png" alt="在这里插入图片描述"><br>对于生成的POJO类Employee类，其类的内容主要如下：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120195937876.png" alt="在这里插入图片描述"><br>而对于映射器接口EmployeeMapper的主要内容为：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120200040192.png" alt="在这里插入图片描述"><br>从上面可以看出，这些都是一些简单的数据库CRUD操作，如根据主键删除，查询所有等。其他的这里不再赘述。</p><p>运行测试一下根据员工id查询的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyBatis3Simple</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession session = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        Employee emp = mapper.selectByPrimaryKey(<span class="number">1</span>);</span><br><span class="line">        System.out.println(emp.getLastName());</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-复杂版MBG"><a href="#4-复杂版MBG" class="headerlink" title="4. 复杂版MBG"></a>4. 复杂版MBG</h2><p>上面我们在配置mbg.xml时，context标签的targetRuntime属性的内容之指定为MyBatis3Simple，也就是MGB会生成简单的CRUD代码。<strong>现在我们在其内容设置为MyBatis3</strong> 。即：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120200824149.png" alt="在这里插入图片描述"><br>重新运行测试 <strong>（记得把之前项目的映射器等文件删除掉，避免发生错误）</strong> ，结果如下所示：<br><img src="/2020/01/05/（七）MyBatis学习笔记-逆向工程/20190120200915969.png" alt="在这里插入图片描述"><br>下面演示部分功能的用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyBatis3</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SqlSessionFactory sessionFactory = getSqlSessionFactory();</span><br><span class="line">    SqlSession session = sessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line">        <span class="comment">/*List&lt;Employee&gt; emps = mapper.selectByExample(null);</span></span><br><span class="line"><span class="comment">for (Employee employee : emps) &#123;</span></span><br><span class="line"><span class="comment">System.out.println(employee.getLastName());</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">        <span class="comment">//xxxExample就是封装查询条件的</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查询员工名字中有e字母的，和员工性别是1的，或者email带有字母e的</span></span><br><span class="line">        <span class="comment">//封装员工查询条件的example</span></span><br><span class="line">        EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">        <span class="comment">//创建一个Criteria，这个Criteria就是拼装查询条件</span></span><br><span class="line">        <span class="comment">//select id, last_name, email, gender, d_id from tbl_employee </span></span><br><span class="line">        <span class="comment">//WHERE ( last_name like ? and gender = ? ) or email like "%e%"</span></span><br><span class="line">        <span class="comment">//封装and部分</span></span><br><span class="line">        Criteria criteria = example.createCriteria();</span><br><span class="line">        criteria.andLastNameLike(<span class="string">"%e%"</span>);</span><br><span class="line">        criteria.andGenderEqualTo(<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">//封装and部分</span></span><br><span class="line">        Criteria criteria2 = example.createCriteria();</span><br><span class="line">        criteria2.andEmailLike(<span class="string">"%e%"</span>);</span><br><span class="line">        <span class="comment">//将上面两部分用or封装</span></span><br><span class="line">        example.or(criteria2);</span><br><span class="line">        </span><br><span class="line">        List&lt;Employee&gt; list = mapper.selectByExample(example);</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : list) &#123;</span><br><span class="line">            System.out.println(employee.getLastName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（八）MyBatis学习笔记-运行原理</title>
      <link href="/2020/01/05/%EF%BC%88%E5%85%AB%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/05/%EF%BC%88%E5%85%AB%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><em>掌握MyBatis运行原理是学习MyBatis插件技术的基础。*</em>学习MyBatis运行原理，我们可以使用Debug一步一步地去理解。***</p><p>下面分析<a href="https://blog.csdn.net/weixin_40374341/article/details/86527843" target="_blank" rel="noopener">笔记二</a>的HelloWorld工程，分为如下步骤分析MyBatis的运行原理。</p><ul><li>获取sqlSessionFactory对象</li><li>获取sqlSession对象</li><li>获取接口的代理对象（MapperProxy），即getMapper方法的执行过程。</li><li>执行增删改查方法</li></ul><a id="more"></a><h2 id="1-获取sqlSessionFactory对象"><a href="#1-获取sqlSessionFactory对象" class="headerlink" title="1. 获取sqlSessionFactory对象"></a>1. 获取sqlSessionFactory对象</h2><p><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120223537782.png" alt="在这里插入图片描述"><br>在XmlConfigBuilder中会创建<strong>XML解析器parser，它用来解析全局配置信息和映射器文件mapper.xml 信息。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121113520422.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121125938726.png" alt="在这里插入图片描述"><br>XPathParser子解析器主要的属性和方法如下所示：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120223851875.png" alt="在这里插入图片描述"><br>解析器解析全局配置文件的部分代码如下：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/2019012113090141.png" alt="在这里插入图片描述"><br>需要说明的是在解析映射器文件mapper.xml 时，会将解析出来的数据封装到一个MappedStatement对象中，<strong>它封装了一个增删改查标签的详细信息</strong>。具体的一些属性如下所示：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120224200114.png" alt="在这里插入图片描述"><br>从上图中可以发现，MappedStatement对象中的id值和sql语句正是我们HellowWorld工程中EmployeeMapper.xml中select查询标签的内容。</p><p>每一次解析都会把配置文件的内容封装到Configuration中，也就是说<strong>Configuration对象保存了所有配置文件的详细信息。</strong> 比如解析setting标签的代码如下：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121114514924.png" alt="在这里插入图片描述"><br>Configuration类的一些属性如下所示：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120224834475.png" alt="在这里插入图片描述"><br>显然上方一些属性比如懒加载aggressiveLazyLoading，二级缓存cahceEnabled等信息都被封装到Configuraton中。</p><p>Configuraton类中一些比较重要的属性，比如我们上面提到的用来封装解析映射器文件mapper.xml数据的MappedStatement。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/2019012022552775.png" alt="在这里插入图片描述"><br>以及MapperRegistry对象，它表明了一个映射器接口对应了一个MapperProxyFactory，也就是映射器代理工厂。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120225609566.png" alt="在这里插入图片描述"><br>最后，<strong>Configuraton对象会被封装到一个DefaultSqlSessionFactory类中，并返回给调用者，</strong> 其中DefaultSqlSessionFactory为SqlSessionFactory接口的实现类。至此，sqlSessionFactory对象的构建基本完成。</p><h2 id="2-获取sqlSession对象"><a href="#2-获取sqlSession对象" class="headerlink" title="2. 获取sqlSession对象"></a>2. 获取sqlSession对象</h2><p><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120231243261.png" alt="在这里插入图片描述"><br>sqlSessionFactory调用openSession方法，会执行SqlSession接口的子类DefaultSqlSessionFactory的openSession方法。在该方法中，实际调用的是openSessionFromDataSource方法。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121113044557.png" alt="在这里插入图片描述"><br>执行openSessionFromDataSource时，会获取一些信息还有创建事务器工厂创建事务等操作。<strong>其中需要注意的是，该方法中会根据配置信息调用Configuration对象的newExecutor方法创建对应的执行器Executer—一个真正执行Java和数据库交互的对象。执行器提供了查询、更新等方法。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121113147941.png" alt="在这里插入图片描述"><br>再创建出执行器Executor后，接着会根据是否开启了二级缓存配置判断是否要包装该执行器。执行完该步骤后，<strong>需要注意的是，MyBatis会执行executor = (Executor) interceptorChain.pluginAll(executor);该语句来使用每一个拦截器来包装执行器。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121113347101.png" alt="在这里插入图片描述"><br>最后，<strong>创建SqlSession接口的子类DefaultSqlSession来封装Configration和执行器Executor，并返回给调用者。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121113305772.png" alt="在这里插入图片描述"><br> 至此，获取sqlSession对象的过程便结束了。</p><h2 id="3-获取接口的代理对象"><a href="#3-获取接口的代理对象" class="headerlink" title="3. 获取接口的代理对象"></a>3. 获取接口的代理对象</h2><p><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120233624769.png" alt="在这里插入图片描述"><br>sqlSession对象调用getMapper方法后会调用Configuration对象的getMapper方法，接着是调用mapperRegistry对象的getMapper方法。</p><p>在mapperRegistry对象的getMapper方法中，则会根据接口类型获取MapperProxyFactory对象，该对象通过执行该语句mapperProxyFactory.newInstance(sqlSession);来创建MapperProxy对象。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121114943378.png" alt="在这里插入图片描述"><br><strong>其中newInstance方法的执行，是通过动态代理执行MapperProxy代理逻辑类（实现InvocationHandler）的newInstance来创建的其对象实例的。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121115128258.png" alt="在这里插入图片描述"></p><p><strong>最后会返回MapperProxy类的代理对象给调用者，该对象包含有DefaultSqlSession实例。</strong> 如下图示：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190120235131189.png" alt="在这里插入图片描述"><br>至此，获取接口的代理对象的过程，即getMapper方法的调用过程也结束了。</p><h2 id="4-执行增删改查方法（查询）"><a href="#4-执行增删改查方法（查询）" class="headerlink" title="4. 执行增删改查方法（查询）"></a>4. 执行增删改查方法（查询）</h2><p><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121091755417.png" alt="在这里插入图片描述"><br>调用者在调用查询方法时，其实会调用代理对象MapperProxy的invoke方法，然后会调用MapperMethod的execute方法。</p><p>执行execute方法时，会先判断增删改查的类型，也就是先判断当前是要进行增加还是查询等操作，这里是要进行查询。<strong>接着调用convertArgsToSqlCommandParam方法，该方法是我们熟悉的将查询所需要的参数封装为一个Map集合等操作。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121092514663.png" alt="在这里插入图片描述"><br>包装完后会接着执行DefaultSqlSession类的selectOne方法，然后<strong>执行selectList方法。在该方法中，会通过Configuration对象的来获取一个MappedStatement，我们知道MappedStatement它封装了一个增删改查标签的详细信息。接着会调用执行器Excutor的的query方法，该query方法判断查询所需要的参数类型是否为Collection集合、List集合或者array。我们之前说过，若查询参数是Collection集合，MyBatis会有自定义的别名collection，这个功能实现便是通过query里的参数方法wrapCollection实现的。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121094242333.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121094328817.png" alt="在这里插入图片描述"><br>紧接着，调用query方法后，会<strong>执行CachingExcutor里的query方法。它通过MappedStatement对象获取到了BoundSql对象，该对象代表sql语句的详细信息</strong>。其属性等内容如下所示：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121094728242.png" alt="在这里插入图片描述"><br>获取完BoundSql对象后，会根据是否开启了二级缓存来获取相应的key来创建缓存。其中的key的内容如下：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121095156561.png" alt="在这里插入图片描述"><br>缓存中保存的key：方法id+sql+参数xxx等等。接着便又开始执行CachingExcutor的query方法。CachingExcutor里的query方法的代码如下：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121095514997.png" alt="在这里插入图片描述"><br>调用query方法中SimpleExcutor的query方法后，会先查看本地缓存是否有数据，没有就调用queryFromDatabase，查出数据以后将数据保存到本地缓存中。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/2019012110052296.png" alt="在这里插入图片描述"><br>执行queryFromDatabase方法后，便会在该方法中执行doQuery方法。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/2019012110351670.png" alt="在这里插入图片描述"><br><strong>在doQuery方法中，会通过Configuration对象来创建StatementHadler对象，StatementHadler即为数据库会话器，其专门用来处理数据库会话的。</strong> 如下为创建过程：<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/2019012110171757.png" alt="在这里插入图片描述"><br><strong>需要注意的是，MyBatis会执行statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);该语句来使用每一个拦截器来包装StatementHandler。</strong></p><p>返回之后，会调用prepareStatement方法进行预编译将产生返回的PrepareStatement对象设置给对象stmt。</p><p><strong>在预编译sql产生PrepareStatement期间会创建ParameterHandler和ResultSetHandler。ParameterHandler即为参数处理器，MyBatis是通过该类对预编译语句进行参数设置的。而ResultSetHandler为结果处理器，用于组装结果集返回的。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121103647712.png" alt="在这里插入图片描述"><br>在调用prepareStatement方法时会调用ParameterHandler设置参数。<strong>在调用setParameters时，会调用TypeHandler给sql预编译设置参数。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121104104824.png" alt="在这里插入图片描述"><br>这些执行完后，会继续调用doQuery方法的query方法。<br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121104850245.png" alt="在这里插入图片描述"><br><strong>并将查出的数据使用ResultSetHandler处理结果，其是通过使用TyperHandler来获取查询的值的。</strong><br><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121105504583.png" alt="在这里插入图片描述"><br>后续就将查询到的数据的List集合或其元素返回给调用者。这里因为是根据1号员工的id查询，所以返回List集合的第一个元素。</p><h3 id="4-1-查询流程总结"><a href="#4-1-查询流程总结" class="headerlink" title="4.1 查询流程总结"></a>4.1 查询流程总结</h3><p><img src="/2020/01/05/（八）MyBatis学习笔记-运行原理/20190121111212358.png" alt="在这里插入图片描述"><br>调用者在调用查询方法时，实际调用的是DefaultSqlSession里的执行器Executor对象的query方法。然后由它调度StatementHadler对象来进行<strong>设置参数等处理sql语句预编译</strong>相关工作。而StatementHadler具体的工作由ParameterHandler和ResultSetHandler处理。<strong>ParameterHandler负责sql语句的参数设置</strong>，而<strong>ResultSetHandler负责查询结果集的处理。</strong> 而两者工作的整个过程中，需要<strong>TypeHandler进行数据库类型和javaBean类型的映射， 并由TypeHandler来进行参数设置和查询结果集的处理工作。</strong> TypeHandler底层使用的是原生JDBC的方式来访问数据库。</p><p>SqlSession下的四大对象分别如下：</p><ul><li>Executor — 执行器</li><li>StatementHandler — 数据库处理器</li><li>ParameterHandler — 参数处理器</li><li>ResultSetHandler — 结果集处理器</li></ul><p>另外：TypeHandler类型处理器后续会讲解。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>上述的总体流程如下：</p><ol><li>根据配置文件（全局配置文件，映射器文件）初始化出Configuration对象；</li><li>创建一个DefaultSqlSession对象，它里面包含Configuration以及Executor（根据全局配置文件中的defaultExecutorType创建出对应的Executor）</li><li>DefaultSqlSession.getMapper（）：拿到Mapper接口对应的MapperProxy，MapperProxy里面有（DefaultSqlSession）；</li><li>执行增删改查方法：<ul><li>调用DefaultSqlSession的增删改查（Executor）；</li><li>然后创建一个StatementHandler对象；（同时也会创建出ParameterHandler和ResultSetHandler）；</li><li>调用StatementHandler预编译参数以及设置参数值；使用ParameterHandler来给sql设置参数；</li><li>调用StatementHandler的增删改查方法；</li><li>使用ResultSetHandler封装结果；</li></ul></li></ol><p>注意：四大对象每个创建的时候都有一个interceptorChain.pluginAll(parameterHandler);</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（九）MyBatis学习笔记-插件开发</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B9%9D%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B9%9D%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-插件原理"><a href="#1-插件原理" class="headerlink" title="1. 插件原理"></a>1. 插件原理</h2><p>MyBatis在四大对象的创建过程中，都会有插件进行介入。 <strong>插件可以利用动态代理机制一层层的包装目标对象，而实现在目标对象执行目标方法之前进行拦截的效果</strong> 。MyBatis 允许在已映射语句执行过程中的某一点进行拦截调用。</p><a id="more"></a><p>默认情况下，MyBatis 允许使用插件来拦截的对象和方法包括如下内容：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121151718879.png" alt="在这里插入图片描述"><br>之前在讲MaBatis的运行原理的时候，讲到了使用拦截器链来包装生成四大对象，以执行器Executor为例。其创建代码如下：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121152535843.png" alt="在这里插入图片描述"><br>其中pluginAll方法的代码如下：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121152830244.png" alt="在这里插入图片描述"><br>该方法获取所有的拦截器Interceptor，并调用拦截器的plugin方法包装并返回目标对象target。</p><p>而对于插件，我们需要实现Interceptor接口。我们可以使用插件为目标对象创建一个代理对象，也就是为四大对象创建代理对象，而代理对象就可以拦截到四大对象的每一个执行。我们在执行前后或者基于该执行自定义我们自己的执行过程。</p><h2 id="2-插件编写与运行"><a href="#2-插件编写与运行" class="headerlink" title="2. 插件编写与运行"></a>2. 插件编写与运行</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><ol><li><p>先编写Interceptor的实现类，即插件类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">    <span class="meta">@Signature</span>(type=StatementHandler.class, method=<span class="string">"parameterize"</span>,args=java.sql.Statement.class)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFirstPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截目标对象和目标方法的执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"intercept方法拦截的目标方法："</span> + invocation.getMethod());</span><br><span class="line">        <span class="comment">//调用proceed即执行目标方法，方法的内容为：method.invoke(target, args);</span></span><br><span class="line">        Object proceed = invocation.proceed();</span><br><span class="line">        <span class="comment">//返回执行后的返回值</span></span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法用来包装目标对象，这里需要为目标对象创建一个代理对象。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"plugin将要包装的对象："</span> + target);</span><br><span class="line">        <span class="comment">//借助Plugin的wrap方法来使用当前Intercepter包装目标对象</span></span><br><span class="line">        <span class="comment">//相当于调用Proxy.newProxyInstance方法</span></span><br><span class="line">        Object wrap = Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//返回为当前target创建的动态代理对象</span></span><br><span class="line">        <span class="keyword">return</span> wrap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将插件注册时的property属性设置进来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"插件配置的信息："</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Interceptors注解完成插件签名，示例如下：<br> <img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/201901211612071.png" alt="在这里插入图片描述"><br> 其中Intercepters标签类中定义如下，其声明了该标签需要实现的内容，也就是Signature注解。<br> <img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121161248953.png" alt="在这里插入图片描述"><br> Signature注解定义了如下内容，其中type是我们要拦截的四大对象的Class对象，method则是该对象中要拦截的方法，args则是该方法中的参数的Class对象。<br> <img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121161456238.png" alt="在这里插入图片描述"></p></li><li><p>将写好的插件注册到全局配置文件中。<br> <img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121162156619.png" alt="在这里插入图片描述"></p></li><li><p>运行结果<br> <img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121171852469.png" alt="在这里插入图片描述"></p><h3 id="2-2-执行原理"><a href="#2-2-执行原理" class="headerlink" title="2.2 执行原理"></a>2.2 执行原理</h3><p>当四大对象通过拦截器链的pluginAll方法时，因为我们编写了实现拦截器接口的插件类，这时运行之后就会调用MyFirstPlugin类的plugin方法。如下图示：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121152830244.png" alt="在这里插入图片描述"><br>执行MyFirstPlugin类的plugin方法后，会调用Plugin类的wrap方法。<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121164820842.png" alt="在这里插入图片描述"><br>在wrap方法中，会通过if语句来判断signatureMap内容中是否有我们要拦截的对象和方法（这里抽取到interfaces中），如果没有则直接返回target，有则创建代理对象。<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121165305348.png" alt="在这里插入图片描述"><br>插件产生目标对象的如下代理对象之后，会返回给MyBatis使用。<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/2019012117023297.png" alt="在这里插入图片描述"><br>之后调用Statement的预编译时，会通过代理对象调用我们插件类MyFirstPlugin中的拦截方法intercept，输出我们自定义的语句之后，调用proceed方法直接放行。</p></li></ol><p>输出结果大致含义：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121171835852.png" alt="在这里插入图片描述"></p><h2 id="3-多插件运行"><a href="#3-多插件运行" class="headerlink" title="3. 多插件运行"></a>3. 多插件运行</h2><p>在原有的基础在创建一个插件MySecondPlugin，并在全局配置文件进行注册，插件类编写与MyFirstPlugin基本一样，这里不再赘述。</p><p>其运行结果如下：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121172737457.png" alt="在这里插入图片描述"><br>需要注意的是，创建动态代理的时候，是按照插件配置顺序创建层层代理对象。<br>执行目标方法的之后，按照逆向顺序执行。如下图示：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121174639277.png" alt="在这里插入图片描述"><br>另外，多个插件就会产生多层代理，也就是在第一个产生的代理对象中在基础上产生一层代理，大致结构如下：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/2019012117311931.png" alt="在这里插入图片描述"></p><h2 id="4-简单应用"><a href="#4-简单应用" class="headerlink" title="4. 简单应用"></a>4. 简单应用</h2><p>需求：使用插件将本来查询1号的员工的查询语句在执行过程中改成查询3号员工。</p><p>修改MyFirstPlugin的拦截方法，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"MyFirstPlugin...intercept方法拦截的目标方法："</span> + invocation.getMethod());</span><br><span class="line">    <span class="comment">//动态的改变一下sql运行的参数：以前1号员工，实际从数据库查询3号员工</span></span><br><span class="line">    Object target = invocation.getTarget();</span><br><span class="line">    System.out.println(<span class="string">"当前拦截到的对象："</span>+target);</span><br><span class="line">    <span class="comment">//拿到：StatementHandler==&gt;ParameterHandler===&gt;parameterObject</span></span><br><span class="line">    <span class="comment">//拿到target的元数据</span></span><br><span class="line">    MetaObject metaObject = SystemMetaObject.forObject(target);</span><br><span class="line">    Object value = metaObject.getValue(<span class="string">"parameterHandler.parameterObject"</span>);</span><br><span class="line">    System.out.println(<span class="string">"sql语句用的参数是："</span>+value);</span><br><span class="line">    <span class="comment">//修改完sql语句要用的参数</span></span><br><span class="line">    metaObject.setValue(<span class="string">"parameterHandler.parameterObject"</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//执行目标方法</span></span><br><span class="line">    Object proceed = invocation.proceed();</span><br><span class="line">    <span class="comment">//返回执行后的返回值</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（九）MyBatis学习笔记-插件开发/20190121173925778.png" alt="在这里插入图片描述"><br>从结果可以知道，我们传入的id值是1，但是我们实际使用的id是3去查询3号员工。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十）MyBatis学习笔记-扩展</title>
      <link href="/2020/01/05/%EF%BC%88%E5%8D%81%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%89%A9%E5%B1%95/"/>
      <url>/2020/01/05/%EF%BC%88%E5%8D%81%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-PageHelper分页插件"><a href="#1-PageHelper分页插件" class="headerlink" title="1. PageHelper分页插件"></a>1. PageHelper分页插件</h2><p>PageHelper是Mybatis通用的分页插件，更加详细地用法参考<a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">官方文档</a>。</p><p>下面演示一下该插件的一些功能的用法。</p><a id="more"></a><h3 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><ol><li><p>先导入需要的Jar包，可以在官方文档地址处下载。<br> <img src="/2020/01/05/（十）MyBatis学习笔记-扩展/20190121203946217.png" alt="在这里插入图片描述"></p></li><li><p>在全局配置文件中，配置插件。<br> <img src="/2020/01/05/（十）MyBatis学习笔记-扩展/20190121204322237.png" alt="在这里插入图片描述"></p></li><li><p>演示PageHelper类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        <span class="comment">//第一个参数为页码，第二个参数为每页显示的数量</span></span><br><span class="line">        Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//查询获取所有的员工对象</span></span><br><span class="line">        List&lt;Employee&gt; emps = mapper.getAllEmps();</span><br><span class="line">        <span class="comment">//输出所有员工的数据</span></span><br><span class="line">        <span class="keyword">for</span> (Employee emp : emps) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取全部查询的员工数据数量</span></span><br><span class="line">        <span class="keyword">long</span> total = page.getTotal();</span><br><span class="line">        System.out.println(<span class="string">"员工数据数量："</span> + total);</span><br><span class="line">        <span class="comment">//获取所有页码数量</span></span><br><span class="line">        <span class="keyword">int</span> pages = page.getPages();</span><br><span class="line">        System.out.println(<span class="string">"所有页码数量"</span> + pages);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pageSize = page.getPageSize();</span><br><span class="line">        System.out.println(<span class="string">"每页大小："</span> + pageSize);</span><br><span class="line">        <span class="keyword">int</span> pageNum = page.getPageNum();</span><br><span class="line">        System.out.println(<span class="string">"当前页号："</span> + pageNum);</span><br><span class="line">        <span class="keyword">int</span> startRow = page.getStartRow();<span class="comment">//从0开始算</span></span><br><span class="line">        System.out.println(<span class="string">"当前页的开始行号："</span> + startRow);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">getSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：PageHelper的调用需要在查询数据库之前，否则不会分页显示数据的。</strong></p></li><li><p>演示PageInfo类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.根据MyBatis的配置文件，即mybatis-config.xml创建SqlSessionFactory</span></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();</span><br><span class="line">    <span class="comment">//2.获取session实例，能直接执行*已经映射的SQL语句*</span></span><br><span class="line">    SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//3.获取接口的实现类对象</span></span><br><span class="line">        EmployeeMapper mapper = session.getMapper(EmployeeMapper.class);</span><br><span class="line">        PageHelper.startPage(<span class="number">4</span>, <span class="number">1</span>);<span class="comment">//分页</span></span><br><span class="line">        <span class="comment">//查询获取所有的员工对象</span></span><br><span class="line">        List&lt;Employee&gt; emps = mapper.getAllEmps();</span><br><span class="line">        <span class="comment">//输出所有员工的数据</span></span><br><span class="line">        <span class="keyword">for</span> (Employee emp : emps) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//PageInfo&lt;Employee&gt; pageInfo =  new PageInfo&lt;&gt;(emps);</span></span><br><span class="line">        <span class="comment">//第二个参数为页码，表示要连续显示几页</span></span><br><span class="line">        PageInfo&lt;Employee&gt; pageInfo =  <span class="keyword">new</span> PageInfo&lt;&gt;(emps,<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">int</span>[] navigatepageNums = pageInfo.getNavigatepageNums();</span><br><span class="line">        System.out.println(<span class="string">"连续显示的页码："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : navigatepageNums) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取所有页码数量</span></span><br><span class="line">        <span class="keyword">int</span> pages = pageInfo.getPages();</span><br><span class="line">        System.out.println(<span class="string">"所有页码数量:"</span> + pages);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pageSize = pageInfo.getPageSize();</span><br><span class="line">        System.out.println(<span class="string">"每页大小："</span> + pageSize);</span><br><span class="line">        <span class="keyword">int</span> pageNum = pageInfo.getPageNum();</span><br><span class="line">        System.out.println(<span class="string">"当前页号："</span> + pageNum);</span><br><span class="line">        <span class="keyword">int</span> startRow = pageInfo.getStartRow();<span class="comment">//从0开始算</span></span><br><span class="line">        System.out.println(<span class="string">"当前页的开始行号："</span> + startRow);</span><br><span class="line">        <span class="keyword">boolean</span> isFirstPage = pageInfo.isIsFirstPage();</span><br><span class="line">        System.out.println(<span class="string">"是否为第一页："</span> + isFirstPage);</span><br><span class="line">        <span class="keyword">long</span> total = pageInfo.getTotal();</span><br><span class="line">        System.out.println(<span class="string">"员工数据总数量："</span> + total);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭会话session</span></span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（十）MyBatis学习笔记-扩展/20190121212631812.png" alt="在这里插入图片描述"></p><h2 id="2-批量操作"><a href="#2-批量操作" class="headerlink" title="2. 批量操作"></a>2. 批量操作</h2><p>之前我们执行批量插入的时候，通常调用数据库进行如下的SQL语句格式的操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(xxx,xxx,xxx),<span class="keyword">values</span>(xxx,xxx,xxx),...</span><br><span class="line"><span class="number">2.</span> <span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(xxx,xxx,xxx);<span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span>(xxx,xxx,xxx);</span><br></pre></td></tr></table></figure></li></ol><p>但是以上的做法可能形成冗长的SQL语句，从而超出数据库的限制，下面我们可以通过设置BatchExector配置的形式来处理。</p><p>假如映射器定义有如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加员工方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEmp</span><span class="params">(Employee emp)</span></span>;</span><br></pre></td></tr></table></figure><p>对应的映射器文件配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addEmp"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">  insert into tbl_employee(last_name,gender,email) values(#&#123;lastName&#125;,#&#123;gender&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码如下：<br><img src="/2020/01/05/（十）MyBatis学习笔记-扩展/20190121214840991.png" alt="在这里插入图片描述"><br>运行结果如下：<br><img src="/2020/01/05/（十）MyBatis学习笔记-扩展/20190121214925455.png" alt="在这里插入图片描述"><br>如果我们改用之前的sqlSession对象，也就是通过如下语句获取创建的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>其运行结果如下所示：<br><img src="/2020/01/05/（十）MyBatis学习笔记-扩展/20190121215118511.png" alt="在这里插入图片描述"><br>从以上两次运行结果可以明显得知，使用ExectorType.BATCH配置来执行批量插入耗时更短，它只预编译一次并执行一次SQL语句。而原本的方式则每次都会预编译一次SQL语句，并且每次都会执行一次SQL语句，也就说我每插入100条数据，数据库就会执行100百次SQL语句。显然，这是不可取的。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）MyBatis学习笔记-MyBatis介绍</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89MyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-MyBatis%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MyBatis简介"><a href="#1-MyBatis简介" class="headerlink" title="1. MyBatis简介"></a>1. MyBatis简介</h2><ul><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架。</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old JavaObjects，普通的Java对象）映射成数据库中的记录.</li></ul><a id="more"></a><h2 id="2-为什么要使用MyBatis？"><a href="#2-为什么要使用MyBatis？" class="headerlink" title="2. 为什么要使用MyBatis？"></a>2. 为什么要使用MyBatis？</h2><ul><li>MyBatis是一个半自动化的持久化层框架。所谓半自动化就是将sql和java编码分开，功能边界清晰，一个专注业务、一个专注数据。核心sql需要开发人员进行编写和优化。</li><li>JDBC<ol><li>SQL夹在Java代码块里，耦合度高导致硬编码内伤<ol start="2"><li>维护不易且实际开发需求中sql是有变化，频繁修改的情况多见 维护不易且实际开发需求中sql是有变化，频繁修改的情况多见</li></ol></li></ol></li><li>Hibernate和JPA<ol><li>长难复杂的SQL，对于Hibernate而言处理也不容易</li><li>内部自动生成的SQL，不容易做特殊优化。</li><li>基于全映射的全自动框架，大量字段的POJO进行部分映射时比较困难。<br> 导致数据库性能下降。</li></ol></li></ul><h2 id="3-源码下载以及官方文档"><a href="#3-源码下载以及官方文档" class="headerlink" title="3. 源码下载以及官方文档"></a>3. 源码下载以及官方文档</h2><p><a href="https://github.com/mybatis/mybatis-3/" target="_blank" rel="noopener">源码下载地址</a><br><img src="/2020/01/05/（一）MyBatis学习笔记-MyBatis介绍/20190117151116494.png" alt="在这里插入图片描述"><br>下图中，mabatis-3.4.1.zip为存放Mybatis所用到的Jar包和官方文档等的压缩包；Source code(zip)为Mybatis的源码包。<br><img src="/2020/01/05/（一）MyBatis学习笔记-MyBatis介绍/2019011715184089.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）SpringMVC学习笔记-表单标签&amp;静态资源处理</title>
      <link href="/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-表单标签"><a href="#1-表单标签" class="headerlink" title="1. 表单标签"></a>1. 表单标签</h1><p>通过 SpringMVC 的表单标签可以实现<strong>将模型数据中的属性和 HTML 表单元素相绑定</strong>，以实现表单数据更便捷编辑和<strong>表单值的回显</strong>。</p><p>SpringMVC 提供了多个表单组件标签，如 <strong>&lt;form:input/&gt;、&lt;form:select/&gt;</strong>  等，用以绑定表单字段的属性值，它们的共有属性如下：</p><ul><li>path：表单字段，对应 html 元素的 name 属性，支持级联属性</li><li>htmlEscape：是否对表单值的 HTML 特殊字符进行转换，默认值为 true</li><li>cssClass：表单组件对应的 CSS 样式类名</li><li>cssErrorClass：表单组件的数据存在错误时，采取的 CSS 样式。</li></ul><p><strong>form:input、form:password、form:hidden、form:textarea：</strong> 对应 HTML 表单的 text、password、hidden、textarea标签。</p><a id="more"></a><p><strong>form:radiobutton</strong>：单选框组件标签，当表单 bean 对应的属性值和    <strong>form:radiobuttons：</strong> 单选框组标签，用于构造多个单选框。</p><ul><li>items：可以是一个 List、String[] 或 Map</li><li>itemValue：指定 radio 的 value 值。可以是集合中 bean 的一个属性值</li><li>itemLabel：指定 radio 的 label 值</li><li>delimiter：多个单选框可以通过 delimiter 指定分隔符 value 值相等时，单选框被选中。</li></ul><p><strong>form:checkbox：</strong> 复选框组件。用于构造单个复选框。<br><strong>form:checkboxs：</strong> 用于构造多个复选框。使用方式同form:radiobuttons 标签<br><strong>form:select</strong>：用于构造下拉框组件。使用方式同form:radiobuttons 标签<br><strong>form:option</strong>：下拉框选项组件标签。使用方式同form:radiobuttons 标签<br><strong>form:errors</strong>：显示表单组件或数据校验所对应的错误</p><ul><li>&lt;form:errors path= “ *” /&gt; ：显示表单所有的错误</li><li>&lt;form:errors path= “ user*” /&gt; ：显示所有以 user 为前缀的属性对应的错误</li><li>&lt;form:errors path= “ username” /&gt; ：显示特定表单对象属性的错误</li></ul><p><strong>注意：form:errors将结合数据校验一起讲。</strong></p><p>下面简单演示一下一些表单标签的使用：</p><ol><li>首先需要在控制器类EmployeeHandler上添加如下方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emp"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">input</span><span class="params">(Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Department&gt; departmentMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    departmentMap.put(<span class="number">101</span>, <span class="keyword">new</span> Department(<span class="number">101</span>, <span class="string">"D-AA"</span>));</span><br><span class="line">    departmentMap.put(<span class="number">102</span>, <span class="keyword">new</span> Department(<span class="number">102</span>, <span class="string">"D-BB"</span>));</span><br><span class="line">    <span class="comment">//需要将所有部门信息放在请求域中，在员工信息添加页面以下拉列表的形式显示部门名称</span></span><br><span class="line">    <span class="comment">//values方法获取键对应的值</span></span><br><span class="line">    map.put(<span class="string">"departments"</span>, departmentMap.values());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"input"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>当我们在页面上点击超链接时会有该方法进行处理，将所有的部门信息添加到Map数据模型中，以方便在input.jsp页面进行数据的读取和回显。</p><ol start="2"><li>下面是input.jsp界面的具体实现：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">import</span>=<span class="string">"java.util.*"</span> %&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 导入SpringMVC的表单标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"form"</span> <span class="attr">uri</span>=<span class="string">"http://www.springframework.org/tags/form"</span> %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>添加员工<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form:form</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/emp"</span> <span class="attr">method</span>=<span class="string">"POST"</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- path：表单字段，对应 html 元素的 name 属性，支持级联属性 </span></span><br><span class="line"><span class="comment">对应指定类的属性名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        LastName: <span class="tag">&lt;<span class="name">form:input</span> <span class="attr">path</span>=<span class="string">"lastName"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        Email: <span class="tag">&lt;<span class="name">form:input</span> <span class="attr">path</span>=<span class="string">"email"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">form:radiobuttons：单选框组标签，用于构造多个单选框.</span></span><br><span class="line"><span class="comment">items：可以是一个 List、String[] 或 Map</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line">            //注意：new HashMap&lt;&gt;();这种格式JDK1.7以上才支持，否则JSP编译出错</span><br><span class="line">            Map<span class="tag">&lt;<span class="name">String,String</span>&gt;</span> genders = new HashMap();</span><br><span class="line">            genders.put("1", "Male");</span><br><span class="line">            genders.put("0", "Female");</span><br><span class="line">            //需要放入请求域中，否则EL表达式无法取到值</span><br><span class="line">            request.setAttribute("genders", genders);</span><br><span class="line">        %&gt;</span><br><span class="line">        <span class="comment">&lt;!-- 多个单选框可以通过 delimiter 指定分隔符 --&gt;</span></span><br><span class="line">        Gender: <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">form:radiobuttons</span> <span class="attr">path</span>=<span class="string">"gender"</span> <span class="attr">items</span>=<span class="string">"$&#123;genders &#125;"</span> <span class="attr">delimiter</span>=<span class="string">"&lt;br&gt;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下拉列表 </span></span><br><span class="line"><span class="comment">itemValue：指定 radio 的 value 值。可以是集合中 bean 的一个属性值</span></span><br><span class="line"><span class="comment">    itemLabel：指定 radio 的 label 值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        Department: <span class="tag">&lt;<span class="name">form:select</span> <span class="attr">path</span>=<span class="string">"department.id"</span></span></span><br><span class="line"><span class="tag"><span class="attr">items</span>=<span class="string">"$&#123;departments&#125;"</span> <span class="attr">itemLabel</span>=<span class="string">"departmentName"</span> <span class="attr">itemValue</span>=<span class="string">"id"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong> SpringMVC会通过 modelAttribute 属性指定绑定的模型属性，若没有指定该属性，则默认从 request 域对象中读取command 的表单 bean，如果该属性值也不在，则会发生错误<strong>java.lang.IllegalStateException: Neither BindingResult nor plain target object for bean name ‘command’ available as request attribute。</strong></p><ol start="4"><li><p>那么需要在&lt;form:form&gt;上配置<strong>modelAttribute</strong>属性，即modelAttribute=”employee”。接着需要在控制器类的input加上如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//键"employee"匹配input.jsp页面的form表单的modelAttribute的属性值</span></span><br><span class="line">map.put(<span class="string">"employee"</span>, <span class="keyword">new</span> Employee());</span><br></pre></td></tr></table></figure></li><li><p>运行结果如下所示：<br><img src="/2020/01/05/（四）SpringMVC学习笔记-表单标签-静态资源处理/20190213223551768.png" alt="在这里插入图片描述"></p><h1 id="2-静态资源处理"><a href="#2-静态资源处理" class="headerlink" title="2. 静态资源处理"></a>2. 静态资源处理</h1><p>在web.xml文件中，若将 DispatcherServlet 请求映射配置为 /，则 Spring MVC 将捕获WEB 容器的所有请求，包括静态资源的请求， 如JQuery的请求。SpringMVC 会将他们当成一个普通请求处理，因找不到对应处理器将导致错误。</p></li></ol><p>我们可以在 SpringMVC 的配置文件中配置 <strong>&lt;mvc:default-servlethandler/&gt;</strong> 的方式解决静态资源的问题：</p><ul><li><strong>&lt;mvc:default-servlet-handler/&gt;</strong> 将在 SpringMVC 上下文中定义一个<strong>DefaultServletHttpRequestHandler</strong>，它会对进入 DispatcherServlet 的请求进行筛查，如果发现是没有经过映射的请求，就将该请求交由 WEB应用服务器默认的 Servlet处理，如果不是静态资源的请求，才由DispatcherServlet 继续处理；因此，我们在配置上述的default-servlet时，<strong>同时还需要配置annotation-driven，以对非静态资源进行映射处理。</strong></li><li>一般 WEB 应用服务器默认的 Servlet 的名称都是 default。若所使用的WEB 服务器的默认 Servlet 名称不是 default，则需要通过 defaultservlet-name 属性显式指定。</li></ul><p>假如现在需要进行REST风格的操作，也就是点击超链接然后删除一个员工信息。显然，超链接是GET请求，而REST风格的删除操作则是DELETE请求，那么现在则需要导入JQuery以实现将GET请求转换为DELETE请求。具体示例如下：</p><ol><li><p>编写如下index.jsp页面，具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 导入JQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"scripts/jquery-1.9.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    $(function()&#123;</span><br><span class="line">        //拦截delete的超链接,然后执行对应的表单</span><br><span class="line">        $(".delete").click(function()&#123;</span><br><span class="line">            //获取链接</span><br><span class="line">            var href = $(this).attr("href");</span><br><span class="line">            //使用链接提交对应的form表单，从而完成get到delete请求的转化</span><br><span class="line">            $("#deleteForm").attr("action",href).submit();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;) </span><br><span class="line">        </span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 实现将GET请求转化为DELETE请求，需借助JQuery --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"deleteForm"</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"DELETE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"delete"</span> <span class="attr">href</span>=<span class="string">"emp/1"</span>&gt;</span>Delete Employee<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>我们知道，Spring MVC 将捕获WEB 容器的所有请求，包括静态资源的请求。那么此时JQuery的导入和使用是不成功的，<strong>那么现在需要在MVC配置中进行如下配置：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制器类的对应方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emp/&#123;id&#125;"</span>,method=RequestMethod.DELETE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"删除了"</span> + id + <span class="string">"号员工"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）SpringMVC学习笔记-返回JSON</title>
      <link href="/2020/01/05/%EF%BC%88%E5%85%AD%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%94%E5%9B%9EJSON/"/>
      <url>/2020/01/05/%EF%BC%88%E5%85%AD%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%BF%94%E5%9B%9EJSON/</url>
      
        <content type="html"><![CDATA[<h2 id="1-返回JSON"><a href="#1-返回JSON" class="headerlink" title="1. 返回JSON"></a>1. 返回JSON</h2><ol><li><p>加入Jar包：<br>  <img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215191425735.png" alt="在这里插入图片描述"></p></li><li><p>编写目标方法，使其返回 JSON 对应的对象或集合，并在在方法上添加 @ResponseBody 注解。具体代码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回 JSON 对应的对象或集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testJackson"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">testJackson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">100</span>, <span class="string">"aa"</span>, <span class="string">"abc123"</span>, <span class="keyword">true</span>, <span class="number">1001.2</span>, <span class="keyword">new</span> Date(), <span class="string">"shoto@gmail.com"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <a id="more"></a><p> @ResponseBody 表示该方法的返回结果<strong>直接写入 HTTP response body</strong> 中，一般在异步获取数据时使用（也就是AJAX），在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。</p></li><li><p>运行结果如下所示：<br> <img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215191706407.png" alt="在这里插入图片描述"><br> JSON数据如下所示：<br> <img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215191732377.png" alt="在这里插入图片描述"></p><h2 id="2-运行原理"><a href="#2-运行原理" class="headerlink" title="2. 运行原理"></a>2. 运行原理</h2><p>在返回JSON的示例中，JSON的返回与HttpMessageConverter&lt;T&gt;接口相关。该接口是 Spring3.0 新添加的一个接口，负责将<strong>请求信息</strong>转换为<strong>一个对象</strong>（类型为 T），将对象（类型为 T）输<strong>出为响应信息</strong>。具体的过程如下图所示：<br><img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215192136210.png" alt="在这里插入图片描述"><br>我们在页面点击请求时，HttpInpyutMessage类会将请求报文转为输入流并由HttpMessageConverter的子类转换器转换为Java对象，然后在由SpringMVC进行处理后会将Java对象通过HttpMessageConverter的子类转换器转换输入流，并生成响应报文。</p></li></ol><h2 id="3-HttpMessageConverter接口"><a href="#3-HttpMessageConverter接口" class="headerlink" title="3. HttpMessageConverter接口"></a>3. HttpMessageConverter接口</h2><h3 id="3-1-接口方法"><a href="#3-1-接口方法" class="headerlink" title="3.1 接口方法"></a>3.1 接口方法</h3><p>HttpMessageConverter&lt;T&gt;接口定义的<strong>方法</strong>：</p><ul><li>Boolean <strong>canRead</strong>(Class&lt;?&gt; clazz,MediaType mediaType): 指定转换器可以读取的对象类型，即转换器是否可将请求信息转换为 clazz 类型的对象，同时指定支持 MIME 类型(text/html,applaiction/json等)</li><li>Boolean <strong>canWrite</strong>(Class&lt;?&gt; clazz,MediaType mediaType):指定转换器是否可将 clazz 类型的对象写到响应流中，响应流支持的媒体类型在MediaType 中定义。</li><li>LIst&lt;MediaType&gt; <strong>getSupportMediaTypes</strong>()：该转换器支持的媒体类型。</li><li>T <strong>read</strong>(Class&lt;? extends T&gt; clazz,<strong>HttpInputMessage</strong> inputMessage)：将请求信息流转换为 T 类型的对象。</li><li>void <strong>write</strong>(T t,MediaType contnetType,<strong>HttpOutputMessgae</strong> outputMessage):将T类型的对象写到响应流中，同时指定相应的媒体类型为 contentType。<h3 id="3-2-接口实现类"><a href="#3-2-接口实现类" class="headerlink" title="3.2 接口实现类"></a>3.2 接口实现类</h3>HttpMessageConverter有如下的实现类。<br><img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215193033465.png" alt="在这里插入图片描述"><br>DispatcherServlet 默认装配RequestMappingHandlerAdapter ，而<strong>RequestMappingHandlerAdapter 默认装配如下HttpMessageConverter</strong>：<br><img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215193218611.png" alt="在这里插入图片描述"><br>在加入 jackson jar 包后， RequestMappingHandlerAdapter装配的 HttpMessageConverter 如下：<br><img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/20190215193255666.png" alt="在这里插入图片描述"><br>上述<strong>返回JSON</strong>的示例，其底层使用的则是HttpMessageConverter的子类<strong>MappingJackson2HttpMessageConverter</strong>转化器处理的。</li></ul><h2 id="4-模拟文件上传"><a href="#4-模拟文件上传" class="headerlink" title="4. 模拟文件上传"></a>4. 模拟文件上传</h2><p>1.在请求页面编写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟文件上传 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。</span></span><br><span class="line"><span class="comment">默认地，表单数据会编码为 "application/x-www-form-urlencoded"。</span></span><br><span class="line"><span class="comment">就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 "+" 加号，</span></span><br><span class="line"><span class="comment">特殊符号转换为 ASCII HEX 值）。</span></span><br><span class="line"><span class="comment">multipart/form-dat:不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testHttpMessageConverter"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    File：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    Desc：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"desc"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span><span class="attr">value</span>=<span class="string">"Submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在控制器类中编写如下目标方法，对请求进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟数据上传</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testHttpMessageConverter"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHttpMessageConverter</span><span class="params">(@RequestBody String requestBody)</span> </span>&#123;</span><br><span class="line">    System.out.println(requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Success！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>： @RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据通过系统默认配置的 HttpMessageConverter进行解析（这里是HttpMessageConverter的子类<strong>StringHttpMessageConverter</strong>），然后封装到入参requestBody上。</p><p>3.需要<strong>在MVC文件中配置&lt;mvc:annotation-driven /&gt; **，&lt;mvc:annotation-driven /&gt; 会自动注册RequestMappingHandlerMapping、</strong>RequestMappingHandlerAdapter** 与ExceptionHandlerExceptionResolver 三个bean。正如前面所提到的RequestMappingHandlerAdapter默认装配了<strong>HttpMessageConverter</strong>。</p><p>4.当在页面选择要上传的文件并输入描述文本并点击提交后，服务器端会打印如下数据并将”Success!”文本返回给客户端并显示在页面上。</p><p><img src="/2020/01/05/（六）SpringMVC学习笔记-返回JSON/2019021519495120.png" alt="在这里插入图片描述"><br>使用 HttpMessageConverter&lt;T&gt; 将请求信息转化并绑定到处理方法的入参中或将响应结果转为对应类型的响应信息，Spring 提供了两种途径：</p><ol><li>@RequestBody / @ResponseBody 对处理方法进行标注。（上面示例使用的）</li><li>使用 HttpEntity&lt;T&gt; / ResponseEntity&lt;T&gt; 作为处理方法的入参或返回值。（下面的文件下载示例）</li></ol><p>注意：@RequestBody 和 @ResponseBody 不一定要成对出现。</p><h2 id="5-文件下载"><a href="#5-文件下载" class="headerlink" title="5. 文件下载"></a>5. 文件下载</h2><p>1.首先需要在请求页面编写文件下载请求链接代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟文件下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"testResponseEntity"</span>&gt;</span>Test ResponseEntity<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.接着在控制器类中编写如下目标方法，对请求进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟数据下载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testResponseEntity"</span>)</span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] body = <span class="keyword">null</span>;</span><br><span class="line">    ServletContext servletContext = session.getServletContext();</span><br><span class="line">    <span class="comment">//读取WebContent下的files/demo.txt并将文件数据读取流中</span></span><br><span class="line">    InputStream in = servletContext.getResourceAsStream(<span class="string">"/files/demo.txt"</span>);</span><br><span class="line">    body = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">    in.read(body);</span><br><span class="line">    <span class="comment">//设置文件下载响应头</span></span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    headers.add(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename=demo.txt"</span>);</span><br><span class="line">    <span class="comment">//设置状态码</span></span><br><span class="line">    HttpStatus statusCode = HttpStatus.OK;</span><br><span class="line">    <span class="comment">//ResponseEntity设置响应头和状态码，并封装文件数据返回</span></span><br><span class="line">    ResponseEntity&lt;<span class="keyword">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> ResponseEntity&lt;&gt;(body, headers, statusCode);</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在MVC文件中配置&lt;mvc:annotation-driven /&gt;后即可点击链接进行文件的下载了。</p><p><strong>提示</strong>：当控制器处理方法使用到 @RequestBody/@ResponseBody 或HttpEntity&lt;T&gt;/ResponseEntity&lt;T&gt; 时, <strong>Spring 首先根据请求头或响应头的Accept 属性选择匹配的 HttpMessageConverter, 进而根据参数类型或泛型类型的过滤得到匹配的HttpMessageConverter, 若找不到可用的HttpMessageConverter 将报错。</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）SpringMVC学习笔记-国际化</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%83%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BD%E9%99%85%E5%8C%96/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%83%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9B%BD%E9%99%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简单示例"><a href="#1-简单示例" class="headerlink" title="1. 简单示例"></a>1. 简单示例</h3><p>下面先演示一个<strong>示例</strong>：</p><p>1.首先需要在src目录下编写三个国际化资源文件。<br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/2019021614590829.png" alt="在这里插入图片描述"><br>i18n_en_US.properties(i18n.properties)和i18n_zh_CN.properties内容分别如下所示：<br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216150051234.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216150143184.png" alt="在这里插入图片描述"></p><a id="more"></a><p>2.在MVC配置文件中注册国际化资源文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册配置国际化资源文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"i18n"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.编写index.jsp，i18n.jsp，i18n2.jsp三个页面，内容分别如下所示：<br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216150512624.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216150613709.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216150642585.png" alt="在这里插入图片描述"><br>3.在MVC配置文件进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置直接转发的页面，而无须在经过控制器的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/i18n"</span> <span class="attr">view-name</span>=<span class="string">"i18n"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"/i18n2"</span> <span class="attr">view-name</span>=<span class="string">"i18n2"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>4.在index.jsp进行请求响应之后即可根据浏览器本地语言的不同显示国际化资源文件中的不同文本。<br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216151011726.png" alt="在这里插入图片描述">)<img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216151025779.png" alt="在这里插入图片描述"><br>上面的实例即为国际化的一个简单实例。默认情况下，SpringMVC 根据 <strong>Accept-Language</strong> 参数判断客户端的本地化类型。</p><p>当接受到请求时，SpringMVC 会在上下文中查找一个<strong>本地化解析器（LocalResolver，如AcceptHeaderLocaleResolver）</strong>，找到后使用它获取请求所对应的本地化类型信息。</p><h3 id="2-获取本地的国际化资源信息"><a href="#2-获取本地的国际化资源信息" class="headerlink" title="2. 获取本地的国际化资源信息"></a>2. 获取本地的国际化资源信息</h3><p>本地的国际化资源信息封装在Locale类中，基于上述的例子我们可以在控制器类中编写如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ResourceBundleMessageSource messageSource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入参Locale是SpringMVC所支持的原始Servlet API</span></span><br><span class="line"><span class="comment"> * Locale封装了一些本地的国际化资源信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/i18n"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testI18n</span><span class="params">(Locale locale)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据对象locale获取指定的username的值</span></span><br><span class="line">    String val = messageSource.getMessage(<span class="string">"i18n.username"</span>, <span class="keyword">null</span>, locale);</span><br><span class="line">    System.out.println(val);<span class="comment">//"用户名"或"Username"</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"i18n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-动态更改本地化类型"><a href="#3-动态更改本地化类型" class="headerlink" title="3. 动态更改本地化类型"></a>3. 动态更改本地化类型</h3><p>我们还可以通过点击链接动态地更改显示的文本内容，比如显示中文或对应的英文等。</p><p>因为SpringMVC 允许装配一个动态<strong>更改本地化类型的拦截器</strong>，这样通过指定一个请求参数（如locale=zh_CN）就可以控制单个请求的本地化类型。</p><p>示例：</p><p>1.在MVC配置文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SessionLocaleResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"localeResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.SessionLocaleResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置LocaleChanceInterceptor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.i18n.LocaleChangeInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.然后在i18n.jsp中添加如下两个超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"i18n?locale=zh_CH"</span>&gt;</span>中文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"i18n?locale=en_US"</span>&gt;</span>英文<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.运行请求响应之后，我们可以动态的更改显示的文本。<br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216152644645.png" alt="在这里插入图片描述"><br>上述示例涉及到了SessionLocaleResolver &amp;LocaleChangeInterceptor ，其工作原理如下图所示（可通过<strong>debug</strong>加深理解）：<br><img src="/2020/01/05/（七）SpringMVC学习笔记-国际化/20190216152841525.png" alt="在这里插入图片描述"></p><h3 id="4-本地化解析器和本地化拦截器"><a href="#4-本地化解析器和本地化拦截器" class="headerlink" title="4. 本地化解析器和本地化拦截器"></a>4. 本地化解析器和本地化拦截器</h3><ul><li>AcceptHeaderLocaleResolver：根据 HTTP 请求头的Accept-Language 参数确定本地化类型，<strong>如果没有显式定义本地化解析器， SpringMVC 使用该解析器。</strong></li><li>CookieLocaleResolver：根据指定的 Cookie 值确定本地化类型</li><li>SessionLocaleResolver：根据 <strong>Session</strong> 中特定的属性确定本地化类型</li><li>LocaleChangeInterceptor：从<strong>请求参数</strong>中获取本次请求对应的本地化类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）SpringMVC学习笔记-HelloWorld</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HelloWorld/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HelloWorld/</url>
      
        <content type="html"><![CDATA[<h3 id="1-导入Jar包"><a href="#1-导入Jar包" class="headerlink" title="1. 导入Jar包"></a>1. 导入Jar包</h3><p><img src="/2020/01/05/（一）SpringMVC学习笔记-HelloWorld/20190210104203251.png" alt="在这里插入图片描述"><br>注意：除了日志相关的包和Spring的基本jar包和aop包外，还<strong>需要web和webmvc的jar包。</strong></p><a id="more"></a><h3 id="2-在-web-xml-中配置-DispatcherServlet"><a href="#2-在-web-xml-中配置-DispatcherServlet" class="headerlink" title="2. 在 web.xml 中配置 DispatcherServlet"></a>2. 在 web.xml 中配置 DispatcherServlet</h3><blockquote><p>DispatcherServlet是SpringMVC的一个核心控制器，是一个Servlet。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置dispatcherServlet</span></span><br><span class="line"><span class="comment">   DispatcherServlet 可以默认加载 /WEBINF/&lt;servletName-servlet&gt;.xml 的 Spring 配置文件,</span></span><br><span class="line"><span class="comment">   启动 WEB 层的 Spring 容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 通过 contextConfigLocation 初始化参数自定</span></span><br><span class="line"><span class="comment">  义配置文件的位置和名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使得Sevlet加载时创建，而非请求时创建 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Servlet拦截配置，/则表示拦截所有--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-加入-Spring-MVC-的配置文件，配置自动扫描包"><a href="#3-加入-Spring-MVC-的配置文件，配置自动扫描包" class="headerlink" title="3. 加入 Spring MVC 的配置文件，配置自动扫描包"></a>3. 加入 Spring MVC 的配置文件，配置自动扫描包</h3><p>在src路径下创建配置文件applicationContext-mvc.xml，具体内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.springmvc.handlers"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-编写处理请求的处理器，并标识为处理器"><a href="#4-编写处理请求的处理器，并标识为处理器" class="headerlink" title="4. 编写处理请求的处理器，并标识为处理器"></a>4. 编写处理请求的处理器，并标识为处理器</h3><p>下面需要在包路径com.shoto.springmvc.handlers下创建HelloWorld请求处理器类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.springmvc.handlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span><span class="comment">//标识该类为请求处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/helloSpringMVC"</span>)<span class="comment">//标识该方法为具体的请求处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hellowolrd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-配置视图解析器"><a href="#5-配置视图解析器" class="headerlink" title="5. 配置视图解析器"></a>5. 配置视图解析器</h3><p>在配置文件applicationContext-mvc.xml文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置视图解析器，将视图逻辑名解析为/WEB-INF/pages/&lt;viewName&gt;.jsp </span></span><br><span class="line"><span class="comment">其中&lt;viewName&gt;为HelloWorld类中的helloworld方法的返回值success,</span></span><br><span class="line"><span class="comment">解析完后会跳转到success.jsp页面</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-编写视图"><a href="#6-编写视图" class="headerlink" title="6. 编写视图"></a>6. 编写视图</h3><p>在/WEB-INF/pages/路径下编写视图页面success.jsp：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Success page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-编写请求视图"><a href="#7-编写请求视图" class="headerlink" title="7. 编写请求视图"></a>7. 编写请求视图</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"helloSpringMVC.action"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：href属性的值helloSpringMVC与处理器的处理方法helloworld的@RequestMapping(“/helloSpringMVC”)的值相同，它表明点击超链接会由该方法进行处理。</p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（八）SpringMVC学习笔记-文件上传</title>
      <link href="/2020/01/05/%EF%BC%88%E5%85%AB%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2020/01/05/%EF%BC%88%E5%85%AB%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 <strong>MultipartResolver</strong> 实现的。Spring 用Jakarta Commons FileUpload 技术实现了一个MultipartResolver 实现类：<strong>CommonsMultipartResovler</strong>。</p><p>Spring MVC 上下文中默认没有装配 MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用 Spring的文件上传功能，<strong>需现在上下文中配置 MultipartResolver</strong>。</p><p>同时，为了让 CommonsMultipartResovler 正确工作，必须先将 <strong>Jakarta Commons FileUpload 及 Jakarta Commons io的类包</strong>添加到类路径下。</p><a id="more"></a><p>示例：</p><p>1.首先需要加入相关的Jar包（commons-fileupload）<br><img src="/2020/01/05/（八）SpringMVC学习笔记-文件上传/20190216154237874.png" alt="在这里插入图片描述"><br>2.然后就是MVC配置文件中配置MultipartResovler，具体如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 MultipartResolver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- defaultEncoding: 必须和用户 JSP 的 pageEncoding </span></span><br><span class="line"><span class="comment">属性一致，以便正确解析表单的内容 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 还有好多属性，不一一列举了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultEncoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"102400"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.在请求页面index.jsp编写如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟文件上传 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。</span></span><br><span class="line"><span class="comment">默认地，表单数据会编码为 "application/x-www-form-urlencoded"。</span></span><br><span class="line"><span class="comment">就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 "+" 加号，</span></span><br><span class="line"><span class="comment">特殊符号转换为 ASCII HEX 值）。</span></span><br><span class="line"><span class="comment">multipart/form-dat:不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testMultipartResolver"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    File：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    Desc：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"desc"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span><span class="attr">value</span>=<span class="string">"Submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.在控制器类中编写目标方法，用于处理上传请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testMultipartResolver"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMultipartResolver</span><span class="params">(@RequestParam(<span class="string">"desc"</span>)</span> String desc, </span></span><br><span class="line"><span class="function">@<span class="title">RequestParam</span><span class="params">(<span class="string">"file"</span>)</span> MultipartFile file) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取上传文件的描述文本</span></span><br><span class="line">    System.out.println(<span class="string">"decs:"</span> + desc);</span><br><span class="line">    <span class="comment">//获取原始文件名</span></span><br><span class="line">    System.out.println(<span class="string">"OriginalFilename:"</span> + file.getOriginalFilename());</span><br><span class="line">    <span class="comment">//获取文件的输入流对象</span></span><br><span class="line">    System.out.println(<span class="string">"InputStream:"</span> + file.getInputStream());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.输出结果如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decs:my describle</span><br><span class="line">OriginalFilename:demo.txt</span><br><span class="line">InputStream:java.io.ByteArrayInputStream@2e887a00</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）SpringMVC学习笔记-映射请求&amp;请求参数</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%98%A0%E5%B0%84%E8%AF%B7%E6%B1%82-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%98%A0%E5%B0%84%E8%AF%B7%E6%B1%82-%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>本文基于SpringMVC的<a href="https://blog.csdn.net/weixin_40374341/article/details/86891498" target="_blank" rel="noopener">helloworld</a>项目来讲解演示。</p><h1 id="1-映射请求"><a href="#1-映射请求" class="headerlink" title="1. 映射请求"></a>1. 映射请求</h1><h2 id="1-1-RequestMapping-映射请求"><a href="#1-1-RequestMapping-映射请求" class="headerlink" title="1.1 @RequestMapping 映射请求"></a>1.1 @RequestMapping 映射请求</h2><p>Spring MVC 使用 @RequestMapping 注解为控制器指定可以处理哪些 <strong>URL 请求</strong>，其在控制器的类定义及方法定义处都可标注。</p><ul><li><strong>类定义处</strong>：提供初步的请求映射信息，相对于 WEB 应用的根目录；</li><li><strong>方法处</strong>：提供进一步的细分映射信息，相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL 相对于WEB 应用的根目录。</li></ul><a id="more"></a><p>下面演示一下在注解@RequestMapping在类上的使用。</p><ol><li><p>首先在com.shoto.springmvc.handlers包下创建如下类，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/springmvc"</span>)<span class="comment">//在类上使用映射请求注解</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMVCTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUCCESS = <span class="string">"success"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testRequestMapping"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testRequestMapping"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp添加如下代码以实现访问。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testRequestMapping.action"</span>&gt;</span>testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>如果在类上没有使用@RequestMapping(“/springmvc”)，那么如下代码可以写成如下的形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"testRequestMapping.action"</span>&gt;</span>testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-2-映射请求参数、请求方法和请求头"><a href="#1-2-映射请求参数、请求方法和请求头" class="headerlink" title="1.2 映射请求参数、请求方法和请求头"></a>1.2 映射请求参数、请求方法和请求头</h2><ul><li>@RequestMapping 除了可以使用请求 URL 映射请求外，还可以使用<strong>请求方法</strong>、<strong>请求参数</strong>及<strong>请求头</strong>映射请求</li><li>@RequestMapping 的 value、method、params 及 heads分别表示请求 URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可让请求映射更加精确化。</li><li>params 和 headers支持简单的表达式：<ol><li>param1: 表示请求必须包含名为 param1 的请求参数</li><li>!param1: 表示请求不能包含名为 param1 的请求参数</li><li>param1 != value1: 表示请求包含名为 param1 的请求参数，但其值不能为 value1</li><li>{“param1=value1”, “param2”}: 请求必须包含名为 param1 和param2<br> 的两个请求参数，且 param1 参数的值必须为 value1</li></ol></li></ul><h3 id="1-2-1-映射请求方法（常用）"><a href="#1-2-1-映射请求方法（常用）" class="headerlink" title="1.2.1 映射请求方法（常用）"></a>1.2.1 映射请求方法（常用）</h3><ol><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用method来指定请求方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"testMethod"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testMethod"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加如下语句进行响应测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/testMethod.action"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"testMethod"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：@RequestMapping中若未指明method属性，那么默认情况下则对于所有请求都会响应。</strong></p><h3 id="1-2-2-映射请求头"><a href="#1-2-2-映射请求头" class="headerlink" title="1.2.2 映射请求头"></a>1.2.2 映射请求头</h3><ol><li>在SpringMVCTest类中添加如下方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"testHeaders"</span>, headers= &#123;<span class="string">"Accept-Language=en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHeaders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testHeaders"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的是Accept-Language后面跟的是等号，而不是冒号。</p><ol start="2"><li>在index.jsp中添加如下语句进行响应测试<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testHeaders.action"</span>&gt;</span>testRequestHeaders<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2-3-映射请求参数"><a href="#1-2-3-映射请求参数" class="headerlink" title="1.2.3 映射请求参数"></a>1.2.3 映射请求参数</h3><ol><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"testRequestParams"</span>, params= &#123;<span class="string">"username"</span>,<span class="string">"age!=10"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testRequestParams"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加如下语句进行响应测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testRequestParams.action?username=abc&amp;age=11"</span>&gt;</span>testRequestParams<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="1-3-Ant-风格的-URL"><a href="#1-3-Ant-风格的-URL" class="headerlink" title="1.3 Ant 风格的 URL"></a>1.3 Ant 风格的 URL</h2><p>@RequestMapping 还支持 Ant 风格的 URL，Ant 风格资源地址支持 3 种匹配符：</p><ul><li>?：匹配文件名中的一个字符</li><li>*：匹配文件名中的任意字符</li><li><strong>：</strong> 匹配多层路径</li></ul><p>示例：</p><ul><li>/user/<em>/createUser: 匹配/user/*</em>aaa<strong>/createUser、/user/</strong>bbb**/createUser 等 URL</li><li>/user/<strong>/createUser: 匹配/user/createUser、/user/</strong>aaa/bbb**/createUser 等 URL</li><li>/user/createUser??: 匹配/user/createUser<strong>aa</strong>、/user/createUser<strong>bb</strong> 等 URL</li></ul><p>下面以*为例，代码示例如下：</p><ol><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"testAntPath/*/abc"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testAntPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testAntPath"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加如下语句进行响应测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testAntPath/nn/abc.action"</span>&gt;</span>testAntPath<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="2-请求参数"><a href="#2-请求参数" class="headerlink" title="2. 请求参数"></a>2. 请求参数</h1><h2 id="2-1-PathVariable-映射-URL-绑定的占位符"><a href="#2-1-PathVariable-映射-URL-绑定的占位符" class="headerlink" title="2.1 @PathVariable 映射 URL 绑定的占位符"></a>2.1 @PathVariable 映射 URL 绑定的占位符</h2><p>带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 <strong>REST</strong> 目标挺进发展过程中具有里程碑的意义。所谓的REST的具体含义如下所示：<br><img src="/2020/01/05/（二）SpringMVC学习笔记-映射请求-请求参数/20190210171444177.png" alt="在这里插入图片描述"><br><strong>举例</strong>：简单地说就是：如一超链接文本（资源）以html格式显示在页面上（表现层），点击超链接文本时会向服务器的发送GET请求获取数据，这个过程服务器端则发生了“状态转化”。</p><p>我们可以通过 @PathVariable 将 URL 中占位符参数绑定到控制器处理方法的入参中。</p><p>比如我们在SpringMVCTest定义如下方法，其实现了将占位符id绑定到控制器处理方法testPathVariable的参数id中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testPathVariable/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPathVariable</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testPathVariable："</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在index.jsp中编写如下代码，并传入参数1，即testPathVariable方法的id值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testPathVariable/1.action"</span>&gt;</span>testPathVariable<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-使用-HiddenHttpMethodFilter-过滤器"><a href="#2-2-使用-HiddenHttpMethodFilter-过滤器" class="headerlink" title="2.2 使用 HiddenHttpMethodFilter 过滤器"></a>2.2 使用 HiddenHttpMethodFilter 过滤器</h2><p>浏览器 form 表单只支持 GET与 POST 请求，而DELETE、PUT 等 method 并不支持，Spring3.0 添加了一个过滤器HiddenHttpMethodFilter，可以将这些POST请求转换为标准的 http 方法，使得支持 GET、POST、PUT 与DELETE 请求。</p><ol><li><p>首先需要进行过滤器的配置，在web.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置HiddenHttpMethodFilter，可以把POST请求转化为DELETE请求和PUT请求 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testRest/&#123;id&#125;"</span>, method=RequestMethod.PUT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRestPut</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testRest PUT："</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testRest/&#123;id&#125;"</span>, method=RequestMethod.DELETE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRestDelete</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testRest DELETE："</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testRest"</span>, method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRestPost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testRest POST"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testRest/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRestGet</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testRest GET："</span> + id);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在index.jsp中添加如下语句进行响应测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/testRest/1.action"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"PUT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"TestRest PUT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/testRest/1.action"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"DELETE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"TestRest DELETE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/testRest.action"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"TestRest POST"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testRest/1.action"</span>&gt;</span>testRest GET<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：这里使用到了隐藏表单，value的值为对应的提交方法，而name的值为_method。我们可以查看HiddenHttpMethodFilter的源码，具体如下示：<br><img src="/2020/01/05/（二）SpringMVC学习笔记-映射请求-请求参数/20190210201230363.png" alt="在这里插入图片描述"><br>即过滤器会根据表单的name的值_method去获取对应的value，然后做对应的过滤操作。</p><h2 id="2-3-使用-RequestParam-绑定请求参数值"><a href="#2-3-使用-RequestParam-绑定请求参数值" class="headerlink" title="2.3 使用 @RequestParam 绑定请求参数值"></a>2.3 使用 @RequestParam 绑定请求参数值</h2><p>在处理方法入参处使用 @RequestParam 可以把请求参数传递给请求方法。</p><p>代码示例如下：</p><ol><li>在SpringMVCTest类中添加如下方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testRequestParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam(value=<span class="string">"username"</span>)</span> String un, </span></span><br><span class="line"><span class="function">@<span class="title">RequestParam</span><span class="params">(value=<span class="string">"age"</span>, required=<span class="keyword">false</span>, defaultValue=<span class="string">"0"</span>)</span> <span class="keyword">int</span> age) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"username:"</span> + un + <span class="string">" age:"</span> + age);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：value：参数名；required：是否必须。默认为 true, 表示请求参数中必须包含对应的参数，若不存在，将抛出异常；defaultValue：默认值。基本数据类型必须要赋予默认值，因为不能使用null值表示。</p><ol start="2"><li>在index.jsp中添加如下语句进行响应测试<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testRequestParam.action?username=abc"</span>&gt;</span>testRest RequestParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-4-使用-RequestHeader-绑定请求报头的属性值"><a href="#2-4-使用-RequestHeader-绑定请求报头的属性值" class="headerlink" title="2.4 使用 @RequestHeader 绑定请求报头的属性值"></a>2.4 使用 @RequestHeader 绑定请求报头的属性值</h2><p>请求头包含了若干个属性，服务器可据此获知客户端的信息，通过 @RequestHeader 即可将请求头中的属性值绑定到处理方法的入参中。</p><p>代码示例如下：</p><ol><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testRequestHeader"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestHeader</span><span class="params">(@RequestHeader(value=<span class="string">"Accept-Language"</span>)</span> String al) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Accept-Language："</span> + al);</span><br><span class="line">    <span class="comment">//输出Accept-Language：en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加如下语句进行响应测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testRequestHeader.action"</span>&gt;</span>testRequestHeader<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：@RequestHeader与@RequestParam相似，都有required等属性。</p><h2 id="2-5-使用-CookieValue-绑定请求中的-Cookie-值"><a href="#2-5-使用-CookieValue-绑定请求中的-Cookie-值" class="headerlink" title="2.5 使用 @CookieValue 绑定请求中的 Cookie 值"></a>2.5 使用 @CookieValue 绑定请求中的 Cookie 值</h2><p>@CookieValue 可让处理方法入参绑定某个 Cookie 值。</p><ol><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testCookieValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testCookieValue</span><span class="params">(@CookieValue(value=<span class="string">"JSESSIONID"</span>)</span> String sessionId) </span>&#123;</span><br><span class="line">    <span class="comment">//输出：session id:8CBD7E8DE6851D48ACB806C4B020C6FB</span></span><br><span class="line">    System.out.println(<span class="string">"session id:"</span> + sessionId);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加语句进行响应测试</p></li></ol><p><strong>注意</strong>：@CookieValue与@RequestParam相似，都有required等属性。</p><h2 id="2-6-使用-POJO-对象绑定请求参数值"><a href="#2-6-使用-POJO-对象绑定请求参数值" class="headerlink" title="2.6 使用 POJO 对象绑定请求参数值"></a>2.6 使用 POJO 对象绑定请求参数值</h2><p>Spring MVC 会按请求参数名和 POJO 属性名进行<strong>自动匹配，自动为该对象填充属性值，并将POJO对象放入请求域中。支持级联属性。</strong></p><p>代码示例如下：</p><ol><li>首先在com.shoto.springmvc.entities下创建两个实体类，具体代码如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String uid, String username, String password, Integer age, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(String province, String city)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.province = province;</span><br><span class="line">        <span class="keyword">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在SpringMVCTest类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testPOJO"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPOJO</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加如下语句进行响应测试</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/testPOJO.action"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    uid：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uid"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    username：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    password：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    age：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    province：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address.province"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    city：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"address.city"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"确定"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-7-使用-Servlet-API-作为参数"><a href="#2-7-使用-Servlet-API-作为参数" class="headerlink" title="2.7 使用 Servlet API 作为参数"></a>2.7 使用 Servlet API 作为参数</h2><p>SpringMVC 的 Handler 方法可以接收如下 ServletAPI 类型的参数：</p><p>HttpServletRequest、HttpServletResponse、HttpSession、java.security.Principal、 Locale、InputStream、OutputStream、Reader、Writer。</p><p>下面演示一下一些API的使用。</p><ol><li><p>同样地，需要在SpringMVCTest定义如下方法，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testServletAPI"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testServletAPI</span><span class="params">(HttpServletRequest req, HttpServletResponse resp, Writer out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"HttpServletRequest："</span> + req);</span><br><span class="line">    System.out.println(<span class="string">"HttpServletResponse："</span> + resp);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * HttpServletRequest：org.apache.catalina.connector.RequestFacade@133beef9</span></span><br><span class="line"><span class="comment"> * HttpServletResponse：org.apache.catalina.connector.ResponseFacade@2b695474</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    out.write(<span class="string">"hello SpringMVC!"</span>);<span class="comment">//会在页面上显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.jsp中添加语句进行响应测试即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（九）SpringMVC学习笔记-拦截器Interceptor</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B9%9D%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B9%9D%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/</url>
      
        <content type="html"><![CDATA[<h2 id="1-自定义拦截器"><a href="#1-自定义拦截器" class="headerlink" title="1. 自定义拦截器"></a>1. 自定义拦截器</h2><p>假如我们在访问有些网页的时候可能会提示无权访问，因为我们的访问请求会被拦截器拦截到，并给我们显示无权访问的提示页面。下面我们使用SpringMVC来演示一下自定义拦截器的使用。</p><p>Spring MVC可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现<strong>HandlerInterceptor接口</strong>。</p><a id="more"></a><p>1.首先我们先编写如下拦截器类，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法在目标方法之前被调用。</span></span><br><span class="line"><span class="comment"> * 若返回值为true，则继续调用后续的拦截器和目标方法；</span></span><br><span class="line"><span class="comment"> * 若返回值为false，则不会再调用后续的拦截器和目标方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可以考虑做权限。日志，事务等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FirstInterceptor:preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用目标方法之后，但在渲染视图之前</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 可以对请求域中的属性或视图做出修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FirstInterceptor:postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 渲染视图之后调用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"FirstInterceptor:afterCompletion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>preHandle()</strong>：这个方法在<strong>业务处理器处理请求之前被调用</strong>，在该方法中对用户请求 request 进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件去处理请求，则返回false。</li><li><strong>postHandle()</strong>：这个方法在业务处理器处理完请求后，但是<strong>DispatcherServlet 向客户端返回响应前被调用</strong>，在该方法中对用户请求request进行处理。</li><li>afterCompletion()：这个方法在 <strong>DispatcherServlet 完全处理完请求后被调用</strong>，可以在该方法中进行一些资源清理的操作。</li></ul><p>2.然后在MVC配置文件中配置自定义的拦截器，具体如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自定义拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截所有,即该控制器里的所有目标方法都会被拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.shoto.springmvc.interceptors.FirstInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.编写控制器类的目标方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testInterceptor"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"目标方法testInterceptor执行啦。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.在页面进行请求响应之后，其运行结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FirstInterceptor:preHandle</span><br><span class="line">目标方法testInterceptor执行啦。。。</span><br><span class="line">FirstInterceptor:postHandle</span><br><span class="line">FirstInterceptor:afterCompletion</span><br></pre></td></tr></table></figure><p>根据如上运行结果和对源码进行debug可以知道，<strong>单个拦截器方法执行顺序</strong>如下图所示：<br><img src="/2020/01/05/（九）SpringMVC学习笔记-拦截器Interceptor/20190216185516662.png" alt="在这里插入图片描述"></p><h2 id="2-拦截器配置"><a href="#2-拦截器配置" class="headerlink" title="2. 拦截器配置"></a>2. 拦截器配置</h2><p>上述我们在MVC配置文件中配置自定义的拦截器时，是配置了拦截所有控制器类中的所有目标方法，当然我们也可以<strong>拦截指定目标方法</strong>或<strong>不拦截指定的目标方法</strong>。如下示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 拦截所有目标方法 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;bean class="com.shoto.springmvc.interceptors.FirstInterceptor"&gt;&lt;/bean&gt; --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 拦截指定的目标方法,其他方法则不拦截 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/testInterceptor"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.shoto.springmvc.interceptors.FirstInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 不拦截指定的目标方法，其他的都拦截 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;mvc:interceptor&gt;</span></span><br><span class="line"><span class="comment">拦截所有的请求，这个必须写在前面，也就是写在【不拦截】的上面 </span></span><br><span class="line"><span class="comment">&lt;mvc:mapping path="/**"/&gt;</span></span><br><span class="line"><span class="comment">&lt;mvc:exclude-mapping path="/testInterceptor"/&gt;</span></span><br><span class="line"><span class="comment">&lt;bean class="com.shoto.springmvc.interceptors.FirstInterceptor"&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="comment">&lt;/mvc:interceptor&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-多个拦截器方法执行顺序"><a href="#3-多个拦截器方法执行顺序" class="headerlink" title="3. 多个拦截器方法执行顺序"></a>3. 多个拦截器方法执行顺序</h2><p>基于上述示例，在创建一个拦截器SecondInterceptor，具体同FirstInterceptor拦截器相似，只是输出语句不同。</p><p>运行请求响应测试之后，输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FirstInterceptor:preHandle</span><br><span class="line">SecondInterceptor:preHandle</span><br><span class="line">目标方法testInterceptor执行啦。。。</span><br><span class="line">SecondInterceptor:postHandle</span><br><span class="line">FirstInterceptor:postHandle</span><br><span class="line">SecondInterceptor:afterCompletion</span><br><span class="line">FirstInterceptor:afterCompletion</span><br></pre></td></tr></table></figure><p><strong>两个拦截器的运行流程如下图所示</strong>（<strong>preHandle的返回值都为true的情形</strong>）：<br><img src="/2020/01/05/（九）SpringMVC学习笔记-拦截器Interceptor/2019021619053171.png" alt="在这里插入图片描述"><br>注意：拦截器在MVC配置文件的配置顺序决定了那个拦截器先执行。<br><img src="/2020/01/05/（九）SpringMVC学习笔记-拦截器Interceptor/20190216191438881.png" alt="在这里插入图片描述"><br>当SecondInterceptor的preHandle返回false时，其执行流程如下图所示：<br><img src="/2020/01/05/（九）SpringMVC学习笔记-拦截器Interceptor/20190216191627412.png" alt="在这里插入图片描述"><br>测试输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FirstInterceptor:preHandle</span><br><span class="line">SecondInterceptor:preHandle</span><br><span class="line">FirstInterceptor:afterCompletion</span><br></pre></td></tr></table></figure><p>从运行结果和执行流程我们也可以知道，当preHandle返回true时，其所对应的afterCompletion一定也会执行，其可以用于<strong>释放资源</strong>等。</p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十）SpringMVC学习笔记-异常处理</title>
      <link href="/2020/01/05/%EF%BC%88%E5%8D%81%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>/2020/01/05/%EF%BC%88%E5%8D%81%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Spring MVC 通过 <strong>HandlerExceptionResolver</strong> 处理程序的异常，包括 <strong>Handler 映射</strong>、<strong>数据绑定</strong>以及<strong>目标方法执行时发生的异常</strong>。</p><p>其中HandlerExceptionResolver的实现类如下图所示：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216200116116.png" alt="在这里插入图片描述"></p><a id="more"></a><p><strong>注意</strong>：AnnotationMethodHandlerExceptionResolver是<strong>过时</strong>的。</p><p>DispatcherServlet 默认装配的 HandlerExceptionResolver 包含如下子类：</p><ul><li>未配置&lt;mvc:annotation-driven/&gt;时：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216200318168.png" alt="在这里插入图片描述"></li><li>配置了&lt;mvc:annotation-driven/&gt;时：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216200409669.png" alt="在这里插入图片描述"><br><strong>所以一般我们在使用HandlerExceptionResolver 处理异常时，需要配置&lt;mvc:annotation-driven/&gt;。</strong></li></ul><h1 id="1-ExceptionHandlerExceptionResolver"><a href="#1-ExceptionHandlerExceptionResolver" class="headerlink" title="1. ExceptionHandlerExceptionResolver"></a>1. ExceptionHandlerExceptionResolver</h1><h2 id="1-1-ExceptionHandler-注解"><a href="#1-1-ExceptionHandler-注解" class="headerlink" title="1.1 @ExceptionHandler 注解"></a>1.1 @ExceptionHandler 注解</h2><h3 id="1-1-1-示例"><a href="#1-1-1-示例" class="headerlink" title="1.1.1 示例"></a>1.1.1 示例</h3><p>ExceptionHandlerExceptionResolver主要处理 Handler 中用 @ExceptionHandler 注解定义的方法。</p><p>下面简单演示一下@ExceptionHandler 注解的使用。</p><p>1.在控制器类中编写定义如下两个方法，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 该方法用于处理<span class="doctag">@ExceptionHandler</span> 中所指明的异常</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span> 中的值是一个class集合。</span></span><br><span class="line"><span class="comment"> * ArithmeticException.class表明该方法可以用于处理ArithmeticException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;ArithmeticException.class&#125;)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入参Exception ex 对应于发生的异常对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ExceptionHandler</span> 作用的方法的入参不能传入Map。若希望把异常信息显示在错误页面上，</span></span><br><span class="line"><span class="comment"> * 则可以同时ModelAndView作为返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleArithmeticException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"出异常了："</span> + ex);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">"exception"</span>, ex);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testExceptionHandlerExceptionResolver"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testExceptionHandlerExceptionResolver</span><span class="params">(@RequestParam(<span class="string">"i"</span>)</span> <span class="keyword">int</span> i) </span>&#123;</span><br><span class="line">    <span class="comment">//测试除0异常</span></span><br><span class="line">    System.out.println(<span class="string">"result:"</span> + (<span class="number">10</span>/i));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.当我们在请求测试传入的参数为0时，这时testExceptionHandlerExceptionResolver方法会发生除0异常并将异常交由@ExceptionHandler作用的handleArithmeticException进行处理。运行的结果如下图所示：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216201337460.png" alt="在这里插入图片描述"></p><h3 id="1-1-2-ExceptionHandler-注解定义的方法优先级问题"><a href="#1-1-2-ExceptionHandler-注解定义的方法优先级问题" class="headerlink" title="1.1.2 @ExceptionHandler 注解定义的方法优先级问题"></a>1.1.2 @ExceptionHandler 注解定义的方法优先级问题</h3><p>例如发生的是NullPointerException，但是声明的异常有RuntimeException 和 Exception，此时会根据异常的最近继承关系找到继承深度最浅的那个@ExceptionHandler注解方法，即标记了 RuntimeException 的方法。</p><p>比如在上述的示例中，我在控制器中添加了另一个异常处理的方法，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(&#123;RuntimeException.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"[出异常了]："</span> + ex);</span><br><span class="line">    ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">"exception"</span>, ex);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果请求发生了除0异常时，该异常会由handleException处理而不是handleArithmeticException。运行结果如下所示：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216202109743.png" alt="在这里插入图片描述"></p><h2 id="1-2-ControllerAdvice-注解"><a href="#1-2-ControllerAdvice-注解" class="headerlink" title="1.2 @ControllerAdvice 注解"></a>1.2 @ControllerAdvice 注解</h2><p>我们若在控制器类中使用@ExceptionHandler定义的方法来处理异常，其只适用于处理当前控制器类方法所发生的异常，SpringMVC还支持全局的异常处理类。</p><p>ExceptionHandlerMethodResolver 内部若找不到@ExceptionHandler 注解的话，也就是在当前的控制器类中找不到@ExceptionHandler 注解作用的异常处理方法的话，则会找@ControllerAdvice标注的类中的@ExceptionHandler 注解方法。</p><p>基于上述示例，将控制器类中的异常处理方法注释掉。并编写一个异常处理类，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ArithmeticException.class&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleArithmeticException</span><span class="params">(Exception ex)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ExceptionHandleTest:出异常了："</span> + ex);</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(<span class="string">"error"</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">"exception"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求响应测试后，运行输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExceptionHandleTest:出异常了：java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><h1 id="2-ResponseStatusExceptionResolver"><a href="#2-ResponseStatusExceptionResolver" class="headerlink" title="2. ResponseStatusExceptionResolver"></a>2. ResponseStatusExceptionResolver</h1><p>我们也可以使用ResponseStatusExceptionResolver来解析自定义的异常类。</p><p>比如现在定义了如下一个异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过<span class="doctag">@ResponseStatus</span>注解来新增异常映射，其中</span></span><br><span class="line"><span class="comment"> * code代表异常映射码，reason代表异常原因。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseStatus</span>(code=HttpStatus.FORBIDDEN,reason=<span class="string">"ID不匹配异常，权限不足！"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDNotMatchException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在若在处理器方法中抛出了上述异常，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testResponseStatusExceptionResolver"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testResponseStatusExceptionResolver</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Integer id) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">13</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IDNotMatchException();</span><br><span class="line">    System.out.println(<span class="string">"testResponseStatusExceptionResolver..."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当请求参数传入的id值为13且ExceptionHandlerExceptionResolver 不解析述异常时，由于触发的异常 IDNotMatchException 带有@ResponseStatus注解。因此会ResponseStatusExceptionResolver 解析到。最后响应HttpStatus.UNAUTHORIZED 码给客户端。HttpStatus.UNAUTHORIZED 代表响应码401，无权限。</p><p>出错的运行结果如下图所示：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216210613535.png" alt="在这里插入图片描述"></p><h1 id="3-DefaultHandlerExceptionResolver"><a href="#3-DefaultHandlerExceptionResolver" class="headerlink" title="3. DefaultHandlerExceptionResolver"></a>3. DefaultHandlerExceptionResolver</h1><p>DefaultHandlerExceptionResolver可以对一些特殊的异常进行处理，比如NoSuchRequestHandlingMethodException、HttpRequestMethodNotSupportedException、HttpMediaTypeNotSupportedException、HttpMediaTypeNotAcceptableException等。<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216211059420.png" alt="在这里插入图片描述"></p><h1 id="4-SimpleMappingExceptionResolver"><a href="#4-SimpleMappingExceptionResolver" class="headerlink" title="4. SimpleMappingExceptionResolver"></a>4. SimpleMappingExceptionResolver</h1><p>如果希望<strong>对所有异常进行统一处理</strong>，可以使用SimpleMappingExceptionResolver，它将<strong>异常类名映射为视图名</strong>，即<strong>发生异常时使用对应的视图报告异常</strong>。</p><p>下面演示一下该类的使用。</p><p>1.首先需要在MVC配置文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置使用SimpleMappingExceptionResolver来映射异常 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置 exceptionAttribute，value表示存储异常的对象，JSP页面上可以通过requestScope.ex来获取--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionAttribute"</span> <span class="attr">value</span>=<span class="string">"ex"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"exceptionMappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 当发生java.lang.ArrayIndexOutOfBoundsException时，由error.jsp错误页面进行显示 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"java.lang.ArrayIndexOutOfBoundsException"</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：&lt;property name=”exceptionAttribute” value=”ex”&gt;&lt;/property&gt;中的value的值默认为exception，SimpleMappingExceptionResolver有进行如下定义：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216213007926.png" alt="在这里插入图片描述"><br>当我们没有配置exceptionAttribute时，我们依然可以在JSP页面通过${requestScope.exception}来获取异常数据。</p><p>2.在控制器类中编写如下目标方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testSimpleMappingExceptionResolver"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSimpleMappingExceptionResolver</span><span class="params">(@RequestParam(<span class="string">"i"</span>)</span> Integer i) </span>&#123;</span><br><span class="line">    String[] strArr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">//可能会发生数组角标越界异常</span></span><br><span class="line">    System.out.println(strArr[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.当请求传入的i值为15时，其运行结果如下图所示：<br><img src="/2020/01/05/（十）SpringMVC学习笔记-异常处理/20190216213403325.png" alt="在这里插入图片描述"><br>不同于使用@ExceptionHandler注解需要返回包含异常信息的ModelAndView对象才能将错误信息显示在页面上那么繁琐，显然使用SimpleMappingExceptionResolver更为方便一点。</p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十一）SpringMVC学习笔记-SpringMVC运行流程</title>
      <link href="/2020/01/05/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SpringMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/01/05/%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SpringMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-运行流程图"><a href="#1-运行流程图" class="headerlink" title="1. 运行流程图"></a>1. 运行流程图</h2><p><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217103536894.png" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2-HelloWorld"><a href="#2-HelloWorld" class="headerlink" title="2. HelloWorld"></a>2. HelloWorld</h2><p>我们再次来编写一个HelloWorld项目，具体步骤如下所示：</p><ol><li><p>加入如下的jar包<br> <img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217101019787.png" alt="在这里插入图片描述"></p></li><li><p>在web.xml中配置DispatcherServlet，并拦截所有。</p></li><li><p>在MVC配置文件applicationContext-mvc.xml中配置&lt;context:component-scan&gt;和视图解析器InternalResourceViewResolver。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描指定包下的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.springmvc"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在WEB-INF目录创建views目录，并编写success.jsp成功页面。</p></li><li><p>在处理器类HelloWorld中定义如下方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/helloWorld"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-运行流程详解"><a href="#3-运行流程详解" class="headerlink" title="3. 运行流程详解"></a>3. 运行流程详解</h2><h3 id="3-1-子流程一"><a href="#3-1-子流程一" class="headerlink" title="3.1 子流程一"></a>3.1 子流程一</h3><p>当我使用<a href="http://localhost:8080/SpringMVC_6/helloWorld2进行请求时，因为此时SpringMVC不存在helloWorld2映射，且在未配置&lt;mvc:default-servlet-handler/&gt;的情况下，此时控制台与打印如下信息并且给出404页面（**上述运行流程图黑线部分**）：" target="_blank" rel="noopener">http://localhost:8080/SpringMVC_6/helloWorld2进行请求时，因为此时SpringMVC不存在helloWorld2映射，且在未配置&lt;mvc:default-servlet-handler/&gt;的情况下，此时控制台与打印如下信息并且给出404页面（**上述运行流程图黑线部分**）：</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">警告: No mapping found for HTTP request with URI [/SpringMVC_6/helloWorld2] in DispatcherServlet with name &apos;springDispatcherServlet&apos;</span><br></pre></td></tr></table></figure><h3 id="3-2-子流程二"><a href="#3-2-子流程二" class="headerlink" title="3.2 子流程二"></a>3.2 子流程二</h3><p>现在我们在MVC配置文件中配置&lt;mvc:default-servlet-handler/&gt;和&lt;mvc:annotation-driven/&gt;，并在WebContent目录在创建一个hello.html文件（目标资源），此时使用<a href="http://localhost:8080/SpringMVC_6/hello.html是响应成功的（**上述运行流程图绿线部分**）。" target="_blank" rel="noopener">http://localhost:8080/SpringMVC_6/hello.html是响应成功的（**上述运行流程图绿线部分**）。</a></p><h3 id="3-3-子流程三"><a href="#3-3-子流程三" class="headerlink" title="3.3 子流程三"></a>3.3 子流程三</h3><p>当SpringMVC中存在对应的映射时，首先会按如下顺序依次执行。（<strong>上述运行流程图红线部分</strong>）。</p><p><strong>1. 通过HandlerMapping获取HandlerExecutionChain对象</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217102629539.png" alt="在这里插入图片描述"><br>HandlerExecutionChain由Handler对象和拦截器组成。<br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217103015801.png" alt="在这里插入图片描述"><br>HandlerMapping定义了请求和Handler对象之间的映射。</p><p><strong>2. 获取HandlerAdapter适配器</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217103204177.png" alt="在这里插入图片描述"><br>HandlerAdapter适配器会进行参数的绑定，数据校验和格式化等等操作。</p><p><strong>3.  调用拦截器的 preHandle方法</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217103648994.png" alt="在这里插入图片描述"><br><strong>4. 调用目标Handler的目标方法得到ModelAndView对象</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217103801202.png" alt="在这里插入图片描述"><br><strong>5. 调用拦截器的postHandle方法</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217103906851.png" alt="在这里插入图片描述"><br><strong>6. 调用processDispatchResult判断是否存在异常</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217104151393.png" alt="在这里插入图片描述"><br><strong>7. 在没有异常的情况下，调用render方法中的resolveViewName解析视图。</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217104315757.png" alt="在这里插入图片描述"><br><strong>8. 由ViewResolver组件根据ModelAndView对象得到实际的View</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217104453667.png" alt="在这里插入图片描述"><br><strong>9. 调用render方法，最后由InternalResourceView类的renderMergedOutputModel方法渲染视图，并进行跳转操作</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217104812389.png" alt="在这里插入图片描述"><br><strong>10. 调用triggerAfterCompletion方法，执行拦截器的afterCompletion方法</strong><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217105045542.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217105138801.png" alt="在这里插入图片描述"></p><h3 id="3-4-子流程四"><a href="#3-4-子流程四" class="headerlink" title="3.4 子流程四"></a>3.4 子流程四</h3><p>调用processDispatchResult判断存在异常后（上述运行流程图蓝线部分），由HandlerExceptionResolver组件处理异常，得到新的ModelAndView对象。<br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/2019021710543324.png" alt="在这里插入图片描述"><br>processHandlerException方法中会使用异常解析器进行异常的解析。<br><img src="/2020/01/05/（十一）SpringMVC学习笔记-SpringMVC运行流程/20190217105603638.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十二）SpringMVC学习笔记-SpringMVC与Spring整合问题&amp;IoC容器关系</title>
      <link href="/2020/01/05/%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SpringMVC%E4%B8%8ESpring%E6%95%B4%E5%90%88%E9%97%AE%E9%A2%98-IoC%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB/"/>
      <url>/2020/01/05/%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-SpringMVC%E4%B8%8ESpring%E6%95%B4%E5%90%88%E9%97%AE%E9%A2%98-IoC%E5%AE%B9%E5%99%A8%E5%85%B3%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p>在进行Spring与SpringMVC的整合操作时，可能会需要加入Spring IoC容器。通常情况下，类似于数据源、事务、Service、Dao和整合其他框架的配置数据都是放在Spring 的配置文件中，而不是放在SpringMVC的配置文件中。</p><a id="more"></a><h2 id="1-SpringMVC与Spring整合问题"><a href="#1-SpringMVC与Spring整合问题" class="headerlink" title="1. SpringMVC与Spring整合问题"></a>1. SpringMVC与Spring整合问题</h2><p>下面在<a href="https://blog.csdn.net/weixin_40374341/article/details/86891498" target="_blank" rel="noopener">Hello World</a>示例的基础上来演示整合时可能出现的问题。</p><p>1.首先在web.xml文件中配置启动Spring IoC容器的Listener，内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置启动Spring IoC容器的Listener --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- needed for ContextLoaderListener --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.接着在src目录下创建Spring 的配置文件applicationContext.xml，具体内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描指定包下的注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.springmvc"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源、事务或整合其他框架等。。。省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.然后添加一个业务层类，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CustomerService..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.将CustomerService 类对象注入到处理器类HelloWorld中，处理器类的具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span><span class="comment">//标识该类为请求处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomerService customerService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloWorld Constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/helloSpringMVC"</span>)<span class="comment">//标识该方法为具体的请求处理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hellowolrd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.请求响应之后，控制台输出如下的信息：<br><img src="/2020/01/05/（十二）SpringMVC学习笔记-SpringMVC与Spring整合问题-IoC容器关系/20190217123553124.png" alt="在这里插入图片描述"><br>显然，处理器类HelloWorld和业务层类CustomerService类都被创建了两次，这是因为我们在SpringMVC的配置文件applicationContext-mvc.xml和Spring的配置文件applicationContext.xml都配置了&lt;context:component-scan base-package=”com.shoto.springmvc”/&gt;所造成的。</p><p><strong>解决方法：</strong></p><p>修改&lt;context:component-scan base-package=”com.shoto.springmvc”/&gt;的配置，使<strong>Spring 的 IOC 容器不应该扫描 SpringMVC 中的 bean</strong>, 对应的<strong>SpringMVC 的 IOC 容器不应该扫描 Spring 中的 bean</strong>。</p><p>具体配置如下所示：</p><p>applicationContext.xml的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不扫描指定包下的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.springmvc"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;context:exclude-filter&gt;用于指定不扫描的注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>applicationContext-mvc.xml的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描指定包下的注解 ,use-default-filters="false"表示不默认扫描全部注解了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.springmvc"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;context:include-filter&gt;用于指定只扫描的注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-SpringMVC与Spring-两者Ioc之间的关系"><a href="#2-SpringMVC与Spring-两者Ioc之间的关系" class="headerlink" title="2. SpringMVC与Spring 两者Ioc之间的关系"></a>2. SpringMVC与Spring 两者Ioc之间的关系</h2><p>在上面的示例中，我们将Spring IoC的bean CustomerService 注入到了 SpringMVC IoC的bean HelloWorld中，即 web 层容器可以引用service层容器的 Bean。<strong>但是反过来却是不行的</strong>，因为service层容器访问不到 web 层容器的 Bean。</p><p>其中Spring MVC web 层容器可作为 service层 Spring容器的子容器。具体关系如下图示：<br><img src="/2020/01/05/（十二）SpringMVC学习笔记-SpringMVC与Spring整合问题-IoC容器关系/2019021712532847.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）SpringMVC学习笔记-数据模型处理&amp;视图和视图解析器&amp;重定向</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%A4%84%E7%90%86-%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8-%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%A4%84%E7%90%86-%E8%A7%86%E5%9B%BE%E5%92%8C%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8-%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据模型处理"><a href="#1-数据模型处理" class="headerlink" title="1. 数据模型处理"></a>1. 数据模型处理</h1><p>Spring MVC 提供了以下几种途径输出模型数据：</p><ul><li>ModelAndView: 处理方法返回值类型为 ModelAndView时, 方法体即可通过该对象添加模型数据；</li><li>Map 及 Model: 入参为org.springframework.ui.Model、org.springframework.ui.ModelMap 或 java.uti.Map 时，处理方法返回时，Map中的数据会自动添加到模型中；</li><li>@SessionAttributes: 将模型中的某个属性暂存到HttpSession 中，以便多个请求之间可以共享这个属性；</li><li>@ModelAttribute: 方法入参标注该注解后, 入参的对象就会放到数据模型中。</li></ul><a id="more"></a><h2 id="1-1-ModelAndView"><a href="#1-1-ModelAndView" class="headerlink" title="1.1 ModelAndView"></a>1.1 ModelAndView</h2><p>控制器处理方法的返回值如果为 ModelAndView, 则其既包含视图信息，也包含模型数据信息。</p><p>下面演示一下ModelAndView的简单使用。</p><ol><li><p>首先需要在控制器类SpringMVCTest定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMVCTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUCCESS = <span class="string">"success"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回值ModelAndView包含视图信息，也包含模型数据信息。</span></span><br><span class="line"><span class="comment"> * SpringMVC会把ModelAndView的数据存放在Request请求域对象中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testModelAndView"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testModelAndView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String viewName = SUCCESS;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView(viewName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//添加模型数据到ModelAndView中</span></span><br><span class="line">        modelAndView.addObject(<span class="string">"time"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在结果视图页面success.jsp中进行如下代码编写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Success<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Success page<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- $&#123;requestScope.time &#125;相当于request.getAttribute("time"); --&gt;</span></span><br><span class="line">    time: $&#123;requestScope.time &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在index.jsp页面点击超链接进行请求响应，index.jsp的具体代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"testModelAndView"</span>&gt;</span>Test ModelAndView<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击超链接请求成功的响应结果如下所示：<br> <img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211160916885.png" alt="在这里插入图片描述"></p><h2 id="1-2-Map"><a href="#1-2-Map" class="headerlink" title="1.2 Map"></a>1.2 Map</h2><p>控制器方法的入参可以是Map类型，也可以是Model类型或ModelMap类型的参数。</p></li><li><p>我们在控制器类SpringMVCTest中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标方法可以添加Map类型(实际也可以是Model类型或ModelMap类型)的参数。</span></span><br><span class="line"><span class="comment"> * 处理方法返回时，Map中的数据会自动添加到模型中。</span></span><br><span class="line"><span class="comment"> * 我们可以在Request请求域对象中取到Map的值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testMap"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    System.out.println(map.getClass().getName());</span><br><span class="line">    <span class="comment">//输出org.springframework.validation.support.BindingAwareModelMap</span></span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"shoto"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以在success.jsp中添加如下语句以用来获取存储在请求域中的Map模型中的name的值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: $&#123;requestScope.name &#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：在方法testMap体内，开发者可以<strong>通过这个入参对象map访问到模型中的所有数据，也可以向模型中添加新的属性数据</strong>。另外这里的Map集合实际是<strong>BindingAwareModelMap</strong>类，其继承体系如下所示：<br><img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211161840595.png" alt="在这里插入图片描述"></p><h2 id="1-3-SessionAttributes"><a href="#1-3-SessionAttributes" class="headerlink" title="1.3 SessionAttributes"></a>1.3 SessionAttributes</h2><p>若希望在多个请求之间共用某个模型属性数据，则可以在控制器类上标注一个@SessionAttributes, Spring MVC将在模型中对应的属性暂存到 <strong>HttpSession</strong> 中。</p><p>SessionAttributes 除了可以通过<strong>属性名</strong>指定需要放到会话中的属性外（使用注解的value属性），还可以通过模型属性的<strong>对象类型</strong>指定哪些模型属性需要放到会话中（使用注解的types属性），下面演示一下其具体的用法：</p><ol><li><p>在控制器类中定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testSessionAttributes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testSessionAttributes</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line"><span class="comment">//new User(uid, username, password, email, age)</span></span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"shoto"</span>, <span class="string">"abc123"</span>, <span class="string">"shoto@gmail.com"</span>, <span class="number">22</span>);</span><br><span class="line">    <span class="comment">//向map集合中添加user对象以及String类型的值shoto</span></span><br><span class="line">    map.put(<span class="string">"user"</span>, user);</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"shoto"</span>);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>控制器类上</strong>添加如下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes</span>(value= &#123;<span class="string">"user"</span>&#125;, types= &#123;String.class&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>该注解的value的值”user”需要与map.put(“user”, user);语句中的键”user”相同，它表明会将该User对象存放在Session域中（Request域也有）。而tyeps中的值String.class表明会将Map模型中的String类型的值存放在会话域中。</p><ol start="3"><li><p>我们可以在结果视图编写如下代码进行模型数据的获取：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Request user: $&#123;requestScope.user &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Session user: $&#123;sessionScope.user &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Request name: $&#123;requestScope.name &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Session name: $&#123;sessionScope.name &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>请求响应成功的结果如下所示：<br> <img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211162943594.png" alt="在这里插入图片描述"></p><h2 id="1-4-ModelAttribute"><a href="#1-4-ModelAttribute" class="headerlink" title="1.4 ModelAttribute"></a>1.4 ModelAttribute</h2><p>假设存在这个场景：在页面的表单上，我需要修改当前的用户密码。我们之前的做法可能是先new一个User对象，然后将表单的数据如密码存储在User对象中，然后再使用该User对象去进行数据库对应数据的更新操作，但是这样在进行数据库更新操作时又需要将对应的数据取出来，过程较为麻烦。</p></li></ol><p>现在我们可以使用另一种方式来解决，即先从数据库获取对应要更新的User对象，然后将表单的数据对应更新到该对象的对应属性中（<strong>注意</strong>：该步骤SpringMVC自动帮我们完成），然后我们可以使用该对象进行对应的数据库更新操作。</p><ol><li><p>首先在index.jsp页面上添加如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模拟提交数据后进行相应的数据库数据的修改操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testModelAttribute"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    password：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"abc123"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后需要在控制器方法中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(@RequestParam(value=<span class="string">"uid"</span>, required=<span class="keyword">false</span>)</span> Integer uid, Map&lt;String, Object&gt; map) </span>&#123;</span><br><span class="line">    <span class="comment">//模拟从数据库获取对象</span></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//根据uid中从数据库中获取对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(uid, <span class="string">"Tom"</span>, <span class="string">"123456"</span>, <span class="string">"shoto@gmail.com"</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(<span class="string">"从数据中获取一个对象："</span> + user);</span><br><span class="line">        <span class="comment">//将从数据库获取的user对象存储到数据模型中</span></span><br><span class="line">        map.put(<span class="string">"user"</span>, user);<span class="comment">//这里的键为User类的首字母小写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"修改User对象："</span> + user);</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果如下所示：<br> <img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211195607527.png" alt="在这里插入图片描述"></p></li></ol><p><strong>运行流程：</strong></p><ol><li>首先执行@ModelAttribute 的注解修饰的方法getUser，即从数据库中取出User对象，然后把对象放入Map中，其中的键为”user”；</li><li><strong>SpringMVC 的内部会从Map中取出User对象，并把表单的请求参数赋给该User对象的对应属性。（SpringMVC内部执行过程，可参见源码）</strong></li><li>SpringMVC把上述对象传入目标方法的参数，也就是将User对象传入到testModelAttribute的参数中。</li></ol><p><strong>注意：</strong> 在@ModelAttribute 修饰的方法中，放入到Map时的键需要和目标方法入参类型的第一个字母小写的字符串一致。上述的Map的键为”user”，即为testModelAttribute方法的入参User的的首字母小写对应的字符串。</p><p>当然，我们可以在目标方法testModelAttribute的入参处使用 @ModelAttribute 注解，也就是实现了Map键的自定义，而不是非要与目标方法入参类型的第一个字母小写的字符串一致。具体的代码如下所示：<br><img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211200923721.png" alt="在这里插入图片描述"><br>另外补充一种情况，假如现在控制器类SpringMVCTest的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes</span>(value= &#123;<span class="string">"user"</span>&#125;)</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMVCTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String SUCCESS = <span class="string">"success"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"修改User对象："</span> + user);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当前有@SessionAttributes注解修饰类，且没有@ModelAttribute 修饰的getUser方法，那么此时会发生<strong>Session attribute ‘user’ required - not found in session</strong>的异常，SpringMVC底层在处理类定义处标注了@SessionAttributes(value= {“user”})时，则会尝试从会话中获取该属性，也就是值”user”所对应的User对象，并将其赋给该入参user，然后再用请求消息填充该入参对象。<strong>如果在会话中找不到对应的属性</strong>，则抛出 HttpSessionRequiredException 异常。</p><p><strong>ModelAttribute运行处理的具体细节可以参考SpringMVC的源代码！以便加深理解。</strong></p><h1 id="2-视图和视图解析器"><a href="#2-视图和视图解析器" class="headerlink" title="2. 视图和视图解析器"></a>2. 视图和视图解析器</h1><p>之前我们在配置文件中配置过视图解析器InternalResourceViewResolver，其具体的解析过程如下所示：<br><img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211204353868.png" alt="在这里插入图片描述"><br>请求处理方法执行完成后，最终返回一个 ModelAndView对象。对于那些返回 String（如”success”），View 或 ModeMap 等类型的处理方法，Spring MVC 也会在内部将它们装配成一个<strong>ModelAndView</strong> 对象，它包含了逻辑名和模型对象的视图。</p><p>Spring MVC 借助视图解析器（ViewResolver）得到最终的视图对象（View），最终的视图可以是 <strong>JSP</strong> ，也可能是Excel、JFreeChart 等各种表现形式的视图。</p><h2 id="2-1-视图"><a href="#2-1-视图" class="headerlink" title="2.1 视图"></a>2.1 视图</h2><p><strong>视图的作用是渲染模型数据，将模型里的数据以某种形式呈现给客户</strong>。为了实现视图模型和具体实现技术的解耦，Spring 在org.springframework.web.servlet 包中定义了一个高度抽象的 View接口。视图对象由视图解析器负责实例化。由于视图是<strong>无状态</strong>的，也就是每次请求都会创建一个新的视图，所以他们<strong>不会有线程安全</strong>的问题</p><p>下面显示的是一些常用的视图实现类：<br><img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211205610839.png" alt="在这里插入图片描述"></p><h2 id="2-2-视图解析器"><a href="#2-2-视图解析器" class="headerlink" title="2.2 视图解析器"></a>2.2 视图解析器</h2><p>SpringMVC 为逻辑视图名的解析提供了不同的策略，可以在 Spring WEB 上下文中配置一种或多种解析策略，并指定他们之间的先后顺序。每一种映射策略对应一个具体的视图解析器实现类。</p><p>视图解析器的作用比较单一：将逻辑视图解析为一个具体的视图对象。所有的视图解析器都必须实现 ViewResolver 接口。</p><p>下面显示的一些常用的视图解析器：<br><img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211210137414.png" alt="在这里插入图片描述"></p><ul><li>程序员可以选择一种视图解析器或混用多种视图解析器</li><li>每个视图解析器都实现了 Ordered 接口并开放出一个 order 属性，可以通过 order 属性指定解析器的优先顺序，order 越小优先级越高。</li><li>SpringMVC 会按视图解析器顺序的优先顺序对逻辑视图名进行解析，直到解析成功并返回视图对象，否则将抛出 ServletException 异常。</li></ul><h3 id="2-2-1-示例一"><a href="#2-2-1-示例一" class="headerlink" title="2.2.1 示例一"></a>2.2.1 示例一</h3><p>下面我们在项目中使用了 JSTL，那么 SpringMVC 会自动把视图由InternalResourceView 转为 <strong>JstlView</strong>。并且使用 JSTL 的 fmt 标签实现<strong>国际化资源文件</strong>的使用。</p><ol><li><p>首先需要添加如下两个Jar包：<br> <img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/20190211213627196.png" alt="在这里插入图片描述"></p></li><li><p>然后需要在MVC配置文件applicationContext-mvc.xml中配置国际化资源文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置国际化资源文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"i18n"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在src路径在创建如下三个文件<br> <img src="/2020/01/05/（三）SpringMVC学习笔记-数据模型处理-视图和视图解析器-重定向/2019021121280764.png" alt="在这里插入图片描述"><br>  其中i18.properties和i18n_en_US.properties的内容如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> i18n.username=Username</span><br><span class="line">i18n.password=Password</span><br></pre></td></tr></table></figure><p>  i18n_zh_CN.properties的内容如下，分别指用户名和密码的中文：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> i18n.username=\u7528\u6237\u540D</span><br><span class="line">i18n.password=\u5BC6\u7801</span><br></pre></td></tr></table></figure><ol start="4"><li>在控制器类SpringMVCTest添加如下方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/testJstlView"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testJstlView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"testJstlView"</span>);</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>最后在index.jsp编写请求响应，在浏览器上会根据浏览器设置的本地语言对应显示英文或者中文的字样。</p></li></ol><p>若希望直接响应通过 SpringMVC 渲染的页面，可以使用 mvc:viewcontroller 标签实现，在配置文件配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置直接转发的页面，而无须在经过控制器的方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">"testJstlView"</span> <span class="attr">view-name</span>=<span class="string">"success"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">如果没有&lt;mvc:annotation-driven/&gt;，那么所有的@Controller注解可能就没有解析，</span></span><br><span class="line"><span class="comment">所以当有请求的时候都没有匹配的处理请求类，</span></span><br><span class="line"><span class="comment">就都去&lt;mvc:default-servlet-handler/&gt;即default servlet处理了</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：需要配置 <strong>&lt;mvc:annotation-driven&gt;</strong> </p><h3 id="2-2-2-示例二"><a href="#2-2-2-示例二" class="headerlink" title="2.2.2 示例二"></a>2.2.2 示例二</h3><p>下面我们演示一下<strong>自定义视图类的使用：</strong></p><ol><li><p>首先需要在MVC配置文件进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置视图解析器 BeanNameViewResolver：使用视图的名字来解析--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.BeanNameViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过order属性来定义视图解析器的优先级，order值越小优先级越高，</span></span><br><span class="line"><span class="comment">视图解析器的order默认值为Integer.MAX_VALUE --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">value</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写自定义视图类，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"abc"</span>)<span class="comment">//使用该注解将自定义视图定义为组件，记得在扫描注解的配置时要包含该包下的该类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloView</span> <span class="keyword">implements</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"text/html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Map&lt;String, ?&gt; map, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">"Hello View"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在控制器类中定义如下方法并在index.jsp进行请求响应即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testView"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testView"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意：testView方法的返回值”abc”与HelloView的Component注解的值相同。abc代表该视图名称，若HelloView的Component注解未指明值，则默认为”helloView”，testView方法的返回值也应该为”helloView”。</p><h1 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3. 重定向"></a>3. 重定向</h1><p>一般情况下，控制器方法返回字符串类型的值会被当成逻辑视图名处理，如果返回的字符串中带 forward: 或 redirect: 前缀时，SpringMVC 会对他们进行特殊处理：将 forward: 和redirect: 当成指示符，其后的字符串作为 URL 来处理。</p><ul><li>redirect:success.jsp：会完成一个到 success.jsp 的重定向的操作</li><li>forward:success.jsp：会完成一个到 success.jsp 的转发操作</li></ul><p>下面演示一下重定向操作：</p><p>在控制器类中定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testRedirect"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testRedirect"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:index.jsp"</span>;<span class="comment">//重定向</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时在index.jsp页面进行请求响应时会进行重定向操作，虽然还是当前页面。</p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）SpringMVC学习笔记-数据转换 &amp; 数据格式化 &amp; 数据校验</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据转换"><a href="#1-数据转换" class="headerlink" title="1. 数据转换"></a>1. 数据转换</h1><h2 id="1-1-默认数据转换器"><a href="#1-1-默认数据转换器" class="headerlink" title="1.1 默认数据转换器"></a>1.1 默认数据转换器</h2><p>Spring MVC 上下文中内建了很多转换器，可完成大多数 Java 类型的转换工作。</p><p>比如我们在页面的文本框上输入了整数或者是布尔值的数据，虽然在文本框的格式依旧是字符串，但是SpringMVC支持将这些数据转成对应的格式。</p><p>比如现在有如下的页面代码如下所示：</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testUserConvert"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    User ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uid"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    Username：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    PassWord：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    is Fale：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"isGender"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们定义有对应的User类用于保存文本输入的数据，具体的属性如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer uid;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Boolean isGender;</span><br></pre></td></tr></table></figure><p>在点击提交之后，会经过如下的控制器方法，SpringMVC会自动将文本框输入的数据以<strong>对应的数据类型封装在User类中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testUserConvert"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUserConvert</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是SpringMVC会将文本框中的字符串uid值和字符串isGender值转为User类对应的数据类型。<strong>这个过程即为数据转换</strong>。</p><p>SpringMVC默认支持如下的数据转换功能:<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190214142951961.png" alt="在这里插入图片描述"></p><h2 id="1-2-自定义数据转换器"><a href="#1-2-自定义数据转换器" class="headerlink" title="1.2 自定义数据转换器"></a>1.2 自定义数据转换器</h2><p>比如我们在页面文本框上输入”100-shoto-abc123-true”，并希望其转换为对应的User对象，那么这时就可以让自定义数据转换器出场了。</p><ol><li><p>首先需要在页面编写如下语句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需求：将这种格式的字符串数据"100-shoto-abc123-true"转为对应的User类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"testConversionServiceConverter"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"user"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在控制器类编写如下的方法，其可以接收经过自定义数据转换器转换过的user对象，并打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/testConversionServiceConverter"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testUserConverter</span><span class="params">(@RequestParam(<span class="string">"user"</span>)</span> User user) </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接下来就是要编写自定义的数据转换类了，Spring 定义了 3 种类型的转换器接口，如下示：<br> <img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/2019021415042992.png" alt="在这里插入图片描述"><br> 我们现在就仅仅演示一下Converters接口的使用，定义UserConverter类，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Converter&lt;String,User&gt;表示将String类型转为User类型的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//source为传递进来的String值，如100-shoto-abc123-true</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (source != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] userStr = source.split(<span class="string">"-"</span>);</span><br><span class="line">            Integer uid = Integer.parseInt(userStr[<span class="number">0</span>]);</span><br><span class="line">            String username = userStr[<span class="number">1</span>];</span><br><span class="line">            String password = userStr[<span class="number">2</span>];</span><br><span class="line">            Boolean isGender = Boolean.parseBoolean(userStr[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(uid, username, password, isGender);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在编写自定义的转换器类后，我们需要在MVC配置文件进行配置。可以利用 <strong>ConversionServiceFactoryBean</strong> 在 Spring 的 IOC容器中定义一个 ConversionService. ConversionService 是 Spring 类型<strong>转换体系</strong>的核心接口。Spring 将自动识别出IOC 容器中的 ConversionService，并在 Bean 属性配置及Spring MVC 处理方法入参绑定等场合使用它进行数据的转换。可通过ConversionServiceFactoryBean 的 <strong>converters</strong> 属性注册自定义的类型转换器，具体如下示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置自定义数据类型转换器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionServiceFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userConverter"</span> <span class="attr">class</span>=<span class="string">"com.shoto.springmvc.converters.UserConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>最后一步，需要配置annotation-driven，具体如下示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用annotation-driven将conversionService注册到SpringMVC上下文中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>其支持使用 ConversionService 实例对表单参数进行类型转换。</strong></p><h2 id="1-3-使用-InitBinder"><a href="#1-3-使用-InitBinder" class="headerlink" title="1.3 使用@InitBinder"></a>1.3 使用@InitBinder</h2><p>由 @InitBinder 标识的方法，可以对 WebDataBinder 对象进行初始化。WebDataBinder是 DataBinder 的子类，<strong>用于完成由表单字段到 JavaBean 属性的绑定</strong>。</p><p>@InitBinder方法不能有返回值，它必须声明为void。@InitBinder方法的参数通常是 WebDataBinder。</p><p>基于上述<strong>默认数据转换器</strong>的例子，演示一下@InitBinder注解的使用。</p><p>假如现在我不需要实现表单中的password字段到User对象的password属性的绑定。那么可以进行如下操作。</p><p>首先需要在控制器类中添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不自动绑定User对象的password属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder dataBinder)</span> </span>&#123;</span><br><span class="line">    dataBinder.setDisallowedFields(<span class="string">"password"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行请求响应之后，testUserConvert的打印结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User [uid=100, username=abc, password=null, isGender=true]</span><br></pre></td></tr></table></figure><p>也就是没有实现表单中的password字段到User对象的password属性的绑定，此时password属性值为null。</p><h1 id="2-数据格式化"><a href="#2-数据格式化" class="headerlink" title="2. 数据格式化"></a>2. 数据格式化</h1><p>假如我们在表单上输入<strong>指定格式</strong>的日期或者数值，这是就需要对输入的值进行数据格式化处理。对属性对象的输入/输出进行格式化，从其本质上讲依然属于 “<strong>类型转换</strong>” 的范畴。</p><p>Spring 在格式化模块中定义了一个实现ConversionService 接口的FormattingConversionService 实现类，该实现类扩展了 GenericConversionService，因此它<strong>既具有类型转换的功能，又具有格式化的功能</strong>。FormattingConversionService 拥有一个FormattingConversionServiceFactroyBean 工厂类，后者用于在 Spring 上下文中构造前者。</p><p>FormattingConversionServiceFactroyBean 内部已经注册了如下两个类：</p><ul><li>NumberFormatAnnotationFormatterFactroy：<strong>支持对数字类型的属性使用 @NumberFormat 注解</strong></li><li>JodaDateTimeFormatAnnotationFormatterFactroy：<strong>支持对日期类型的属性使用 @DateTimeFormat 注解</strong>。</li></ul><p>装配了 FormattingConversionServiceFactroyBean 后，就可以在 Spring MVC <strong>入参绑定</strong>及<strong>模型数据输出</strong>时使用注解驱动了。&lt;mvc:annotation-driven/&gt; <strong>默认创建</strong>的ConversionService 实例即为FormattingConversionServiceFactroyBean。</p><h2 id="2-1-数值格式化"><a href="#2-1-数值格式化" class="headerlink" title="2.1 数值格式化"></a>2.1 数值格式化</h2><p>@NumberFormat 可对类似数字类型的属性进行标注，它拥有两个<strong>互斥</strong>的属性：</p><ol><li><p>style：类型为 NumberFormat.Style。用于<strong>指定样式类型</strong>，包括三种Style.NUMBER（正常数字类型）、Style.CURRENCY（货币类型）、Style.PERCENT（百分数类型）</p></li><li><p>pattern：类型为 String，<strong>自定义样式</strong>，如patter=”#,###”；</p><h2 id="2-2-日期格式化"><a href="#2-2-日期格式化" class="headerlink" title="2.2 日期格式化"></a>2.2 日期格式化</h2><p>@DateTimeFormat 注解可对java.util.Date、java.util.Calendar、java.long.Long 时间<br>类型进行标注：</p></li><li><p>pattern 属性：类型为字符串。<strong>指定解析/格式化字段数据的模式</strong>，如：”yyyy-MM-dd hh:mm:ss”</p></li><li><p>iso 属性：类型为 DateTimeFormat.ISO。<strong>指定解析/格式化字段数据的ISO模式</strong>，包括四种：ISO.NONE（不使用-默认）、ISO.DATE(yyyy-MM-dd) ISO.TIME(hh:mm:ss.SSSZ)、ISO.DATE_TIME(yyyy-MM-dd hh:mm:ss.SSSZ)</p></li><li><p>style 属性：字符串类型。<strong>通过样式指定日期时间的格式</strong>，由两位字符组成，第一位表示日期的格式，第二位表示时间的格式：</p><p>S：短日期/时间格式、M：中日期/时间格式、L：长日期/时间格式、F：完整日期/时间格式、-：忽略日期或时间格式</p></li></ol><p><strong>示例：</strong></p><ol><li><p>首先需要在页面编写如下代码，即表单代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"formatDateAndNumber"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    User ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uid"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    Username：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    PassWord：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    is Fale：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"isGender"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    salary：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"salary"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    birthday：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"birthday"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写对应的User类，其属性如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer uid;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> Boolean isGender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NumberFormat</span>(pattern=<span class="string">"###,###,###.##"</span>)</span><br><span class="line"><span class="keyword">private</span> Double salary;</span><br><span class="line"><span class="meta">@DateTimeFormat</span>(iso = ISO.DATE)<span class="comment">//格式是yyyy-MM-dd</span></span><br><span class="line"><span class="keyword">private</span> Date birthday;</span><br></pre></td></tr></table></figure></li></ol><p>注意：这里使用到了格式化用的注解。</p><ol start="3"><li><p>接着需要在控制器类上定义如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/formatDateAndNumber"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">formatDateAndNumber</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出：User [uid=100, username=abc, password=abc123, isGender=true, </span></span><br><span class="line">    <span class="comment">//salary=100452.12, birthday=Thu Feb 14 08:00:00 CST 2019]</span></span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，需要在MVC配置文件中进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>&lt;mvc:annotation-driven/&gt; 默认创建的ConversionService 实例即为FormattingConversionServiceFactroyBean，后者可以在 Spring MVC 入参绑定及模型数据输出时<strong>使用注解驱动</strong>，以完成@NumberFormat annotation、@DateTimeFormat注解数据类型的格式化。</p><h1 id="3-数据校验"><a href="#3-数据校验" class="headerlink" title="3. 数据校验"></a>3. 数据校验</h1><h2 id="3-1-JSR-303"><a href="#3-1-JSR-303" class="headerlink" title="3.1 JSR 303"></a>3.1 JSR 303</h2><p>JSR 303 是 Java 为 <strong>Bean 数据合法性校验</strong>提供的标准框架，它已经包含在 JavaEE 6.0 中 。</p><p>JSR 303 通过<strong>在 Bean 属性上标注</strong>类似于 @NotNull、@Max等标准的注解<strong>指定校验规则</strong>，并通过标准的验证接口对 Bean进行验证。下面显示的是一些标准的校验注解：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190214172133143.png" alt="在这里插入图片描述"></p><h2 id="3-2-Hibernate-Validator-扩展注解"><a href="#3-2-Hibernate-Validator-扩展注解" class="headerlink" title="3.2 Hibernate Validator 扩展注解"></a>3.2 Hibernate Validator 扩展注解</h2><p>Hibernate Validator 是 <strong>JSR 303 的一个参考实现</strong>，除支持所有标准的校验注解外，它还支持以下的扩展注解：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190214172256180.png" alt></p><h2 id="3-3-SpringMVC-数据校验"><a href="#3-3-SpringMVC-数据校验" class="headerlink" title="3.3 SpringMVC 数据校验"></a>3.3 SpringMVC 数据校验</h2><p>我们下面演示一下Hibernate Validator框架进行数据校验的使用：</p><p>Spring 4.0 拥有自己独立的数据校验框架，同时<strong>支持 JSR 303 标准的校验框架</strong>。因为Spring 本身并没有提供 JSR303 的实现，所以必须将<strong>JSR303 的实现者</strong>的 jar 包放到类路径下。那么现在首先需要导入Hibernate Validator所需的jar包：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190214211520911.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/2019021421154177.png" alt="在这里插入图片描述"><br>假如定义有如下的表单，具体的代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"format"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">    User ID：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uid"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    Username：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    PassWord：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    is Fale：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"isGender"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    salary：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"salary"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    birthday：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"birthday"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    Email：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。<strong>在 Spring MVC 中，可直接通过注解驱动的方式进行数据校验</strong>。那么现在需要对表单所对应的User对象配置相关的校验注解，具体如下所示：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190214212217110.png" alt="在这里插入图片描述"><br>Spring 的 <strong>LocalValidatorFactroyBean</strong> 既实现了 Spring 的Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在 Spring 容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean 中。因为 <strong>&lt;mvc:annotation-driven/&gt; 会默认装配好一个LocalValidatorFactoryBean</strong> 。那么下面即需要<strong>在MVC配置文件中配置&lt;mvc:annotation-driven/&gt;。</strong></p><p>接着需要在控制器类定义如下目标方法，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/format"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">formatDateAndNumber</span><span class="params">(@Valid User user, BindingResult result)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result.getErrorCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(result.getFieldError());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/index.jsp"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解@Valid的使用，可以让Spring MVC 框架在将请求参数绑定到该入参对象后，就会调用校验框架根据注解声明的校验规则<strong>实施校验</strong>。</p><p>入参BindingResult的作用是将前一个表单/命令对象（如User）的<strong>校验结果保存到随后的入参中，</strong> 也就是保存到BindingResult对象中。这个保存<strong>校验结果</strong>的入参必须是 <strong>BindingResult</strong> 或<strong>Errors</strong> 类型，这两个类都位于org.springframework.validation 包中。另外，<strong>需校验的 Bean 对象和其绑定结果对象或错误对象时是成对出现的，它们之间不允许声明其他的入参</strong>。也就是需要保持如下的格式：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190214213301977.png" alt="在这里插入图片描述"></p><h2 id="3-4-页面显示校验结果"><a href="#3-4-页面显示校验结果" class="headerlink" title="3.4 页面显示校验结果"></a>3.4 页面显示校验结果</h2><p>Spring MVC 除了会将表单/命令对象的校验结果保存到对应的 BindingResult 或 Errors 对象中外，还会将所有校验结果保存到 “隐含模型”。即使处理方法的签名中没有对应于表单/命令对象的结果入参，校验结果也会保存在 “隐含对象” 中。</p><p>隐含模型中的所有数据最终将通过 HttpServletRequest 的属性列表暴露给 JSP 视图对象，因此在 JSP 中可以获取错误信息。在 JSP 页面上可通过 &lt;form:errors path=“userName”&gt;显示错误消息。</p><p><strong>示例：</strong></p><p>假如现在在列表页面点击添加员工的超链接，并会经过如下的控制器类的目标方法进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emp"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">input</span><span class="params">(Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//键"employee"匹配input.jsp页面的form表单的modelAttribute的属性值</span></span><br><span class="line">    map.put(<span class="string">"employee"</span>, <span class="keyword">new</span> Employee());</span><br><span class="line">    <span class="comment">//需要将所有部门信息放在请求域中，在员工信息添加页面以下拉列表的形式显示部门名称</span></span><br><span class="line">    map.put(<span class="string">"departments"</span>, departmentDao.getDepartments());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"input"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后跳转到员工信息的输入页面input.jsp，其中的表单代码如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">可以通过 modelAttribute 属性指定绑定的模型属性，若没有指定该属性，</span></span><br><span class="line"><span class="comment">则默认从 request 域对象中读取command 的表单 bean，</span></span><br><span class="line"><span class="comment">如果该属性值也不存在，则会发生错误。</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form:form</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/emp"</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">modelAttribute</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- path：表单字段，对应 html 元素的 name 属性，支持级联属性 </span></span><br><span class="line"><span class="comment">对应指定类的属性名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id不为空时不显示LastName，也就是LastName不可修改</span></span><br><span class="line"><span class="comment">当添加员工信息时，也就是员工id为空时会显示LastName</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;employee.id == null&#125;"</span>&gt;</span></span><br><span class="line">        LastName: <span class="tag">&lt;<span class="name">form:input</span> <span class="attr">path</span>=<span class="string">"lastName"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;employee.id != null&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form:hidden</span> <span class="attr">path</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"_method"</span> <span class="attr">value</span>=<span class="string">"PUT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">    Email: <span class="tag">&lt;<span class="name">form:input</span> <span class="attr">path</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">form:radiobuttons：单选框组标签，用于构造多个单选框.</span></span><br><span class="line"><span class="comment">items：可以是一个 List、String[] 或 Map</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line">        //注意：new HashMap&lt;&gt;();这种格式JDK1.7以上才支持，否则JSP编译出错</span><br><span class="line">        Map<span class="tag">&lt;<span class="name">String,String</span>&gt;</span> genders = new HashMap();</span><br><span class="line">        genders.put("1", "Male");</span><br><span class="line">        genders.put("0", "Female");</span><br><span class="line">        //需要放入请求域中，否则EL表达式无法取到值</span><br><span class="line">        request.setAttribute("genders", genders);</span><br><span class="line">    %&gt;</span><br><span class="line">    <span class="comment">&lt;!-- 多个单选框可以通过 delimiter 指定分隔符 --&gt;</span></span><br><span class="line">    Gender: <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">form:radiobuttons</span> <span class="attr">path</span>=<span class="string">"gender"</span> <span class="attr">items</span>=<span class="string">"$&#123;genders &#125;"</span> <span class="attr">delimiter</span>=<span class="string">"&lt;br&gt;"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下拉列表 </span></span><br><span class="line"><span class="comment">itemValue：指定 radio 的 value 值。可以是集合中 bean 的一个属性值</span></span><br><span class="line"><span class="comment">   itemLabel：指定 radio 的 label 值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    Department: <span class="tag">&lt;<span class="name">form:select</span> <span class="attr">path</span>=<span class="string">"department.id"</span></span></span><br><span class="line"><span class="tag"><span class="attr">items</span>=<span class="string">"$&#123;departments&#125;"</span> <span class="attr">itemLabel</span>=<span class="string">"departmentName"</span> <span class="attr">itemValue</span>=<span class="string">"id"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form:form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们在Employee类的email属性使用了@Email校验注解。当我们点击员工信息输入页面的提交按钮后，会经过如下的控制器类的目标方法进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个员工</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emp"</span>,method=RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">save</span><span class="params">(@Valid Employee employee, BindingResult result, Map&lt;String, Object&gt; map)</span> </span>&#123;<span class="comment">//SpringMVC自动将标签的属性装载进Employee对象中</span></span><br><span class="line">    <span class="keyword">if</span> (result.getErrorCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (FieldError error : result.getFieldErrors()) &#123;</span><br><span class="line">            System.out.println(error.getField() + <span class="string">":"</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要将所有部门信息放在请求域中，在员工信息输入页面以下拉列表的形式显示部门名称</span></span><br><span class="line">        map.put(<span class="string">"departments"</span>, departmentDao.getDepartments());</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查看map中的employee是否有值用于回显?为什么map中有入参enployee的值</span></span><br><span class="line"><span class="comment"> * 为什么不用map.put("employee", employee);?雾。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        <span class="comment">//System.out.println(map.get("employee"));</span></span><br><span class="line">        <span class="comment">//Employee [id=null, lastName=abc, email=abc, gender=1, department=Department [id=101, departmentName=null]]</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"input"</span>;<span class="comment">//重新跳转到输入页面</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//校验通过后才能保存员工数据</span></span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/emps"</span>;<span class="comment">//重定向到显示所有员工的list方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们需要在员工信息输入页面添加&lt;form:errors/&gt;，当email输入错误时，会显示在页面上。<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190215105200191.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190215105230849.png" alt="在这里插入图片描述"></p><h2 id="3-4-提示消息国际化"><a href="#3-4-提示消息国际化" class="headerlink" title="3.4 提示消息国际化"></a>3.4 提示消息国际化</h2><p>我们可以实现错误消息的自定义或国际化。当一个属性校验失败后，校验框架会为该属性生成 4 个消息代码，这些代码以<strong>校验注解类名为前缀</strong>，<strong>结合modleAttribute</strong>、<strong>入参对象名</strong>及<strong>入参属性名</strong>生成多个对应的消息代码：例如 User 类中的 password 属性使用了一个 @Pattern 注解，当该属性值不满足 @Pattern 所定义的规则时, 就会产生以下 4个错误代码：</p><ul><li>Pattern.user.password</li><li>Pattern.password</li><li>Pattern.java.lang.String</li><li>Pattern</li></ul><p>当使用 Spring MVC 标签显示错误消息时， <strong>Spring MVC 会查看WEB 上下文是否装配了对应的国际化消息</strong>，如果没有，则显示默认的错误消息，否则使用国际化消息。</p><p>下面演示一下其使用：</p><p>首先我们需要创建一个国际化资源文件i18n.properties，如下所示：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190215112717567.png" alt="在这里插入图片描述"><br>接着需要在MVC配置文件进行国际化资源注册，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册国际化资源文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basename"</span> <span class="attr">value</span>=<span class="string">"i18n"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求响应后，若输入的Email不合法，在浏览器上会根据浏览器设置的本地语言对应显示英文或者中文的字样的出错提示信息。<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190215113054508.png" alt="在这里插入图片描述"><br>若<strong>数据类型转换</strong>或<strong>数据格式转换</strong>时发生错误，或该<strong>有的数不存在</strong>，或<strong>调用处理方法时发生错误</strong>，<strong>都会在隐含模型中创建错误消息</strong>。其错误代码前缀说明如下：</p><ul><li>required：必要的参数不存在。如 @RequiredParam(“param1”)标注了一个入参，但是该参数不存在；</li><li>typeMismatch：在数据绑定时，发生数据类型不匹配的问题；</li><li>methodInvocation：Spring MVC 在调用处理方法时发生了错误；</li></ul><p>比如在数据绑定时，表单输入的Birth不是一个日期，也就是发生了数据类型转换的错误，此时可以在i18n.properties进行如下配置：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/20190215113518585.png" alt="在这里插入图片描述"><br>然后进行国际化资源注册即可。</p><h1 id="4-数据绑定流程"><a href="#4-数据绑定流程" class="headerlink" title="4. 数据绑定流程"></a>4. 数据绑定流程</h1><p>Spring MVC 通过反射机制对目标处理方法进行解析，将请求消息绑定到处理方法的入参中的过程即为数据绑定。绑定的流程如下所示：</p><ol><li>Spring MVC 主框架将 ServletRequest 对象及目标方法的入参实例传递给WebDataBinderFactory 实例，以创建 <strong>DataBinder</strong> 实例对象；</li><li>DataBinder 调用装配在 Spring MVC 上下文中的ConversionService 组件进行<strong>数据类型转换、数据格式化工作</strong>。将 Servlet 中的请求信息填充到入参对象中；</li><li>调用 Validator 组件对已经绑定了请求消息的入参对象进行<strong>数据合法性校</strong>验，并最终生成数据绑定结果<strong>BindingData</strong> 对象；</li><li>Spring MVC 抽取 <strong>BindingResult</strong> 中的入参对象和校验错误对象，将它们赋给处理方法的响应入参。</li></ol><p>数据绑定的核心部件是<strong>DataBinder</strong>，运行机制如下：<br><img src="/2020/01/05/（五）SpringMVC学习笔记-数据转换-数据格式化-数据校验/2019021513432434.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合笔记</title>
      <link href="/2020/01/05/SSM%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/05/SSM%E6%95%B4%E5%90%88%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建数据库表"><a href="#1-创建数据库表" class="headerlink" title="1.  创建数据库表"></a>1.  创建数据库表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tbl_employee (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  last_name <span class="built_in">varchar</span>(<span class="number">255</span>) ,</span><br><span class="line">  gender <span class="built_in">char</span>(<span class="number">1</span>) ,</span><br><span class="line">  email <span class="built_in">varchar</span>(<span class="number">255</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-导入Jar包"><a href="#2-导入Jar包" class="headerlink" title="2. 导入Jar包"></a>2. 导入Jar包</h3><p>主要包括如下几部分的 Jar 包：</p><ul><li>Spring 核心 Jar 包<br><img src="/2020/01/05/SSM整合笔记/20190217191839836.png" alt="在这里插入图片描述"></li><li>SpringMVC 所需要的额外 Jar 包<br><img src="/2020/01/05/SSM整合笔记/20190217191944709.png" alt="在这里插入图片描述"></li><li>Spring 切面编程的 Jar 包<br><img src="/2020/01/05/SSM整合笔记/20190217192057467.png" alt="在这里插入图片描述"></li><li>Spring JDBC 开发相关的 Jar 包，包括第三方C3P0数据源相关 Jar 包<br><img src="/2020/01/05/SSM整合笔记/20190217192245736.png" alt="在这里插入图片描述"></li><li>MyBatis 支持 Jar 包和 MyBatis 与 Spring 整合的 Jar 包<br><img src="/2020/01/05/SSM整合笔记/2019021719241914.png" alt="在这里插入图片描述"></li><li>日志包以及 MySQL 数据库驱动<br><img src="/2020/01/05/SSM整合笔记/20190217192531598.png" alt="在这里插入图片描述"></li><li>JSTL 所需 Jar 包<br><img src="/2020/01/05/SSM整合笔记/20190217192621925.png" alt="在这里插入图片描述"><h3 id="3-编写-POJO-类-Employee"><a href="#3-编写-POJO-类-Employee" class="headerlink" title="3. 编写 POJO 类 Employee"></a>3. 编写 POJO 类 Employee</h3>按照数据库字段，编写一个 POJO 类 Employee，具体代码如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.ssm.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String lastName;<span class="comment">//该属性和数据库表的对应字段名last_name不同</span></span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(Integer id, String lastName, String gender, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-配置web-xml文件"><a href="#4-配置web-xml文件" class="headerlink" title="4. 配置web.xml文件"></a>4. 配置web.xml文件</h3><p>在web.xml文件中，我们需要配置Spring相关的ContextLoaderListener以及与SpringMVC相关的DispatcherServlet等信息。具体配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- Spring 配置 --&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- needed for ContextLoaderListener --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstraps the root web application context before servlet initialization --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC 配置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- The front controller of this Spring Web application, responsible for handling all application requests --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Map all requests to the DispatcherServlet for handling --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-创建和配置Spring和SpringMVC配置文件"><a href="#5-创建和配置Spring和SpringMVC配置文件" class="headerlink" title="5. 创建和配置Spring和SpringMVC配置文件"></a>5. 创建和配置Spring和SpringMVC配置文件</h3><p>创建src的同级目录config，用于存放一些配置文件，如Spring的配置文件applicationContext.xml和SpringMVC配置文件applicationContext-mvc.xml。如下所示：<br><img src="/2020/01/05/SSM整合笔记/20190217193521922.png" alt="在这里插入图片描述"></p><h4 id="5-1-applicationContext-mvc-xml配置"><a href="#5-1-applicationContext-mvc-xml配置" class="headerlink" title="5.1 applicationContext-mvc.xml配置"></a>5.1 applicationContext-mvc.xml配置</h4><p>applicationContext-mvc.xml的内容如下所示，主要配置<strong>注解扫描</strong>、<strong>视图解析器</strong>、<strong>静态资源处理</strong>以及 <strong>&lt;mvc:annotation-driven&gt;</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 只扫描指定注解标识的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.ssm"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringMVC 控制器类 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringMVC中的 自定义异常处理器类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"resourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-2-applicationContext-xml配置"><a href="#5-2-applicationContext-xml配置" class="headerlink" title="5.2 applicationContext.xml配置"></a>5.2 applicationContext.xml配置</h4><p>applicationContext.xml的配置主要包括如下几个步骤：</p><ol><li><p>配置注解扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不扫描指定注解标识的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.ssm"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC 控制器类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC中的 自定义异常处理器类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>config目录下创建数据库配置文件dbconfig.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=abc123!</span><br><span class="line"></span><br><span class="line">orcl.driver=oracle.jdbc.OracleDriver</span><br><span class="line">orcl.url=jdbc:oracle:thin:@localhost:1521:orcl</span><br><span class="line">orcl.username=scott</span><br><span class="line">orcl.password=tiger</span><br></pre></td></tr></table></figure></li><li><p>配置C3P0连接池和事务管理器<br>我们之前在MyBatis的配置文件mybatis-config.xml中配置的<strong>默认连接池</strong>和<strong>事务管理器</strong>全部交由Spring来管理。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入数据库配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:dbconfig.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置C3P0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span>  <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置声明式事务管理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启声明式事务管理：注解方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Spring与MyBatis的整合配置<br>之前我们使用MyBatis时都是使用SqlSessionFactoryBuilder类读取MyBatis的配置文件mybatis-config.xml来创建SqlSessionFactory 类，然后使用其开启和获取会话session以此获取映射接口进行数据库操作。</p></li></ol><p>现在我们可以让Spring来帮我们做这些事情，我们只需要进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建sqlSessionFactory对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入C3P0数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定MyBatis全局配置文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定Mapper文件的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mapper/*.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 扫描所有的mapper接口的实现，让这些mapper能够自动注入。</span></span><br><span class="line"><span class="comment">service层的类要使用mapper接口时只需使用注解@AutoWired即可将其注入</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mybatis-spring:scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.ssm.dao"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面的bean配置同&lt;mybatis-spring:scan&gt;，一般建议使用 &lt;mybatis-spring:scan&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;</span></span><br><span class="line"><span class="comment">&lt;property name="basePackage" value="com.shoto.ssm"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">&lt;/bean&gt; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-创建和配置MyBatis配置文件"><a href="#6-创建和配置MyBatis配置文件" class="headerlink" title="6. 创建和配置MyBatis配置文件"></a>6. 创建和配置MyBatis配置文件</h3><p>我们在config目录下创建MyBatis的配置文件mybatis-config.xml。具体内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开启驼峰命名法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- MyBatis的其他配置，如延迟加载等。。。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-编写映射接口（Dao层）"><a href="#7-编写映射接口（Dao层）" class="headerlink" title="7. 编写映射接口（Dao层）"></a>7. 编写映射接口（Dao层）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.ssm.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有员工</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmps</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-编写映射文件EmployeeMapper-xml"><a href="#8-编写映射文件EmployeeMapper-xml" class="headerlink" title="8. 编写映射文件EmployeeMapper.xml"></a>8. 编写映射文件EmployeeMapper.xml</h3><p>在config目录下创建包<strong>mybatis.mapper</strong>，在该包下创建映射文件EmployeeMapper.xml。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.shoto.ssm.dao.EmployeeMapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getEmps"</span> <span class="attr">resultType</span>=<span class="string">"com.shoto.ssm.bean.Employee"</span>&gt;</span></span><br><span class="line">    select * from tbl_employee</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-编写EmployeeService（Service层）"><a href="#9-编写EmployeeService（Service层）" class="headerlink" title="9. 编写EmployeeService（Service层）"></a>9. 编写EmployeeService（Service层）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.ssm.services;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要再applicationContext.xml中进行配置才可实现自动注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeMapper employeeMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * service层的获取所有员工的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmps</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> employeeMapper.getEmps();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-编写控制器（Web层）"><a href="#10-编写控制器（Web层）" class="headerlink" title="10. 编写控制器（Web层）"></a>10. 编写控制器（Web层）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.ssm.controller;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getAllEmps"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAllEmps</span><span class="params">(Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; empList = employeeService.getAllEmps();</span><br><span class="line">        <span class="comment">//将查询到的所有员工数据放在Map数据模型中</span></span><br><span class="line">        map.put(<span class="string">"empList"</span>, empList);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-编写员工列表页面"><a href="#11-编写员工列表页面" class="headerlink" title="11. 编写员工列表页面"></a>11. 编写员工列表页面</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>员工列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"10"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>ID<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>LastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;empList &#125;"</span> <span class="attr">var</span>=<span class="string">"emp"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;emp.id &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;emp.lastName &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;emp.gender &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;emp.email &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="12-请求响应测试"><a href="#12-请求响应测试" class="headerlink" title="12. 请求响应测试"></a>12. 请求响应测试</h3><p>最后进行请求响应测试，查询数据库后员工列表页面显示如下：<br><img src="/2020/01/05/SSM整合笔记/20190217201607726.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringMVC </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）Spring学习笔记-事务管理</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>事务就是逻辑上的一组操作，组成这组操作的各个单元，要么全都成功，要么全都失败。</p><h2 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h2><ul><li><strong>原子性</strong>：事务不可分割，整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像事务出来没有被执行过一样；</li><li><strong>一致性</strong>：事务执行前后数据完整性保持一致；</li><li><strong>隔离性</strong>：一个事务的执行不应该受到其他事务的干扰，指两个事务之间的隔离程度；</li><li>持久性：一旦事务结束，数据就持久化到数据库。</li></ul><a id="more"></a><h2 id="1-3-安全问题"><a href="#1-3-安全问题" class="headerlink" title="1.3 安全问题"></a>1.3 安全问题</h2><p>如果不考虑事务的隔离性会导致读问题和写问题，以下是相关问题的介绍。</p><h3 id="1-3-1-读问题"><a href="#1-3-1-读问题" class="headerlink" title="1.3.1 读问题"></a>1.3.1 读问题</h3><ul><li><strong>脏读</strong>：一个事务读到另一个事务未提交的数据；</li><li><strong>不可重复读</strong>：一个事务读到另一个事务已经提交的update的数据，导致一个事务中多次查询结果不一致；</li><li><strong>虚读（幻读）</strong>：一个事务读到另一个事务已经提交的insert的数据，导致一个事务中多次查询结果不一致。<h3 id="1-3-2-写问题"><a href="#1-3-2-写问题" class="headerlink" title="1.3.2 写问题"></a>1.3.2 写问题</h3></li><li><strong>丢失更新</strong>：假设有一场景：张三和李四使用同一账户购买物品，账户的余额为10000元。张三刷卡消费了1000块，提交事务后账户余额变为9000元。与此同时，在张三未提交事务之前，李四查询到账户余额仍为10000元，李四网购消费了1000元，在张三提交事务后她再提交事务，此时会根据之前余额的10000元，扣减1000元，余额为9000元。由于是不同的事务，无法探知其他事物的操作，导致两者提交后，余额都为9000元。此时，张三的写的更新操作丢失了。</li></ul><h2 id="1-4-隔离级别"><a href="#1-4-隔离级别" class="headerlink" title="1.4 隔离级别"></a>1.4 隔离级别</h2><p>数据库规范中定义了事务之间的隔离级别，来解决读问题以及在不同程度上减少丢失更新的可能性。</p><ul><li><strong>Read uncommitted</strong>：未提交读，任何读问题解决不了；</li><li><strong>Read committed</strong>：已提交读，<strong>解决脏读</strong>，但是不可重复读和虚读有可能发生；</li><li><strong>Repeatable read</strong>：重复读，<strong>解决脏读和不可重复读</strong>，但是虚读有可能发生。</li><li><strong>Serializable</strong>：序列化，<strong>解决所有读问题</strong>。</li></ul><h1 id="2-Spring的事务传播行为"><a href="#2-Spring的事务传播行为" class="headerlink" title="2. Spring的事务传播行为"></a>2. Spring的事务传播行为</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传播行为是指方法之间的调用事务策略的问题。假设现在需要实现信用卡还款功能，有一个总的调用代码逻辑—RepaymentBatchService类的batch方法，它要实现的是记录还款功能成功的总卡数和对应完成的信息，而每一张卡的还款则是通过RepaymentService类的repay方法完成的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果只有一条事务，那么当调用RepaymentService的repay方法对某一张信用卡进行还款时发生了异常。如果将这条事务回滚，就会造成repay方法异常之前的所有操作都发生回滚，这是很糟糕的。我们可以通过另一种方法来处理，就是当batch方法调用repay方法时，会为repay方法创建一条新的事务，即使repay方法发生了异常，它也只会回滚自己的事务。类似这样一个方法调度另外一个方法时，可以对事务的特性进行传播配置的行为，称之为传播行为。</p><p><strong>Spring中提供了七种事务的传播行为</strong>，是通过一个枚举类型去定义的，这个枚举类是org.springframework.transaction.annotation.Propagation，它定义了如下七种事务的传播行为：</p><ol><li>保证多个操作在同一个事务中</li></ol><ul><li><strong>PROPAGATION_REQUIRED</strong>    ：默认值，当调用方法时，如果不存在当前事务，那么就创建事务；如果之前的方法已经存在事务了，那么就沿用之前的事务；</li><li><strong>PROPAGATION_SUPPORTS</strong>：支持事务，当方法调用时，如果不存在当前事务，那么不启用事务；如果存在当前事务，那么就沿用当前的事务；</li><li><strong>PROPAGATION_MANDATORY</strong>：方法必须在事务内运行，如果不存在当前事务，那么就抛出异常；    </li></ul><ol start="2"><li>保证多个操作不在同一个事务中</li></ol><ul><li><strong>PROPAGATION_REQUIRES_NEW</strong>：无论是否存在当前事务，方法都会在新的事务中运行，也就是事务管理器会打开新的事务运行该方法；</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong>：不支持事务，如果不存在当前事务也不会创建事务；如果存在当前事务，则挂起它，直至该方法结束后才恢复当前事务；适用于那些不需要事务的SQL；</li><li><strong>PROPAGATION_NEVER</strong>：不支持事务，只有在没有事务的环境才能运行它，如果方法存在当前事务，则抛出异常；</li></ul><ol start="3"><li>嵌套事务</li></ol><ul><li><strong>PROPAGATION_NESTED</strong>：嵌套事务，也就是调用方法如果抛出异常只回滚自己内部执行的SQL，而不回滚主方法的SQL。它的实现存在两种情况，如果当前数据库支持保存点，那么它就会在当前事务上使用保存点技术；如果发生异常则将方法内执行的SQL回滚到保存点上，而不是全部回滚，否则就等同于PROPAGATION_REQUIRES_NEW创建新的事务运行方法代码。</li></ul><h1 id="3-Spring事务管理API"><a href="#3-Spring事务管理API" class="headerlink" title="3. Spring事务管理API"></a>3. Spring事务管理API</h1><h2 id="3-1-PlatformTransactionManager：平台事务管理器"><a href="#3-1-PlatformTransactionManager：平台事务管理器" class="headerlink" title="3.1 PlatformTransactionManager：平台事务管理器"></a>3.1 PlatformTransactionManager：平台事务管理器</h2><p>PlatformTransactionManager平台事务管理器是一个接口，是Spring用于管理事务的真正的对象。其有如下两个子类：</p><ul><li>DataSourceTransactionManager：底层使用JDBC管理事务。</li><li>HibernateTransactionManager：底层使用Hibernate管理事务，整合Hibernate框架时会用到。</li></ul><h2 id="3-2-TransactionDefinition：事务定义信息"><a href="#3-2-TransactionDefinition：事务定义信息" class="headerlink" title="3.2 TransactionDefinition：事务定义信息"></a>3.2 TransactionDefinition：事务定义信息</h2><p>事务定义信息<strong>用于定义事务的相关的信息，隔离级别、超时信息、传播行为、是否只读</strong>。</p><h2 id="3-3-TransactionStatus：事务的状态"><a href="#3-3-TransactionStatus：事务的状态" class="headerlink" title="3.3 TransactionStatus：事务的状态"></a>3.3 TransactionStatus：事务的状态</h2><p>事务状态用于<strong>记录在事务管理过程中，事务的状态的对象</strong>。</p><h2 id="3-4-事务管理API的关系"><a href="#3-4-事务管理API的关系" class="headerlink" title="3.4 事务管理API的关系"></a>3.4 事务管理API的关系</h2><p>Spring进行事务管理的时候，首先<strong>平台事务管理器</strong>根据<strong>事务定义信息</strong>进行事务的管理，在事务管理过程中，产生各种状态，将这些状态的信息记录到<strong>事务状态的对象</strong>中。</p><h1 id="4-Spring事务管理"><a href="#4-Spring事务管理" class="headerlink" title="4. Spring事务管理"></a>4. Spring事务管理</h1><p>下面模拟一下两个账户之间的转账场景。</p><h2 id="4-1-环境搭建"><a href="#4-1-环境搭建" class="headerlink" title="4.1 环境搭建"></a>4.1 环境搭建</h2><ol><li><p>首先是创建数据库和数据库表，具体如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> spring4;</span><br><span class="line"><span class="keyword">USE</span> spring4;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>创建web项目和相关文件，并导入jar包，具体如下：<br><img src="/2020/01/05/（五）Spring学习笔记-事务管理/20190127163933364.png" alt="在这里插入图片描述"></li></ol></li><li><p>创建AccountDao接口和其实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//转出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String from, Double money)</span></span>;</span><br><span class="line">    <span class="comment">//转进</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String to, Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMoney</span><span class="params">(String from, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(<span class="string">"update account set money = money - ? where name = ?"</span>, money, from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inMoney</span><span class="params">(String to, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getJdbcTemplate().update(<span class="string">"update account set money = money + ? where name = ?"</span>, money, to);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里AccountDaoImpl 继承了JdbcDaoSupport类，我们可以通过this来获取Jdbc模板，而不需要我们手动注入。当然我们需要在配置文件给继承JdbcDaoSupport的类也就是AccountDaoImpl注入连接池才可以用Jdbc模板。具体参考JdbcDaoSupport类代码，下面给出核心部分代码：<br><img src="/2020/01/05/（五）Spring学习笔记-事务管理/20190127164649457.png" alt="在这里插入图片描述"><br>4. 创建AccountServie接口和其实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> from 转出账号用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> to 转入账号用户名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> money转账金额</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String from, String to, Double money)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//set方法属性注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(AccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String from, String to, Double money)</span> </span>&#123;</span><br><span class="line">        accountDao.outMoney(from, money);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//测试一下</span></span><br><span class="line">        accountDao.inMoney(to, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--  引入数据库属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">&lt;!-- 配置C3P0连接池 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 属性注入 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!--  配置Dao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.txdemo.AccountDaoImpl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 向Dao注入连接池，继承JdbcDaoSupport的类会自动创建jdbc模板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--  配置Service,并注入Dao --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.txdemo.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试类，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"accountService"</span>)</span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//张三给李四转账1000元</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountService.transfer(<span class="string">"张三"</span>, <span class="string">"李四"</span>, <span class="number">1000</span>d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>通过上面的代码容易知道，当outMoney方法与inMoney方法执行期间发生异常时，张三的余额会减少而李四的余额却不会对应的增加同等的金额。下面我们采用<strong>事务管理</strong>的方式来处理。</p><h2 id="4-2-编程式事务（了解）"><a href="#4-2-编程式事务（了解）" class="headerlink" title="4.2 编程式事务（了解）"></a>4.2 编程式事务（了解）</h2><ol><li><p>配置平台事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置平台事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务管理的模板类(由Spring提供)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置事务管理模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.transaction.support.TransactionTemplate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">ref</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在业务层注入事务管理的模板<br>首先在AccountServiceImpl类中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//set方法注入事务管理模板</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionTemplate</span><span class="params">(TransactionTemplate transactionTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.transactionTemplate = transactionTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>然后在applicationContext.xml进行如下配置：<br><img src="/2020/01/05/（五）Spring学习笔记-事务管理/20190127172508521.png" alt="在这里插入图片描述"><br>4. 编写事务管理的代码，即修改AccountServiceImpl类的transfer方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String from, String to, Double money)</span> </span>&#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> TransactionCallbackWithoutResult() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> </span>&#123;</span><br><span class="line">            accountDao.outMoney(from, money);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//测试一下</span></span><br><span class="line">            accountDao.inMoney(to, money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;<span class="comment">//transfer</span></span><br></pre></td></tr></table></figure><ol start="5"><li>运行测试，此时不会出现张三的余额会减少而李四的余额却不会对应的增加同等的金额的情况。</li></ol><h2 id="4-3-声明式事务管理（AOP方式）"><a href="#4-3-声明式事务管理（AOP方式）" class="headerlink" title="4.3 声明式事务管理（AOP方式）"></a>4.3 声明式事务管理（AOP方式）</h2><h3 id="4-3-1-XML方式"><a href="#4-3-1-XML方式" class="headerlink" title="4.3.1 XML方式"></a>4.3.1 XML方式</h3><ol><li><p>首先应该恢复转账环境，即恢复到未进行编程式事务配置管理之前的状态</p></li><li><p>引入aop的开发包<br><img src="/2020/01/05/（五）Spring学习笔记-事务管理/2019012718313835.png" alt="在这里插入图片描述"></p></li><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置平台事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置增强</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置事务的增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下面是一些事务管理的规则，常用于实际开发中，save*表示以save开头的方法 </span></span><br><span class="line"><span class="comment">propagation：表示传播行为</span></span><br><span class="line"><span class="comment">isolation：表示隔离级别</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;tx:method name="save*" propagation="REQUIRED" isolation="DEFAULT"/&gt;</span></span><br><span class="line"><span class="comment">&lt;tx:method name="update*" propagation="REQUIRED"/&gt;</span></span><br><span class="line"><span class="comment">&lt;tx:method name="delete*" propagation="REQUIRED"/&gt;</span></span><br><span class="line"><span class="comment">&lt;tx:method name="find*" read-only="true"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"transfer"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>注意：<strong>&lt;tx:method&gt;中的rollback-for=”Exception”表示发生异常时进行回滚操作</strong>，另外其还有一个属性no-rollback-for=”IndexOutOfBoundsException”表示在遇到某些异常如IndexOutOfBoundsException时不执行回滚操作。<br>5. AOP的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- aop配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.shoto.spring.txdemo.AccountServiceImpl.transfer(..))"</span> </span></span><br><span class="line"><span class="tag"> <span class="attr">id</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>运行测试</p><h3 id="4-3-2-注解方式（最简单）"><a href="#4-3-2-注解方式（最简单）" class="headerlink" title="4.3.2 注解方式（最简单）"></a>4.3.2 注解方式（最简单）</h3></li><li><p>首先应该恢复转账环境，即恢复到未进行编程式事务配置管理之前的状态</p></li><li><p>导入AOP相关jar包<br><img src="https://img-blog.csdnimg.cn/2019012718313835.png" alt="在这里插入图片描述"></p></li><li><p>配置事务管理器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置平台事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启注解事务</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启注解事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在业务层添加注解<br><img src="/2020/01/05/（五）Spring学习笔记-事务管理/20190127184950332.png" alt="在这里插入图片描述"></p></li><li><p>运行测试</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）Spring学习笔记-JDBC模板</title>
      <link href="/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JDBC%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-JDBC%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Spring的JDBC的模板"><a href="#1-Spring的JDBC的模板" class="headerlink" title="1. Spring的JDBC的模板"></a>1. Spring的JDBC的模板</h2><p>Spring是EE开发的一站式的框架，有EE开发的每层的解决方案。Spring对持久层也提供了解决方案：ORM模块和JDBC的模板。</p><p>Spring提供了很多的模板用于简化开发：<br><img src="/2020/01/05/（四）Spring学习笔记-JDBC模板/20190127092517461.png" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2-JDBC模板使用入门"><a href="#2-JDBC模板使用入门" class="headerlink" title="2. JDBC模板使用入门"></a>2. JDBC模板使用入门</h2><ol><li><p>首先自然先创建web项目，并导入所需jar包和log4j.properties文件，具体如下：<br><img src="/2020/01/05/（四）Spring学习笔记-JDBC模板/20190127092744555.png" alt="在这里插入图片描述"><br>分别是两个日志相关的包、MySQL数据库驱动包、Spring核心开发包、jdbc相关包以及 事务相关包。</p></li><li><p>创建数据库和数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> spring4;</span><br><span class="line"><span class="keyword">USE</span> spring4;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">account</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    money <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>测试代码，如向数据库插入数据，具体代码如下示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//Jdbc模板的使用类似于DBUtils</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建连接池</span></span><br><span class="line">    DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql:///spring4"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"abc123!"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.创建JDBC模板</span></span><br><span class="line">    JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    <span class="comment">//增删改方法都是使用update方法</span></span><br><span class="line">    template.update(<span class="string">"insert into account values (null,?,?)"</span>, <span class="string">"川普"</span>,<span class="number">1522</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-将连接池和模板交由Spring管理"><a href="#3-将连接池和模板交由Spring管理" class="headerlink" title="3. 将连接池和模板交由Spring管理"></a>3. 将连接池和模板交由Spring管理</h2><p>上面我们是直接用代码的形式来创建连接池和JDBC模板，显然这种代码编写会造成代码复用性和耦合性变差，下面我们将连接池和JDBC模板交给Spring管理。</p><ol><li>引入所需jar包<br><img src="/2020/01/05/（四）Spring学习笔记-JDBC模板/20190127102412852.png" alt="在这里插入图片描述"></li><li>引入配置文件并配置连接池和Jdbc模板<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx.xsd"</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!--  配置Spring的内置连接池 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 属性注入 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring4"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"abc123!"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">&lt;!--  配置Spring的JDBC模板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入Spring的内置连接池，因为需要根据连接池创建模板 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意</strong>：连接池中的property标签中的name的值”driverClassName”，”url”，”username”，”password”以及jdbc模板中的name的值”dataSource”这些字段都是默认规定好的，切不可更改，注意大小写。</p><ol start="3"><li>测试代码，如向数据库插入数据，具体代码如下示： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"jdbcTemplate"</span>)<span class="comment">//注入模板</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"insert into account values (null,?,?)"</span>, <span class="string">"川普"</span>,<span class="number">1522</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-使用第三方数据库连接池"><a href="#4-使用第三方数据库连接池" class="headerlink" title="4. 使用第三方数据库连接池"></a>4. 使用第三方数据库连接池</h2><h3 id="4-1-DBCP的使用"><a href="#4-1-DBCP的使用" class="headerlink" title="4.1 DBCP的使用"></a>4.1 DBCP的使用</h3><ol><li>导入所需jar包<br><img src="/2020/01/05/（四）Spring学习笔记-JDBC模板/2019012710334944.png" alt="在这里插入图片描述"></li><li>配置DBCP连接池<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置dbcp连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 属性注入 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring4"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"abc123!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-2-C3P0的使用"><a href="#4-2-C3P0的使用" class="headerlink" title="4.2 C3P0的使用"></a>4.2 C3P0的使用</h3><ol><li>引入c3p0连接池jar包<br><img src="/2020/01/05/（四）Spring学习笔记-JDBC模板/20190127103832662.png" alt="在这里插入图片描述"></li><li>配置C3P0连接池<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置C3P0连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 属性注入 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///spring4"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"abc123!"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>注意一下连接池中的property标签中的name的写法。</strong></p><h2 id="5-抽取数据库配置到属性文件"><a href="#5-抽取数据库配置到属性文件" class="headerlink" title="5. 抽取数据库配置到属性文件"></a>5. 抽取数据库配置到属性文件</h2><ol><li><p>创建一个数据库属性文件jdbc.proerties，具体内容如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## MySQL数据库属性配置</span><br><span class="line">jdbc.driverClass=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql:///spring4</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=abc123!</span><br></pre></td></tr></table></figure></li><li><p>引入属性文件</p></li></ol><ul><li><p>第一种方式引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种方式通过一个bean标签引入（很少） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"location"</span> <span class="attr">value</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二种方式引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第二种方式通过context标签引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>引入属性文件中的属性值，以C3P0连接池为例<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置C3P0连接池 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性注入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClass&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="6-JDBC模板的CRUD"><a href="#6-JDBC模板的CRUD" class="headerlink" title="6. JDBC模板的CRUD"></a>6. JDBC模板的CRUD</h2><h3 id="6-1-保存操作"><a href="#6-1-保存操作" class="headerlink" title="6.1 保存操作"></a>6.1 保存操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//添加操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"insert into account values (null,?,?)"</span>, <span class="string">"川普"</span>,<span class="number">1522</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-更新操作"><a href="#6-2-更新操作" class="headerlink" title="6.2 更新操作"></a>6.2 更新操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//更新操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"update account set name = ? where id = ?"</span>,<span class="string">"希拉里"</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-删除操作"><a href="#6-3-删除操作" class="headerlink" title="6.3 删除操作"></a>6.3 删除操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//删除操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    jdbcTemplate.update(<span class="string">"delete from account where id = ?"</span>, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-查询操作"><a href="#6-4-查询操作" class="headerlink" title="6.4 查询操作"></a>6.4 查询操作</h3><p>查询某个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询获取表的某个字段</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//String.class表示返回值类型，10为id值</span></span><br><span class="line">    String name = jdbcTemplate.queryForObject(<span class="string">"select name from account where id = ?"</span>, String.class, <span class="number">10</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计查询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//统计查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long count = jdbcTemplate.queryForObject(<span class="string">"select count(*) from account"</span>, Long.class);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询返回对象</p><p>首先需要定义如下一个POJO，用于封装数据库查询的数据到对象中，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(Integer id, String name, Double money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setter,getter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在定义一个类MyRowMapper，该类用于封装数据，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该类用于将数据库中查询的数据封装到POJO中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要手动完成数据到Account对象的封装</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setId(rs.getInt(<span class="string">"id"</span>));</span><br><span class="line">        account.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">        account.setMoney(rs.getDouble(<span class="string">"money"</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后现在可以使用jdbcTemplate去执行查询操作了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询并封装到一个对象中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Account account = jdbcTemplate.queryForObject(<span class="string">"select * from account where id = ?"</span>, <span class="keyword">new</span> MyRowMapper(), <span class="number">5</span>);</span><br><span class="line">    System.out.println(account);<span class="comment">//Account [id=5, name=钱七, money=6545.0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询返回集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//查询多条数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">"select * from account"</span>, <span class="keyword">new</span> MyRowMapper());</span><br><span class="line">    <span class="keyword">for</span> (Account account : accountList) &#123;</span><br><span class="line">        System.out.println(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）Spring学习笔记-AOP</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-AOP/</url>
      
        <content type="html"><![CDATA[<h1 id="1-AOP概念和术语"><a href="#1-AOP概念和术语" class="headerlink" title="1. AOP概念和术语"></a>1. AOP概念和术语</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>AOP即为Aspect Oriented Programming的缩写，意为：面向切面编程。AOP是OOP（面向对象编程）的扩展和延伸，用于解决OOP开发遇到的问题。</p><p>AOP思想是最早由AOP联盟组织提出的，Spring是目前使用这种思想最好的框架。Spring的AOP有自己的实现方式。因其比较繁琐，所以Spring引入AspectJ（一个AOP框架）作为自身AOP的开发。</p><a id="more"></a><h2 id="1-2-术语理解"><a href="#1-2-术语理解" class="headerlink" title="1.2 术语理解"></a>1.2 术语理解</h2><p>为了方便理解，假设现在定义有如下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>Advice：增强，通知</strong>。即在方法层面上进行的增强。 比如，现在需要对save方法进行权限校验，而该权限校验的方法（checkPri）便是增强。</li><li><strong>Joinpoint：连接点，即可以被拦截到的点</strong>。所有可以进行增强的方法，如UserDao中的增删改查方法都可以被称为连接点。</li><li><strong>Pointcut：切入点，即真正被拦截到的点</strong>。在实际开发过程中，我们不一定要对所有的方法都进行增强，而是只对save方法进行增强，那么save方法则是一个切入点。</li><li><strong>Introduction：引介</strong>。不同于Advice是在方法层面上的增强，Introduction是在类层面上的增强。比如现在需要对UserDao类通过动态代理的方式丰富UserDao的功能，这就是引介。</li><li><strong>Target：被增强的对象</strong>。比如我要对UserDao进行增强，那么UserDao类称为是Target。</li><li><strong>Weaving：织入</strong>。指的就是将增强（Advice）应用到目标（Target）的过程。比如我现在需要将权限校验的方法的代码应用到UserDao的save方法上的过程便是织入。</li><li><strong>Proxy：代理。</strong> 就是一个类被AOP织入增强后产生的一个结果代理类。</li><li><strong>Aspect：切面。</strong> 是多个切入点和多个通知或引介的结合。</li></ul><p>补充：<strong>Spring的底层原理</strong> 使用到了JDK动态代理和CGLIB动态代理，具体参考<a href="https://blog.csdn.net/weixin_40374341/article/details/86645145" target="_blank" rel="noopener">Java之动态代理</a></p><h1 id="2-AOP开发（XML）"><a href="#2-AOP开发（XML）" class="headerlink" title="2. AOP开发（XML）"></a><span id="jump">2. AOP开发（XML）</span></h1><h2 id="2-1-创建web项目，引入jar包"><a href="#2-1-创建web项目，引入jar包" class="headerlink" title="2.1 创建web项目，引入jar包"></a>2.1 创建web项目，引入jar包</h2><ul><li><p>引入基本开发包<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126123204922.png" alt="在这里插入图片描述"></p></li><li><p>引入aop开发的相关jar包<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126123239944.png" alt="在这里插入图片描述"><br>分别为AOP联盟相关Jar包、Aspectj包（因为我们要使用Aspectj框架开发）、AOP包和Spring与Apspectj的整合包。</p></li><li><p>引入日志打印相关包<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126134440809.png" alt="在这里插入图片描述"></p><h2 id="2-2-引入Spring的配置文件"><a href="#2-2-引入Spring的配置文件" class="headerlink" title="2.2 引入Spring的配置文件"></a>2.2 引入Spring的配置文件</h2></li><li><p>引入aop约束，配置文件applicationContext.xml的内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 可在spring-framework-4.2.4.RELEASE-dist\spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration.html找到。</p></li></ul><h2 id="2-3-编写目标类并完成配置"><a href="#2-3-编写目标类并完成配置" class="headerlink" title="2.3 编写目标类并完成配置"></a>2.3 编写目标类并完成配置</h2><p>首先定义ProductDao接口，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加实现类ProductDaoImpl，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImpl</span> <span class="keyword">implements</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询商品"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置目标对象，即被增强的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"productDao"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.xmldemo.ProductDaoImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-编写测试类"><a href="#2-4-编写测试类" class="headerlink" title="2.4 编写测试类"></a>2.4 编写测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)<span class="comment">//Spring整合JUnit4单元测试</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:applicationContext.xml"</span>)<span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"productDao"</span>)<span class="comment">//属性注入</span></span><br><span class="line">    <span class="keyword">private</span> ProductDao productDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span><span class="comment">//需要JUnit4，不能使用JUnit5</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        productDao.save();</span><br><span class="line">        productDao.update();</span><br><span class="line">        productDao.delete();</span><br><span class="line">        productDao.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 这里使用到了Spring与<strong>JUnit4</strong>的整合，需要在web工程导入spring-test-4.2.4.RELEASE.jar，然后使用RunWith声明。另外我们也是了ContextConfiguration注解来加载配置文件，因此不用每次都以new的方式来获取ApplicationContext对象。</p><p>测试运行结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126135403545.png" alt="在这里插入图片描述"></p><h2 id="2-5-编写一个切面类"><a href="#2-5-编写一个切面类" class="headerlink" title="2.5 编写一个切面类"></a>2.5 编写一个切面类</h2><ul><li><p>编写切面类，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectXML</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//权限校验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPri</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"权限校验..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将切面类交由Spring管理，在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将切面类交由Spring管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.xmldemo.MyAspectXML"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-6-通过AOP配置来引用切面类"><a href="#2-6-通过AOP配置来引用切面类" class="headerlink" title="2.6 通过AOP配置来引用切面类"></a>2.6 通过AOP配置来引用切面类</h2><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过AOP的配置完成对目标对象类ProductDaoImpl产生代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切入点。</span></span><br><span class="line"><span class="comment">expression表达式配置哪些类的哪些方法需要进行增强 ，这里是ProductDaoImpl的save方法。</span></span><br><span class="line"><span class="comment">其中*表示任意返回值，..表示任意参数</span></span><br><span class="line"><span class="comment">此时save方法为一个pointcut，即切入点--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.shoto.spring.xmldemo.ProductDaoImpl.save(..))"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置前置增强，简单说就是在切入点save之前先执行的增强即checkPri权限校验方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"checkPri"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次运行测试类SpringDemo的测试方法，其测试结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126141643895.png" alt="在这里插入图片描述"><br>也就是在save方法执行之前进行了权限校验，即对save进行了增强。</p><h1 id="3-Spring增强类型（XML）"><a href="#3-Spring增强类型（XML）" class="headerlink" title="3. Spring增强类型（XML）"></a>3. Spring增强类型（XML）</h1><h2 id="3-1-前置增强：在目标方法执行之前进行操作"><a href="#3-1-前置增强：在目标方法执行之前进行操作" class="headerlink" title="3.1 前置增强：在目标方法执行之前进行操作"></a>3.1 前置增强：在目标方法执行之前进行操作</h2><p>比如上面配置的内容，即给save方法设置前置增强checkPri方法，如下所示：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126145520729.png" alt="在这里插入图片描述"><br>另外，我们可以通过JoinPoint类来获取切入点信息：</p><p>修改切面类MyAspectXML的checkPri方法如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126145758838.png" alt="在这里插入图片描述"><br>运行测试输出如下结果：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126145938154.png" alt="在这里插入图片描述"></p><h2 id="3-2-后置增强：在目标方法执行之后进行操作"><a href="#3-2-后置增强：在目标方法执行之后进行操作" class="headerlink" title="3.2 后置增强：在目标方法执行之后进行操作"></a>3.2 后置增强：在目标方法执行之后进行操作</h2><p>下面我们给ProductDaoImpl的delete方法添加一个后置增强writeLog方法，即在删除后进行日志记录。</p><p>在applicationContext.xml进行delelet切入点的配置，具体如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126150933768.png" alt="在这里插入图片描述"><br>然后配置后置通知，具体配置如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126151028549.png" alt="在这里插入图片描述"><br>此时再次运行测试类SpringDemo的测试方法，其测试结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126151141648.png" alt="在这里插入图片描述"><br>也就是在删除商品后进行日志记录操作。</p><p>另外，&lt;aop:after-returning&gt;标签有retruning属性，我们可以使用它来获取切入点delete方法的返回值。下面修改ProductDao的实现类ProductDaoImpl的delete方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"删除商品"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"删除成功！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，修改切面类MyAspect的writeLog方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志记录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"日志记录..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"delete方法的返回值为："</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>applicationContext.xml的配置如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126152047634.png" alt="在这里插入图片描述"><br><strong>returning的内容result即为writeLog方法的result参数。该result用于接收切入点方法delete的返回值，</strong> 这里即是”删除成功”。</p><p>运行测试的结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126152403538.png" alt="在这里插入图片描述"></p><h2 id="3-3-环绕增强：在目标方法执行前后进行操作"><a href="#3-3-环绕增强：在目标方法执行前后进行操作" class="headerlink" title="3.3 环绕增强：在目标方法执行前后进行操作"></a>3.3 环绕增强：在目标方法执行前后进行操作</h2><p>下面以ProductDaoImpl的update方法为切入点，演示环绕增强的使用。</p><p>在applicationContext.xml进行update切入点的配置，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.shoto.spring.xmldemo.ProductDaoImpl.update(..))"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"pointcut3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在增强类添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个环绕的增强方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕输出..."</span>);</span><br><span class="line">    <span class="comment">//调度ProceedingJoinPoint的proceed方法就可以调用原有的方法</span></span><br><span class="line">    Object object = joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"环绕输出..."</span>);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applicationContext.xml进行后置增强配置，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置环绕增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">"around"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut3"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次运行测试类SpringDemo的测试方法，其测试结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126153810502.png" alt="在这里插入图片描述"></p><h2 id="3-4-异常抛出增强：在程序出现异常时进行的操作"><a href="#3-4-异常抛出增强：在程序出现异常时进行的操作" class="headerlink" title="3.4 异常抛出增强：在程序出现异常时进行的操作"></a>3.4 异常抛出增强：在程序出现异常时进行的操作</h2><p>下面以find方法为切入点来演示异常抛出增强的使用。</p><p>同样的，在applicationContext.xml进行update切入点的配置，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(* com.shoto.spring.xmldemo.ProductDaoImpl.find(..))"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"pointcut4"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在增强类添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常抛出增强，ex封装有异常信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"异常抛出增强..."</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applicationContext.xml进行异常抛出增强配置，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置异常抛出增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"afterThrowing"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut4"</span> <span class="attr">throwing</span>=<span class="string">"ex"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong> throwing属性中的ex即为afterThrowing方法的参数名</p><p>此时find方法若发生了除0异常，运行测试会输出如下结果：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126155028747.png" alt="在这里插入图片描述"></p><h2 id="3-5-最终增强：无论代码是否有异常，总会执行"><a href="#3-5-最终增强：无论代码是否有异常，总会执行" class="headerlink" title="3.5 最终增强：无论代码是否有异常，总会执行"></a>3.5 最终增强：无论代码是否有异常，总会执行</h2><p>在上面演示异常抛出增强的基础上来演示最终增强的使用。</p><p>在增强类添加如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个最终增强方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终通知增强..."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applicationContext.xml进行最终增强配置，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置最终增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"after"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pointcut4"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>运次测试结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/2019012615570391.png" alt="在这里插入图片描述"></p><h1 id="4-切入点表达式语法"><a href="#4-切入点表达式语法" class="headerlink" title="4. 切入点表达式语法"></a>4. 切入点表达式语法</h1><p>基于execution的函数完成的，其结构如下所示：</p><pre><code>[访问修饰符]  方法返回值   包名.类名.方法名(参数)</code></pre><p>示例如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126160249227.png" alt="在这里插入图片描述"><br>第一个表示访问修饰符是public，返回值是void，然后就是com.itheima.spring.CustomerDao.save方法，其中参数用..表示任意参数；</p><p>第二个省略了访问修饰符（后面几个同理），表示任意返回值，任意包下的所有以Dao结尾的类的save方法；</p><p>第三个的+号表示CustomerDao的当前类和其子类有效；</p><p>第四个表示com.itheima.spring包的所有子包的所有子类的所有方法。</p><h1 id="5-AOP开发（注解）"><a href="#5-AOP开发（注解）" class="headerlink" title="5. AOP开发（注解）"></a>5. AOP开发（注解）</h1><h2 id="5-1-创建web项目，引入Jar包，并引入配置文件"><a href="#5-1-创建web项目，引入Jar包，并引入配置文件" class="headerlink" title="5.1 创建web项目，引入Jar包，并引入配置文件"></a>5.1 创建web项目，引入Jar包，并引入配置文件</h2><p>具体参考<a href="#jump">基于XML的AOP开发的内容</a></p><h2 id="5-2-编写目标类并配置"><a href="#5-2-编写目标类并配置" class="headerlink" title="5.2 编写目标类并配置"></a>5.2 编写目标类并配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDao</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"保存订单..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新订单..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除订单..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"删除成功！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询订单..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"orderDao"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo.OrderDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-3-编写切面类并配置"><a href="#5-3-编写切面类并配置" class="headerlink" title="5.3 编写切面类并配置"></a>5.3 编写切面类并配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面类：注解的切面类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//声明该类为切面类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspectAnno</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强==========="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：需要使用@Aspect注解来声明该类为切面类。</p><p>同样，在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo.MyAspectAnno"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-使用注解对AOP对象目标类进行增强"><a href="#5-4-使用注解对AOP对象目标类进行增强" class="headerlink" title="5.4 使用注解对AOP对象目标类进行增强"></a>5.4 使用注解对AOP对象目标类进行增强</h2><ul><li><p>要使用注解，必须在配置中开启注解的AOP开发</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在配置文件中开启注解的AOP开发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后下面以前置增强为例来在切面类上使用注解，具体代码如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126170743364.png" alt="在这里插入图片描述"></p><h2 id="5-5-编写测试类"><a href="#5-5-编写测试类" class="headerlink" title="5.5 编写测试类"></a>5.5 编写测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)<span class="comment">//Spring整合JUnit单元测试</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(<span class="string">"classpath:applicationContext.xml"</span>)<span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"orderDao"</span>)<span class="comment">//属性注入</span></span><br><span class="line">    <span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span><span class="comment">//需要JUnit4，不能使用JUnit5</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        orderDao.save();</span><br><span class="line">        orderDao.update();</span><br><span class="line">        orderDao.delete();</span><br><span class="line">        orderDao.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行结果如下：<br><img src="/2020/01/05/（三）Spring学习笔记-AOP/20190126170944540.png" alt="在这里插入图片描述"></p><h1 id="6-Spring增强类型（注解）"><a href="#6-Spring增强类型（注解）" class="headerlink" title="6. Spring增强类型（注解）"></a>6. Spring增强类型（注解）</h1><p>下面讲一下Spring的基于注解的AOP的各种增强使用，这里只给出<strong>增强的使用的核心内容</strong>（切面类MyAspectAnno中）。</p><h2 id="6-1-Before：前置增强"><a href="#6-1-Before：前置增强" class="headerlink" title="6.1 @Before：前置增强"></a>6.1 @Before：前置增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过注解的方式给save配置前置增强</span></span><br><span class="line"><span class="meta">@Before</span>(value=<span class="string">"execution(* com.shoto.spring.demo.OrderDao.save(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"前置增强==========="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-AfterReturning：后置增强"><a href="#6-2-AfterReturning：后置增强" class="headerlink" title="6.2 @AfterReturning：后置增强"></a>6.2 @AfterReturning：后置增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置通知</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(value=<span class="string">"execution(* com.shoto.spring.demo.OrderDao.delete(..))"</span>,returning=<span class="string">"result"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"后置增强==========="</span> + result);</span><br><span class="line">    <span class="comment">//输出  后置增强===========删除成功！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-Around：环绕增强"><a href="#6-3-Around：环绕增强" class="headerlink" title="6.3 @Around：环绕增强"></a>6.3 @Around：环绕增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Around</span>(value=<span class="string">"execution(* com.shoto.spring.demo.OrderDao.update(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"环绕前增强=========="</span>);</span><br><span class="line">    Object object = joinPoint.proceed();</span><br><span class="line">    System.out.println(<span class="string">"环绕后增强=========="</span>);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-AfterThrowing：异常抛出增强"><a href="#6-4-AfterThrowing：异常抛出增强" class="headerlink" title="6.4 @AfterThrowing：异常抛出增强"></a>6.4 @AfterThrowing：异常抛出增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常抛出异常</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(* com.shoto.spring.demo.OrderDao.find(..))"</span>,throwing=<span class="string">"ex"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"异常抛出增强=========="</span> + ex.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-After：最终增强"><a href="#6-5-After：最终增强" class="headerlink" title="6.5 @After：最终增强"></a>6.5 @After：最终增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最终增强</span></span><br><span class="line"><span class="meta">@After</span>(value=<span class="string">"execution(* com.shoto.spring.demo.OrderDao.find(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"最终增强=========="</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）Spring学习笔记-Bean管理</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Bean%E7%AE%A1%E7%90%86/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Bean%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Bean实例化方式"><a href="#1-Bean实例化方式" class="headerlink" title="1. Bean实例化方式"></a>1. Bean实例化方式</h2><p>下面演示一下Spring中的Bean实例化过程。</p><h3 id="1-1-无参构造方法方式（默认）"><a href="#1-1-无参构造方法方式（默认）" class="headerlink" title="1.1 无参构造方法方式（默认）"></a>1.1 无参构造方法方式（默认）</h3><ol><li>编写如下类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"Bean1的无参构造方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无参构造方法的方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo2.Bean1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">//输出结果：Bean1的无参构造方法执行了。。。</span></span><br><span class="line">    Bean1 bean1 = (Bean1) applicationContext.getBean(<span class="string">"bean1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果当前的类Bean1中没有无参构造方法，则会发生错误。</strong></p><h3 id="1-2-静态工厂实例化的方式"><a href="#1-2-静态工厂实例化的方式" class="headerlink" title="1.2 静态工厂实例化的方式"></a>1.2 静态工厂实例化的方式</h3></li><li><p>编写Bean2类和Bean2Factory工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"Bean2的无参构造方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean2Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bean2 <span class="title">createBean2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean2Factory中createBean2方法执行了。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--静态工厂实例化的方式  factory-method的值为Bean2Factory中的同名方法,用于调用工厂类方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo2.Bean2Factory"</span> <span class="attr">factory-method</span>=<span class="string">"createBean2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBean2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出结果：</span></span><br><span class="line"><span class="comment"> * Bean2Factory中createBean2方法执行了。。。</span></span><br><span class="line"><span class="comment"> * Bean2的无参构造方法执行了。。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    Bean2 bean2 = (Bean2) applicationContext.getBean(<span class="string">"bean2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-3-实例工厂实例化的方式"><a href="#1-3-实例工厂实例化的方式" class="headerlink" title="1.3 实例工厂实例化的方式"></a>1.3 实例工厂实例化的方式</h3><ol><li><p>编写Bean3类和对应的实例工厂类Bean3Factory：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean3</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"Bean3的无参构造方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bean3Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bean3 <span class="title">createBean3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean3的实例化工厂执行了。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Bean3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 实例工厂实例化方法 </span></span><br><span class="line"><span class="comment">必须实例化工厂类（factory-bean）后才能调用工厂方法,用于实例化工厂类.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3Factory"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo2.Bean3Factory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean3"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo2.Bean3"</span> <span class="attr">factory-bean</span>=<span class="string">"bean3Factory"</span>  <span class="attr">factory-method</span>=<span class="string">"createBean3"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试同理，不再赘述。</p></li></ol><h2 id="2-依赖注入（XML）"><a href="#2-依赖注入（XML）" class="headerlink" title="2. 依赖注入（XML）"></a>2. 依赖注入（XML）</h2><h3 id="2-1-构造方法方式"><a href="#2-1-构造方法方式" class="headerlink" title="2.1 构造方法方式"></a>2.1 构造方法方式</h3><ol><li><p>编写User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Infor infor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Integer uid, String username, String password, Infor infor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.uid = uid;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.infor = infor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [uid="</span> + uid + <span class="string">", username="</span> + username + <span class="string">", password="</span> + password + <span class="string">", infor="</span> + infor + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写Infor类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Infor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Infor</span><span class="params">(String gender, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//***getter，setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 构造方法方式属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- index的值分别代表构造方法的参数下标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"001"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"张三"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"abc123!"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里引用Infor类的Bean，ref中的值为Infor的Bean的id值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"3"</span> <span class="attr">ref</span>=<span class="string">"infor"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"infor"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.Infor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"广州"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructorDI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    User user = (User) applicationContext.getBean(<span class="string">"user"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(user);<span class="comment">//User [uid=1, username=张三, password=abc123!, infor=Infor [gender=男, address=广州]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-set方法方式"><a href="#2-2-set方法方式" class="headerlink" title="2.2 set方法方式"></a>2.2 set方法方式</h3><ol><li><p>在上面的User类中添加对应属性的setter方法以及<strong>无参构造方法</strong>，Spring默认使用无参构造方法来创建Bean的。</p></li><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"infor"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.Infor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"广州"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- setter方法方式属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">value</span>=<span class="string">"002"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"李四"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"infor"</span> <span class="attr">ref</span>=<span class="string">"infor"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试同理，不再赘述。</p><h3 id="2-3-P名称空间方式"><a href="#2-3-P名称空间方式" class="headerlink" title="2.3 P名称空间方式"></a>2.3 P名称空间方式</h3><h4 id="2-3-1-写法"><a href="#2-3-1-写法" class="headerlink" title="2.3.1 写法"></a>2.3.1 写法</h4></li></ol><ul><li>普通属性：p:属性名=”值”</li><li>对象属性：p:属性名-ref=”值”</li></ul><h4 id="2-3-2-引入"><a href="#2-3-2-引入" class="headerlink" title="2.3.2 引入"></a>2.3.2 引入</h4><p><img src="/2020/01/05/（二）Spring学习笔记-Bean管理/20190124090345780.png" alt="在这里插入图片描述"></p><h4 id="2-3-3-使用"><a href="#2-3-3-使用" class="headerlink" title="2.3.3 使用"></a>2.3.3 使用</h4><p><img src="/2020/01/05/（二）Spring学习笔记-Bean管理/20190124090500471.png" alt="在这里插入图片描述"></p><h3 id="2-4-SpEL方式"><a href="#2-4-SpEL方式" class="headerlink" title="2.4 SpEL方式"></a>2.4 SpEL方式</h3><p>SpEL：Spring Expression Language，Spring的表达式语言。<br>使用语法：<strong>#{SpEL}</strong></p><h4 id="2-4-1-使用"><a href="#2-4-1-使用" class="headerlink" title="2.4.1 使用"></a>2.4.1 使用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpEL方式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"infor"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.Infor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"#&#123;'女'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"#&#123;'北京'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">value</span>=<span class="string">"#&#123;003&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"#&#123;'王五'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为了测试，这里使用Infor类的address作为User类的password的值 </span></span><br><span class="line"><span class="comment">另外也可以使用如下的方式：</span></span><br><span class="line"><span class="comment">&lt;property name="password" value="#&#123;infor.getAddress()&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"#&#123;infor.address&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里引用Infor的Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"infor"</span> <span class="attr">value</span>=<span class="string">"#&#123;infor&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：SpEL的功能远远不止用于属性的注入，它还可以进行运算、集合匹配和提供正则表达式进行匹配等，有时间在补充一下吧。</p><h3 id="2-5-集合类型属性注入"><a href="#2-5-集合类型属性注入" class="headerlink" title="2.5 集合类型属性注入"></a>2.5 集合类型属性注入</h3><ol><li><p>编写CollectionBean类，如下示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] arrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> Properties props;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CollectionBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//***setter，getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>applicationContext.xml的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring的集合属性注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"collection"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo3.CollectionBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入数组类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arrs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入List集合类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Jan<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注入Map集合类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"2"</span> <span class="attr">value</span>=<span class="string">"bbb"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"3"</span> <span class="attr">value</span>=<span class="string">"ccc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注入Set集合类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>壹<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>贰<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>叁<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 注入Properties集合类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop1"</span>&gt;</span>prop1的值<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop2"</span>&gt;</span>prop2的值<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop3"</span>&gt;</span>prop3的值<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面我们都是对字符串的各个集合的装载，下面我们对自定义类进行装载。</p></li><li><p>先编写三个POJO，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">(Long id, String roleName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id, String username, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter,setter,toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRoleAssembly</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Role&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Role, User&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;Role&gt; set;</span><br><span class="line">    <span class="comment">//getter,setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Role --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role1"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo4.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">value</span>=<span class="string">"roleName1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"roleNote1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role2"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo4.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">value</span>=<span class="string">"roleName2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"roleNote2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置User --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user1"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo4.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"username1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"userNote1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo4.User"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"username2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"userNote2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置UserRoleAssembly--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userRoleAssembly"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo4.UserRoleAssembly"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给装载有自定义对象的List集合属性注入值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"role1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"role2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给装载有自定义对象的Map集合属性注入值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"role1"</span> <span class="attr">value-ref</span>=<span class="string">"user1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"role2"</span> <span class="attr">value-ref</span>=<span class="string">"user2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 给装载有自定义对象的Set集合属性注入值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"role1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"role2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    UserRoleAssembly userRoleAssembly = (UserRoleAssembly) applicationContext.getBean(<span class="string">"userRoleAssembly"</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"输出List集合："</span>);</span><br><span class="line">    List&lt;Role&gt; list = userRoleAssembly.getList();</span><br><span class="line">    <span class="keyword">for</span> (Role r : list) &#123;</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"输出Map集合："</span>);</span><br><span class="line">    Map&lt;Role, User&gt; map = userRoleAssembly.getMap();</span><br><span class="line">    Set&lt;Entry&lt;Role, User&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Role, User&gt; entry : entrySet) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"=="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"输出Set集合："</span>);</span><br><span class="line">    Set&lt;Role&gt; set = userRoleAssembly.getSet();</span><br><span class="line">    <span class="keyword">for</span> (Role r : set) &#123;</span><br><span class="line">        System.out.println(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-IoC的注解开发"><a href="#3-IoC的注解开发" class="headerlink" title="3. IoC的注解开发"></a>3. IoC的注解开发</h2><h3 id="3-1-入门案例"><a href="#3-1-入门案例" class="headerlink" title="3.1 入门案例"></a>3.1 入门案例</h3><ol><li><p>创建Web项目，引入Jar包<br> <img src="/2020/01/05/（二）Spring学习笔记-Bean管理/20190124115946462.png" alt="在这里插入图片描述"><br> 注意：在Spring4版本中，除了引入基本的开发包和日志相关包以外，<strong>还需要引入aop的包。</strong></p></li><li><p>引入Spring的配置文件，即在src下创建applicationContext.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span> <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：<strong>要使用注解开发需要引入context约束</strong>，具体的内容引用自spring-framework-4.2.4.RELEASE-dist\spring-framework-4.2.4.RELEASE\docs\spring-framework-reference\html\xsd-configuration下。</p></li><li><p>编写接口UserDAO和实现类UserDAOImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.spring.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserDAO的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"userDAO"</span>)<span class="comment">//相当于&lt;bean id="userDAO" class="com.shoto.spring.demo.UserDAOImpl"&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDAOImpl中实现用户保存的方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：使用注解Componet在类添加上注解。</p></li><li><p>开启Spring的组件扫描</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用IoC的注解开发，配置组件扫描，即扫描哪些包下的哪些类在**类上**使用了注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.spring.demo"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        UserDAO userDAO = (UserDAO) applicationContext.getBean(<span class="string">"userDAO"</span>);</span><br><span class="line">        userDAO.save();<span class="comment">//输出UserDAOImpl中实现用户保存的方法执行了。。。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-注解方式依赖注入"><a href="#3-2-注解方式依赖注入" class="headerlink" title="3.2 注解方式依赖注入"></a>3.2 注解方式依赖注入</h3><p>注解方式：使用注解方式，Bean所对应的类可以没有set方法。</p><ul><li>如果属性有set方法，则需要将属性注入的注解添加到set方法上；</li><li>如果属性没有set方法，则需要将属性注入的注解添加在属性上。<br><img src="/2020/01/05/（二）Spring学习笔记-Bean管理/20190124131504478.png" alt="在这里插入图片描述"><br>注意：注解@Value代表的是值的注入。如果同时使用注解@Value在属性和对应的setter方法，则实际使用的setter方法的注解注入的值。<h3 id="3-3-注解详解"><a href="#3-3-注解详解" class="headerlink" title="3.3 注解详解"></a>3.3 注解详解</h3><h4 id="3-3-1-Component注解"><a href="#3-3-1-Component注解" class="headerlink" title="3.3.1 @Component注解"></a>3.3.1 @Component注解</h4>该注解用于修饰一个类，将这个类交给Spring管理，这个注解有三个衍生注解，功能类似，只是分别应用于不同的MVC层，具体如下：</li><li>@Controller：web层</li><li>@Service：service层</li><li>@Repository：dao层</li></ul><h4 id="3-3-2-属性注入的注解"><a href="#3-3-2-属性注入的注解" class="headerlink" title="3.3.2 属性注入的注解"></a>3.3.2 属性注入的注解</h4><h5 id="1-普通属性："><a href="#1-普通属性：" class="headerlink" title="1. 普通属性："></a>1. 普通属性：</h5><p>@Value：用于设置好普通属性的值。</p><h5 id="2-对象类型的属性："><a href="#2-对象类型的属性：" class="headerlink" title="2. 对象类型的属性："></a>2. 对象类型的属性：</h5><ul><li><p><strong>@Autowired</strong>：用于设置对象类型的属性的值，但是需要按照<strong>类型</strong>完成属性的注入，所谓按类型完成属性注入就是将与该属性的类型相同的bean注入进来，显然这是不太合理的，因为该属性如果是接口且有多个实现类，就会发生歧义而无法完成属性注入。因此可以<strong>使用@Autowired注解和@Qualifier注解的配合使用来完成按照名称属性注入。</strong> 具体用法如下（实现将UserDAOImpl2注入到UserDAOImpl中）：</p><p>新建一个UserDAO的新的实现类UserDAOImpl2，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"userDAOImpl2"</span>)<span class="comment">//先使用注解声明创建Bean，才能被引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl2</span> <span class="keyword">implements</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDAOImpl2的save方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改UserDAOImpl类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"userDAOImpl"</span>)<span class="comment">//相当于&lt;bean id="userDAOImpl" class="com.shoto.spring.demo.UserDAOImpl"&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"张三"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注入UserDAOImpl2</span></span><br><span class="line"><span class="comment"> * 相当于&lt;property name="userDAOImpl2" ref="userDAOImpl2"/&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userDAOImpl2"</span>)<span class="comment">//与UserDAOImpl中的@Component中的值相同</span></span><br><span class="line">    <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDAOImpl中实现用户保存的方法执行了。。。"</span> + username);</span><br><span class="line">        userDAO.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    UserDAO userDAO = (UserDAO) applicationContext.getBean(<span class="string">"userDAOImpl"</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 运行输出：</span></span><br><span class="line"><span class="comment"> * UserDAOImpl中实现用户保存的方法执行了。。。张三</span></span><br><span class="line"><span class="comment"> * UserDAOImpl2的save方法执行了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    userDAO.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Resource</strong>：相当于@AutoWired与@Qualifier的结合，完成对象类型的属性的注入，按照名称完成属性注入，常用于实际开发中。</p><p>修改上面的UserDAOImpl为如下：<br><img src="/2020/01/05/（二）Spring学习笔记-Bean管理/20190124145912815.png" alt="在这里插入图片描述"><br><strong>注意：@Resource注解使用name属性来引用</strong></p></li></ul><h4 id="3-3-3-Bean的其他注解"><a href="#3-3-3-Bean的其他注解" class="headerlink" title="3.3.3 Bean的其他注解"></a>3.3.3 Bean的其他注解</h4><h5 id="1-生命周期相关注解"><a href="#1-生命周期相关注解" class="headerlink" title="1. 生命周期相关注解"></a>1. 生命周期相关注解</h5><ul><li>@PostConstruct：初始化方法</li><li>@PreDestroy：销毁方法</li></ul><p>下面演示一些这两个注解的简单使用：</p><p>首先编写一个Customer类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(value=<span class="string">"customer"</span>) <span class="comment">//相当于&lt;bean id="customer" class="com.shoto.spring.demo2.Customer"/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Customer中的purchase方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">//相当于bean中的init-method属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Customer的init方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//相当于bean中的destroy-method属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Customer的destroy方法执行了。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在applicatinContext.xml开启注解扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用IoC的注解开发，配置组件扫描，即扫描哪些包下的类使用的注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.shoto.spring.demo2"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInitAndDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    Customer customer = (Customer) applicationContext.getBean(<span class="string">"customer"</span>);</span><br><span class="line">    customer.purchase();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭工厂，才会调用destroy</span></span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（二）Spring学习笔记-Bean管理/20190124152214199.png" alt="在这里插入图片描述"></p><h5 id="2-Bean作用范围相关注解"><a href="#2-Bean作用范围相关注解" class="headerlink" title="2. Bean作用范围相关注解"></a>2. Bean作用范围相关注解</h5><p>使用@Scope注解来设置作用范围，有以下4中作用域：</p><ul><li>singleton（单例）：默认选项，Spring会采用单例模式创建这个对象，即Bean实例；</li><li>prototype（多例）：多例模式，Struts2和Spring整合一定会用到，不过现在Struts2很少用了。比如我们希望Struts2中的Action（Struts2的控制层类）有时候需要多个实例，这时就需要将Spring设置为多例模式了；</li><li>request（请求）：应用在web项目中，就是在一次请求中Spring会创建一个实例，但是不同点的请求会创建不同的实例；</li><li>session    （会话）：应用在web项目中，就是在会话过程中Spring只创建一个实例</li></ul><p>下面简单演示以下@Scope的使用：</p><p>在上面定义的Customer添加@Scope(“prototype”)，如下所示：<br><img src="/2020/01/05/（二）Spring学习笔记-Bean管理/2019012416111180.png" alt="在这里插入图片描述"><br>运行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    Customer customer1 = (Customer) applicationContext.getBean(<span class="string">"customer"</span>);</span><br><span class="line">    Customer customer2 = (Customer) applicationContext.getBean(<span class="string">"customer"</span>);</span><br><span class="line">    <span class="comment">//两次的输出结果是不同的，说明使用@Scope("prototype")可以产生不同的Bean实例</span></span><br><span class="line">    System.out.println(customer1);<span class="comment">//com.shoto.spring.demo2.Customer@7b02881e</span></span><br><span class="line">    System.out.println(customer2);<span class="comment">//com.shoto.spring.demo2.Customer@1ebd319f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-IoC的XML和注解开发比较"><a href="#4-IoC的XML和注解开发比较" class="headerlink" title="4. IoC的XML和注解开发比较"></a>4. IoC的XML和注解开发比较</h2><h3 id="4-1-适用场景"><a href="#4-1-适用场景" class="headerlink" title="4.1 适用场景"></a>4.1 适用场景</h3><ul><li>XML：可以适用任何场景，结构清晰并维护方便。</li><li>注解：注解在有些地方是无法使用的，比如我们在引用第三包或者其他外部的接口时，这是可以使用XML的方式。而在对于自己的工程中所开发的类使用注解则会更为方便。</li></ul><h3 id="4-2-混合使用"><a href="#4-2-混合使用" class="headerlink" title="4.2 混合使用"></a>4.2 混合使用</h3><ul><li><p><strong>推荐使用XML来管理Bean，而注解则完成属性注入。</strong> 也就是不再使用@Component等注解来声明创建Bean，而是以如下的形式直接写在XML文件中。</p> <bean id="xxx" class="xxx.xxxx.xxxx"></bean></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）Spring学习笔记-IoC控制反转</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-IoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-IoC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Spring-IoC概述"><a href="#1-Spring-IoC概述" class="headerlink" title="1. Spring IoC概述"></a>1. Spring IoC概述</h2><p>IoC即为控制反转（Inversion of Controll），它用来将对象的创建权反转给（交给）Spring来创建。假如，你现在需要一杯果汁，你没有必要去买果汁机，橙子，准备橙子等操作，而是去超市直接买即可。果汁就相当于你需要使用的对象，而该对象是由果汁厂创建然后由超市提供的，果汁厂就相当于Spring。</p><a id="more"></a><h2 id="2-IoC入门实例"><a href="#2-IoC入门实例" class="headerlink" title="2. IoC入门实例"></a>2. IoC入门实例</h2><h3 id="2-1-下载Spring的开发包"><a href="#2-1-下载Spring的开发包" class="headerlink" title="2.1 下载Spring的开发包"></a>2.1 下载Spring的开发包</h3><p><a href="http://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">官方地址</a><br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123115923551.png" alt="在这里插入图片描述"><br>上面的压缩包分别为Spring相关的依赖包，开发包，开发文档以及约束。</p><h3 id="2-2-创建web项目并导入Jar包"><a href="#2-2-创建web项目并导入Jar包" class="headerlink" title="2.2 创建web项目并导入Jar包"></a>2.2 创建web项目并导入Jar包</h3><p><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123120410749.png" alt="在这里插入图片描述"><br>前两个jar包为日志相关的依赖包，分别位于如下路径下：<br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123120715953.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123120805177.png" alt="在这里插入图片描述"><br>后面四个依赖包为Spring核心容器相关的必需包。<br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123121008110.png" alt="在这里插入图片描述"></p><h3 id="2-3-创建接口和类"><a href="#2-3-创建接口和类" class="headerlink" title="2.3 创建接口和类"></a>2.3 创建接口和类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.spring.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理DAO层接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shoto.spring.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理DAO层实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDAOImpl的Save方法执行了。。。"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-编写appliactionContext-xml，将实现类交给Spring管理"><a href="#2-4-编写appliactionContext-xml，将实现类交给Spring管理" class="headerlink" title="2.4 编写appliactionContext.xml，将实现类交给Spring管理"></a>2.4 编写appliactionContext.xml，将实现类交给Spring管理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo1.UserDAOImpl"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖注入，name为UserDAOImpl中的属性，value则是赋给的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-5-运行测试"><a href="#2-5-运行测试" class="headerlink" title="2.5 运行测试"></a>2.5 运行测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传统方式，接口与实现类之间有耦合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*@Test</span></span><br><span class="line"><span class="comment">public void test() &#123;</span></span><br><span class="line"><span class="comment">UserDAO userDAO = new UserDAOImpl();</span></span><br><span class="line"><span class="comment">userDAO.save();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Spring工厂</span></span><br><span class="line">    ApplicationContext applicationContext = </span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">//获取bean，userDAO为applicationContext对应的bean的id值</span></span><br><span class="line">    UserDAO userDAO = (UserDAO) applicationContext.getBean(<span class="string">"userDAO"</span>);</span><br><span class="line">    userDAO.save();<span class="comment">//输出UserDAOImpl的Save方法执行了。。。张三</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同于传统的方式，通过使用创建Spring工厂ApplicationContext来创建Bean，也就是UserDAO的实现类，<strong>从而实现了接口与实现类的解耦。</strong></p><h2 id="3-Spring-IoC容器"><a href="#3-Spring-IoC容器" class="headerlink" title="3. Spring IoC容器"></a>3. Spring IoC容器</h2><h3 id="3-1-结构图"><a href="#3-1-结构图" class="headerlink" title="3.1 结构图"></a>3.1 结构图</h3><p><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123122633875.png" alt="在这里插入图片描述"></p><h3 id="3-2-BeanFactory"><a href="#3-2-BeanFactory" class="headerlink" title="3.2 BeanFactory"></a>3.2 BeanFactory</h3><p>该类是Spring Ioc容器所定义的最底层接口，是老版本的工厂类。当调用getBean的时候，才会生成类的实例。</p><h3 id="3-3-AppliactionFactory"><a href="#3-3-AppliactionFactory" class="headerlink" title="3.3 AppliactionFactory"></a>3.3 AppliactionFactory</h3><p>ApplicationFactory对BeanFactory接口进行了功能的扩展，其是新版本的工厂类。在大部分工作场景下，都会使用ApplicationFactory作为Spring IoC容器。<strong>其在加载配置文件的时候，就会将Spring管理的类都实例化。</strong></p><p> 其有两个如下的实现类：</p><ol><li><p>ClassPathXmlApplicationContext    ：用于加载类路径下的配置文件</p><ol start="2"><li>FileSystemXmlApplicationContext    ：用于加载文件系统下的配置文件</li></ol></li></ol><h2 id="4-依赖注入DI"><a href="#4-依赖注入DI" class="headerlink" title="4. 依赖注入DI"></a>4. 依赖注入DI</h2><p><strong>在有IOC的环境的前提下，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。</strong></p><p>比如上面我们在配置Bean时，使用到了其子元素&lt;property&gt;来给该Bean对应的类的属性赋值。</p><h2 id="5-五、Spring配置"><a href="#5-五、Spring配置" class="headerlink" title="5. 五、Spring配置"></a>5. 五、Spring配置</h2><h3 id="5-1-Schema约束配置（XML具有提示功能）"><a href="#5-1-Schema约束配置（XML具有提示功能）" class="headerlink" title="5.1 Schema约束配置（XML具有提示功能）"></a>5.1 Schema约束配置（XML具有提示功能）</h3><p><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123125635267.png" alt="在这里插入图片描述"></p><h3 id="5-2-Bean相关配置"><a href="#5-2-Bean相关配置" class="headerlink" title="5.2 Bean相关配置"></a>5.2 Bean相关配置</h3><h4 id="5-2-1-标签的id和name的配置"><a href="#5-2-1-标签的id和name的配置" class="headerlink" title="5.2.1 标签的id和name的配置"></a>5.2.1 <bean>标签的id和name的配置</bean></h4><ul><li>id    ：使用了约束中的唯一约束，里面不能出现特殊字符。</li><li>name    ：没有使用约束中的唯一约束（理论上可以出现重复的，但是实际开发不能出现的），里面可以出现特殊字符。</li></ul><p>比如，可以更改上方的applicationContext.xml中的bean为如下格式。当然一般情况下不推荐这种方式。<br>    <img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123134825367.png" alt="在这里插入图片描述"><br>另一方面，早在之前Spring与Struts 1整合的时候，配置bean时是不支持如下这种格式的，因为id中存在特殊字符  /  。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;/user&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><p>此时就要改成如下的格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;/user&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-Bean的生命周期的配置"><a href="#5-2-2-Bean的生命周期的配置" class="headerlink" title="5.2.2 Bean的生命周期的配置"></a>5.2.2 Bean的生命周期的配置</h4><p>生命周期主要是为了了解Spring IoC容器初始化和销毁Bean的过程，通过对它的学习就可以知道如何在初始化和销毁的时候加入自定义的方法，以满足特定的要求。</p><p>它有如下两个生命周期相关的方法：</p><ul><li>init-method：Bean被初始化的时候执行的方法；</li><li>destroy-method：Bean被销毁的时候执行的方法，Bean是单例创建且<strong>在工厂关闭是才会调用。</strong></li></ul><p>下面演示一下它们的用法：</p><ol><li><p>修改applicationContext.xml的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDAO"</span> <span class="attr">class</span>=<span class="string">"com.shoto.spring.demo1.UserDAOImpl"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 属性注入，name为UserDAOImpl中的属性，value则是赋给的值--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"张三"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在原有UserDAOImpl类中增加如下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"UserDAOImpl被初始化了。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"UserDAOImpl被销毁了。。。"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInitAndDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Spring工厂</span></span><br><span class="line">    ClassPathXmlApplicationContext applicationContext = </span><br><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    <span class="comment">//获取bean，userDAO为applicationContext对应的bean的id值</span></span><br><span class="line">    UserDAO userDAO = (UserDAO) applicationContext.getBean(<span class="string">"userDAO"</span>);</span><br><span class="line">    userDAO.save();</span><br><span class="line">    <span class="comment">//关闭applicationContext工厂，销毁方法才会被调用</span></span><br><span class="line">    applicationContext.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是ApplicationContext的子类才拥有close方法。</strong></p></li><li><p>运行结果：<br> <img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123143202963.png" alt="在这里插入图片描述"></p><h4 id="5-2-3-Bean的作用范围的配置"><a href="#5-2-3-Bean的作用范围的配置" class="headerlink" title="5.2.3 Bean的作用范围的配置"></a>5.2.3 Bean的作用范围的配置</h4><p>Spring提供了4种作用域，它会根据情况来决定是否生成新的对象。可以通过bean标签的scope属性来配置。<br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/2019012314430893.png" alt="在这里插入图片描述"></p></li></ol><ul><li>singleton（单例）：默认选项，Spring会采用单例模式创建这个对象，即Bean实例；</li><li>prototype（多例）：多例模式，Struts2和Spring整合一定会用到，不过现在Struts2很少用了。比如我们希望Struts2中的Action（Struts2的控制层类）有时候需要多个实例，这时就需要将Spring设置为多例模式了；</li><li>request（请求）：应用在web项目中，就是在一次请求中Spring会创建一个实例，但是不同点的请求会创建不同的实例；</li><li>session    （会话）：应用在web项目中，就是在会话过程中Spring只创建一个实例。</li></ul><p>我们可以测试一下Spring是否为单例的，在不设置scope属性的情况下，在上面的基础上编写如下测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Spring工厂</span></span><br><span class="line">ApplicationContext applicationContext = </span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">//获取bean，userDAO为applicationContext对应的bean的id值</span></span><br><span class="line">UserDAO userDAO1 = (UserDAO) applicationContext.getBean(<span class="string">"userDAO"</span>);</span><br><span class="line">System.out.println(userDAO1);</span><br><span class="line"></span><br><span class="line">UserDAO userDAO2 = (UserDAO) applicationContext.getBean(<span class="string">"userDAO"</span>);</span><br><span class="line">System.out.println(userDAO2);</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190123145757843.png" alt="在这里插入图片描述"></p><h3 id="5-3-分模块配置"><a href="#5-3-分模块配置" class="headerlink" title="5.3 分模块配置"></a>5.3 分模块配置</h3><ol><li>在加载配置文件的时候，加载多个的情况<br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190124103852877.png" alt="在这里插入图片描述"></li><li>在一个配置文件中引入多个配置文件<br><img src="/2020/01/05/（一）Spring学习笔记-IoC控制反转/20190124103937982.png" alt="在这里插入图片描述"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c3p0连接超时：com.mchange.v2.resourcepool.TimeoutException</title>
      <link href="/2020/01/05/c3p0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%EF%BC%9Acom-mchange-v2-resourcepool-TimeoutException/"/>
      <url>/2020/01/05/c3p0%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%EF%BC%9Acom-mchange-v2-resourcepool-TimeoutException/</url>
      
        <content type="html"><![CDATA[<p>异常信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">13:07:04.315 [main] DEBUG com.mchange.v2.sql.SqlUtils - Converting Throwable to SQLException...</span><br><span class="line">com.mchange.v2.resourcepool.TimeoutException: A client timed out while waiting to acquire a resource from com.mchange.v2.resourcepool.BasicResourcePool@4c2bb6e0 -- timeout at awaitAvailable()</span><br><span class="line">    at com.mchange.v2.resourcepool.BasicResourcePool.awaitAvailable(BasicResourcePool.java:1467)</span><br><span class="line">    at com.mchange.v2.resourcepool.BasicResourcePool.prelimCheckoutResource(BasicResourcePool.java:644)</span><br><span class="line">    at com.mchange.v2.resourcepool.BasicResourcePool.checkoutResource(BasicResourcePool.java:554)</span><br><span class="line">    at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutAndMarkConnectionInUse(C3P0PooledConnectionPool.java:758)</span><br><span class="line">    at com.mchange.v2.c3p0.impl.C3P0PooledConnectionPool.checkoutPooledConnection(C3P0PooledConnectionPool.java:685)</span><br><span class="line">    at com.mchange.v2.c3p0.impl.AbstractPoolBackedDataSource.getConnection(AbstractPoolBackedDataSource.java:140)</span><br><span class="line">    at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:157)</span><br><span class="line">    at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:115)</span><br><span class="line">    at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:78)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a><p>在spring配置c3p0的信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据库连接池：c3p0--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置连接池属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置数据库连接池的私有属性--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池的最大连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接池的最小连接数量--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 关闭连接后不自动commit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoCommitOnClose"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--连接失败的重试次数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireRetryAttempts"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--获取连接超时时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将连接超时时间改大一点即可，具体如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"5000"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java对象克隆</title>
      <link href="/2020/01/05/Java%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/"/>
      <url>/2020/01/05/Java%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86/</url>
      
        <content type="html"><![CDATA[<h3 id="1-clone对象使用原因"><a href="#1-clone对象使用原因" class="headerlink" title="1. clone对象使用原因"></a>1. clone对象使用原因</h3><p>在实际编程过程中，我们常常要遇到这种情况：有一个对象 A，在某一时刻 A 中已经包含了一些有效值，此时可能会需要一个和 A 完全相同新对象 B，并且此后对 B 任何改动都不会影响到 A 中的值，也就是说， A 与 B 是两个独立的对象，但 B 的初始值是由 A 对象确定的。在 Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需求虽然有很多途径，但实现 clone（）方法是其中最简单，也是最高效的手段。</p><a id="more"></a><h3 id="2-new对象与clone对象的区别"><a href="#2-new对象与clone对象的区别" class="headerlink" title="2. new对象与clone对象的区别"></a>2. new对象与clone对象的区别</h3><ul><li>new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型，才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用（地址）发布到外部，在外部就可以使用这个引用操纵这个对象。</li><li>clone 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象（即调用 clone 方法的对象）相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后， clone 方法返回，一个新的相同的对象被创建，同样可以把这个新对象的引用发布到外部。</li></ul><h3 id="3-clone对象的使用"><a href="#3-clone对象的使用" class="headerlink" title="3. clone对象的使用"></a>3. clone对象的使用</h3><h4 id="3-1-浅克隆"><a href="#3-1-浅克隆" class="headerlink" title="3.1 浅克隆"></a>3.1 浅克隆</h4><p>在浅克隆中，被复制的对象的所有普通成员变量都具有与原来的对象相同的值，而所有的对其他对对象的引用仍然指向原来的对象。换言之，浅克隆仅仅复制所考虑的对象，而不复制它所引用的成员对象。</p><p><img src="/2020/01/05/Java对象克隆/20181225105532191.png" alt="在这里插入图片描述"><br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：要克隆的类需要实现Cloneable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Attachment attachment = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Email</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachment = <span class="keyword">new</span> Attachment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Email <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Email clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            clone = (Email)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"CLone failture!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Attachment <span class="title">getAttachment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attachment;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttachment</span><span class="params">(Attachment attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Email email = <span class="keyword">new</span> Email();</span><br><span class="line">        System.out.println(<span class="string">"email:"</span> + email.hashCode() + <span class="string">", attrament:"</span> + email.getAttachment().hashCode());</span><br><span class="line">        Email copy = email.clone();</span><br><span class="line">        System.out.println(<span class="string">"copy email:"</span> + copy.hashCode() + </span><br><span class="line">                <span class="string">", copy attrament:"</span> + copy.getAttachment().hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">email:2018699554, attrament:1311053135</span><br><span class="line">copy email:118352462, copy attrament:1311053135</span><br></pre></td></tr></table></figure><h4 id="3-2-深克隆"><a href="#3-2-深克隆" class="headerlink" title="3.2 深克隆"></a>3.2 深克隆</h4><p>在深克隆中被复制对象的所有普通成员变量也都含有与原来对象相同的值，其中的引用对象也被复制。换言之，深克隆把要复制的对象所引用的对象都复制了一遍。</p><p><img src="/2020/01/05/Java对象克隆/20181225105601154.png" alt="在这里插入图片描述"><br><strong>方法一（将克隆对象的引用属性都克隆一遍）：</strong></p><p>修改上述类 Email 的 clone 方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Email <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Email clone = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        clone = (Email)<span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//拷贝引用属性</span></span><br><span class="line">        clone.setAttachment(attachment.clone());</span><br><span class="line">    &#125; <span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">"CLone failture!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Attachment 类如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Attachment <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Attachment clone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            clone = (Attachment)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"CLone failture!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">email:2018699554, attrament:1311053135</span><br><span class="line">copy email:118352462, copy attrament:1550089733</span><br></pre></td></tr></table></figure><p><strong>方法二（序列化）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：要克隆的类需要实现序列化接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Attachment attachment = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Email</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachment = <span class="keyword">new</span> Attachment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, OptionalDataException </span>&#123;</span><br><span class="line">        <span class="comment">// 将对象写入流中</span></span><br><span class="line">        ByteArrayOutputStream bao = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bao);</span><br><span class="line">        oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象从流中取出</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bao.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Attachment <span class="title">getAttachment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.attachment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttachment</span><span class="params">(Attachment attachment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.attachment = attachment;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Attachment</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">email:2018699554, attrament:1311053135</span><br><span class="line">copy email:1831932724, copy attrament:1747585824</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础语法</title>
      <link href="/2020/01/05/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/01/05/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h2><p><img src="/2020/01/05/Java基础语法/20190109094913925.png" alt="在这里插入图片描述"></p><a id="more"></a><ul><li>注意事项1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte i = 5;</span><br><span class="line">i = i + 5;</span><br></pre></td></tr></table></figure></li></ul><p>上述代码示例编译时会报错，因为语句i = i +5;中右边的5是int类型值，所以 i + 5也是int类型值。可以写成如下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">byet i = 5;</span><br><span class="line">i += 5;</span><br><span class="line">----------------</span><br><span class="line">byet i = 5;</span><br><span class="line">i = (byte)(i + 5);</span><br></pre></td></tr></table></figure><p> i += 5;相当于语句i = (byte)(i + 5);。其在底层默认会进行类型转换。</p><ul><li>注意事项2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte i = 127;</span><br><span class="line">i += 1;</span><br></pre></td></tr></table></figure></li></ul><p>运行上述代码之后输出的结果是-128。<br>这是因为byte类型的127在计算机底层是表示形式是01111111。加1之后则变为10000000，也就是-128。</p><ul><li>注意事项3</li></ul><p>长整型的值有一个后缀L或l，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long i = 1554555L;</span><br><span class="line">long j = 1554555l;</span><br></pre></td></tr></table></figure><p>float类型的值有一个后缀F或f，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float i = 3.14F;</span><br><span class="line">float j = 3.14f;</span><br></pre></td></tr></table></figure><p>当然可以在浮点数值后面加上后缀D或d以表示是double类型数值。</p><ul><li>注意事项4</li></ul><p>整型值可以用前缀0x或0X表示其是十六进制值。<br>从Java 7开始，整型值可以用前缀0b或0B表示其是二进制值，还可以在数字字面加下划线，更容易理解。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 1_000_000; //表示十进制的一百万</span><br><span class="line">int j = 0b1010； //相当于十进制的10</span><br><span class="line">System.out.println(j);//输出自动转为十进制值 10</span><br><span class="line">int j = 0b1_010； //相当于十进制的10</span><br></pre></td></tr></table></figure><h2 id="2-lt-lt-、-gt-gt-与-gt-gt-gt"><a href="#2-lt-lt-、-gt-gt-与-gt-gt-gt" class="headerlink" title="2. &lt;&lt;、&gt;&gt;与&gt;&gt;&gt;"></a>2. &lt;&lt;、&gt;&gt;与&gt;&gt;&gt;</h2><blockquote><p>数值的二进制值的位移。在与2的倍数进行数值运算时，位移运算比传统的乘法运算速度要快。</p></blockquote><p>&lt;&lt;（左移）：左移几位其实就是该数据乘以2的几次方。&lt;&lt;可以完成2的次幂运算。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 &lt;&lt; 2 = 12  --&gt;  3 * 2^2 = 12</span><br><span class="line">3 &lt;&lt; 3 = 24  --&gt;  3 * 2^3 = 24</span><br></pre></td></tr></table></figure><p>&gt;&gt; （右移）：右移几位其实就是该数据除以2的几次幂。右移后对于高位出现的空位，原来高位是什么就用什么补这个空位。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 &gt;&gt; 1 = 3  --&gt;  6 / 2 = 3</span><br><span class="line">6 &gt;&gt; 2 = 1  --&gt;  6 / 2^2 = 1</span><br></pre></td></tr></table></figure><p>&gt;&gt;&gt; （无符号右移）：数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补。</p><h2 id="3-amp-与-amp-amp"><a href="#3-amp-与-amp-amp" class="headerlink" title="3. &amp;与&amp;&amp;"></a>3. &amp;与&amp;&amp;</h2><p>&amp; 运算符有两种用法： (1)按位与； (2)逻辑与。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">按位与：</span><br><span class="line">int i = 3 &amp; 2; </span><br><span class="line">int i = 0011 &amp; 0010 = 0010;//转为二进制数进行&amp;位运算</span><br><span class="line">int i = 2;</span><br><span class="line"></span><br><span class="line">逻辑与：</span><br><span class="line">boolean i = true;</span><br><span class="line">boolean j = false;</span><br><span class="line">boolean r = i &amp; j = false;//判断i为真，后在判断j为假，得出假</span><br><span class="line">boolean r = !i &amp; j = false;//判断!i为假，再判断j为假，得出假</span><br></pre></td></tr></table></figure><p>&amp;&amp; 运算符是 短路与运算。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean i = flase;</span><br><span class="line">boolean j = true;</span><br><span class="line">boolean r = i &amp;&amp; j;//判断i为假，不再判断j，直接得出假</span><br></pre></td></tr></table></figure><h2 id="4-break"><a href="#4-break" class="headerlink" title="4. break"></a>4. break</h2><p>面临需要跳出嵌套循环的情况时，break语句可以跳出指定的循环，可以通过标号来完成。但是就像要避免使用 goto 一样，应该避免使用带标签的 break。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A:for (int x = 0; x&lt;3; x++) &#123;</span><br><span class="line">    B:for (int y=0; y&lt;3; y++) &#123;</span><br><span class="line">    System.out.println(&quot;x&quot; + x);</span><br><span class="line">        break A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-continue"><a href="#5-continue" class="headerlink" title="5. continue"></a>5. continue</h2><p>continue可以提前结束循环，继续下次循环（可以通过标号指定某一循环）。同样应该避免使用带标签的continue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A:for (int x = 0; x&lt;3; x++) &#123;</span><br><span class="line">    B:for (int y=0; y&lt;3; y++) &#123;</span><br><span class="line">    System.out.println(&quot;x&quot; + x);</span><br><span class="line">        continue A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：事实上，可以将标签应用到任何语句中，甚至可以应用到 if 语句或者块语句中，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">dis:<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"跳出if语句"</span>);</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span> dis;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"==== "</span> + i);</span><br><span class="line">dis:System.out.println(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><h2 id="6-switch"><a href="#6-switch" class="headerlink" title="6. switch"></a>6. switch</h2><p>支持数据类型：</p><ul><li>char、byte、short或int的常量表达式</li><li>枚举常量</li><li>从Java SE 7开始，case标签还可以是字符串字面量</li></ul><p>与if语句的比较：<br>if语句：</p><ol><li>对具体的值进行判断</li><li>对区间进行判断</li><li>对运算结果是boolean类型的表达式进行判断</li></ol><p>switch语句：</p><ol><li>对具体的值进行判断（对于几个固定值的判断，建议使用switch语句，因为switch语句会将具体的要判断的值都加载进内存中，效率相对高一些）</li><li>值的个数通常是固定的</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instanceof运算符</title>
      <link href="/2020/01/05/instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2020/01/05/instanceof%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>java 中的instanceof 运算符是用来在运行时指出对象是否是特定类的一个实例。instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。</p><a id="more"></a><h5 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h5><pre><code>boolean result = object instanceof class</code></pre><h5 id="2-说明"><a href="#2-说明" class="headerlink" title="2. 说明"></a>2. 说明</h5><p>如果 object 是 class 的一个实例，则 instanceof 运算符返回 true。如果 object 不是指定类的一个实例，或者 object 是 null，则编译出错。<strong>class可以是object对象的父类，自身类，子类，当class是object对象的子类时返回false。</strong></p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person类构造函数加载了。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tom</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Tom类构造函数加载了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Tom tom = <span class="keyword">new</span> Tom(); </span><br><span class="line">        System.out.println(p <span class="keyword">instanceof</span> Tom); <span class="comment">//false</span></span><br><span class="line">        System.out.println(tom <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//System.out.println(p instanceof Object);//编译出错</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><pre><code>Person类构造函数加载了。。Person类构造函数加载了。。Tom类构造函数加载了falsetrue</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==与equals方法</title>
      <link href="/2020/01/05/%E4%B8%8Eequals%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/05/%E4%B8%8Eequals%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1. =="></a>1. ==</h2><ol><li>对于基础数据类型，如int,float,double类型的值，==比较的是值是否相等。</li><li>对于引用数据类型，如自定义类实例，String类实例，其比较的是对象实例的地址。</li></ol><a id="more"></a><h2 id="2-equals方法"><a href="#2-equals方法" class="headerlink" title="2. equals方法"></a>2. equals方法</h2><h3 id="2-1-Object类的equals方法"><a href="#2-1-Object类的equals方法" class="headerlink" title="2.1 Object类的equals方法"></a>2.1 Object类的equals方法</h3><p>Object类中的equals方法用于检测一个对象是否等于另一个对象，默认情况下其比较的是两个对象的哈希值，也就是判断两个对象是否具有相同的引用（地址）。</p><h3 id="2-2-Objects类的equals方法"><a href="#2-2-Objects类的equals方法" class="headerlink" title="2.2 Objects类的equals方法"></a>2.2 Objects类的equals方法</h3><ol><li>static boolean equals(Object a, Object b)<blockquote><p>如果a和b都为空，返回真；如果只有其中之一为空，则返回假；否则返回a.equals(b);     避免了使用a.equals(b)且a为空时产生的空指针异常。</p></blockquote></li></ol><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package equalstest;</span><br><span class="line"></span><br><span class="line">import java.util.Objects;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String a = new String(&quot;abc&quot;);</span><br><span class="line">        String b = new String(&quot;abc&quot;);</span><br><span class="line">        System.out.println(Objects.equals(a, b)); //true</span><br><span class="line">        a = null;</span><br><span class="line">        System.out.println(Objects.equals(a, b));//false</span><br><span class="line">        b = null;</span><br><span class="line">        System.out.println(Objects.equals(a, b));//true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>static boolean deepEquals(Object a, Object b)<blockquote><p>如果对象a和b不是数组的话，则会比较两个对象的地址，否则会比较两个数组对应角标的元素的值（底层使用的Arrays.deepEquals0(Object a, Object b)）。比较自定义对象数组时需覆盖equlas方法，否则比较的还是地址。</p></blockquote></li></ol><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static void equalsTest() &#123;</span><br><span class="line">    int[] numArr1 = &#123;45,45,656,78,998,12,30,45&#125;;</span><br><span class="line">    int[] numArr2 = &#123;45,45,656,78,998,12,30,45&#125;;</span><br><span class="line">    System.out.println(Objects.deepEquals(numArr1, numArr2)); //true</span><br><span class="line"></span><br><span class="line">    String s1 = new String(&quot;a&quot;);</span><br><span class="line">    String s2 = new String(&quot;b&quot;);</span><br><span class="line">    String[] sArr = &#123;s1, s2&#125;;</span><br><span class="line">    String c1 = new String(&quot;a&quot;);</span><br><span class="line">    String c2 = new String(&quot;b&quot;);</span><br><span class="line">    String[] cArr = &#123;c1, c2&#125;;</span><br><span class="line">    System.out.println(Objects.deepEquals(sArr, cArr));//true</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>equals方法与hashcode方法</title>
      <link href="/2020/01/05/equals%E6%96%B9%E6%B3%95%E4%B8%8Ehashcode%E6%96%B9%E6%B3%95/"/>
      <url>/2020/01/05/equals%E6%96%B9%E6%B3%95%E4%B8%8Ehashcode%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>在Java中，equals方法和hashcode方法都是用来对比两个对象是否相等。</li><li>默认情况下equals比较的是两个对象的哈希码，hashcode则负责获取引用对象的哈希码。一般情况下，在覆盖equals方法时，同时也要覆盖hashcode方法。</li><li>不同对象可能有相同的哈希码，因为自身算法的原因，所以当a.equals(b) == true（对象值相同）时，两个对象一定相等，但是如果两个对象的哈希码相等却不能断定两个对象是相等的。</li></ul><a id="more"></a><hr><p><strong>equals和hashcode的使用在集合框架Set中有体现：</strong></p><ul><li>将对象放入到集合中时，首先判断要放入对象的hashCode值与集合中的任意一个元素的hashCode值是否相等。</li><li>如果不相等直接将该对象放入集合中。如果hashCode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。</li></ul><p>具体流程如下图所示：<br><img src="/2020/01/05/equals方法与hashcode方法/20181225162219337.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重载(overload)与重写(override)的区别</title>
      <link href="/2020/01/05/%E9%87%8D%E8%BD%BD-overload-%E4%B8%8E%E9%87%8D%E5%86%99-override-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2020/01/05/%E9%87%8D%E8%BD%BD-overload-%E4%B8%8E%E9%87%8D%E5%86%99-override-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>重载与重写的区别：</p><ul><li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li><li>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</li><li>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求。</li></ul><a id="more"></a><p>方法重载的规则：</p><ol><li>方法名一致，参数列表中参数的顺序，类型，个数不同。</li><li>重载与方法的返回值无关，存在于父类和子类， 同类中。</li><li>可以抛出不同的异常，可以有不同修饰符。</li></ol><p>方法重写的规则：</p><ol><li>参数列表必须完全与被重写方法一致，返回类型必须完全与被重写方法的返回类型一致。</li><li>构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次声明。</li><li>访问权限不能比父类中被重写的方法的访问权限更低。</li><li>重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li></ol><hr><p>为什么函数不能根据返回类型来区分重载？<br>因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float max(int a, int b);</span><br><span class="line">int max(int a, int b);</span><br></pre></td></tr></table></figure><p>当调用 max(1, 2);时无法确定调用的是哪个，单从这一点上来说，仅返回值类型不同的重载是不应该允许的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之反射（reflection）</title>
      <link href="/2020/01/05/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%EF%BC%88reflection%EF%BC%89/"/>
      <url>/2020/01/05/Java%E4%B9%8B%E5%8F%8D%E5%B0%84%EF%BC%88reflection%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>反射是后续web框架学习的基础！</strong></p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><blockquote><p>Java的反射机制是在运行状态中，对于任意一个类（class文件），都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取信息以及动态调用对象的方法的功能称为Java语言的反射机制。亦即动态获取类中的信息，可以理解为对类的解剖。</p></blockquote><a id="more"></a><h2 id="2-Class类"><a href="#2-Class类" class="headerlink" title="2. Class类"></a>2. Class类</h2><blockquote><p>在程序运行期间，Java运行时始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类，保存这些信息的类被称为Class。</p></blockquote><h3 id="2-1-Class对象的获取"><a href="#2-1-Class对象的获取" class="headerlink" title="2.1 Class对象的获取"></a>2.1 Class对象的获取</h3><pre><code>Random r = new Random();Class clazz = r.getClass();-------------------------------------------String className = &quot;java.util.Random&quot;;Class clazz = Class.forName(className);-------------------------------------------Class clazz = Random.class;  //if you import java.util.*;</code></pre><h3 id="2-2-Class类的相关方法"><a href="#2-2-Class类的相关方法" class="headerlink" title="2.2 Class类的相关方法:"></a>2.2 Class类的相关方法:</h3><ul><li><p>public String getName();    获取Class对象的类名。</p><p> 示例：</p><pre><code>Random r = new Random();Class clazz = r.getClass();String name = clazz.getName();    //name is set to &quot;java.util.Random&quot;</code></pre></li><li><p>public Object newInstance();    //返回这个类的一个新实例（构造方法为空参）。</p><pre><code> 示例：String s = &quot;java.util.Random&quot;;Object obj = Class.forName(s).newInstance();Random r = (Random)obj;</code></pre></li></ul><h2 id="3-Field类"><a href="#3-Field类" class="headerlink" title="3. Field类"></a>3. Field类</h2><blockquote><p>该类用于描述类的属性（域）</p></blockquote><h3 id="3-1-Field对象的获取"><a href="#3-1-Field对象的获取" class="headerlink" title="3.1 Field对象的获取"></a>3.1 Field对象的获取</h3><ul><li>Filed[] getFields();    <blockquote><p>返回一个包含Field对象的数组，这些对象记录了这个类或其超类的公有域。</p></blockquote></li><li>Field[] getDeclaredFields();<blockquote><p>返回一个包含Field对象的数组，这些对象记录了这个类的全部域</p></blockquote></li><li>Filed getFiled(String name);<blockquote><p>获取指定名称的公有域</p></blockquote></li></ul><h3 id="3-2-Filed类的相关方法"><a href="#3-2-Filed类的相关方法" class="headerlink" title="3.2 Filed类的相关方法"></a>3.2 Filed类的相关方法</h3><ul><li>Class getType();    <blockquote><p>返回Filed对象的类型所对应的Class对象。比如有属性定义：String name = “zzz”;那么该方法返回的即为字符串name所对应的Class对象。</p></blockquote></li><li>int getModifiers();<blockquote><p>返回一个用于描述构造器、方法或域的修饰符的整型数值。可以使用Modifier类中的静态方法toString(int modifilerNum)来显示该数值所对应的修饰符。</p></blockquote></li></ul><h3 id="3-3-Field类的对象域值"><a href="#3-3-Field类的对象域值" class="headerlink" title="3.3 Field类的对象域值"></a>3.3 Field类的对象域值</h3><ul><li>Object get(Object obj);<blockquote><p>返回Object对象中用Field对象表示的域值。如果是类中的属性是基本数据类型则返回对应的包装类。</p></blockquote></li><li>void set(Object obj, Object newValue);<blockquote><p>用一个新值设置Obj对象的中Field对象表示的域</p></blockquote></li><li>void setAccessible(Boolean falg);<blockquote><p>类中的私有属性是不可以通过get(Object obj)方法获取到的。该方法为反射对象设置可访问标志。flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置。</p></blockquote></li><li>static void setAccessible(Fileds[] fields, boolean flag);<blockquote><p>fields为需要设置访问标志的字段对应的Filed对象，该方法时设置对象数组可访问标志的快捷方法。</p></blockquote></li></ul><h2 id="4-Method类"><a href="#4-Method类" class="headerlink" title="4. Method类"></a>4. Method类</h2><h3 id="4-1-Method对象的获取"><a href="#4-1-Method对象的获取" class="headerlink" title="4.1 Method对象的获取"></a>4.1 Method对象的获取</h3><ul><li><p>Method getMethod(String name, Class… parameterTypes);</p><blockquote><p>第一个参数为方法名，第二个参数为该方法的参数的类型</p></blockquote><p>  示例：<br>  比如存在一个类Person，有一个void eat(String foodName);方法。<br>  那么可以使用getMethod方法获取Person类的eat方法的Method对象。<br>  Method eatMethod = Person.class.getMethod(“eat”, String.class);</p></li><li><p>Method getMethod(String name);</p><blockquote><p>通过方法名去获取Method对象。</p></blockquote></li><li><p>Method[] getMethod();</p><blockquote><p>返回所有的公有方法，包括从超类继承来的公有方法。</p></blockquote></li><li><p>Method[] getDeclaredMethod();</p><blockquote><p>返回这个类或接口的全部方法，但不包括由超类继承了的方法。</p></blockquote><h3 id="4-2-Method类的相关方法"><a href="#4-2-Method类的相关方法" class="headerlink" title="4.2 Method类的相关方法"></a>4.2 Method类的相关方法</h3></li><li><p>Class getReturnType();</p><blockquote><p>返回一个用于描述返回类型的Class对象。</p></blockquote></li><li><p>Class[] getParameterTypes();</p><blockquote><p>返回一个用于描述参数类型的Class对象数组。</p></blockquote></li><li><p>Object invoke(Object implictParameter, Object[] explicitParamemters);</p><blockquote><p>调用这个对象所描述的方法，传递给定参数，并返回方法的返回值。第一个参数为调用该方法的对象，第二个参数为该方法需要传入的参数值。对于静态方法。把null作为隐式参数传递。在使用包装器传递基本类型的值时，基本类型的返回值必须是未包装的。</p></blockquote><h2 id="5-Constructor类"><a href="#5-Constructor类" class="headerlink" title="5. Constructor类"></a>5. Constructor类</h2><h3 id="5-1-Constructor对象的获取"><a href="#5-1-Constructor对象的获取" class="headerlink" title="5.1 Constructor对象的获取"></a>5.1 Constructor对象的获取</h3></li><li><p>Constructor[] getConstrcutors();</p><blockquote><p>返回包含Constructor对象的数组，其中包含了Class对象所描述的类的所有<strong>公有</strong>构造器</p></blockquote></li><li><p>Constructor[] getDeclaredConstrcutors();</p><blockquote><p>返回包含Constructor对象的数组，其中包含了Class对象所描述的类的所有构造器</p></blockquote><h3 id="5-2-Constructor类的相关方法"><a href="#5-2-Constructor类的相关方法" class="headerlink" title="5.2 Constructor类的相关方法"></a>5.2 Constructor类的相关方法</h3></li><li><p>Object newInstance(Object[] args);</p></li></ul><blockquote><p>构造一个这个构造器所属类的新实例。数组参数若有基本数据类型，需传入对应的包装类。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常</title>
      <link href="/2020/01/05/Java%E5%BC%82%E5%B8%B8/"/>
      <url>/2020/01/05/Java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java异常的分类和类结构图"><a href="#1-Java异常的分类和类结构图" class="headerlink" title="1. Java异常的分类和类结构图"></a>1. Java异常的分类和类结构图</h2><p>Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。</p><p>Throwable又派生出Error类和Exception类。</p><p>错误：Error类以及他的子类的实例，代表了JVM本身的错误。错误不能被程序员通过代码处理，Error很少出现。因此，程序员应该关注Exception为父类的分支下的各种异常类。</p><a id="more"></a><p>异常：Exception以及他的子类，代表程序运行时发送的各种不期望发生的事件。可以被Java异常处理机制使用，是异常处理的核心。<br><img src="/2020/01/05/Java异常/20190108105233836.png" alt="在这里插入图片描述"><br>总体上我们根据Javac对异常的处理要求，将异常类分为2类。</p><p><strong>非检查异常（unckecked exception）</strong>： <strong>Error 和 RuntimeException 以及他们的子类。</strong> javac在编译时，不会提示和发现这样的异常，不要求在程序处理这些异常。所以如果愿意，我们可以编写代码处理（使用try…catch…finally）这样的异常，也可以不处理。对于这些异常，我们应该修正代码，而不是去通过异常处理器处理 。这样的异常发生的原因多半是代码写的有问题。如除0错误ArithmeticException，错误的强制类型转换错误ClassCastException，数组索引越界ArrayIndexOutOfBoundsException，使用了空对象NullPointerException等等。</p><p><strong>检查异常（checked exception）</strong>：<strong>除了Error 和 RuntimeException的其它异常。</strong> javac强制要求程序员为这样的异常做预备处理工作（使用try…catch…finally或者throws）。在方法中要么用try-catch语句捕获它并处理，要么用throws子句声明抛出它，否则编译不会通过。这样的异常一般是由程序的运行环境导致的。因为程序可能被运行在各种未知的环境下，而程序员无法干预用户如何使用他编写的程序，于是程序员就应该为这样的异常时刻准备着。如SQLException , IOException,ClassNotFoundException 等。</p><h2 id="2-自定义异常类"><a href="#2-自定义异常类" class="headerlink" title="2. 自定义异常类"></a>2. 自定义异常类</h2><p>如果要自定义异常类，则扩展Exception类即可，因此这样的自定义异常都属于检查异常（checked exception）。如果要自定义非检查异常，则扩展自RuntimeException。</p><p>按照国际惯例，自定义的异常应该总是包含如下的构造函数：</p><ul><li>一个无参构造函数</li><li>一个带有String参数的构造函数，并传递给父类的构造函数。</li><li>一个带有String参数和Throwable参数，并都传递给父类构造函数</li><li>一个带有Throwable 参数的构造函数，并传递给父类的构造函数。</li></ul><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7818375828146090155L</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">(String message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">(String message, Throwable cause)</span> <span class="comment">// cause代表引起该异常(this)的异常对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IOException</span><span class="params">(Throwable cause)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-异常的抛出"><a href="#3-异常的抛出" class="headerlink" title="3. 异常的抛出"></a>3. 异常的抛出</h2><p>throw:</p><ol><li>throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。</li><li>throw 是具体向外抛出异常的动作，所以它抛出的是一个异常实例，执行 throw 一定是抛出了某种异常。</li></ol><p>throws:</p><ol><li>throws 语句是用在方法声明后面，表示如果抛出异常，由该方法的调用者来进行异常的处理。</li><li>throws 主要是声明这个方法会抛出某种类型的异常，让它的使用者要知道需要捕获的异常的类型。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这种异常</li></ol><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">readData</span><span class="params">(Scanner in)</span> <span class="keyword">throws</span> EOFException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!in.hasNext())  &#123; <span class="comment">//EOF encountered </span></span><br><span class="line">            <span class="keyword">if</span> (n &lt; len)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EOFException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>子类在覆盖父类方法时，父类的方法如果抛出了异常，那么子类的方法只能抛出父类方法的异常或该异常的子类；</li><li>如果父类抛出多个异常，那么子类只能抛出父类异常的子集。简单说就是子类覆盖父类的方法只能抛出父类的异常或子类或子集。</li><li>如果父类的方法没有抛出异常，那么子类覆盖时绝对不能抛出异常而只能捕获。</li></ul><h3 id="3-1-再次抛出异常"><a href="#3-1-再次抛出异常" class="headerlink" title="3.1 再次抛出异常"></a>3.1 再次抛出异常</h3><blockquote><p>在catch子句中可以抛出一个异常，这样做的目的是改变是异常的类型。</p></blockquote><ol><li><p>普通的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> MyException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用异常封装的方式（建议）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Throwable se = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">10</span>/<span class="number">0</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            se = <span class="keyword">new</span> MyException(<span class="string">"除0异常信息封装！"</span>);</span><br><span class="line">            se.initCause(ex);</span><br><span class="line">            <span class="keyword">throw</span> se;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyDemo mydemo = <span class="keyword">new</span> MyDemo();</span><br><span class="line">            mydemo.count();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">//在这里可以获取原始异常，即count方法里产生的除0异常</span></span><br><span class="line">            Throwable e = se.getCause();</span><br><span class="line">            System.out.println(e.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义异常类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ArithmeticException</span><br></pre></td></tr></table></figure><p>使用异常包装技术，这样可以让用户抛出子系统中的高级异常而不会丢失原始异常的细节。</p><p>如果在一个方法中发生了一个受查异常，而不允许抛出它，那么包装技术就十分有用。我们可以捕获这个受查异常，并将它包装成一个运行时异常。</p><h2 id="4-异常捕获"><a href="#4-异常捕获" class="headerlink" title="4. 异常捕获"></a>4. 异常捕获</h2><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-多重捕获"><a href="#4-1-多重捕获" class="headerlink" title="4.1 多重捕获"></a>4.1 多重捕获</h3><blockquote><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p></blockquote><p>多重捕获块的语法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码段包含了 3 个 catch块。</p><p>可以在 try 语句后面添加任意数量的 catch 块。</p><p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p><p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p><p>如果不匹配，它会被传递给第二个 catch 块。</p><p>如此，直到异常被捕获或者通过所有的 catch 块。</p><p><strong>注意：</strong> 多catch块时，捕获父类异常的catch放在最下面。</p><h3 id="4-2-多重捕获的另一种形式"><a href="#4-2-多重捕获的另一种形式" class="headerlink" title="4.2 多重捕获的另一种形式"></a>4.2 多重捕获的另一种形式</h3><p>在Java SE 7 中，同一个catch子句中可以捕获多个异常类型。例如，假设对应缺少文件和未知主机异常的动作是一样的，就可以合并cacth子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException | UnknowHostException ex) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：只有当捕获的异常类型彼此之间<strong>不存在子类关系</strong>时才需要这个特性，即才能合并多catch块。</p><h2 id="5-finally子句"><a href="#5-finally子句" class="headerlink" title="5. finally子句"></a>5. finally子句</h2><p>finally 关键字用来创建在 try 代码块后面执行的代码块。<br>无论是否发生异常，finally 代码块中的代码总会被执行。<br>通常用来关闭（释放）资源，如流的关闭等。<br>finally 代码块出现在 catch 代码块最后，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提示：建议使用解耦合try/catch和try/finally语句块。这样可以提高代码的清晰度。代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//code that might throw exceptions</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//show error message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内层的try语句块只有一个职责，就是确保关闭输入流。外层的try语句块也只有一个职责功能，就是确保报告出现的错误。这种设计方式不仅清楚，而且还具有一个功能，就是将会报告finally子句中出现的错误。</p><h3 id="5-1-finally子句包含return语句"><a href="#5-1-finally子句包含return语句" class="headerlink" title="5.1 finally子句包含return语句"></a>5.1 finally子句包含return语句</h3><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行上述代码时，try语句会发生错误从而执行catch块中的语句。在执行retrun 2;这条语句时，发现有finally语句块所以从而去执行finally语句块中的内容，执行了return 3;后该方法就结束了。如果finally语句中不是return语句而是其他逻辑操作，则在执行完finally语句中的内容之后会回来返回执行catch中的内容，即返回2。</p><h2 id="6-带资源的try语句"><a href="#6-带资源的try语句" class="headerlink" title="6. 带资源的try语句"></a>6. 带资源的try语句</h2><p>假设有这种情况的发生：假设在try语句块中代码抛出了一些非IOException异常，这些异常只有这个方法的调用者才能够给予处理。执行finally语句块，并调用close方法。而close方法本身也有可能抛出IOException异常。当这种情况发生时，原始的异常将会丢失，转而抛出close方法的异常。</p><p>普通解决方法代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = ...;</span><br><span class="line">Exception ex = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//code that might throw exceptions</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ex = e;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex == <span class="keyword">null</span>) <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法会使代码变得极其繁琐，我们使用Java SE 7 的带资源try语句去处理。它允许在try关键字后跟一对圆括号，圆括号可以声明，初始化一个或多个资源，此处的资源指得是那些必须在程序结束时必须关闭的资源（比如数据库连接，网络连接等），try语句在该语句结束时自动关闭这些资源。<br> 为了保证try语句可以正常关闭资源，这些资源实现类必须实现Closeable或AutoCloseable接口，实现这些类就必须实现close方法（一般情况不用自己实现）。</p><p> 代码示例：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream in = ...; PrintWriter out = ...) &#123;</span><br><span class="line">    <span class="comment">//程序代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//程序代码，不用自己关闭流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Number，Math与大数值</title>
      <link href="/2020/01/05/Number%EF%BC%8CMath%E4%B8%8E%E5%A4%A7%E6%95%B0%E5%80%BC/"/>
      <url>/2020/01/05/Number%EF%BC%8CMath%E4%B8%8E%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Number类"><a href="#1-Number类" class="headerlink" title="1. Number类"></a>1. Number类</h2><h3 id="1-1-Nunber类结构"><a href="#1-1-Nunber类结构" class="headerlink" title="1.1 Nunber类结构"></a>1.1 Nunber类结构</h3><p><img src="/2020/01/05/Number，Math与大数值/20190109133433812.png" alt="在这里插入图片描述"><br>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。</p><a id="more"></a><h3 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h3><p>abstract xxx xxxValue()方法<br>用于将Number类对象转化为xxx数据类型的值并返回。注意，这个方法不接受任何参数，包装类对象调用。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Float a = <span class="number">1.0f</span>;</span><br><span class="line">System.out.println(a.intValue());</span><br><span class="line">System.out.println(a.doubleValue());</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1.0</span><br></pre></td></tr></table></figure><p>底层代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Float&#125; as an &#123;<span class="doctag">@code</span> int&#125; after</span></span><br><span class="line"><span class="comment">     * a narrowing primitive conversion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &#123;<span class="doctag">@code</span> float&#125; value represented by this object</span></span><br><span class="line"><span class="comment">     *          converted to type &#123;<span class="doctag">@code</span> int&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.3 Narrowing Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)value; <span class="comment">//直接强制转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns value of this &#123;<span class="doctag">@code</span> Float&#125; as a &#123;<span class="doctag">@code</span> long&#125; after a</span></span><br><span class="line"><span class="comment">     * narrowing primitive conversion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &#123;<span class="doctag">@code</span> float&#125; value represented by this object</span></span><br><span class="line"><span class="comment">     *          converted to type &#123;<span class="doctag">@code</span> long&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@jls</span> 5.1.3 Narrowing Primitive Conversions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>)value; <span class="comment">//直接强制转换</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="2-Math类"><a href="#2-Math类" class="headerlink" title="2. Math类"></a>2. Math类</h2><h3 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h3><p>static double ceil(double a);</p><blockquote><p>返回大于参数a的最小整数</p></blockquote><p>static double floor(double a);</p><blockquote><p>返回小于参数的最大整数</p></blockquote><p>static long round(double a);</p><blockquote><p>返回四舍五入的整数</p></blockquote><p>static double pow(double a, double b);</p><blockquote><p>返回a的b次方值</p></blockquote><p>static double sqrt(double a);</p><blockquote><p>返回a的平方根值</p></blockquote><p>static double abs(double a);</p><blockquote><p>返回a的绝对值。另外还有适合int，long，float的方法</p></blockquote><p>static double max(double a, double b);</p><blockquote><p>返回a，b之间的数值较大者</p></blockquote><p>static double min(double a, double b);</p><blockquote><p>返回a，b之间的数值较小者</p></blockquote><p>static double random();</p><blockquote><p>返回大于等于0.0且小于1.的double值</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回大于参数的最小整数</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">15.5</span>));</span><br><span class="line">        <span class="comment">//返回小于参数的最大整数</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">15.5</span>));</span><br><span class="line">        <span class="comment">//返回四舍五入的整数</span></span><br><span class="line">        System.out.println(Math.round(-<span class="number">15.5</span>));</span><br><span class="line">        System.out.println(Math.round(<span class="number">15.5</span>));</span><br><span class="line">        <span class="comment">//返回a的b次方值</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">12</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="comment">//返回a的平方根值</span></span><br><span class="line">        System.out.println(Math.sqrt(<span class="number">4</span>));</span><br><span class="line">        <span class="comment">//返回a的绝对值。另外还有适合int，long，float的方法</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">15.5</span>));</span><br><span class="line">        <span class="comment">//返回a，b之间的数值较大者</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">15</span>, <span class="number">45</span>));</span><br><span class="line">        <span class="comment">//返回a，b之间的数值较小者</span></span><br><span class="line">        System.out.println(Math.min(<span class="number">15</span>, <span class="number">45</span>));</span><br><span class="line">        <span class="comment">//返回大于等于0.0且小于1.的double值</span></span><br><span class="line">        System.out.println(Math.random());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">16.0</span><br><span class="line">15.0</span><br><span class="line">-15</span><br><span class="line">16</span><br><span class="line">144.0</span><br><span class="line">2.0</span><br><span class="line">15.5</span><br><span class="line">45</span><br><span class="line">15</span><br><span class="line">0.5322750043361659</span><br></pre></td></tr></table></figure><h2 id="3-大数值"><a href="#3-大数值" class="headerlink" title="3. 大数值"></a>3. 大数值</h2><h3 id="3-1-BigInteger类"><a href="#3-1-BigInteger类" class="headerlink" title="3.1 BigInteger类"></a>3.1 BigInteger类</h3><blockquote><p>BigInteger 支持任意精度的整数，也就是说在运算中 BigInteger 类型可以准确地表示任何大小的整数值而不会丢失任何信息。</p></blockquote><p>常用方法：<br>BigInteger(String val);</p><blockquote><p>构造函数，使用字符串表示的值去实例化一个BigInteger对象</p></blockquote><p>static BigInteger valueOf(long val);</p><blockquote><p>返回一个BigInteger，其值等于指定long的值。</p></blockquote><p>BigInteger add(BigInteger other);<br>BigInteger subtract(BigInteger other);<br>BigInteger multiply(BigInteger other);<br>BigInteger divide(BigInteger other);<br>BigInteger mod(BigInteger other);</p><blockquote><p>返回这个大整数和另一个大整数other的和、差、积、商以及余数。</p></blockquote><p>int compareTo(BigInteger other);</p><blockquote><p>如果这个大整数与另一个大整数other相等，返回0；如果这个大整数小于另一个大整数other，返回-1；否则，返回1。</p></blockquote><h3 id="3-2-BigDecimal类"><a href="#3-2-BigDecimal类" class="headerlink" title="3.2 BigDecimal类"></a>3.2 BigDecimal类</h3><blockquote><p>  BigDecimal 和  BigInteger 都能用来实现大数字的运算，不同的是 BigDecimal 加入了小数的概念。一般的 float 型和 double 型数据只可以用来做科学计算或工程计算，但由于在商业计算中要求数字精度比较高，所以要用到 java.math.BigDecimal 类。 BigDecimal 类支持任何精度的定点数，可以用它来精确计算货币值</p></blockquote><p>重点方法：<br>BigDecomal divide(BigDecimal divisor , int sacle ,int roundingMode);</p><blockquote><p>做除法操作，方法中 3 个参数分别代表除数、商的小数点后的位数、近似处理模式</p></blockquote><p>BigDecimal 类中 divide() 方法的多种处理模式：</p><table><thead><tr><th>模式</th><th>含义</th></tr></thead><tbody><tr><td>BigDecimal.ROUND_UP</td><td>商的最后一位如果大于 0 ，则向前进位，正负数都如此</td></tr><tr><td>BigDecimal .ROUND_DOWN</td><td>商的最后一位无论是什么数字都省略</td></tr><tr><td>BigDecimal .ROUND_CEILING</td><td>商如果是正数，按照 ROUND_UP 模式处理；如果是负数，按照 ROUND_DOWN 模式处理。这种模式的处理都会使近似值大于等于实际值。</td></tr><tr><td>BigDecimal .ROUND_FLOOR</td><td>与 ROUND_CEILING 模式相反，商如果是正数，按照 ROUND_DOWN 模式处理；如果是负数，按照ROUND_UP 模式处理。这种模式的处理都会使近似值小于等于实际值。</td></tr><tr><td>BigDecimal .ROUND_HALF_DOWN</td><td>对商进行四舍五入操作，如果商最后一位小于等于 5，则做舍弃操作；如果最后一位大于 5 ，则做进位操作，如 7.5 ≈ 7</td></tr><tr><td>BigDecimal ROUND_HALF_EVEN</td><td>如果商的倒数第二位为奇数，则按照 ROUND_HALF_UP 处理；如果为偶数，则按照 ROUND_HALF_DOWN 处理，如 7.5 ≈ 8 , 8.5 ≈ 8</td></tr><tr><td>BigDecimal .ROUND_HALF_UP</td><td>对商进行四舍五入操作，如果商的最后一位小于 5 则舍弃；如果大于等于 5 ，进行进位操作，如 7.5 ≈ 8</td></tr></tbody></table><p>代码示例（使用BigDecimal .ROUND_HALF_UP处理模式）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testBigDecimalDicide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BigDecimal num = <span class="keyword">new</span> BigDecimal(<span class="number">16.0</span>);</span><br><span class="line">    BigDecimal other = <span class="keyword">new</span> BigDecimal(<span class="number">5.1</span>);</span><br><span class="line">    <span class="comment">//进行除法运算</span></span><br><span class="line">    BigDecimal result = num.divide(other, <span class="number">10</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.1372549020</span><br></pre></td></tr></table></figure><p>参看文章：<a href="https://blog.csdn.net/js940814/article/details/80210456" target="_blank" rel="noopener">https://blog.csdn.net/js940814/article/details/80210456</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String、StringBuilder和StringBuffer</title>
      <link href="/2020/01/05/String%E3%80%81StringBuilder%E5%92%8CStringBuffer/"/>
      <url>/2020/01/05/String%E3%80%81StringBuilder%E5%92%8CStringBuffer/</url>
      
        <content type="html"><![CDATA[<p>String类，StringBuilder和StringBuffer类有许多相似之处，对于其中的异同之处需仔细琢磨。</p><h2 id="1-性质"><a href="#1-性质" class="headerlink" title="1. 性质"></a>1. 性质</h2><ul><li><p>String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。 初学者可能会有这样的误解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = “abc”；</span><br><span class="line">str = “bcd”;</span><br></pre></td></tr></table></figure><p>如上，字符串 str 明明是可以改变的呀！其实不然， str 仅仅是一个引用对象，它指向一个字符串对象“abc”。第二行代码的含义是让 str 重新指向了一个新的字符串“bcd”对象，而“abc”对象并没有任何改变，只不过该对象已经成为一个不可及对象罢了。</p></li><li><p>StringBuffer/StringBuilder表示的字符串对象可以直接进行修改。其中StringBuilder 是 Java5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方法都没有被 synchronized 修饰，<strong>因此它的效率理论上比StringBuffer 要高</strong> </p></li></ul><a id="more"></a><h2 id="2-字符串拼接"><a href="#2-字符串拼接" class="headerlink" title="2. 字符串拼接"></a>2. 字符串拼接</h2><p>String类提供了字符串之间的拼接符号“+”，可以用来字符串之间的拼接。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span> + <span class="string">"123"</span>;</span><br></pre></td></tr></table></figure><p>当然，StringBuilder类也提供用于字符串拼接的方法append。</p><p>下面我们来研究“+”与append方法之间异同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">        String ss = <span class="string">"ok"</span> + s + <span class="string">"xyz"</span> + <span class="number">5</span>;</span><br><span class="line">        System.out.println(ss);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Jad根据进行反编译的结果如下（命令：jad -o -a -s d.java MyDemo.class）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) annotate </span></span><br><span class="line"><span class="comment">// Source File Name:   MyDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//    0    0:aload_0         </span></span><br><span class="line">    <span class="comment">//    1    1:invokespecial   #1   &lt;Method void Object()&gt;</span></span><br><span class="line">    <span class="comment">//    2    4:return          </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="comment">//    0    0:ldc1            #2   &lt;String "abc"&gt;</span></span><br><span class="line">    <span class="comment">//    1    2:astore_1        </span></span><br><span class="line">        String s1 = (<span class="keyword">new</span> StringBuilder()).append(<span class="string">"ok"</span>).append(s).append(<span class="string">"xyz"</span>).append(<span class="number">5</span>).toString();</span><br><span class="line">    <span class="comment">//    2    3:new             #3   &lt;Class StringBuilder&gt;</span></span><br><span class="line">    <span class="comment">//    3    6:dup             </span></span><br><span class="line">    <span class="comment">//    4    7:invokespecial   #4   &lt;Method void StringBuilder()&gt;</span></span><br><span class="line">    <span class="comment">//    5   10:ldc1            #5   &lt;String "ok"&gt;</span></span><br><span class="line">    <span class="comment">//    6   12:invokevirtual   #6   &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//    7   15:aload_1         </span></span><br><span class="line">    <span class="comment">//    8   16:invokevirtual   #6   &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//    9   19:ldc1            #7   &lt;String "xyz"&gt;</span></span><br><span class="line">    <span class="comment">//   10   21:invokevirtual   #6   &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//   11   24:iconst_5        </span></span><br><span class="line">    <span class="comment">//   12   25:invokevirtual   #8   &lt;Method StringBuilder StringBuilder.append(int)&gt;</span></span><br><span class="line">    <span class="comment">//   13   28:invokevirtual   #9   &lt;Method String StringBuilder.toString()&gt;</span></span><br><span class="line">    <span class="comment">//   14   31:astore_2        </span></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">    <span class="comment">//   15   32:getstatic       #10  &lt;Field PrintStream System.out&gt;</span></span><br><span class="line">    <span class="comment">//   16   35:aload_2         </span></span><br><span class="line">    <span class="comment">//   17   36:invokevirtual   #11  &lt;Method void PrintStream.println(String)&gt;</span></span><br><span class="line">    <span class="comment">//   18   39:return          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码很容易看出，虽然在源程序中使用了”+”，但在编译时仍然将”+”转换成 StringBuilder。因此，我们可以得出结论， 在 Java 中无论使用何种方式进行字符串连接，实际上都使用的是 StringBuilder。</p><p>那么是不是可以根据这个结论推出使用”+”和 StringBuilder 的效果是一样的呢？这个要从两个方面的解释。如果从运行结果来解释，那么”+”和 StringBuilder 是完全等效的。但如果从<strong>运行效率和资源消耗</strong>方面看，那它们将存在很大的区别。<br>当然，如果连接字符串行表达式很简单（如上面的顺序结构），那么”+”和 StringBuilder 基本是一样的，但如果结构比较复杂，如使用循环来连接字符串，那么产生的 Java Byte Code 就会有很大的区别。先让我们看看如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            s = s + rand.nextInt(<span class="number">1000</span>) + <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) annotate </span></span><br><span class="line"><span class="comment">// Source File Name:   MyDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//    0    0:aload_0         </span></span><br><span class="line">    <span class="comment">//    1    1:invokespecial   #1   &lt;Method void Object()&gt;</span></span><br><span class="line">    <span class="comment">//    2    4:return          </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//    0    0:ldc1            #2   &lt;String ""&gt;</span></span><br><span class="line">    <span class="comment">//    1    2:astore_1        </span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">//    2    3:new             #3   &lt;Class Random&gt;</span></span><br><span class="line">    <span class="comment">//    3    6:dup             </span></span><br><span class="line">    <span class="comment">//    4    7:invokespecial   #4   &lt;Method void Random()&gt;</span></span><br><span class="line">    <span class="comment">//    5   10:astore_2        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="comment">//*   6   11:iconst_0        </span></span><br><span class="line">    <span class="comment">//*   7   12:istore_3        </span></span><br><span class="line">    <span class="comment">//*   8   13:iload_3         </span></span><br><span class="line">    <span class="comment">//*   9   14:bipush          10</span></span><br><span class="line">    <span class="comment">//*  10   16:icmpge          55</span></span><br><span class="line">            s = (<span class="keyword">new</span> StringBuilder()).append(s).append(random.nextInt(<span class="number">1000</span>)).append(<span class="string">" "</span>).toString();</span><br><span class="line">    <span class="comment">//   11   19:new             #5   &lt;Class StringBuilder&gt;</span></span><br><span class="line">    <span class="comment">//   12   22:dup             </span></span><br><span class="line">    <span class="comment">//   13   23:invokespecial   #6   &lt;Method void StringBuilder()&gt;</span></span><br><span class="line">    <span class="comment">//   14   26:aload_1         </span></span><br><span class="line">    <span class="comment">//   15   27:invokevirtual   #7   &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//   16   30:aload_2         </span></span><br><span class="line">    <span class="comment">//   17   31:sipush          1000</span></span><br><span class="line">    <span class="comment">//   18   34:invokevirtual   #8   &lt;Method int Random.nextInt(int)&gt;</span></span><br><span class="line">    <span class="comment">//   19   37:invokevirtual   #9   &lt;Method StringBuilder StringBuilder.append(int)&gt;</span></span><br><span class="line">    <span class="comment">//   20   40:ldc1            #10  &lt;String " "&gt;</span></span><br><span class="line">    <span class="comment">//   21   42:invokevirtual   #7   &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//   22   45:invokevirtual   #11  &lt;Method String StringBuilder.toString()&gt;</span></span><br><span class="line">    <span class="comment">//   23   48:astore_1        </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   24   49:iinc            3  1</span></span><br><span class="line">    <span class="comment">//*  25   52:goto            13</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">    <span class="comment">//   26   55:getstatic       #12  &lt;Field PrintStream System.out&gt;</span></span><br><span class="line">    <span class="comment">//   27   58:aload_1         </span></span><br><span class="line">    <span class="comment">//   28   59:invokevirtual   #13  &lt;Method void PrintStream.println(String)&gt;</span></span><br><span class="line">    <span class="comment">//   29   62:return          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，虽然编译器将”+”转换成了 StringBuilder，但创建 StringBuilder 对象的位置却在 for 语句内部。这就意味着每执行一次循环，就会创建一个 StringBuilder 对象（对于本例来说，是创建了 10 个 StringBuilder对象），虽然 Java 有垃圾回收器，但这个回收器的工作时间是不定的。如果不断产生这样的垃圾，那么仍然会占用大量的资源。</p><p>推荐使用如下方式编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           result.append(rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">           result.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译的结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) annotate </span></span><br><span class="line"><span class="comment">// Source File Name:   MyDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//    0    0:aload_0         </span></span><br><span class="line">    <span class="comment">//    1    1:invokespecial   #1   &lt;Method void Object()&gt;</span></span><br><span class="line">    <span class="comment">//    2    4:return          </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//    0    0:ldc1            #2   &lt;String ""&gt;</span></span><br><span class="line">    <span class="comment">//    1    2:astore_1        </span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">//    2    3:new             #3   &lt;Class Random&gt;</span></span><br><span class="line">    <span class="comment">//    3    6:dup             </span></span><br><span class="line">    <span class="comment">//    4    7:invokespecial   #4   &lt;Method void Random()&gt;</span></span><br><span class="line">    <span class="comment">//    5   10:astore_2        </span></span><br><span class="line">        StringBuilder stringbuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//    6   11:new             #5   &lt;Class StringBuilder&gt;</span></span><br><span class="line">    <span class="comment">//    7   14:dup             </span></span><br><span class="line">    <span class="comment">//    8   15:invokespecial   #6   &lt;Method void StringBuilder()&gt;</span></span><br><span class="line">    <span class="comment">//    9   18:astore_3        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="comment">//*  10   19:iconst_0        </span></span><br><span class="line">    <span class="comment">//*  11   20:istore          4</span></span><br><span class="line">    <span class="comment">//*  12   22:iload           4</span></span><br><span class="line">    <span class="comment">//*  13   24:bipush          10</span></span><br><span class="line">    <span class="comment">//*  14   26:icmpge          54</span></span><br><span class="line">        &#123;</span><br><span class="line">            stringbuilder.append(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">    <span class="comment">//   15   29:aload_3         </span></span><br><span class="line">    <span class="comment">//   16   30:aload_2         </span></span><br><span class="line">    <span class="comment">//   17   31:sipush          1000</span></span><br><span class="line">    <span class="comment">//   18   34:invokevirtual   #7   &lt;Method int Random.nextInt(int)&gt;</span></span><br><span class="line">    <span class="comment">//   19   37:invokevirtual   #8   &lt;Method StringBuilder StringBuilder.append(int)&gt;</span></span><br><span class="line">    <span class="comment">//   20   40:pop             </span></span><br><span class="line">            stringbuilder.append(<span class="string">" "</span>);</span><br><span class="line">    <span class="comment">//   21   41:aload_3         </span></span><br><span class="line">    <span class="comment">//   22   42:ldc1            #9   &lt;String " "&gt;</span></span><br><span class="line">    <span class="comment">//   23   44:invokevirtual   #10  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//   24   47:pop             </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//   25   48:iinc            4  1</span></span><br><span class="line">    <span class="comment">//*  26   51:goto            22</span></span><br><span class="line">        System.out.println(stringbuilder.toString());</span><br><span class="line">    <span class="comment">//   27   54:getstatic       #11  &lt;Field PrintStream System.out&gt;</span></span><br><span class="line">    <span class="comment">//   28   57:aload_3         </span></span><br><span class="line">    <span class="comment">//   29   58:invokevirtual   #12  &lt;Method String StringBuilder.toString()&gt;</span></span><br><span class="line">    <span class="comment">//   30   61:invokevirtual   #13  &lt;Method void PrintStream.println(String)&gt;</span></span><br><span class="line">    <span class="comment">//   31   64:return          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的反编译结果可以看出，创建 StringBuilder 的代码被放在了 for 语句外。虽然这样处理在源程序中看起来复杂，但却换来了更高的效率，同时消耗的资源也更少了。</p><p>在使用 StringBuilder 时要注意，尽量不要”+”和 StringBuilder 混着用，否则会创建更多的 StringBuilder 对象，如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    result.append(rand.nextInt(<span class="number">1000</span>));</span><br><span class="line">    result.append(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上方的代码改为如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result.append(rand.nextInt(<span class="number">1000</span>) + <span class="string">" "</span>); <span class="comment">// +与append混用</span></span><br></pre></td></tr></table></figure><p>反编译结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></span><br><span class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></span><br><span class="line"><span class="comment">// Decompiler options: packimports(3) annotate </span></span><br><span class="line"><span class="comment">// Source File Name:   MyDemo.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDemo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//    0    0:aload_0         </span></span><br><span class="line">    <span class="comment">//    1    1:invokespecial   #1   &lt;Method void Object()&gt;</span></span><br><span class="line">    <span class="comment">//    2    4:return          </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//    0    0:ldc1            #2   &lt;String ""&gt;</span></span><br><span class="line">    <span class="comment">//    1    2:astore_1        </span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="comment">//    2    3:new             #3   &lt;Class Random&gt;</span></span><br><span class="line">    <span class="comment">//    3    6:dup             </span></span><br><span class="line">    <span class="comment">//    4    7:invokespecial   #4   &lt;Method void Random()&gt;</span></span><br><span class="line">    <span class="comment">//    5   10:astore_2        </span></span><br><span class="line">        StringBuilder stringbuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//    6   11:new             #5   &lt;Class StringBuilder&gt;</span></span><br><span class="line">    <span class="comment">//    7   14:dup             </span></span><br><span class="line">    <span class="comment">//    8   15:invokespecial   #6   &lt;Method void StringBuilder()&gt;</span></span><br><span class="line">    <span class="comment">//    9   18:astore_3        </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    <span class="comment">//*  10   19:iconst_0        </span></span><br><span class="line">    <span class="comment">//*  11   20:istore          4</span></span><br><span class="line">    <span class="comment">//*  12   22:iload           4</span></span><br><span class="line">    <span class="comment">//*  13   24:bipush          10</span></span><br><span class="line">    <span class="comment">//*  14   26:icmpge          65</span></span><br><span class="line">    <span class="comment">// 此处产生StringBuilder对象</span></span><br><span class="line">            stringbuilder.append((<span class="keyword">new</span> StringBuilder()).append(random.nextInt(<span class="number">1000</span>)).append(<span class="string">" "</span>).toString()); </span><br><span class="line">    <span class="comment">//   15   29:aload_3         </span></span><br><span class="line">    <span class="comment">//   16   30:new             #5   &lt;Class StringBuilder&gt;</span></span><br><span class="line">    <span class="comment">//   17   33:dup             </span></span><br><span class="line">    <span class="comment">//   18   34:invokespecial   #6   &lt;Method void StringBuilder()&gt;</span></span><br><span class="line">    <span class="comment">//   19   37:aload_2         </span></span><br><span class="line">    <span class="comment">//   20   38:sipush          1000</span></span><br><span class="line">    <span class="comment">//   21   41:invokevirtual   #7   &lt;Method int Random.nextInt(int)&gt;</span></span><br><span class="line">    <span class="comment">//   22   44:invokevirtual   #8   &lt;Method StringBuilder StringBuilder.append(int)&gt;</span></span><br><span class="line">    <span class="comment">//   23   47:ldc1            #9   &lt;String " "&gt;</span></span><br><span class="line">    <span class="comment">//   24   49:invokevirtual   #10  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//   25   52:invokevirtual   #11  &lt;Method String StringBuilder.toString()&gt;</span></span><br><span class="line">    <span class="comment">//   26   55:invokevirtual   #10  &lt;Method StringBuilder StringBuilder.append(String)&gt;</span></span><br><span class="line">    <span class="comment">//   27   58:pop             </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//   28   59:iinc            4  1</span></span><br><span class="line">    <span class="comment">//*  29   62:goto            22</span></span><br><span class="line">        System.out.println(stringbuilder.toString());</span><br><span class="line">    <span class="comment">//   30   65:getstatic       #12  &lt;Field PrintStream System.out&gt;</span></span><br><span class="line">    <span class="comment">//   31   68:aload_3         </span></span><br><span class="line">    <span class="comment">//   32   69:invokevirtual   #11  &lt;Method String StringBuilder.toString()&gt;</span></span><br><span class="line">    <span class="comment">//   33   72:invokevirtual   #13  &lt;Method void PrintStream.println(String)&gt;</span></span><br><span class="line">    <span class="comment">//   34   75:return          </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出， Java 编译器将”+”编译成了 StringBuilder，这样 for 语句每循环一次，又创建了一个StringBuilder 对象。</p><hr><h2 id="3-String常量池相关"><a href="#3-String常量池相关" class="headerlink" title="3. String常量池相关"></a>3. String常量池相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abc"</span>;<span class="comment">//创建一个字符串对象在字符串常量池中</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>); <span class="comment">//创建两个对象，一个new（存储引用），一个字符串对象在堆内存中。</span></span><br></pre></td></tr></table></figure><p>相关问题：<br><img src="/2020/01/05/String、StringBuilder和StringBuffer/20190109173414371.png" alt="在这里插入图片描述"></p><ol><li>String 对象的 intern（）方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String 对象的 equals 结果是 true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用；</li><li>String s6 = s3 + s4;中的对象s6是在运行期间创建，这条语句所创建的”Programing”字符串作为String对象存储在内存中的一个独立位置。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的日期与时间</title>
      <link href="/2020/01/05/Java%E7%9A%84%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/"/>
      <url>/2020/01/05/Java%E7%9A%84%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Date类"><a href="#1-Date类" class="headerlink" title="1. Date类"></a>1. Date类</h2><h3 id="1-1-对象创建"><a href="#1-1-对象创建" class="headerlink" title="1.1 对象创建"></a>1.1 对象创建</h3><p> 可以通过Date的两个构造函数来实现</p><ol><li>Date( )    获取当前日期和时间的Date对象</li><li>Date(long millisec)    其中的参数是从1970年1月1日起的毫秒数</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 初始化 Date 对象</span></span><br><span class="line">       Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 使用 toString() 函数显示日期时间</span></span><br><span class="line">       System.out.println(date.toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="1-2-常用API"><a href="#1-2-常用API" class="headerlink" title="1.2 常用API"></a>1.2 常用API</h3><p>boolean after(Date date);</p><blockquote><p>若当调用此方法的Date对象在指定日期之后返回true,否则返回false。</p></blockquote><p>boolean before(Date date)</p><blockquote><p>若当调用此方法的Date对象在指定日期之前返回true,否则返回false。</p></blockquote><p>int compareTo(Date date)</p><blockquote><p>比较当调用此方法的Date对象和指定日期。两者相等时候返回0。调用对象在指定日期之前则返回负数。调用对象在指定日期之后则返回正数。</p></blockquote><p>boolean equals(Object date)</p><blockquote><p>当调用此方法的Date对象和指定日期相等时候返回true,否则返回false。</p></blockquote><p>long getTime( )</p><blockquote><p>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</p></blockquote><p>void setTime(long time)</p><blockquote><p>用自1970年1月1日00:00:00 GMT以后time毫秒数设置时间和日期。</p></blockquote><p>String toString( )</p><blockquote><p>把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)。</p></blockquote><h3 id="1-3-日期比较"><a href="#1-3-日期比较" class="headerlink" title="1.3 日期比较"></a>1.3 日期比较</h3><p>Java使用以下三种方法来比较两个日期：</p><ul><li>使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。</li><li>使用方法 before()，after() 和 equals()。</li><li>使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        Date d2 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//使用毫秒值来比较大小</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = (d2.getTime() - d1.getTime())&gt;<span class="number">0</span> ? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"d2比d1大吗？"</span> + flag); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//使用before来比较大小</span></span><br><span class="line">        System.out.println(<span class="string">"d2比d1大吗？"</span> + d2.after(d1)); <span class="comment">//true</span></span><br><span class="line">        <span class="comment">//使用compareTo方法来比较</span></span><br><span class="line">        <span class="keyword">boolean</span> cFlag = d2.compareTo(d1) &gt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"d2比d1大吗？"</span> + cFlag); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-格式化日期"><a href="#1-4-格式化日期" class="headerlink" title="1.4 格式化日期"></a>1.4 格式化日期</h3><h4 id="1-4-1-使用DateFormat类来格式化日期"><a href="#1-4-1-使用DateFormat类来格式化日期" class="headerlink" title="1.4.1 使用DateFormat类来格式化日期"></a>1.4.1 使用DateFormat类来格式化日期</h4><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">String dateStr = dateFormat.format(date);</span><br><span class="line">System.out.println(dateStr);<span class="comment">//输出为2019年1月10日 星期四</span></span><br></pre></td></tr></table></figure><p>使用该类来格式化日期都是JDK自带的日期格式，DateFormat.FULL为其中一种格式化风格，其他风格可以查看API。</p><h4 id="1-4-2-使用SimpleDateFormat类来格式化日期"><a href="#1-4-2-使用SimpleDateFormat类来格式化日期" class="headerlink" title="1.4.2 使用SimpleDateFormat类来格式化日期"></a>1.4.2 使用SimpleDateFormat类来格式化日期</h4><blockquote><p>SimpleDateFormat是DateFormat的子类，可以<strong>自定义</strong>日期的格式化风格</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleDateFormatDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date dNow = <span class="keyword">new</span> Date( );</span><br><span class="line">    SimpleDateFormat ft = <span class="keyword">new</span> SimpleDateFormat (<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">    System.out.println(<span class="string">"当前时间为: "</span> + ft.format(dNow));</span><br><span class="line">    <span class="comment">//输出为当前时间为: 2019-01-10 10:12:06</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 yyyy 是完整的公元年，MM 是月份，dd 是日期，HH:mm:ss 是时、分、秒。<br>注意:有的格式大写，有的格式小写，例如 MM 是月份，mm 是分；HH 是 24 小时制，而 hh 是 12 小时制。</p><p>具体的日期和时间的格式化编码如下示：<br><img src="/2020/01/05/Java的日期与时间/2019011010171478.png" alt="在这里插入图片描述"></p><h4 id="1-4-3-使用parse方法解析字符串为时间"><a href="#1-4-3-使用parse方法解析字符串为时间" class="headerlink" title="1.4.3 使用parse方法解析字符串为时间"></a>1.4.3 使用parse方法解析字符串为时间</h4><blockquote><p>SimpleDateFormat 类有一些附加的方法，特别是parse()，它试图按照给定的SimpleDateFormat 对象的格式化存储来解析字符串。</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strToDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//按指定格式将字符串转换为Date对象</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        String strDate = <span class="string">"2019-01-11"</span>; </span><br><span class="line">        Date date = simpleDateFormat.parse(strDate);</span><br><span class="line">        <span class="comment">//将Date对象转换其他格式的时间字符串</span></span><br><span class="line">        DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL);</span><br><span class="line">        String newStrDate = dateFormat.format(date);</span><br><span class="line">        System.out.println(newStrDate);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"时间转换错误！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Calendar类"><a href="#2-Calendar类" class="headerlink" title="2. Calendar类"></a>2. Calendar类</h2><p>Date有许多弊端和不足之处，无法满足特定需求。相比于Date，Calendar则强大得多。我们可以使用Calendar类设置和获取日期数据的特定部分，比如说小时，日，或者分钟。</p><h3 id="2-1-Calendar实例获取"><a href="#2-1-Calendar实例获取" class="headerlink" title="2.1 Calendar实例获取"></a>2.1 Calendar实例获取</h3><p>可以使用getInstance方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calendar示例的获取</span></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">String strDate = calendar.getTime().toString();</span><br><span class="line">System.out.println(strDate); <span class="comment">//Thu Jan 10 10:55:19 CST 2019</span></span><br></pre></td></tr></table></figure><h3 id="2-2-Calendar类对象字段类型"><a href="#2-2-Calendar类对象字段类型" class="headerlink" title="2.2 Calendar类对象字段类型"></a>2.2 Calendar类对象字段类型</h3><p><img src="/2020/01/05/Java的日期与时间/20190110110040402.png" alt="在这里插入图片描述"></p><p>特别注意：MONTH月份是从0开始计算的，也就是说0代表一月份，1代表二月份，以此类推；DAY_OF_WEEK规定了一个星期是从星期日开始的，1代表星期日，2代表星期一，以此类推。</p><h4 id="2-2-1-Calendar对象特定部分的获取"><a href="#2-2-1-Calendar对象特定部分的获取" class="headerlink" title="2.2.1 Calendar对象特定部分的获取"></a>2.2.1 Calendar对象特定部分的获取</h4><p>下面是Calendar对象的特定部分进行获取的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1 = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 获得年份</span></span><br><span class="line"><span class="keyword">int</span> year = c1.get(Calendar.YEAR);</span><br><span class="line">System.out.println(<span class="string">"year:"</span> + year);</span><br><span class="line"><span class="comment">// 获得月份</span></span><br><span class="line"><span class="keyword">int</span> month = c1.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">"month:"</span> + month);</span><br><span class="line"><span class="comment">// 获得日期</span></span><br><span class="line"><span class="keyword">int</span> date = c1.get(Calendar.DATE);</span><br><span class="line">System.out.println(<span class="string">"date:"</span> + date);</span><br><span class="line"><span class="comment">// 获得小时</span></span><br><span class="line"><span class="keyword">int</span> hour = c1.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">System.out.println(<span class="string">"hour:"</span> + hour);</span><br><span class="line"><span class="comment">// 获得分钟</span></span><br><span class="line"><span class="keyword">int</span> minute = c1.get(Calendar.MINUTE);</span><br><span class="line">System.out.println(<span class="string">"minute:"</span> + minute);</span><br><span class="line"><span class="comment">// 获得秒</span></span><br><span class="line"><span class="keyword">int</span> second = c1.get(Calendar.SECOND);</span><br><span class="line">System.out.println(<span class="string">"second:"</span> + second);</span><br><span class="line"><span class="comment">// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）</span></span><br><span class="line"><span class="keyword">int</span> day = c1.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">System.out.println(<span class="string">"day:"</span> + day);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">year:2019</span><br><span class="line">month:1</span><br><span class="line">date:10</span><br><span class="line">hour:11</span><br><span class="line">minute:9</span><br><span class="line">second:7</span><br><span class="line">day:5</span><br></pre></td></tr></table></figure><h4 id="2-2-2-Calendar类对象信息的设置"><a href="#2-2-2-Calendar类对象信息的设置" class="headerlink" title="2.2.2 Calendar类对象信息的设置"></a>2.2.2 Calendar类对象信息的设置</h4><p>set设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalendarTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c1 = Calendar.getInstance();</span><br><span class="line">    <span class="comment">//使用set设置日期</span></span><br><span class="line">    c1.set(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">25</span>);</span><br><span class="line">    myPrintln(c1);<span class="comment">//2019-06-25 11:32:01</span></span><br><span class="line">    <span class="comment">//使用set设置字段</span></span><br><span class="line">    <span class="comment">//设置年份</span></span><br><span class="line">    c1.set(Calendar.YEAR, <span class="number">2018</span>); <span class="comment">//2018-06-25 11:32:01</span></span><br><span class="line">    myPrintln(c1);</span><br><span class="line">    <span class="comment">//设置月份</span></span><br><span class="line">    c1.set(Calendar.MONTH, <span class="number">10</span>); <span class="comment">//2018-11-25 11:32:01</span></span><br><span class="line">    myPrintln(c1);</span><br><span class="line">    <span class="comment">//设置日期</span></span><br><span class="line">    c1.set(Calendar.DATE, <span class="number">31</span>);<span class="comment">//2018年11月是没有31号的，时间会重新计算，变成12月1号</span></span><br><span class="line">    myPrintln(c1);<span class="comment">//2018-12-01 11:33:32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPrintln</span><span class="params">(Calendar c1)</span> </span>&#123;</span><br><span class="line">    Date time = c1.getTime();</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">    System.out.println(format.format(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set方法有两种，一种是直接设置日期时间，另一种则是设置日期时间的某一特定部分。<br>注意：在设置月份的时候，如果设置的月份为负数或者大于12，则会对应的更改当前年份。日期和具体时间同理。</p><p>add设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCalendarTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c1 = Calendar.getInstance();</span><br><span class="line">    <span class="comment">//当前日期时间</span></span><br><span class="line">    myPrintln(c1); <span class="comment">//2019-01-10 11:48:53</span></span><br><span class="line">    <span class="comment">//设置月份,月份加了13</span></span><br><span class="line">    c1.add(Calendar.MONTH, <span class="number">13</span>); </span><br><span class="line">    myPrintln(c1);<span class="comment">//2020-02-10 11:40:21</span></span><br><span class="line">    <span class="comment">//设置日期，天数加了23</span></span><br><span class="line">    c1.add(Calendar.DATE, <span class="number">23</span>);</span><br><span class="line">    myPrintln(c1);<span class="comment">//2020-03-04 11:47:19</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPrintln</span><span class="params">(Calendar c1)</span> </span>&#123;</span><br><span class="line">    Date time = c1.getTime();</span><br><span class="line">    SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">    System.out.println(format.format(time));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他字段属性的add的意义以此类推。</p><h2 id="3-GregorianCalendar类"><a href="#3-GregorianCalendar类" class="headerlink" title="3. GregorianCalendar类"></a>3. GregorianCalendar类</h2><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><h3 id="3-1-GregorianCalendar对象的创建"><a href="#3-1-GregorianCalendar对象的创建" class="headerlink" title="3.1 GregorianCalendar对象的创建"></a>3.1 GregorianCalendar对象的创建</h3><p><img src="/2020/01/05/Java的日期与时间/20190110130612234.png" alt="在这里插入图片描述"></p><h3 id="3-2-GregorianCalendar常用方法"><a href="#3-2-GregorianCalendar常用方法" class="headerlink" title="3.2 GregorianCalendar常用方法"></a>3.2 GregorianCalendar常用方法</h3><p>GregorianCalendar类的常用方法主要是使用其父类Calendar的方法。</p><p>下面讲一下其比较特殊常用的方法：</p><p>boolean isLeapYear(int year)；</p><blockquote><p>确定给定的年份是否为闰年。如果给定的年份是闰年，则返回 true。如果要指定 BC 年份，必须给定 1 - 年份。例如，指定 -3 为 BC 4 年</p></blockquote><hr><p>Calendar的功能还不够给力，它的实现是易便的，并且它没有处理诸如闰秒这样的缺。所以Java SE 8中引入的java.time API,它修正了过去的缺陷。</p><p>下面开始讲述关于Java SE 8的一些关于时间日期的新特性，包括java.time.*;包里的Instant，LocalDate，LocalTime 和 LocalDateTime等类。</p><h2 id="4-Instant类"><a href="#4-Instant类" class="headerlink" title="4. Instant类"></a>4. Instant类</h2><p>所谓的 Instant 类代表的是时间线上的某个时间点（有点像 java.util.Date），它是精确到纳秒（而不是像旧版本的Date精确到毫秒），是计算机相关的时间。<br>起点是格林威治时间（GMT）1970-01-01:00:00（实际上Instant 取代原有的 Date 类）。<br>时间从起点开始向前移动，每天为86,400秒。</p><h3 id="4-1-对象创建"><a href="#4-1-对象创建" class="headerlink" title="4.1 对象创建"></a>4.1 对象创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前时间 默认获取 UTC 时区</span></span><br><span class="line">Instant instant = Instant.now();<span class="comment">//2019-01-10T05:41:33.411Z</span></span><br><span class="line"><span class="comment">//给定秒值或毫秒值构建Instant对象</span></span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">1547102726</span>);</span><br><span class="line">Instant instant = Instant.ofEpochMilli(<span class="number">1564564121354544</span>);</span><br></pre></td></tr></table></figure><p>注意：Instant表示的时间是UTC时区的时间，即世界标准时间（比中国时差为-8个小时）</p><h3 id="4-2-获取时间"><a href="#4-2-获取时间" class="headerlink" title="4.2 获取时间"></a>4.2 获取时间</h3><p>Instant 对象中包含两个内部属性用于表示当前的时间：即距离初始时间的秒钟数+在当前一秒内的第几纳秒，他们的组合表达了当前时间点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = Instant.now();</span><br><span class="line"><span class="keyword">long</span> second = instant.getEpochSecond();<span class="comment">//获取秒值</span></span><br><span class="line"><span class="keyword">int</span> nano = instant.getNano();<span class="comment">//获取纳秒值</span></span><br></pre></td></tr></table></figure><h3 id="4-3-Instant的操作"><a href="#4-3-Instant的操作" class="headerlink" title="4.3 Instant的操作"></a>4.3 Instant的操作</h3><p>Instant类与许多用于时间的算术运算方法，比如plusNanos，plusMillis等等。下面仅仅演示plusMillis(long millisToAdd)方法。其他方法可以查看API文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Instant startInstant = Instant.now();</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">Instant endInstant = Instant.now();</span><br><span class="line"></span><br><span class="line">Instant plusMillis = startInstant.plusMillis(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(plusMillis);</span><br><span class="line">System.out.println(endInstant);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-01-10T07:09:00.763Z</span><br><span class="line">2019-01-10T07:09:00.764Z</span><br></pre></td></tr></table></figure><h2 id="5-Duration类"><a href="#5-Duration类" class="headerlink" title="5. Duration类"></a>5. Duration类</h2><p>Duration类用来计算两个时刻之间的时间量</p><h3 id="5-1-常用方法"><a href="#5-1-常用方法" class="headerlink" title="5.1 常用方法"></a>5.1 常用方法</h3><p>static Duration between(Temporal startInclusive,Temporal endExclusive)；</p><blockquote><p>计算两个时间的间隔，默认的单位是秒</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant startInstant = Instant.now();</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">Instant endInstant = Instant.now();</span><br><span class="line"><span class="comment">//两次时间戳之间的时间量</span></span><br><span class="line">Duration duration = Duration.between(startInstant, endInstant);</span><br><span class="line">System.out.println(duration.toMillis());<span class="comment">//输出200毫秒</span></span><br></pre></td></tr></table></figure><p>其他常用方法基本与Instant类一样。</p><p>注意：<strong>Instant和Duration类都是不可修改类</strong>，所以诸如multipliedBy和munus这样的方法都会返回一个新的实例。</p><h2 id="6-LocalDate类"><a href="#6-LocalDate类" class="headerlink" title="6. LocalDate类"></a>6. LocalDate类</h2><p>LocalDate类指的是本地时间，它包含年、月、日的日期，也就是说它不包含时间，只是单纯的年月日。</p><h3 id="6-1-对象的创建"><a href="#6-1-对象的创建" class="headerlink" title="6.1 对象的创建"></a>6.1 对象的创建</h3><p>主要使用now方法和of方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前的日期</span></span><br><span class="line">LocalDate today = LocalDate.now();<span class="comment">//2019-01-11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据年月日取日期</span></span><br><span class="line"><span class="comment">//注意：日期不存在时会发生 java.time.DateTimeException</span></span><br><span class="line">LocalDate crischristmas = LocalDate.of(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">25</span>);<span class="comment">//2017-12-25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据字符串取：</span></span><br><span class="line"><span class="comment">// 严格按照ISO yyyy-MM-dd验证，02写成2都不行，当然也有一个重载方法允许自己定义格式</span></span><br><span class="line">LocalDate endOfFeb = LocalDate.parse(<span class="string">"2014-02-28"</span>); <span class="comment">//2014-02-28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//LocalDate.parse("2014-02-29"); // 无效日期无法通过：DateTimeParseException: Invalid date</span></span><br></pre></td></tr></table></figure><h3 id="6-2-常用日期操作"><a href="#6-2-常用日期操作" class="headerlink" title="6.2 常用日期操作"></a>6.2 常用日期操作</h3><h4 id="6-2-1-加法运算"><a href="#6-2-1-加法运算" class="headerlink" title="6.2.1 加法运算"></a>6.2.1 加法运算</h4><blockquote><p>plusDays，plusWeeks，plusMonths，plusYears，plus等方法<br>即在当前的LocalDate上加上一定量的天、星期、月或年等。</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用加法运算</span></span><br><span class="line">    <span class="comment">//程序员日是每年的第256天，可以通过加上255天来求得当天的日期</span></span><br><span class="line">    LocalDate programmingDay = LocalDate.of(<span class="number">2014</span>, <span class="number">1</span>, <span class="number">1</span>).plusDays(<span class="number">255</span>);</span><br><span class="line">    System.out.println(programmingDay);<span class="comment">//2014-09-13</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//年份加5</span></span><br><span class="line">    LocalDate newYearDay = programmingDay.plusYears(<span class="number">5</span>);</span><br><span class="line">    System.out.println(newYearDay);<span class="comment">//2019-09-13</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//月份加6</span></span><br><span class="line">    LocalDate newMonthDay = newYearDay.plusMonths(<span class="number">6</span>);</span><br><span class="line">    System.out.println(newMonthDay);<span class="comment">//2020-03-13</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道在两个Insatnt之间的时长是Duration，而用于本地时期的等价物是Period，它表示的是流逝的年、月或日的数量。plus方法涉及到该类，下面以代码的方式说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate birthday = LocalDate.of(<span class="number">1997</span>, <span class="number">4</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">//得到下一年的生日</span></span><br><span class="line">LocalDate nextYearBirthday = birthday.plus(Period.ofYears(<span class="number">1</span>));<span class="comment">//和plusYears(1)一样的</span></span><br><span class="line">System.out.println(nextYearBirthday);<span class="comment">//1998-04-19</span></span><br></pre></td></tr></table></figure><p>日期的<strong>减法运算</strong>和加法运算基本运算，不过多说明。</p><h4 id="6-2-2-util方法"><a href="#6-2-2-util方法" class="headerlink" title="6.2.2 util方法"></a>6.2.2 util方法</h4><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取今天具体我出生日期的时长</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate birthday = LocalDate.of(<span class="number">1997</span>, <span class="number">4</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"距离出生日期的日期时长为："</span> + birthday.until(today));</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取天数</span></span><br><span class="line">System.out.println(<span class="string">"距离出生日期的天数为："</span> + birthday.until(today, ChronoUnit.DAYS));</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">距离出生日期的日期时长为：P21Y8M23D</span><br><span class="line">距离出生日期的天数为：7937</span><br></pre></td></tr></table></figure><h4 id="6-2-3-其他方法"><a href="#6-2-3-其他方法" class="headerlink" title="6.2.3 其他方法"></a>6.2.3 其他方法</h4><ul><li><p>withDayOfMonth，WithDayOfYear，withMonth，withYear</p><blockquote><p>返回一个新的LocalDate，其月的日期、年的日期、月或年修改为给定的值，相当于设置日期。</p></blockquote></li><li><p>getMonth，getMonthValue</p><blockquote><p>获取月份的枚举值，<strong>或者是1 ~ 12之间的数字 。注意，不同于Calendar类那样月份从0开始。</strong></p></blockquote></li><li><p>getDayOfWeek</p><blockquote><p>获取星期的日期，返回DayOfWeek枚举值。</p></blockquote></li></ul><p>注意：DayOfWeek.MONDAY的枚举值为1，而DayOfWeek.SUNDAY的枚举值为7。这与Calendar类周日为1，周一为2有所不同。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">weekDayDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();</span><br><span class="line">    System.out.println(today);<span class="comment">//2019-01-11</span></span><br><span class="line">    </span><br><span class="line">    DayOfWeek dayOfWeek = today.getDayOfWeek();</span><br><span class="line">    <span class="comment">//输出枚举值</span></span><br><span class="line">    System.out.println(dayOfWeek);<span class="comment">//FRIDAY</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出枚举值对应的数</span></span><br><span class="line">    System.out.println(dayOfWeek.getValue()); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法查看API文档。</p><h2 id="7-TemporalAdjusters类"><a href="#7-TemporalAdjusters类" class="headerlink" title="7. TemporalAdjusters类"></a>7. TemporalAdjusters类</h2><p>该类为日期调整器，提供大量的用于常见调整的静态方法。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">temporalAdjustersDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDate today = LocalDate.now();<span class="comment">//201901-11</span></span><br><span class="line">    <span class="comment">// 取本月第1天：</span></span><br><span class="line">    LocalDate firstDayOfThisMonth = today.with(TemporalAdjusters.firstDayOfMonth()); </span><br><span class="line">    System.out.println(firstDayOfThisMonth);  <span class="comment">//2019-01-01</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取本月最后一天，再也不用计算是28，29，30还是31：</span></span><br><span class="line">    LocalDate lastDayOfThisMonth = today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">    System.out.println(lastDayOfThisMonth);<span class="comment">//2019-01-31</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取2017年1月第一个周一</span></span><br><span class="line">    LocalDate firstMondayOf2017 = LocalDate.parse(<span class="string">"2017-01-01"</span>).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(firstMondayOf2017);  <span class="comment">//2017-01-02</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取下个周一</span></span><br><span class="line">    LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(nextMonday);<span class="comment">//2019-01-14</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//取这个月的第三个周一</span></span><br><span class="line">    LocalDate theThirdMonday = today.with(TemporalAdjusters.dayOfWeekInMonth(<span class="number">3</span>, DayOfWeek.MONDAY));</span><br><span class="line">    System.out.println(theThirdMonday);<span class="comment">//2019-01-21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-LocalTime类"><a href="#8-LocalTime类" class="headerlink" title="8. LocalTime类"></a>8. LocalTime类</h2><p>与LocalDate仅仅包含日期不同是，LocalTime仅包含时间部分。LocalTime表示当前时刻，例如 15:30:21。</p><h3 id="8-1-对象的创建"><a href="#8-1-对象的创建" class="headerlink" title="8.1 对象的创建"></a>8.1 对象的创建</h3><ul><li>使用now方法创建当前时间的实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalTime rightTime = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"当前时间为："</span> + rightTime); <span class="comment">//当前时间为：10:41:22.334</span></span><br><span class="line"></span><br><span class="line">LocalTime bedTime = LocalTime.of(<span class="number">23</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">4560</span> &lt;&lt; <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"睡觉时间为："</span> + bedTime);<span class="comment">//睡觉时间为：23:12:30.002334720</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="8-2-常见操作"><a href="#8-2-常见操作" class="headerlink" title="8.2 常见操作"></a>8.2 常见操作</h3><p>LocalTime的许多时间的操作方法基本与LocalDate相同，这里不再赘述。详细参见API文档。</p><h2 id="9-LocalDateTime类"><a href="#9-LocalDateTime类" class="headerlink" title="9. LocalDateTime类"></a>9. LocalDateTime类</h2><p>LocalDateTime类相当于LocalDate类与LocalTime的结合，它可以表示日期和时间，适合存储固定时区的时间点。</p><h3 id="9-1-对象的创建"><a href="#9-1-对象的创建" class="headerlink" title="9.1 对象的创建"></a>9.1 对象的创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(dateTime);<span class="comment">//2019-01-11T10:52:13.434</span></span><br><span class="line"></span><br><span class="line">LocalDateTime myDateTime = LocalDateTime.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">12</span>, <span class="number">45</span>);</span><br><span class="line">System.out.println(myDateTime);<span class="comment">//2018-09-23T12:45</span></span><br></pre></td></tr></table></figure><h3 id="9-2-常见操作"><a href="#9-2-常见操作" class="headerlink" title="9.2 常见操作"></a>9.2 常见操作</h3><h4 id="9-2-1-间隔运算"><a href="#9-2-1-间隔运算" class="headerlink" title="9.2.1 间隔运算"></a>9.2.1 间隔运算</h4><p>使用Duration进行 day,hour,minute,second等的计算<br>使用Period进行Year,Month的计算</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tiemCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">    LocalDateTime birthdateTime = LocalDateTime.of(<span class="number">1997</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">4</span>, <span class="number">21</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Duration进行 day,hour,minute,second等的计算 </span></span><br><span class="line">    Duration duration = Duration.between(birthdateTime,dateTime);</span><br><span class="line">    <span class="keyword">long</span> days = duration.toDays();</span><br><span class="line">    <span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line">    <span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line">    System.out.println(<span class="string">"days:"</span> + days + <span class="string">" | hours:"</span> + hours + <span class="string">" | minutes:"</span> + minutes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用Period进行Year,Month的计算</span></span><br><span class="line">    Period period = Period.between(birthdateTime.toLocalDate(), dateTime.toLocalDate());</span><br><span class="line">    <span class="keyword">int</span> years = period.getYears();</span><br><span class="line">    <span class="keyword">long</span> totalMonths = period.toTotalMonths();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"years:"</span> + years + <span class="string">" | totalMonths:"</span> + totalMonths);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days:7937 | hours:190495 | minutes:11429737</span><br><span class="line">years:21 | totalMonths:260</span><br></pre></td></tr></table></figure><h4 id="9-2-2-其他方法"><a href="#9-2-2-其他方法" class="headerlink" title="9.2.2 其他方法"></a>9.2.2 其他方法</h4><p>LocalDateTime与LocalDate和LocalTime的方法有许多相似之处，如时间日期的运算、比较、获取和设置等，在这里不再赘述。</p><h2 id="10-格式化与解析"><a href="#10-格式化与解析" class="headerlink" title="10. 格式化与解析"></a>10. 格式化与解析</h2><p>格式化与解析所涉及到的类主要是DateTimeFormater类，它是用来替代java.util.DateFormat类的。</p><h3 id="10-1-格式化"><a href="#10-1-格式化" class="headerlink" title="10.1 格式化"></a>10.1 格式化</h3><p>DateTimeFormater类提供了三种用于打印日期/时间的格式器：</p><ul><li>预定义的格式器（具体参见API文档）</li><li>Locale相关的格式器</li><li>带有定制模式的格式器</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter[] formatters = <span class="keyword">new</span> DateTimeFormatter[]&#123;</span><br><span class="line">      <span class="comment">// 预定义的格式器，即直接使用常量创建DateTimeFormatter格式器</span></span><br><span class="line">        DateTimeFormatter.ISO_LOCAL_DATE,</span><br><span class="line">        DateTimeFormatter.ISO_LOCAL_TIME,</span><br><span class="line">        DateTimeFormatter.ISO_LOCAL_DATE_TIME,</span><br><span class="line">        <span class="comment">//注意：DateTimeFormatter.ISO_OFFSET_DATE是有时区偏移的，即适用时区时间的格式化</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用Locale相关的格式器的不同风格来创建DateTimeFormatter格式器</span></span><br><span class="line">        DateTimeFormatter.ofLocalizedDateTime(FormatStyle.FULL, FormatStyle.MEDIUM),</span><br><span class="line">        DateTimeFormatter.ofLocalizedTime(FormatStyle.LONG),</span><br><span class="line">        DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG),</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 带有定制模式的格式器,即根据模式字符串来创建DateTimeFormatter格式器</span></span><br><span class="line">        DateTimeFormatter.ofPattern(<span class="string">"Gyyyy%%MMM%%dd HH:mm:ss"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    LocalDateTime date = LocalDateTime.now();</span><br><span class="line">    <span class="comment">// 依次使用不同的格式器对LocalDateTime进行格式化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; formatters.length ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下面两行代码的作用相同</span></span><br><span class="line">        System.out.println(date.format(formatters[i]));</span><br><span class="line">        System.out.println(formatters[i].format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-01-11</span><br><span class="line">2019-01-11</span><br><span class="line">11:40:29.895</span><br><span class="line">11:40:29.895</span><br><span class="line">2019-01-11T11:40:29.895</span><br><span class="line">2019-01-11T11:40:29.895</span><br><span class="line">2019年1月11日 星期五 11:40:29</span><br><span class="line">2019年1月11日 星期五 11:40:29</span><br><span class="line">上午11时40分29秒</span><br><span class="line">上午11时40分29秒</span><br><span class="line">2019年1月11日</span><br><span class="line">2019年1月11日</span><br><span class="line">公元2019%%一月%%11 11:40:29</span><br><span class="line">公元2019%%一月%%11 11:40:29</span><br></pre></td></tr></table></figure><h3 id="10-2-字符串解析"><a href="#10-2-字符串解析" class="headerlink" title="10.2 字符串解析"></a>10.2 字符串解析</h3><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个任意格式的日期时间字符串</span></span><br><span class="line">String str1 = <span class="string">"2014==04==12 01时06分09秒"</span>;</span><br><span class="line"><span class="comment">// 根据需要解析的日期、时间字符串定义解析所用的格式器</span></span><br><span class="line">DateTimeFormatter fomatter1 = DateTimeFormatter</span><br><span class="line">    .ofPattern(<span class="string">"yyyy==MM==dd HH时mm分ss秒"</span>);</span><br><span class="line"><span class="comment">// 执行解析</span></span><br><span class="line">LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1);</span><br><span class="line">System.out.println(dt1); <span class="comment">// 输出 2014-04-12T01:06:09</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---下面代码再次解析另一个字符串---</span></span><br><span class="line">String str2 = <span class="string">"2014$$$四月$$$13 20小时"</span>;</span><br><span class="line">DateTimeFormatter fomatter2 = DateTimeFormatter</span><br><span class="line">    .ofPattern(<span class="string">"yyy$$$MMM$$$dd HH小时"</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2);</span><br><span class="line">System.out.println(dt2); <span class="comment">// 输出 2014-04-13T20:00</span></span><br></pre></td></tr></table></figure><h2 id="11-Java-8-日期-时间设计原则"><a href="#11-Java-8-日期-时间设计原则" class="headerlink" title="11. Java 8 日期/时间设计原则"></a>11. Java 8 日期/时间设计原则</h2><p>Java 8 日期/时间 API 是 JSR-310 的实现，它的实现目标是克服旧的日期时间实现中所有的缺陷，新的日期/时间API 的一些设计原则是：</p><ul><li>不变性：新的日期/时间 API 中，<strong>所有的类都是不可变的</strong>，这对多线程环境有好处。</li><li>关注点分离：新的 API 将人可读的日期时间和机器时间（unix timestamp）明确分离，它为日期（Date）、时间（Time）、日期时间（DateTime）、时间戳（unix timestamp）以及时区定义了不同的类。</li><li>清晰：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用 now()方法，在所有的类中都定义了 format()和 parse()方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。</li><li>实用操作：所有新的日期/时间 API 类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。</li><li>可扩展性：新的日期/时间 API 是工作在 ISO-8601 日历系统上的，但我们也可以将其应用在非 ISO 的日历上。</li></ul><h2 id="12-总结"><a href="#12-总结" class="headerlink" title="12. 总结"></a>12. 总结</h2><p>java关于时间日期的内容还有很多，比如不同类之间的转换问题以及相互应用的问题等等。另外，还有关于时区时间的内容等还没有讲到。</p><p>这部分内容错综复杂，暂时就总结到这了。应该多在具体的实践中加深这部分内容的理解和应用。</p><p>参考文章：<br><a href="https://blog.csdn.net/lamp113/article/details/79049528" target="_blank" rel="noopener">https://blog.csdn.net/lamp113/article/details/79049528</a><br><a href="http://www.runoob.com/java/java-date-time.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-date-time.html</a><br><a href="http://www.runoob.com/java/java8-datetime-api.html" target="_blank" rel="noopener">http://www.runoob.com/java/java8-datetime-api.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Integer类相关问题</title>
      <link href="/2020/01/05/Integer%E7%B1%BB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/05/Integer%E7%B1%BB%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Integer类是int类型对应的包装类，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><p>下面记录几个问题</p><p>问题一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer num2 = <span class="number">40</span>;<span class="comment">//自动装箱，相当于Integer num2 = new Integer(40);</span></span><br><span class="line"><span class="keyword">int</span> num3 = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(num1 == num2);<span class="comment">//false</span></span><br><span class="line"><span class="comment">//在进行比较的时候，num1自动拆箱为inty类型的40，即相当于int num1 = 40;</span></span><br><span class="line">System.out.println(num1 == num3);  <span class="comment">//true </span></span><br><span class="line">System.out.println(num2 == num3);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>第一个输出为false，是因为num1与num2比较的是两个对象的地址，故为false。</p><p>问题二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">127</span>, num2 = <span class="number">127</span>, num3 = <span class="number">128</span>, num4 = <span class="number">128</span>;</span><br><span class="line">        </span><br><span class="line">System.out.println(num1 == num2);<span class="comment">//true</span></span><br><span class="line">System.out.println(num3 == num4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>首先需要注意的是 num1、 num2、 num3、 num4 四个变量都是 Integer 对象引用，所以==运算比较的不是值而是引用。</p><p>当我们给一个 Integer 对象赋一个 int 值的时候，会调用 Integer 类的静态方法 valueOf，valueOf的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">   * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment">   * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment">   * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment">   * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment">   * caching frequently requested values.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment">   * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">          <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简单的说，如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池中的 Integer 对象，所以上面的问题中num1 == num2 的结果是 true，而 num3 == num4 的结果是 false。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collections类</title>
      <link href="/2020/01/05/Collections%E7%B1%BB/"/>
      <url>/2020/01/05/Collections%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Collections类为Java的常用工具类，下面介绍它的一些常用方法：</p><h5 id="1-排序"><a href="#1-排序" class="headerlink" title="1. 排序"></a>1. 排序</h5><ul><li>static sort(List<t> list);</t></li><li>static sort(List<t> list, Comparator&lt;? super T&gt; com);<blockquote><p>根据元素的自然顺序或自定义比较器指定顺序来对列表中的元素进行排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">42</span>);</span><br><span class="line">    integerList.add(<span class="number">48</span>);</span><br><span class="line">    integerList.add(<span class="number">3</span>);</span><br><span class="line">    integerList.add(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//初始顺序为 42, 48, 3, 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sort方法对integerList进行排序，默认从小到大排序</span></span><br><span class="line">    Collections.sort(integerList);</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[2, 3, 42, 48]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自定义比较器类，从大到小排序</span></span><br><span class="line">    Collections.sort(integerList, <span class="keyword">new</span> MyComparator());</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[48, 42, 3, 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义比较器类，从大到小排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 &gt; o2) </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (o1 &lt; o2)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></li></ul><h5 id="2-交换"><a href="#2-交换" class="headerlink" title="2. 交换"></a>2. 交换</h5><ul><li>static swap(List&lt;?&gt; list, int i, int j);<blockquote><p>对指定List的指定角标的两个元素进行位置交换</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">42</span>);</span><br><span class="line">    integerList.add(<span class="number">48</span>);</span><br><span class="line">    integerList.add(<span class="number">3</span>);</span><br><span class="line">    integerList.add(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定List的指定角标的两个元素进行位置交换</span></span><br><span class="line">    Collections.swap(integerList, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[2, 48, 3, 42]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-折半查询"><a href="#3-折半查询" class="headerlink" title="3. 折半查询"></a>3. 折半查询</h5><ul><li>static binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,  T key);<blockquote><p>二分查找方法，根据指定key来查询List中的对应元素下标</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySearchDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">40</span>);</span><br><span class="line">    integerList.add(<span class="number">41</span>);</span><br><span class="line">    integerList.add(<span class="number">42</span>);</span><br><span class="line">    integerList.add(<span class="number">43</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过指定的key查找List对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> index = Collections.binarySearch(integerList, <span class="number">43</span>);</span><br><span class="line">    System.out.println(index); <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-最值"><a href="#4-最值" class="headerlink" title="4. 最值"></a>4. 最值</h5><blockquote><p>该方法用于求集合元素的最大值，同时可以自定义比较器来规定大小的判定规则</p></blockquote><ul><li>max (Collection&lt;? extends T&gt; coll);</li><li>max (Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt;  comp);</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">40</span>);</span><br><span class="line">    integerList.add(<span class="number">41</span>);</span><br><span class="line">    integerList.add(<span class="number">42</span>);</span><br><span class="line">    integerList.add(<span class="number">43</span>);</span><br><span class="line">    </span><br><span class="line">    Integer max = Collections.max(integerList);</span><br><span class="line">    System.out.println(max);<span class="comment">//43</span></span><br><span class="line">    </span><br><span class="line">    Integer max2 = Collections.max(integerList, <span class="keyword">new</span> MyComparator());</span><br><span class="line">    System.out.println(max2);<span class="comment">//40</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-逆序"><a href="#5-逆序" class="headerlink" title="5. 逆序"></a>5. 逆序</h5><ul><li>reverse (List&lt;?&gt; list)：反转指定列表中的元素的顺序</li><li>reverseOrder()：返回一个比较器，它强行逆转实现了Comparable接口对象Collection的自然顺序。</li><li>reverseOrder(Comparator<t> cmp)：返回一个比较器，它强行逆转指定比较器的顺序。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">40</span>);</span><br><span class="line">    integerList.add(<span class="number">5</span>);</span><br><span class="line">    integerList.add(<span class="number">45</span>);</span><br><span class="line">    integerList.add(<span class="number">33</span>);<span class="comment">//[45, 40, 33, 5]</span></span><br><span class="line">    </span><br><span class="line">    Collections.reverse(integerList);</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[33, 45, 5, 40]</span></span><br><span class="line">    </span><br><span class="line">    Comparator&lt;Object&gt; comparator = Collections.reverseOrder();</span><br><span class="line">    integerList.sort(comparator);<span class="comment">//使用比较器再次逆转回来</span></span><br><span class="line">    System.out.println(integerList);  <span class="comment">//[45, 40, 33, 5]</span></span><br><span class="line">    </span><br><span class="line">    Comparator&lt;Integer&gt; comparator2 = Collections.reverseOrder(<span class="keyword">new</span> MyComparator());</span><br><span class="line">    <span class="comment">//MyComparator比较器是实现从大到小进行逆序排序的</span></span><br><span class="line">    <span class="comment">//使用reverseOrder进行反转之后，获取了自然排序的比较器comparator2</span></span><br><span class="line">    integerList.sort(comparator2);<span class="comment">//根据自然排序的比较其来排序（虽然默认也是自然排序）</span></span><br><span class="line">    System.out.println(integerList);  <span class="comment">//[5, 33, 40, 45]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></li></ul><h5 id="6-替换"><a href="#6-替换" class="headerlink" title="6. 替换"></a>6. 替换</h5><ul><li>boolean replaceAll(List&lt;?&gt;  list,  T  oldVal,  T newVal)：替换失败则返回false，否则返回true</li><li>fill (List&lt;? super T&gt;  list,  T  obj)：使用指定元素替换列表中的所有元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAllAndFillDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">40</span>);</span><br><span class="line">    integerList.add(<span class="number">5</span>);</span><br><span class="line">    integerList.add(<span class="number">45</span>);</span><br><span class="line">    integerList.add(<span class="number">33</span>);<span class="comment">//[45, 40, 33, 5]</span></span><br><span class="line">    </span><br><span class="line">    Collections.replaceAll(integerList, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[40, 6, 45, 33]</span></span><br><span class="line">    </span><br><span class="line">    Collections.replaceAll(integerList, <span class="number">40</span>, <span class="number">33</span>);<span class="comment">//33是已存在的值</span></span><br><span class="line">    System.out.println(integerList);<span class="comment">//[33, 6, 45, 33]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> flag = Collections.replaceAll(integerList, -<span class="number">1</span>, <span class="number">100</span>);  <span class="comment">//-1不存在</span></span><br><span class="line">    System.out.println(flag);  <span class="comment">//false</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将集合中的元素全部替换为100</span></span><br><span class="line">    Collections.fill(integerList, <span class="number">100</span>);</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[100, 100, 100, 100]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h5><ul><li>shuffle(List&lt;?&gt;  list)：对列表中的元素的位置进行随机变换，可以用于洗牌。</li><li>List<t>  synchronizedList(  List<t>  list)：将非同步的集合转换成同步的集合。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shuffleDemo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化列表</span></span><br><span class="line">    List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    integerList.add(<span class="number">40</span>);</span><br><span class="line">    integerList.add(<span class="number">5</span>);</span><br><span class="line">    integerList.add(<span class="number">45</span>);</span><br><span class="line">    integerList.add(<span class="number">33</span>);<span class="comment">//[45, 40, 33, 5]</span></span><br><span class="line">    </span><br><span class="line">    Collections.shuffle(integerList);</span><br><span class="line">    System.out.println(integerList);<span class="comment">//[5, 45, 40, 33]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></t></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arrays类</title>
      <link href="/2020/01/05/Arrays%E7%B1%BB/"/>
      <url>/2020/01/05/Arrays%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的</p><a id="more"></a><h4 id="1-常用方法表"><a href="#1-常用方法表" class="headerlink" title="1. 常用方法表"></a>1. 常用方法表</h4><table><thead><tr><th align="left">方法和说明</th></tr></thead><tbody><tr><td align="left"><strong>static List asList(T… a)</strong> <br>返回由指定数组支持的固定大小的列表</td></tr><tr><td align="left"><strong>static int binarySearch(Object[] a, Object key)</strong> <br>用二分查找算法在给定数组中搜索给定值的对象(Byte,Int,double等)。数组在调用前必须排序好的。如果查找值包含在数组中，则返回搜索键的索引；否则返回 (-(插入点) - 1)。</td></tr><tr><td align="left"><strong>static int[] copyOf(int[] original, int newLength)</strong> <br> 复制original并指定长度newLength的新数组，如果newLength小于原本数组的长度，则进行截断。相反则用0去补充。</td></tr><tr><td align="left"><strong>static int[] copyOfRange(int[] original, int from, int to)</strong><br> 将指定数组的指定范围复制到新数组中，超出数组长度时会用0进行填充</td></tr><tr><td align="left"><strong>static boolean equals(long[] a, long[] a2)</strong><br> 如果两个指定的 long 型数组彼此相等，则返回 true。如果两个数组包含相同数量的元素，并且两个数组中的所有相应元素对都是相等的，则认为这两个数组是相等的。换句话说，如果两个数组以相同顺序包含相同的元素，则两个数组是相等的。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="left"><strong>static void fill(int[] a, int val)</strong><br> 将指定的 int 值分配给指定 int 型数组指定范围中的每个元素。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="left"><strong>static void sort(Object[] a)</strong><br> 对指定对象数组根据其元素的自然顺序进行升序排列。同样的方法适用于所有的其他基本数据类型（Byte，short，Int等）。</td></tr><tr><td align="left"><strong>static void deepToString(Object[] a)</strong><br> 将多维数组以字符串的形式返回。形如：[[…],[…],[…]]。</td></tr></tbody></table><h4 id="2-数组转集合"><a href="#2-数组转集合" class="headerlink" title="2. 数组转集合"></a>2. 数组转集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String[] strArray = &#123;<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>&#125;;</span><br><span class="line"><span class="comment">//转为List集合</span></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(strArray);</span><br><span class="line">System.out.println(strList); <span class="comment">//[abc, def, ghi]</span></span><br><span class="line"></span><br><span class="line">strList.add(<span class="string">"王尼玛"</span>);<span class="comment">//UnsupportedOperationException异常</span></span><br><span class="line">System.out.println(strList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] numArray = &#123;<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>&#125;;</span><br><span class="line"><span class="comment">//转为List集合</span></span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; numList = Arrays.asList(numArray);</span><br><span class="line">System.out.println(Arrays.toString(numList.get(<span class="number">0</span>)));<span class="comment">//[123, 456, 789]</span></span><br></pre></td></tr></table></figure><p>由以上代码示例可以说明：</p><ul><li>当将数组转换为List集合时，可以使用集合的方法来操作数组中的元素</li><li>因为数组的长度是固定的，所以对于有数组转换过来的List集合是<strong>不可以使用增删方法</strong>的，否则会发生UnsupportedOperationException异常</li><li>如果数组中的元素是对象，那么转成集合时，直接将数组中的元素作为集合中的元素进行集合存储，如上面的strArray转strList的例子。</li><li>如果数组中的元素是基本数据类型数值，那么会将该数组作为集合中的元素进行存储，如上面的numArray转numList的例子。</li></ul><h4 id="3-集合转数组"><a href="#3-集合转数组" class="headerlink" title="3. 集合转数组"></a>3. 集合转数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listToArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    strList.add(<span class="string">"J"</span>);</span><br><span class="line">    strList.add(<span class="string">"a"</span>);</span><br><span class="line">    strList.add(<span class="string">"v"</span>);</span><br><span class="line">    strList.add(<span class="string">"a"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//toArry没有参数的情形</span></span><br><span class="line">    String[] array = (String[]) strList.toArray();</span><br><span class="line">    System.out.println(<span class="string">"数组大小："</span> + array.length);  <span class="comment">//数组大小：4</span></span><br><span class="line">    System.out.println(Arrays.toString(array));<span class="comment">//[J, a, v, a]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//toArray带数组类型参数，指定的数组长度小于List的长度</span></span><br><span class="line">    String[] strArray = strList.toArray(<span class="keyword">new</span> String[<span class="number">2</span>]);</span><br><span class="line">    System.out.println(<span class="string">"\n数组大小："</span> + strArray.length); <span class="comment">//数组大小：4</span></span><br><span class="line">    System.out.println(Arrays.toString(strArray));<span class="comment">//[J, a, v, a]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定的数组长度小于List的长度</span></span><br><span class="line">    String[] strArray2 = strList.toArray(<span class="keyword">new</span> String[<span class="number">6</span>]);</span><br><span class="line">    System.out.println(<span class="string">"\n数组大小："</span> + strArray2.length); <span class="comment">//数组大小：6</span></span><br><span class="line">    System.out.println(Arrays.toString(strArray2));<span class="comment">//[J, a, v, a, null, null]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toArray方法传入一个指定类型的数组参数的情况：</p><ul><li>如果数组长度小于集合的长度，那么该方法会创建一个同类型并和集合长度相同数组</li><li>如果数组长度小于集合的长度，那么该方法就会使用指定的数组长度以存储集合中的元素，其他位置默认为null</li></ul><h4 id="4-拷贝元素"><a href="#4-拷贝元素" class="headerlink" title="4. 拷贝元素"></a>4. 拷贝元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;     <span class="comment">//初始化一个数组</span></span><br><span class="line">         </span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOfRange(arr, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">System.out.println(Arrays.toString(newArr));<span class="comment">//[9, 8, 3, 5, 2, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] newArr2 = Arrays.copyOf(arr, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(newArr2));<span class="comment">//[9, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] outOfRangeArr = Arrays.copyOfRange(arr, <span class="number">8</span>, <span class="number">10</span>);<span class="comment">//java.lang.ArrayIndexOutOfBoundsException</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span>[] reverseRangeArr = Arrays.copyOfRange(arr, <span class="number">4</span>, <span class="number">2</span>);<span class="comment">//java.lang.ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure><p>由以上代码示例可以说明：</p><ul><li>copyOfRange方法的最后一个参数是不包含的</li><li>如果后一个参数超出了原本数组大小-1的范围，那么以0补充多出的空位。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System类与Runtime类</title>
      <link href="/2020/01/05/System%E7%B1%BB%E4%B8%8ERuntime%E7%B1%BB/"/>
      <url>/2020/01/05/System%E7%B1%BB%E4%B8%8ERuntime%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="1-System类"><a href="#1-System类" class="headerlink" title="1. System类"></a>1. System类</h2><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。</p><h3 id="1-1-成员变量"><a href="#1-1-成员变量" class="headerlink" title="1.1 成员变量"></a>1.1 成员变量</h3><p>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p><a id="more"></a><h4 id="1-1-1-out与err的区别"><a href="#1-1-1-out与err的区别" class="headerlink" title="1.1.1 out与err的区别"></a>1.1.1 out与err的区别</h4><ul><li><p>System.out在JVM和操作系统都具有缓存功能，就是输出的数据不一定实时输出，有时候会积攒到一定数量才会输出；System.err会实时输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"out输出Java"</span>);</span><br><span class="line">System.err.println(<span class="string">"err输出Python"</span>);</span><br><span class="line">System.out.println(<span class="string">"out输出C++"</span>);</span><br></pre></td></tr></table></figure><p>输出结果1：<br><img src="/2020/01/05/System类与Runtime类/20190112103715878.png" alt="在这里插入图片描述"><br>输出结果2：<br><img src="/2020/01/05/System类与Runtime类/20190112103815666.png" alt="在这里插入图片描述"><br>由于System.out不是实时输出的，所以直观地造成System.err输出位置的不确定性。</p></li><li><p>如果使用了log4j的日志记录，System.err会被记入日志，System.out不会。</p></li><li><p>System.out是<strong>通常输出信息的方式</strong>，System.err是用在显示错误信息或者system.out被重定向以后，需要立即让用户注意到的信息的输出</p></li></ul><h3 id="1-2-成员方法"><a href="#1-2-成员方法" class="headerlink" title="1.2 成员方法"></a>1.2 成员方法</h3><ol><li><p><strong>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</strong><br> 该方法的作用是数组拷贝，src为被拷贝的数组，srcPos为src要拷贝的初始位置，dest为目的数组，目的数组dest放置拷贝数据的初始位置，length为从src拷贝到的数据长度。</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] srcArr = &#123;<span class="number">20</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">17</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] destArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">System.arraycopy(srcArr, <span class="number">1</span>, destArr, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(srcArr));<span class="comment">//[20, 23, 45, 12, 17, 8]</span></span><br><span class="line">System.out.println(Arrays.toString(destArr));<span class="comment">//[0, 0, 23, 45, 0]</span></span><br></pre></td></tr></table></figure><p>注意：执行拷贝之后，源数组不发生变化，而目的数组发生变化。</p></li><li><p><strong>static long currentTimeMillis()</strong><br> 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p></li><li><p><strong>static void exit(int status)</strong><br> 该方法的作用是退出程序。其中status的值为<strong>0代表正常退出</strong>，<strong>非零代表异常退出</strong>。使用该方法可以在<strong>图形界面编程</strong>中实现程序的退出功能等。</p></li><li><p><strong>static void gc()</strong><br> 请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p></li><li><p><strong>static Properties getProperties()</strong><br> 获取系统的属性信息，并存储到Properties集合中。Properties集合中存储的都是String类型的键值对。</p></li><li><p><strong>static String getProperty(String key)</strong><br> 获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：<br> <img src="/2020/01/05/System类与Runtime类/2019011211032895.png" alt="在这里插入图片描述"><br> 代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取操作系统名称</span></span><br><span class="line">String osName = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line"><span class="comment">//获取操作系统版本</span></span><br><span class="line">String osVersion = System.getenv(<span class="string">"os.version"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"操作系统名："</span> + osName);<span class="comment">//Windows 10</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"操作系统版本："</span> + osVersion);<span class="comment">//null</span></span><br></pre></td></tr></table></figure></li><li><p><strong>static String setProperty(String key, String value)</strong><br> 给系统设置一些属性信息，这些信息是全局的，其他程序都可以使用</p></li></ol><h2 id="2-Runtime类"><a href="#2-Runtime类" class="headerlink" title="2. Runtime类"></a>2. Runtime类</h2><p>Runtime类封装了运行时的环境。每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。另外该类无法创建对象。</p><h3 id="2-1-常用方法"><a href="#2-1-常用方法" class="headerlink" title="2.1 常用方法"></a>2.1 常用方法</h3><ol><li><strong>static Runtime getRuntime()</strong><br> 返回一个Runtime实例</li><li><strong>Process exec(String command)</strong><br> 指定某个exe文件并返回该程序进程，参数command为本地exe文件路径。</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line">Process notepadProcess = runtime.exec(<span class="string">"C:\\\\Windows\\\\notepad.exe"</span>);<span class="comment">//打开记事本程序</span></span><br><span class="line"><span class="comment">//三秒后关闭该记事本进程</span></span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">notepadProcess.destroy();</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>long freeMemory()</strong><br> 返回Java虚拟机中的空闲内存量，以字节为单位</li><li><strong>long maxMemory()</strong><br> 返回Java虚拟机试图使用的最大内存量</li><li><strong>long totalMemory()</strong><br> 返回Java虚拟机中的内存总量</li></ol><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line"><span class="keyword">long</span> freeMemory = runtime.freeMemory();</span><br><span class="line"><span class="keyword">long</span> totalMemory = runtime.totalMemory();</span><br><span class="line"><span class="keyword">long</span> maxMemory = runtime.maxMemory();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"虚拟机空闲内存量："</span> + freeMemory);</span><br><span class="line">System.out.println(<span class="string">"虚拟机内存总量："</span> + totalMemory);</span><br><span class="line">System.out.println(<span class="string">"虚拟机试图使用的最大内存量："</span> + maxMemory);</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟机空闲内存量：126930080</span><br><span class="line">虚拟机内存总量：128974848</span><br><span class="line">虚拟机试图使用的最大内存量：1890582528</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://www.cnblogs.com/xuhuan/articles/1522212.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuhuan/articles/1522212.html</a><br><a href="https://blog.csdn.net/zhuwei1035838807/article/details/79464603" target="_blank" rel="noopener">https://blog.csdn.net/zhuwei1035838807/article/details/79464603</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO之File类</title>
      <link href="/2020/01/05/IO%E4%B9%8BFile%E7%B1%BB/"/>
      <url>/2020/01/05/IO%E4%B9%8BFile%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>该类用来将<strong>文件</strong>或<strong>文件夹</strong>封装成对象，方便对文件和文件夹的属性信息进行操作。</p><h4 id="1-对象的创建与删除"><a href="#1-对象的创建与删除" class="headerlink" title="1. 对象的创建与删除"></a>1. 对象的创建与删除</h4><p>可以使用File类创建一个文件对象，通常使用以下3种构造方法来创建文件对象。</p><ul><li>File(String pathname)</li><li>File(String parent,  String child);</li><li>File(File f,  String child);</li></ul><a id="more"></a><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line">File file0 = <span class="keyword">new</span> File(<span class="string">"C:/Users/郑松涛/Desktop/demo.txt"</span>);</span><br><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\郑松涛\\Desktop"</span>,<span class="string">"demo.txt"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">"C:\\Users\\郑松涛\\Desktop"</span>),<span class="string">"demo.txt"</span>);</span><br><span class="line"><span class="comment">//创建文件夹对象</span></span><br><span class="line">File dir = <span class="keyword">new</span> File(<span class="string">"f:/myDir"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>boolean createNewFile();</p><blockquote><p>如果FIle构造方法里的路径不存在指定的文件如demo.txt时，可以调用该方法创建指定的文件。</p></blockquote></li><li><p>boolean mkdir();    创建文件夹。</p></li><li><p>boolean delete();  删除指定文件，如demo.txt。<strong>如果要删除的是目录，则该目录必须为空。</strong></p></li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"word.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">    file.delete();</span><br><span class="line">    System.out.println(<span class="string">"文件已删除！"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    file.createNewFile();</span><br><span class="line">    System.out.println(<span class="string">"文件已创建！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取文件信息"><a href="#2-获取文件信息" class="headerlink" title="2. 获取文件信息"></a>2. 获取文件信息</h4><p>File类提供了很多方法用于获取一些文件本身的信息，下面以代码的形式演示其用法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"word.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;<span class="comment">//判断文件是否存在</span></span><br><span class="line">    String fileName = file.getName();<span class="comment">//获取文件名称</span></span><br><span class="line">    <span class="keyword">boolean</span> canRead = file.canRead();<span class="comment">//判断文件是否可读</span></span><br><span class="line">    <span class="keyword">boolean</span> canWrite = file.canWrite();<span class="comment">//判断文件是否可写</span></span><br><span class="line">    <span class="keyword">long</span> length = file.length();<span class="comment">//获取文件长度，以字节为单位</span></span><br><span class="line">    String absolutePath = file.getAbsolutePath();<span class="comment">//获取文件绝对路径</span></span><br><span class="line">    String parentPath = file.getParent();<span class="comment">//获取父路径</span></span><br><span class="line">    <span class="keyword">boolean</span> isFile = file.isFile(); <span class="comment">//判断是否是文件</span></span><br><span class="line">    <span class="keyword">boolean</span> isDirectory = file.isDirectory();<span class="comment">//判断是否是目录</span></span><br><span class="line">    <span class="keyword">boolean</span> isHidden = file.isHidden();<span class="comment">//是否是隐藏文件</span></span><br><span class="line">    <span class="keyword">long</span> lastModifiedTime = file.lastModified();<span class="comment">//获取最后修改时间</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"文件名称："</span> + fileName);</span><br><span class="line">    System.out.println(<span class="string">"文件是否可读："</span> + canRead);</span><br><span class="line">    System.out.println(<span class="string">"文件是否可写："</span> + canWrite);</span><br><span class="line">    System.out.println(<span class="string">"文件长度："</span> + length);</span><br><span class="line">    System.out.println(<span class="string">"文件绝对路径："</span> + absolutePath);</span><br><span class="line">    System.out.println(<span class="string">"文件父路径："</span> + parentPath);</span><br><span class="line">    System.out.println(<span class="string">"是否是文件："</span> + isFile);</span><br><span class="line">    System.out.println(<span class="string">"是否是目录："</span> + isDirectory);</span><br><span class="line">    System.out.println(<span class="string">"是否是隐藏文件："</span> + isHidden);</span><br><span class="line">    System.out.println(<span class="string">"最后修改时间："</span> + <span class="keyword">new</span> Date(lastModifiedTime));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"文件不存在！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">文件名称：word.txt</span><br><span class="line">文件是否可读：true</span><br><span class="line">文件是否可写：true</span><br><span class="line">文件长度：28</span><br><span class="line">文件绝对路径：F:\eclipse-workspace\MyTest\word.txt</span><br><span class="line">文件父路径：null</span><br><span class="line">是否是文件：true</span><br><span class="line">是否是目录：false</span><br><span class="line">是否是隐藏文件：false</span><br><span class="line">最后修改时间：Sun Jan 13 08:40:50 CST 2019</span><br></pre></td></tr></table></figure><h4 id="3-系统根目录和文件容量获取"><a href="#3-系统根目录和文件容量获取" class="headerlink" title="3. 系统根目录和文件容量获取"></a>3. 系统根目录和文件容量获取</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">File[] listRoots = File.listRoots();<span class="comment">//获取系统根</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listRoots.length; i++) &#123;</span><br><span class="line">        System.out.print(listRoots[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;<span class="comment">//输出C:\ D:\ E:\ F:\</span></span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line"><span class="keyword">long</span> freeSpace = file.getFreeSpace();<span class="comment">//获取剩余空间</span></span><br><span class="line"><span class="keyword">long</span> totalSpace = file.getTotalSpace();<span class="comment">//获取全部空间</span></span><br><span class="line"><span class="keyword">long</span> usableSpace = file.getUsableSpace();<span class="comment">//获取可用空间</span></span><br></pre></td></tr></table></figure><h4 id="4-获取目录内容"><a href="#4-获取目录内容" class="headerlink" title="4. 获取目录内容"></a>4. 获取目录内容</h4><ul><li>String[] list[];  该方法获取<strong>当前目录下</strong>的文件以及文件夹的<strong>名称</strong>，包含隐藏文件。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"f:/sublime text"</span>);</span><br><span class="line">String[] list = file.list();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    System.out.println(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.js</span><br><span class="line">practice.html</span><br><span class="line">table.css</span><br></pre></td></tr></table></figure><p> 调用list方法的File对象中封装的必须是目录，否则会发生空指针异常。如果目录访问的系统级目录也会发生空指针异常。如果目录存在但是没有内容，则返回一个空数组。</p><ul><li>File[] listFiles(); <strong>获取当前目录下</strong>的所有内容，返回<strong>路径名</strong>数组</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"f:/dir"</span>);<span class="comment">//构件目录对象</span></span><br><span class="line">File[] listFiles = file.listFiles();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listFiles.length; i++) &#123;</span><br><span class="line">    System.out.println(listFiles[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/05/IO之File类/20190113105744883.png" alt="在这里插入图片描述"><br>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f:\dir\demo1.txt</span><br><span class="line">f:\dir\demo2.txt</span><br><span class="line">f:\dir\demo3.java</span><br><span class="line">f:\dir\demo4.class</span><br><span class="line">f:\dir\dir1</span><br><span class="line">f:\dir\dir2</span><br></pre></td></tr></table></figure><ul><li>File[] listFiles(FileFilter filter); 指定过滤器来获取<strong>当前目录</strong>下的指定内容</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.自定义过滤器,只有扩展名为txt才符合</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.getName().endsWith(<span class="string">".txt"</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//2.获取目录下的指定内容</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"f:/dir"</span>);<span class="comment">//构件目录对象</span></span><br><span class="line">        File[] listFiles = file.listFiles(<span class="keyword">new</span> ImplementFilter());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listFiles.length; i++) &#123;</span><br><span class="line">            System.out.println(listFiles[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/01/05/IO之File类/20190113105246320.png" alt="在这里插入图片描述"><br><img src="/2020/01/05/IO之File类/20190113105303475.png" alt="在这里插入图片描述"><br>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f:\dir\demo1.txt</span><br><span class="line">f:\dir\demo2.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO之字节流</title>
      <link href="/2020/01/05/IO%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81/"/>
      <url>/2020/01/05/IO%E4%B9%8B%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-总体结构"><a href="#1-总体结构" class="headerlink" title="1. 总体结构"></a>1. 总体结构</h2><p><img src="/2020/01/05/IO之字节流/2019011215211591.png" alt="在这里插入图片描述"></p><a id="more"></a><h2 id="2-FileInputStream与FileOutputStream"><a href="#2-FileInputStream与FileOutputStream" class="headerlink" title="2. FileInputStream与FileOutputStream"></a>2. FileInputStream与FileOutputStream</h2><h3 id="2-1-FileInputStream类"><a href="#2-1-FileInputStream类" class="headerlink" title="2.1 FileInputStream类"></a>2.1 FileInputStream类</h3><p>该类表示读取文件数据的输入字节流，使用该类的主要步骤为：</p><ol><li>找到目标文件</li><li>建立数据的输入通道</li><li>建立缓冲区</li><li>读取文件中的数据</li><li>关闭资源</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到目标文件</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line"><span class="comment">//建立数据的输入通道</span></span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">//建立缓冲区</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//读取目标文件的数据，每次读取1024个字节的数据</span></span><br><span class="line"><span class="comment">//若读取不到数据，read会返回-1，否则返回读到的字节数</span></span><br><span class="line"><span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((num = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//使用字节数组构建字符串，并将数据简单的打印到控制台上</span></span><br><span class="line">    String content = <span class="keyword">new</span> String(buf, <span class="number">0</span>, num);</span><br><span class="line">    System.out.print(content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">is.close();</span><br></pre></td></tr></table></figure><h3 id="2-2-FileOutputStream类"><a href="#2-2-FileOutputStream类" class="headerlink" title="2.2 FileOutputStream类"></a>2.2 FileOutputStream类</h3><p>该类表示写入文件数据的输出字节流，下面我们结合FileInputStream类和FileOutputStream类来实现读取某个文件的数据并输出都新的文件中的功能。主要步骤为：</p><ol><li>找到源文件</li><li>建立数据的输入通道</li><li>建立目的文件</li><li>建立数据的输出通道</li><li>建立缓冲区</li><li>读取源文件中的数据并写入缓冲区</li><li>将缓冲区中的文件数据写入目标文件</li><li>关闭流</li></ol><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到源文件</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line"><span class="comment">//建立数据的输入通道</span></span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line"><span class="comment">//建立目的文件</span></span><br><span class="line">File desFile = <span class="keyword">new</span> File(<span class="string">"src/io/desDemo.txt"</span>);</span><br><span class="line"><span class="comment">//建立数据的输出通道</span></span><br><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(desFile);</span><br><span class="line"><span class="comment">//建立缓冲区</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//读取源文件中的数据并写入缓冲区,每次读取1024个字节的数据</span></span><br><span class="line"><span class="comment">//如果读到了数据，则num为读到的字节数，否则为-1</span></span><br><span class="line"><span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((num = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//将缓冲区中的文件数据写入目标文件</span></span><br><span class="line">    fos.write(buf, <span class="number">0</span>, num);</span><br><span class="line">    fos.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><hr><p>在使用FileOutputStream写入数据到文件时，会覆盖到原始文件中的数据，可以使用FileOutputStream类的另一个构造方法来实现每次写入数据都添加到原文件的末尾。</p><p>假设存在目的文件desFile.txt，里面存在一些数据，如果我们使用如下操作向该文件写入新的数据，则会覆盖掉该文件中的原始数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//desFile.txt文件的原数据为："源数据内容"</span></span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"src/io/desFile.txt"</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 写出数据  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;  </span><br><span class="line">    fos.write((<span class="string">"新的数据"</span> + x).getBytes());  </span><br><span class="line">    fos.write(<span class="string">"\r\n"</span>.getBytes());<span class="comment">//写入windows系统的换行符</span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭输出流  </span></span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure><p>可以该更改FileOutputStream的构造方法的操作解决该问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"src/io/desFile.txt"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>后面的参数为true表示写入数据的可以追加在原有文件数据的尾部。</p><h2 id="3-BufferedInputStream与BufferedOutputStream"><a href="#3-BufferedInputStream与BufferedOutputStream" class="headerlink" title="3. BufferedInputStream与BufferedOutputStream"></a>3. BufferedInputStream与BufferedOutputStream</h2><p>在上面演示文件输入输出流的时候，我们都是<strong>用字节数组来充当缓冲区，其不存在刷新缓冲区等功能。</strong> Java有自带缓冲区的缓冲流BufferedInputStream和BufferedOutputStream，其为I/O流增加了内存缓冲区。</p><h3 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h3><ul><li>BufferedInputStream(InputStream)</li><li>BufferedInputStream(InputStream in,  int size)</li></ul><p>第一种形式的构造方法创建了一个带有32个字节的缓冲流；第二个形式的构造方法按指定的大小来创建缓冲区。BufferedOutputStream的构造方法基本一样。</p><h3 id="3-2-flush方法"><a href="#3-2-flush方法" class="headerlink" title="3.2 flush方法"></a>3.2 flush方法</h3><blockquote><p>该<strong>方法的作用是强制将缓存中的输出流（字节流，字符流等）强制输出</strong>。因为输出流在进行输出时，比如像某个文件中写入内容，其实是先将输出流写入到缓冲区，当缓冲区写满后才将缓冲区的内容输出到文件中。但是当主机完成输出流的输出后，有可能缓冲区这个时候还没有被填满，这样的话，就会一直等待主机发送内容，这时候，就可以<strong>使用flush将缓冲区的内容强制输出到文件中，清空缓冲区</strong>。 所以，一般在关闭输出流之前，要先调用flush方法强制缓冲区中的内容输出，并清空缓冲区。</p></blockquote><h3 id="3-3-字节数据读取文件与写入文件过程"><a href="#3-3-字节数据读取文件与写入文件过程" class="headerlink" title="3.3 字节数据读取文件与写入文件过程"></a>3.3 字节数据读取文件与写入文件过程</h3><p><img src="/2020/01/05/IO之字节流/20190113092100656.png" alt="在这里插入图片描述"><br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">InputStream fis = <span class="keyword">null</span>;</span><br><span class="line">BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">OutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line">        <span class="comment">//使用缓冲流封装输入流</span></span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"src/io/desFile.txt"</span>);</span><br><span class="line">        <span class="comment">//使用缓冲流封装输出流</span></span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//用来存储每次读取到的字节数组,做中间媒介</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//每次读取到的字节数组的长度  </span></span><br><span class="line">        <span class="keyword">while</span> ((num = bis.read(buf)) != -<span class="number">1</span>) &#123;<span class="comment">//读取bis中的数据</span></span><br><span class="line">            <span class="comment">//将bis中的数据写入bos中</span></span><br><span class="line">            bos.write(buf, <span class="number">0</span>, num);</span><br><span class="line">            <span class="comment">//刷新bos缓冲区</span></span><br><span class="line">            bos.flush();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭包装流,被包装的流会默认关闭</span></span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-DataInputStream与DataOutputStream"><a href="#4-DataInputStream与DataOutputStream" class="headerlink" title="4. DataInputStream与DataOutputStream"></a>4. DataInputStream与DataOutputStream</h2><p>在io包中，提供了两个与平台无关的数据操作流数据输出流（DataOutputStream）和数据输入流 （DataInputStream）<br><strong>通常数据输出流会按照一定的格式将数据输出，再通过数据输入流按照一定的格式将数据读入。</strong></p><p>比如按照如下的格式将数据输出到文件：<br><img src="/2020/01/05/IO之字节流/20190113143505174.png" alt="在这里插入图片描述"><br>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.构建文件输出流</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"f:"</span> + File.separator + <span class="string">"demo.txt"</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            dos = <span class="keyword">new</span> DataOutputStream(fos);</span><br><span class="line">            <span class="comment">//2.按指定的数据保存格式写入数据</span></span><br><span class="line">            String names[] = &#123;<span class="string">"衬衣"</span>,<span class="string">"手套"</span>,<span class="string">"围巾"</span>&#125; ;<span class="comment">// 商品名称</span></span><br><span class="line">            <span class="keyword">float</span> prices[] = &#123;<span class="number">98.3f</span>,<span class="number">30.3f</span>,<span class="number">50.5f</span>&#125; ;<span class="comment">// 商品价格</span></span><br><span class="line">            <span class="keyword">int</span> nums[] = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125; ;<span class="comment">// 商品数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;names.length;i++)&#123;<span class="comment">// 循环输出</span></span><br><span class="line">                dos.writeChars(names[i]) ;<span class="comment">// 写入字符串</span></span><br><span class="line">                dos.writeChar(<span class="string">'\t'</span>) ;<span class="comment">// 写入分隔符</span></span><br><span class="line">                dos.writeFloat(prices[i]) ; <span class="comment">// 写入价格</span></span><br><span class="line">                dos.writeChar(<span class="string">'\t'</span>) ;<span class="comment">// 写入分隔符</span></span><br><span class="line">                dos.writeInt(nums[i]) ; <span class="comment">// 写入数量</span></span><br><span class="line">                dos.writeChar(<span class="string">'\n'</span>) ;<span class="comment">// 换行</span></span><br><span class="line">                dos.flush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            dos.close();</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们直接用记事本打开demo.txt文件，会出现乱码现象。<br><img src="/2020/01/05/IO之字节流/20190113140753234.png" alt="在这里插入图片描述"><br>应该将使用DataOutputStream写入的数据通过DataInputStream读取出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建文件读取流</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"f:"</span> + File.separator + <span class="string">"demo.txt"</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            dis = <span class="keyword">new</span> DataInputStream(fis);</span><br><span class="line">            </span><br><span class="line">            String names = <span class="keyword">null</span>;<span class="comment">// 保存所有商品名称</span></span><br><span class="line">            <span class="keyword">float</span> price = <span class="number">0.0f</span> ;<span class="comment">// 接收价格</span></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">0</span> ;<span class="comment">// 接收数量</span></span><br><span class="line">            <span class="keyword">char</span> temp[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">200</span>];<span class="comment">// 存放商品名称缓冲区</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span> ;<span class="comment">// 保存读取数据的个数</span></span><br><span class="line">            <span class="keyword">char</span> c = <span class="number">0</span> ;<span class="comment">// '\u0000</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//1.初始化</span></span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//2.读取所有的商品名,一次循环读取一个名称</span></span><br><span class="line">                <span class="keyword">while</span>((c = dis.readChar()) != <span class="string">'\t'</span>) &#123;</span><br><span class="line">                    temp[len++] = c;</span><br><span class="line">                &#125;</span><br><span class="line">                names = <span class="keyword">new</span> String(temp, <span class="number">0</span>, len);</span><br><span class="line">                <span class="comment">//3.读取价格</span></span><br><span class="line">                price = dis.readFloat();</span><br><span class="line">                dis.readChar();<span class="comment">//读取\t</span></span><br><span class="line">                <span class="comment">//4.读取商品数量</span></span><br><span class="line">                num = dis.readInt();</span><br><span class="line">                dis.readChar() ;<span class="comment">// 读取\n</span></span><br><span class="line">                <span class="comment">//5.直接打印输出</span></span><br><span class="line">                System.out.printf(<span class="string">"名称：%s；价格：%5.2f；数量：%d\n"</span>,names,price,num) ;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            dis.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">名称：衬衣；价格：98.30；数量：3</span><br><span class="line">名称：手套；价格：30.30；数量：2</span><br><span class="line">名称：围巾；价格：50.50；数量：1</span><br></pre></td></tr></table></figure><h2 id="5-PrintStream"><a href="#5-PrintStream" class="headerlink" title="5. PrintStream"></a>5. PrintStream</h2><ol><li>PrintStream 是打印输出流，它继承于FilterOutputStream。是用来装饰其它输出流，它能为其他输出流添加了功能，使它们能够<strong>方便地打印各种数据值表示形式</strong>。</li><li>与其他输出流不同，PrintStream 永远<strong>不会抛出 IOException</strong>；它产生的IOException会被自身的函数所捕获并设置错误标记， 用户可以通过 checkError() 返回错误标记，从而查看PrintStream内部是否产生了IOException。</li><li>PrintStream 提供了<strong>自动flush 和 字符集设置功能</strong>。所谓自动flush，就是往PrintStream写入的数据会立刻调用flush()函数。</li><li>PrintStream能<strong>更为方便地输出数据到文件中</strong>。</li></ol><p>举个例子：<br>比如我们使用FileOutputStream向指定文件写入数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"F:\\a.txt"</span>);</span><br><span class="line">FileOutputStream outputStream = <span class="keyword">new</span> FileOutputStream(file,<span class="keyword">true</span>);<span class="comment">//第二个参数为追加文本</span></span><br><span class="line">outputStream.write(<span class="number">97</span>);</span><br></pre></td></tr></table></figure><p>上面的代码执行完之后，a.txt中的内容存的是a,因为write方法接收的为byte类型的数据，97对应的ASCII码为a。<br>假设我就想将97写入到文件中呢？那么得将第三行代码改为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">outputStream.write(<span class="string">"97"</span>.getBytes());<span class="comment">//先将97作为字符串再转换为byte数组</span></span><br></pre></td></tr></table></figure><p>而PrintStream的出现，使我们写数据到文件变得十分方便，你传入的是什么，就会给你写入什么数据。原因是其内部帮我们自动转换好了。</p><p>下面介绍其一些方法的简单使用：</p><h3 id="5-1-print方法"><a href="#5-1-print方法" class="headerlink" title="5.1 print方法"></a>5.1 print方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PrintStream ps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line">                <span class="comment">//指定编码，即对打印打印到文件中的数据进行UTF-8的编码</span></span><br><span class="line">                ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file), <span class="keyword">true</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">                <span class="comment">//print方法</span></span><br><span class="line">                <span class="comment">//将数据写入到"PrintStream输出流"中，print实际调用的是write函数</span></span><br><span class="line">                ps.print(<span class="string">"打印流数据1"</span>);</span><br><span class="line">                ps.print(<span class="string">"打印流数据2"</span>);</span><br><span class="line">                ps.print(<span class="keyword">true</span>);</span><br><span class="line">                ps.print(<span class="string">'a'</span>);</span><br><span class="line">                ps.print(<span class="number">5.2</span>);</span><br><span class="line">                ps.print(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果（demo.txt中的数据）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印流数据1打印流数据2truea5.25</span><br></pre></td></tr></table></figure><h3 id="5-2-println方法"><a href="#5-2-println方法" class="headerlink" title="5.2 println方法"></a>5.2 println方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PrintStream ps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line">                ps = <span class="keyword">new</span> PrintStream(<span class="keyword">new</span> FileOutputStream(file), <span class="keyword">true</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">                <span class="comment">//println方法</span></span><br><span class="line">                <span class="comment">//将数据+换行符写入到"PrintStream输出流"中，println实际调用的是write函数</span></span><br><span class="line">                ps.println(<span class="string">"打印流数据1"</span>);</span><br><span class="line">                ps.println(<span class="string">"打印流数据2"</span>);</span><br><span class="line">                ps.println(<span class="keyword">true</span>);</span><br><span class="line">                ps.println(<span class="string">'a'</span>);</span><br><span class="line">                ps.println(<span class="number">5.2</span>);</span><br><span class="line">                ps.println(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果（demo.txt中的数据）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">打印流数据1</span><br><span class="line">打印流数据2</span><br><span class="line">true</span><br><span class="line">a</span><br><span class="line">5.2</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="6-ObjectInputStream与ObjectOutputStream"><a href="#6-ObjectInputStream与ObjectOutputStream" class="headerlink" title="6. ObjectInputStream与ObjectOutputStream"></a>6. ObjectInputStream与ObjectOutputStream</h2><p>ObjectInputStream和ObjectInputStream类创建的对象被称为对象输入流和对象输出流。对象输出流可以将Java对象进行持久化存储，即<strong>实现对象的序列化</strong>。而对象输入流可以实现持久化<strong>对象的反序列化</strong>。<br>注意：被序列化的对象需要实现序列化接口Serializable。</p><p>假设需要对类User进行序列化并保存在user.dat文件中，然后再使用反序列化操作获取该类实例化对象。</p><p>User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;<span class="comment">//实现序列化接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, String gender, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", gender="</span> + gender + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的序列化与反序列化操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutputStream  fos;</span><br><span class="line">    <span class="keyword">private</span> ObjectOutputStream oos;</span><br><span class="line">    <span class="keyword">private</span> InputStream fis;</span><br><span class="line">    <span class="keyword">private</span> ObjectInputStream ois;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serializableObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.创建用于存储对象的文件</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">"f:"</span> + File.separator + <span class="string">"user.dat"</span>);</span><br><span class="line">                <span class="comment">//2.建立文件输出流</span></span><br><span class="line">                fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">                <span class="comment">//3.包装文件输出流</span></span><br><span class="line">                oos = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">                <span class="comment">//4.序列化user对象</span></span><br><span class="line">                oos.writeObject(<span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="string">"男"</span>,<span class="number">22</span>));</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//5.关闭流</span></span><br><span class="line">                oos.close();</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reSerializableObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.创建用于存储对象的文件</span></span><br><span class="line">                File file = <span class="keyword">new</span> File(<span class="string">"f:"</span> + File.separator + <span class="string">"user.dat"</span>);</span><br><span class="line">                <span class="comment">//2.建立文件输入流</span></span><br><span class="line">                fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">                <span class="comment">//3.包装文件输入流</span></span><br><span class="line">                ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line">                <span class="comment">//4.反序列化user对象</span></span><br><span class="line">                User user = (User) ois.readObject();</span><br><span class="line">                <span class="comment">//5.输出user的信息</span></span><br><span class="line">                System.out.println(user);<span class="comment">//User [name=张三, gender=男, age=22]</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//5.关闭流</span></span><br><span class="line">                ois.close();</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ObjectStreamDemo demo = <span class="keyword">new</span> ObjectStreamDemo();</span><br><span class="line">        demo.serializableObj();</span><br><span class="line">        demo.reSerializableObj();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>文末：字节流的一些常用类，暂时就简单总结到了，其他诸如序列流SequenceInputStream和管道流PipedInputStream等暂时就不去总结了。休息！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO之字符流</title>
      <link href="/2020/01/05/IO%E4%B9%8B%E5%AD%97%E7%AC%A6%E6%B5%81/"/>
      <url>/2020/01/05/IO%E4%B9%8B%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-总体结构"><a href="#1-总体结构" class="headerlink" title="1. 总体结构"></a>1. 总体结构</h2><p><img src="/2020/01/05/IO之字符流/20190112150210285.png" alt="在这里插入图片描述"><br>由于字节流操作中文不是特别方便，所以，java就提供了转换流。其中字符流就是字节流+编码表。字符流的两个顶层父类为Reader和Writer，分别用于字符流的读取和写入。下面分别来简单地介绍这些流的用法。</p><a id="more"></a><h2 id="2-InputStreamReader与OutputStreamWriter"><a href="#2-InputStreamReader与OutputStreamWriter" class="headerlink" title="2. InputStreamReader与OutputStreamWriter"></a>2. InputStreamReader与OutputStreamWriter</h2><h3 id="2-1-使用时机"><a href="#2-1-使用时机" class="headerlink" title="2.1 使用时机"></a>2.1 使用时机</h3><ol><li>源或者目的对应的设备是字节流，但是操作的却是文本数据的时候可以使用转换流作为桥梁，以提高对文本操作的便捷；</li><li>一旦操作的文本涉及到具体的指定编码表时，必须使用<strong>转换流</strong>。<h3 id="2-2-InputStreamReader-字符输入流"><a href="#2-2-InputStreamReader-字符输入流" class="headerlink" title="2.2 InputStreamReader 字符输入流"></a>2.2 InputStreamReader 字符输入流</h3>该类为转换流，实现了根据指定编码将字节数据到字符数据的转换（解码）。</li></ol><p><strong>构造方法</strong><br><img src="/2020/01/05/IO之字符流/20190113163529479.png" alt="在这里插入图片描述"><br>下面演示一下InputStreamReader的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.构建要读取的文件对象</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">"f:/demo.txt"</span>);</span><br><span class="line"><span class="comment">//2.建立输入流</span></span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line"><span class="comment">//3.按指定编码将字节数据转换为字符输入流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"Unicode"</span>);</span><br><span class="line"><span class="comment">//4.建立缓存区</span></span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//读到的字符数</span></span><br><span class="line"><span class="comment">//5.输出数据</span></span><br><span class="line"><span class="keyword">while</span>((num = isr.read(buf))!= -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, num));</span><br><span class="line">&#125;<span class="comment">//输出   演示InputStreamReader类</span></span><br><span class="line"><span class="comment">//6.关闭流</span></span><br><span class="line">isr.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p>我在本地f盘下的demo.txt文件以Unicode编码来保存文件数据，如下示：<br><img src="/2020/01/05/IO之字符流/20190113165240102.png" alt="在这里插入图片描述"><br>所以在InputStreamReader来读取该文件的数据时，必须以相同的编码Unicode去读取数据，即解码。否则会发生乱码的情况。</p><h3 id="2-3-OutputStreamWriter-字符输出流"><a href="#2-3-OutputStreamWriter-字符输出流" class="headerlink" title="2.3 OutputStreamWriter 字符输出流"></a>2.3 OutputStreamWriter 字符输出流</h3><p>该类为转换流，实现了根据指定编码将字符数据到字节数据的转换（编码）<br><strong>构造方法</strong><br><img src="/2020/01/05/IO之字符流/2019011316563930.png" alt="在这里插入图片描述"><br>下面演示一下OutputStreamWriter的使用（实现文件的复制）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.构建文件对象</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line">File desFile = <span class="keyword">new</span> File(<span class="string">"src/io/desFile.txt"</span>);</span><br><span class="line"><span class="comment">//2.建立输入输出字节流</span></span><br><span class="line">InputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">OutputStream fos = <span class="keyword">new</span> FileOutputStream(desFile);</span><br><span class="line"><span class="comment">//3.按指定编码将字节数据转换为字符输入输出流</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//4.建立缓冲区</span></span><br><span class="line"><span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//5.读取指定文件的数据并写入到指定文件之中</span></span><br><span class="line"><span class="keyword">while</span>((num = isr.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    osw.write(buf, <span class="number">0</span>, num);</span><br><span class="line">    osw.flush();<span class="comment">//刷新流</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.关闭流</span></span><br><span class="line">osw.close();</span><br><span class="line">isr.close();</span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h2 id="3-BufferedReader与BufferedWriter"><a href="#3-BufferedReader与BufferedWriter" class="headerlink" title="3. BufferedReader与BufferedWriter"></a>3. BufferedReader与BufferedWriter</h2><p>这两个类为字符缓冲流，在普通Reader或Writer的基础上，提供了缓冲功能，可以更加高效的读取和写入数据；</p><h3 id="3-1-BufferedReader"><a href="#3-1-BufferedReader" class="headerlink" title="3.1 BufferedReader"></a>3.1 BufferedReader</h3><h4 id="3-1-1-构造方法"><a href="#3-1-1-构造方法" class="headerlink" title="3.1.1 构造方法"></a>3.1.1 构造方法</h4><p><img src="/2020/01/05/IO之字符流/20190114092215411.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-常用方法"><a href="#3-1-2-常用方法" class="headerlink" title="3.1.2 常用方法"></a>3.1.2 常用方法</h4><ol><li>public int read() throws IOException<blockquote><p>读取单个字符。,如果已到达流末尾，则返回 -1</p></blockquote></li><li>public int read(char[] cbuf) throws IOException<blockquote><p>一次读取一个字节数组，读取的字符数，如果已到达流的末尾，则返回 -1 </p></blockquote><h5 id="3-1-2-1-特有方法"><a href="#3-1-2-1-特有方法" class="headerlink" title="3.1.2.1 特有方法"></a>3.1.2.1 特有方法</h5></li><li>public String readLine() throws IOException<blockquote><p>读取一个文本行。通过下列字符之一即可认为某行已终止：换行 (‘\n’)、回车 (‘\r’) 或回车后直接跟着换行。读取返回的字符串包含该行内容，不包含任何行终止符，如果已到达流末尾，则返回 null </p></blockquote><h5 id="3-1-2-2-基本用法"><a href="#3-1-2-2-基本用法" class="headerlink" title="3.1.2.2 基本用法"></a>3.1.2.2 基本用法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.构建字符读取流对象</span></span><br><span class="line">        isr = <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"src/io/demo.txt"</span>));</span><br><span class="line">        <span class="comment">//2.包装成字符缓冲读取流</span></span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        <span class="comment">//3.一次去读一行数据</span></span><br><span class="line">        String content = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((content = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//4.直接输出数据</span></span><br><span class="line">            System.out.println(content);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.关闭包装流，其实关闭的就是被缓冲的流对象isr</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-2-BufferedWriter"><a href="#3-2-BufferedWriter" class="headerlink" title="3.2 BufferedWriter"></a>3.2 BufferedWriter</h3><h4 id="3-2-1-构造方法"><a href="#3-2-1-构造方法" class="headerlink" title="3.2.1 构造方法"></a>3.2.1 构造方法</h4><p><img src="/2020/01/05/IO之字符流/20190114094033400.png" alt="在这里插入图片描述"></p><h4 id="3-2-2-常用方法"><a href="#3-2-2-常用方法" class="headerlink" title="3.2.2 常用方法"></a>3.2.2 常用方法</h4><p><img src="/2020/01/05/IO之字符流/20190114094133827.png" alt="在这里插入图片描述"><br>注意：不同的操作系统有些换行符号是不一样的，比如Windows的换行符是’\r\n’，而有的是’\n’。为了是代码的复用性和移植性更好，可以使用BufferedWriter的特有方法newLine写入一个换行符。</p><h5 id="3-2-2-1-基本用法"><a href="#3-2-2-1-基本用法" class="headerlink" title="3.2.2.1 基本用法"></a>3.2.2.1 基本用法</h5><p>下面实现在控制台输入一行数据后直接输出打印在控制台上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line">InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader bufr = <span class="keyword">null</span>;</span><br><span class="line">OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bufw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">//复杂捕获异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//复杂关闭流</span></span><br><span class="line">        <span class="comment">//1.创建从控制台来的字节输入流</span></span><br><span class="line">        in = System.in;</span><br><span class="line">        <span class="comment">//2.将字节输入流转换为字符输入流</span></span><br><span class="line">        isr = <span class="keyword">new</span> InputStreamReader(in);</span><br><span class="line">        <span class="comment">//3.对字符流进行高效装饰，即加缓冲区</span></span><br><span class="line">        bufr = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        <span class="comment">//4.读取一行数据</span></span><br><span class="line">        String line = bufr.readLine();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.创建输出到控制台的字节输出流</span></span><br><span class="line">        out = System.out;</span><br><span class="line">        <span class="comment">//6.将字节输出流转换为字符输出流</span></span><br><span class="line">        osw = <span class="keyword">new</span> OutputStreamWriter(out);</span><br><span class="line">        <span class="comment">//7.对对字符流进行高效装饰，即加缓冲区</span></span><br><span class="line">        bufw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">        <span class="comment">//8.写入一行数据</span></span><br><span class="line">        bufw.write(line);</span><br><span class="line">        bufw.flush();<span class="comment">//刷新</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//9.仅关闭流包装流就可以了，其他的流对象也会被关闭</span></span><br><span class="line">        bufw.close();</span><br><span class="line">        bufr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/IO之字符流/2019011410003448.png" alt="在这里插入图片描述"></p><h2 id="4-FileReader与FileWriter"><a href="#4-FileReader与FileWriter" class="headerlink" title="4. FileReader与FileWriter"></a>4. FileReader与FileWriter</h2><h3 id="4-1-FileReader"><a href="#4-1-FileReader" class="headerlink" title="4.1 FileReader"></a>4.1 FileReader</h3><p>FileReader类从InputStreamReader类继承而来。该类按字符读取流中数据。其是用来方便的从文件中读出字符的类，带有默认编码和默认缓冲区大小。如果要改变默认编码和默认缓冲区大小可以用FileInputStream来构造InputStreamReader来实现。</p><h4 id="4-1-1-构造方法"><a href="#4-1-1-构造方法" class="headerlink" title="4.1.1 构造方法"></a>4.1.1 构造方法</h4><p><img src="/2020/01/05/IO之字符流/20190114102039886.png" alt="在这里插入图片描述"></p><h4 id="4-1-2-常用方法"><a href="#4-1-2-常用方法" class="headerlink" title="4.1.2 常用方法"></a>4.1.2 常用方法</h4><p><img src="/2020/01/05/IO之字符流/20190114103133211.png" alt="在这里插入图片描述"></p><h5 id="4-1-2-1-基本用法"><a href="#4-1-2-1-基本用法" class="headerlink" title="4.1.2.1 基本用法"></a>4.1.2.1 基本用法</h5><p>下面演示下读取一个文本文件，然后将读取到的字符打印在控制台上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.构建要读取的文件对象</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>);</span><br><span class="line">        <span class="comment">//2.建立字符读取流</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(srcFile);</span><br><span class="line">        <span class="comment">//3.读取数据</span></span><br><span class="line">        <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];<span class="comment">//缓冲区</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//读取到的字符数</span></span><br><span class="line">        <span class="comment">//一次读取一个字节数组的数据，如果流已到达末尾则返回-1</span></span><br><span class="line">        <span class="keyword">while</span>((num = fr.read(buf))!= -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//4.直接输出数据</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, num));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.关闭流</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-FileWriter"><a href="#4-2-FileWriter" class="headerlink" title="4.2 FileWriter"></a>4.2 FileWriter</h3><p>FileWriter 类从 OutputStreamWriter 类继承而来。该类按字符向流中写入数据。这个类默认带有字符编码方式和缓冲区大小，如果要改变指定编码和缓冲区大小可以用FileOutputStream来构造一个OutputStreamWriter来实现。</p><h4 id="4-2-1-构造方法"><a href="#4-2-1-构造方法" class="headerlink" title="4.2.1 构造方法"></a>4.2.1 构造方法</h4><p><img src="/2020/01/05/IO之字符流/20190114103509153.png" alt="在这里插入图片描述"></p><h4 id="4-2-2-常用方法"><a href="#4-2-2-常用方法" class="headerlink" title="4.2.2 常用方法"></a>4.2.2 常用方法</h4><table><thead><tr><th align="left">方法说明</th></tr></thead><tbody><tr><td align="left"><strong>public  void write(int c)</strong><br> 写入当个字符c。</td></tr><tr><td align="left"><strong>public void write(char[] c,  int offset,  int len)</strong><br>写入字符数组中开始为offset长度为len的某一部分。</td></tr><tr><td align="left"><strong>public void write(String s, int offset, int len)</strong><br>写入字符串中开始为offset长度为len的某一部分。</td></tr><tr><td align="left"><strong>public void flush()</strong><br>刷新流，将数据直接写入目的地中</td></tr></tbody></table><h5 id="4-2-2-1基本用法"><a href="#4-2-2-1基本用法" class="headerlink" title="4.2.2.1基本用法"></a>4.2.2.1基本用法</h5><p>下面实现文件的复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.构建文件字符输入流</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>));</span><br><span class="line">        <span class="comment">//2.缓冲流包装</span></span><br><span class="line">        BufferedReader bufr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">        <span class="comment">//3.构建文件字符输出流，第二个参数为true实现数据追加</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"src/io/desFile.txt"</span>),<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//4.缓冲流包装</span></span><br><span class="line">        BufferedWriter bufw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">        <span class="comment">//5.读取一行数据</span></span><br><span class="line">        String content = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((content = bufr.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//6.写入一行数据</span></span><br><span class="line">            bufw.write(content);</span><br><span class="line">            bufw.newLine();<span class="comment">//加一个换行符</span></span><br><span class="line">            <span class="comment">//7.刷新缓冲区</span></span><br><span class="line">            bufw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7.关闭流</span></span><br><span class="line">        bufw.close();</span><br><span class="line">        bufr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-LineNumberReader"><a href="#5-LineNumberReader" class="headerlink" title="5. LineNumberReader"></a>5. LineNumberReader</h2><blockquote><p>跟踪行号的缓冲字符输入流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.LineNumberReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineNumberReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LineNumberReader lnr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//1.构建字符读取流</span></span><br><span class="line">                FileReader fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">"src/io/demo.txt"</span>));</span><br><span class="line">                <span class="comment">//2.构建跟踪行号的缓冲字符输出流</span></span><br><span class="line">                lnr = <span class="keyword">new</span> LineNumberReader(fr);</span><br><span class="line">                <span class="comment">//3.读取数据并输出当前行号</span></span><br><span class="line">                lnr.setLineNumber(<span class="number">2</span>);<span class="comment">//设置当前行号为2，默认为0</span></span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line=lnr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(lnr.getLineNumber()+<span class="string">":"</span>+line);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//4.关闭流</span></span><br><span class="line">                lnr.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中demo.txt的内容如下：<br><img src="/2020/01/05/IO之字符流/20190114112551862.png" alt="在这里插入图片描述"><br>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3:演示LineNumberReader类演示LineNumberReader类</span><br><span class="line">4:演示LineNumberReader类 演示LineNumberReader类</span><br><span class="line">5:演示LineNumberReader类</span><br></pre></td></tr></table></figure><p>注意：setLineNumber()能改变行号，却不能改变读的位置</p><h2 id="6-PrintWriter"><a href="#6-PrintWriter" class="headerlink" title="6. PrintWriter"></a>6. PrintWriter</h2><p>该类用于向文本输出流打印对象的<strong>格式化</strong>表示形式。此类实现在 PrintStream 中的所有 print 方法，且此类中的方法不会抛出 I/O 异常。</p><h3 id="6-1-构造方法"><a href="#6-1-构造方法" class="headerlink" title="6.1 构造方法"></a>6.1 构造方法</h3><table><thead><tr><th align="left"></th></tr></thead><tbody><tr><td align="left"><strong>PrintWriter(File file)</strong> <br>使用指定文件创建不具有自动行刷新的新 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(File file, String csn)</strong> <br> 创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(OutputStream out)</strong> <br>根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(OutputStream out, boolean autoFlush)</strong> <br>  通过现有的 OutputStream 创建新的 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(String fileName)</strong>  <br> 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(String fileName, String csn)</strong> <br>创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(Writer out)</strong> <br>创建不带自动行刷新的新 PrintWriter。</td></tr><tr><td align="left"><strong>PrintWriter(Writer out, boolean autoFlush)</strong>  <br>创建带自动行刷新的新 PrintWriter。</td></tr></tbody></table><h3 id="6-2-基本用法"><a href="#6-2-基本用法" class="headerlink" title="6.2 基本用法"></a>6.2 基本用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">PrintWriter pw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.构建字符打印流</span></span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">"src/io/desFile.txt"</span>));</span><br><span class="line">        pw = <span class="keyword">new</span> PrintWriter(fw, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.向指定文件写入内容</span></span><br><span class="line">        String content1 = <span class="string">"这是写入到desFile.txt中的数据内容"</span>;</span><br><span class="line">        String content2 = <span class="string">"这是补充的内容"</span>;</span><br><span class="line">        pw.println(content1);</span><br><span class="line">        pw.println(content2);</span><br><span class="line">        pw.flush();<span class="comment">//刷新</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//2.关闭流</span></span><br><span class="line">        pw.close();</span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/01/05/IO之字符流/20190114114451162.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之动态代理</title>
      <link href="/2020/01/05/Java%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/01/05/Java%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在Java中有种动态代理技术，比如JDK，CGLIB，Javassist，ASM，其中最常用的动态代理有两种：一种JDK动态代理，这是JDK自带的功能；另一种CGLIB，这是第三方提供的一个技术。目前，Spring常用JDK和CGLIB，而MyBatis还使用了Javassist，无论哪种代理其技术和理念都是相似的。</p><p>下面讲一下常用的JDK动态代理和CGLIB动态代理。</p><a id="more"></a><h2 id="1-JDK动态代理"><a href="#1-JDK动态代理" class="headerlink" title="1. JDK动态代理"></a>1. JDK动态代理</h2><p>JDK动态代理必须借助一个接口才能产生代理对象，所以先定义一个接口，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后提供实现类HelloWorldIMpl来实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着要建立代理对象和真实对象HelloWorldImpl的关系，然后实现代理逻辑，通过JdkProxyExample类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//真实对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立代理对象和真实对象的代理关系，并返回代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理方法逻辑</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method 当前调度方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args 当前方法的参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 代理结果返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Throwable 异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入代理逻辑方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"在调度真实对象之前的服务"</span>);</span><br><span class="line">        Object obj = method.invoke(target, args);<span class="comment">//相当于调用sayHelloWorld方法</span></span><br><span class="line">        System.out.println(<span class="string">"在调度真实对象之后的服务"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了bind方法去完成代理对象和真实对象之间关系的建立。方法里面首先使用类的属性target去保存真实对象，然后通过如下代码建立并生成代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>其中newProxyInstance方法包含3个参数。</p><ul><li>第一个参数为类加载器，我们采用了target本身的类加载器。</li><li>第二个参数是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在target实现的接口下，getInterfaces可以获取target所实现的所有的接口。</li><li>第三个是定义实现方法逻辑的<strong>代理类</strong>，this表示当前对象，它必须实现InvocationHandler接口的invoke方法，它就是代理逻辑方法的现实方法。</li></ul><p>另外，使用到了invoke方法来实现代理逻辑方法。invoke方法的三个参数的含义如下：</p><ul><li>proxy，代理对象，就是bind方法生成的对象。</li><li>method，当前调度的方法。</li><li>args，调度方法的参数。</li></ul><p>测试JDK动态代理，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJdkProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JdkProxyExample jdkProxy = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line">    <span class="comment">//绑定关系，因为挂在接口HelloWorld下，所以声明代理对象HelloWorld proxy</span></span><br><span class="line">    HelloWorld proxy = (HelloWorld) jdkProxy.bind(<span class="keyword">new</span> HelloWorldImpl());</span><br><span class="line">    <span class="comment">//注意，此时HelloWorld对象proxy已经是一个代理对象，它会进入代理的逻辑方法invoke里</span></span><br><span class="line">    proxy.sayHelloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进入代理逻辑方法</span><br><span class="line">在调度真实对象之前的服务</span><br><span class="line">Hello World!</span><br><span class="line">在调度真实对象之后的服务</span><br></pre></td></tr></table></figure><p>代码的实际运行是首先调用jdkProxy代理逻辑类对象的bind方法生成真实对象HelloWolrdImpl的代理对象proxy。该代理对象和HelloWolrdImpl一样同属于HelloWorld接口下，我们便可调用HelloWorld接口定义的方法。当我们调用sayHelloWorld时，实际是调用代理对象proxy的invoke方法，具体你步骤如下：<br><img src="/2020/01/05/Java之动态代理/201901251547376.png" alt="在这里插入图片描述"><br>也就是先打印输出，然后<strong>通过method.invoke方法调用真实对象HelloWolrdImpl的sayHelloWorld方法，</strong> 然后在打印输出信息，当然我们可以在调用真实的对象的方法前后，可以调用执行我们自定义的方法，这也是代理的作用。</p><h2 id="2-CGLIB动态代理"><a href="#2-CGLIB动态代理" class="headerlink" title="2. CGLIB动态代理"></a>2. CGLIB动态代理</h2><p>JDK动态代理必须提供接口才能使用，在一些不能提供接口的环境中，只能采用其他第三方技术，比如CGLIB动态代理。<strong>它的优势在于不需要提供接口，只要一个非抽象类就可以实现的动态代理。</strong></p><p>下面演示一下CGLIB动态代理的使用：</p><p>首先需要搭建好环境，使用CGLIB动态代理需要使用使用两个Jar。如下所示：<br><img src="/2020/01/05/Java之动态代理/20190125162838223.png" alt="在这里插入图片描述"><br>接口创建HelloWorld类，也就是需要产生代理对象的真实对象。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后需要创建一个代理逻辑类，用于产生代理对象并实现代理逻辑方法，它需要实现MethodInterceptor接口的intercepter方法。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyExample</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成CGLIB代理对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clsClass类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>Class类的CGLIB代理对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//CGLIB enhancer增强类对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置增强类型，这里的cls即为要生成代理对象的真实对象的Class</span></span><br><span class="line">        enhancer.setSuperclass(cls);</span><br><span class="line">        <span class="comment">//定义代理逻辑对象为当前对象，要求当前对象实现MethodInterceptor方法</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//生成并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用真实对象方法前执行"</span>);</span><br><span class="line">        <span class="comment">//CGLIB反射调用真实对象方法</span></span><br><span class="line">        Object obj = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"调用真实对象方法后执行"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要说明的是，这里用到了CGLIB的加强者Enhancer，通过设置超类的方法（setSuperclass），然后通过setCallBack方法设置那个类为它的代理类。其他的详见注释。</p><p>最后我们测试一下CGLIB动态代理，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCglib</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CglibProxyExample proxyExample = <span class="keyword">new</span> CglibProxyExample();</span><br><span class="line">    HelloWorld proxy = (HelloWorld) proxyExample.getProxy(HelloWorld.class);</span><br><span class="line">    proxy.sayHelloWorld();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用真实对象方法前执行</span><br><span class="line">Hello World!</span><br><span class="line">调用真实对象方法后执行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="/2020/01/05/final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2020/01/05/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-含义"><a href="#1-含义" class="headerlink" title="1. 含义"></a>1. 含义</h2><p>final 表面意思就是<strong>不可更改的,恒量的意思</strong>。final 修饰的变量与静态变量是有所不同的，静态变量指的是只有一份存储空间，值是可以改变的，而 final 修饰的变量是不可更改的。</p><h2 id="2-修饰类"><a href="#2-修饰类" class="headerlink" title="2. 修饰类"></a>2. 修饰类</h2><p>当用 final 修饰一个类时，表明这个<strong>类不能被继承</strong>。其中，final 类中的所有<strong>成员方法</strong>都会被隐式地指定为 final 方法，而 final 类中的成员属性则不会有隐式的 final 修饰，这也恰恰说明 final 类的成员变量是可以更改的。</p><a id="more"></a><h2 id="3-修饰方法"><a href="#3-修饰方法" class="headerlink" title="3. 修饰方法"></a>3. 修饰方法</h2><p> final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此<strong>方法不能被重写</strong>。</p><p>注意：因为重写的前提是子类可以从父类中继承此方法，如果父类中 final 修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法。因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（类的 private 方法会隐式地被指定为 final 方法。）示例如下：</p><p>父类 Father 的具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//final 修饰， 访问控制权限为 private</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fmethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father ... fmethod1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fmethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father ... fmethod2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 Son 的具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与父类的私有方法 fmethod1相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fmethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fmethod1</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fmethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.fmethod2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-修饰变量"><a href="#4-修饰变量" class="headerlink" title="4. 修饰变量"></a>4. 修饰变量</h2><p>final 修饰的变量必须要初始化，赋初值后不能再重新赋值。初始化可以以三种方式：</p><ol><li>定义时初始化；</li><li>在构造方法中初始化；</li><li>在代码块中为 final 实例变量初始化。</li></ol><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 定义时初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">45</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 构造方法中初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FinalDemo</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 代码块中初始化</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line">&#123;</span><br><span class="line">    b = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当final修饰一个<strong>基本数据类型</strong>时，表示该基本数据类型的值一旦在初始化后便<strong>不能发生变化</strong>；如果final修饰一个<strong>引用数据类型</strong>时，则在对其初始化之后便<strong>不能再让其指向其他对象了</strong>，但该引用所指向的对象的内容是可以发生变化的。</p><h2 id="5-修饰参数"><a href="#5-修饰参数" class="headerlink" title="5. 修饰参数"></a>5. 修饰参数</h2><p>与使用 final 修饰变量相似，在方法参数列表中被 final 修饰的基本数据类型参数在方法体内是不可以被更改的，如果是引用数据类型则不可以指向其他对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> i, <span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//The final local variable i cannot be assigned. </span></span><br><span class="line">    <span class="comment">//It must be blank and not using a compound assignment</span></span><br><span class="line">    <span class="comment">//i++; 编译出错</span></span><br><span class="line">    <span class="comment">//str = ""; 编译出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 8 接口新特性</title>
      <link href="/2020/01/05/Java-8-%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2020/01/05/Java-8-%E6%8E%A5%E5%8F%A3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-静态方法"><a href="#1-静态方法" class="headerlink" title="1. 静态方法"></a>1. 静态方法</h3><p> 在 Java 8 中，允许在接口中增加静态方法。理论上讲，这是合法的，只是这有违于将接口作为抽象的初衷。</p><p>目前为止，通常的做法是将静态方法放在伴随类中，比如标准库中，有成对出现的接口和对应工具类，如Path/Paths，Colletion/Collections。</p><p>比如我们可以在 Path 接口增加 Paths 实现类中的一些方法，如如下 get 方法：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Path</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">get</span><span class="params">(String first, String... more)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FileSystems.getDefault().getPath(first, more);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，Paths 类就不再必要了。当然在标准库中都以这种方式来重构不太可能，我们在实现自定义的接口时，可以在接口中定义静态方法而不用另外实现一个伴随类。</p><h3 id="2-默认方法"><a href="#2-默认方法" class="headerlink" title="2. 默认方法"></a>2. 默认方法</h3><p>我们可以在接口与方法中定义默认方法，必须要用 default 修饰符去修饰该默认方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，默认方法也可以调用<strong>任何</strong>其他方法，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person eat"</span>);</span><br><span class="line">        say();<span class="comment">//子类调用 eat 方法时会调用接口静态方法 say</span></span><br><span class="line">        running();<span class="comment">//子类调用 eat 方法时并调用其实现方法 running</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">running</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认方法出现的原因是为了对原有接口的扩展，有了默认方法之后就不怕因改动原有的接口而对已经使用这些接口的程序造成的代码不兼容的影响。这个重要用法即是“接口演化”( interface evolution)。</p><p>比如以Collection接口为例，假设之前你提供了这样一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> <span class="keyword">implements</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Java 8 之后，又为 Collection 接口增加了一个 stream 方法，假设该方法不是默认方法，那么之前实现的类 Bag 需要去实现该方法并重新编译。但是如果该 stream 方法是默认方法，我们不需要去修改 Bag 类，同时还可以使用 Bag 的对象去调用 stream 方法。</p><h3 id="3-解决默认方法冲突"><a href="#3-解决默认方法冲突" class="headerlink" title="3. 解决默认方法冲突"></a>3. 解决默认方法冲突</h3><h4 id="3-1-超类优先"><a href="#3-1-超类优先" class="headerlink" title="3.1 超类优先"></a>3.1 超类优先</h4><p>如果先在一个接口中定义了一个默认方法，然后又在超类中定义了一个同样的方法，会发生什么情况呢？Java 定义了如下规则：</p><ul><li>超类优先：如果一个超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li></ul><p>比如，现在定义有一个超类 Father：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有一个接口 Person 也实现了一个与类 Father 的 eat 方法一样的默认方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个 Son 类，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//超类优先，调用父类的 eat方法</span></span><br><span class="line">        son.eat();<span class="comment">//Father eat</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于遵循超类优先原则，son 对象会调用父类的 eat 方法而不是接口 Person 中的默认方法。</p><h4 id="3-2-接口冲突"><a href="#3-2-接口冲突" class="headerlink" title="3.2 接口冲突"></a>3.2 接口冲突</h4><p>现在可能会出现另外一种冲突情况，比如有一个子类实现了两个接口，这两个接口中有两个一样的默认方法，我们可以通过覆盖这个方法来解决冲突。</p><p>比如有如下两个接口，它们具有相同的默认方法 eat ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"People eat.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//调用被覆盖的接口的 eat 方法</span></span><br><span class="line">        son.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//覆盖People中的 eat 默认方法</span></span><br><span class="line"><span class="comment">//People.super.eat();</span></span><br><span class="line">        <span class="comment">//覆盖Person中的 eat 默认方法</span></span><br><span class="line">        Person.<span class="keyword">super</span>.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>son 对象调用的 eat 方法会根据其覆盖的方法 eat 中的具体调用来决定。</p><p>假设 People 类中没有定义默认方法而是声明了一个与 Person 接口一样的 eat 方法的情况呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Son类是不会从 Person接口继承默认方法的。为了强调一致性，我们还是要覆盖 eat 方法的，如重写 Person 中的 eat 方法或实现 People中的 eat 方法。具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Person</span>, <span class="title">People</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        <span class="comment">//调用被覆盖的 eat 方法</span></span><br><span class="line">        son.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">public void eat() &#123;</span></span><br><span class="line"><span class="comment">System.out.println("实现 People 接口中的 eat方法");</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用 Person中的默认方法</span></span><br><span class="line">        Person.<span class="keyword">super</span>.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDK8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java之Lambda表达式</title>
      <link href="/2020/01/05/Java%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/01/05/Java%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lambda-表达式入门"><a href="#1-Lambda-表达式入门" class="headerlink" title="1. Lambda 表达式入门"></a>1. Lambda 表达式入门</h2><p>Lambda 表达式支持将代码块作为方法参数， Lambda 表达式允许使用更简洁的代码来创建只有一个抽象方法的接口（这种接口被称为函数式接口）的实例。</p><a id="more"></a><p>我们来看一个示例，使用Comparator自定义比较器实现字符串按长度进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按字符串长度进行排列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        String[] strArr = &#123;<span class="string">"abc"</span>, <span class="string">"sd"</span>, <span class="string">"sf"</span>, <span class="string">"sgfhd"</span>, <span class="string">"sdjg"</span>&#125;;</span><br><span class="line">        Arrays.sort(strArr, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//输出：[sd, sf, abc, sdjg, sgfhd]</span></span><br><span class="line">        System.out.println(Arrays.toString(strArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们为了传入一个Comparator实例使用到了匿名内部类，但是我们可以使用Lambda表达式来创建简化的匿名内部类对象，可以改写为如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按字符串长度进行排列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        String[] strArr = &#123;<span class="string">"abc"</span>, <span class="string">"sd"</span>, <span class="string">"sf"</span>, <span class="string">"sgfhd"</span>, <span class="string">"sdjg"</span>&#125;;</span><br><span class="line">        Arrays.sort(strArr, (o1, o2) -&gt; o1.length() - o2.length());</span><br><span class="line">        <span class="comment">//输出：[sd, sf, abc, sdjg, sgfhd]</span></span><br><span class="line">        System.out.println(Arrays.toString(strArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-语法"><a href="#1-1-语法" class="headerlink" title="1.1 语法"></a>1.1 语法</h3><p>Lambda 由如下三部分组成：</p><ol><li>形参列表：形参列表允许省略形参类型。如果形参列表中只有一个参数，同时还可以省略形参列表的圆括号。如果 lambda 表达式没有参数，则仍要提供空括号，就像无参方法一样。</li><li>箭头（-&gt;）：必须通过英文中划线和大于符号组成。</li><li>代码块：如果代码块只包含一条语句，Lambda 表达式允许省略代码块的花括号，那么这条语句就不要用花括号表示语句结束。无需指定 Lambda 表达式的返回类型，Lambda 表达式的返回类型总是会由上下文推导得出。</li></ol><p><strong>注意：</strong> 如果一个 lambda 表达式只在某些分支返回一个值，而在另外一些分支不返回值，这是不合法的。例如，(int x) -&gt; {if (x &gt;= 0) return 1;}</p><p>下面程序示范了 Lambda 表达式的几种简化写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaQs</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用该方法需要 Eatable 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        e.taste();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用该方法需要 Flyable 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在驾驶："</span> + f);</span><br><span class="line">        f.fly(<span class="string">"【碧空如洗的晴日】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用该方法需要 Addable 对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"5 与 3 的和为："</span> + a.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LambdaQs qs = <span class="keyword">new</span> LambdaQs();</span><br><span class="line">        <span class="comment">/* lambda 表达式没有参数，需保留括号。</span></span><br><span class="line"><span class="comment"> * 表达式中的代码块只有一条语句，可省略括号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        qs.eat(() -&gt; System.out.println(<span class="string">"苹果的味道不错！"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//lambda表达式的形参列表只有一个形参，可以省略圆括号</span></span><br><span class="line">        qs.drive(weather -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"今天天气是："</span> + weather);</span><br><span class="line">            System.out.println(<span class="string">"直升机飞行平稳"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 形参列表允许省略形参类型</span></span><br><span class="line"><span class="comment"> * 只有一条语句，可以省略花括号；</span></span><br><span class="line"><span class="comment"> * 可以省略return 语句</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        qs.test((a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h2><p>Lambda 表达式的类型，也被称为“目标类型（target tye）”，Lambda 表达式的目标类型必须是“函数式接口（functional interface）”。<strong>函数式接口代表只包含一个抽象方法的接口</strong>。函数式接口可以包含多个默认方法、静态方法，但只能声明一个抽象方法。</p><p>正如上述示例中的 Eatable、Flyable 和 Addable 都为函数式接口，它们都只有一个抽象方法。Java 8 API 有大量的函数式接口，例如：Runnable、ActionListener等接口。</p><p><strong>提示</strong>：我们可以使用注解 @FunctionalInterface 来标记一个接口为函数式接口。该注解对程序功能没有任何作用，它用于告诉编译器执行更严格检查 — 检查该接口必须是函数式接口，否则编译器就会报错。</p><p>如在上述示例的 Eatable接口中我们可以使用注解@FunctionalInterface 来标记它是一个函数式接口，当我们在该接口多声明一个方法时编译器则会报错。<br><img src="/2020/01/05/Java之Lambda表达式/20190326101428301.png" alt="在这里插入图片描述"></p><hr><p>由于Lambda表达式具有类型（函数式接口类型），其本质是实现某个函数式接口的对象实例，我们<strong>可以使用 Lambda 表达式进行赋值操作</strong>。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将Lambda表达式赋值给一个函数式接口 Rannable</span></span><br><span class="line">        Runnable r = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">                System.out.println(<span class="string">"你好"</span> + i);</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lambda 表达式的目标类型必须是明确的函数式接口</strong>，比如下面的操作便是不合法的，因为Object不是函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object obj = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        System.out.println(<span class="string">"你好"</span> + i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然我们可以使用强制类型转换的方式，使其可以赋值给一个Object对象，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Lambda表达式赋值给一个函数式接口 Rannable</span></span><br><span class="line">Object r = (Runnable)() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        System.out.println(<span class="string">"你好"</span> + i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前面已经说过，Lambda表达式其本质是实现某个函数式接口的对象实例，由于多态特性，我们便可以将其强转赋值给Object对象。</p><p>假设现在定义有如下函数式接口，其唯一的抽象方法具有和Runnable 接口的run方法一样的参数列表，这里即都是无参的函数 run。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的 Lambda 表达式可以被当成不同的目标类型，唯一的要求是Lambda 表达式的形参类型列表与函数式接口唯一的抽象方法的形参列表相同。下述代码是正确的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object f = (FkTest)() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        System.out.println(<span class="string">"你好"</span> + i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>java.util.function 包下预定义大量函数式接口，比如有如下一个很有用的函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="comment">// addtitonal default and static method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayLIst 类有一个 removeIf方法，它的参数就是一个Predicate。这个接口专门用来传递lambda表达式的。例如下面的语句将从一个ArrayList中删除所有的null值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.removeIf(e -&gt; e == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h2><p>如果 <strong>lambda 表达式的代码块只有一条代码</strong>，除了可以省略花括号，我们还可以在代码块中使用方法引用和构造器引用。方法的引用和构造器的引用都需要使用两个英文冒号“<strong>::</strong>”。</p><table><thead><tr><th align="left">种类</th><th align="left">示例</th><th align="left">说明</th><th align="left">对应的 Lambda 表达式</th></tr></thead><tbody><tr><td align="left">引用类方法</td><td align="left">类名::静态方法</td><td align="left">函数式接口中被实现方法的全部参数传给该静态方法作为参数</td><td align="left">(a,b,…) -&gt; 类名.静态方法(a,b,…)</td></tr><tr><td align="left">引用特定对象的实例方法</td><td align="left">特定对象::实例方法</td><td align="left">函数式接口中被实现方法的全部参数传给该方法作为参数</td><td align="left">(a,b,…) -&gt; 特定对象.实例方法(a,b,…)</td></tr><tr><td align="left">引用某类的实例方法</td><td align="left">类名::实例方法</td><td align="left">函数式接口中被实现方法的第一个参数作为调用者，后面的参数全部传给该方法作为参数</td><td align="left">(a,b,…) -&gt; a.实例方法(b,…)</td></tr><tr><td align="left">引用构造器</td><td align="left">类名::new</td><td align="left">函数式接口中被实现方法的全部参数传给该构造器作为参数</td><td align="left">(a,b,…) -&gt; new 类名(a,b,…)</td></tr></tbody></table><h3 id="3-1-引用静态方法"><a href="#3-1-引用静态方法" class="headerlink" title="3.1 引用静态方法"></a>3.1 引用静态方法</h3><p>假设定义有如下函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//负责将String 参数转换为 Integer</span></span><br><span class="line">    <span class="function">Integer <span class="title">convert</span><span class="params">(String from)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用Lambda 表达式来创建一个 Converter对象，并调用其 convert 方法实现字符到Integer的转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaStaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//旧版</span></span><br><span class="line"><span class="comment">//Converter converter = new Converter() &#123;</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public Integer convert(String from) &#123;</span></span><br><span class="line"><span class="comment">//return Integer.valueOf(from);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line">        <span class="comment">//Lambda 表达式形式</span></span><br><span class="line">        Converter converter = from -&gt; Integer.valueOf(from);</span><br><span class="line">        Integer num = converter.convert(<span class="string">"99"</span>);</span><br><span class="line">        System.out.println(num + <span class="number">1</span>);<span class="comment">//100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面Lambda 表达式只有一行调用静态方法 valueOf 的代码，因此可以使用如下方法引用进行替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaStaticMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Converter converter = Integer::valueOf;</span><br><span class="line">        Integer num = converter.convert(<span class="string">"99"</span>);</span><br><span class="line">        System.out.println(num + <span class="number">1</span>);<span class="comment">//100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：valueOf方法中的参数列表是省略的，如果Integer类中有多个同名方法，具体的方法调用会根据函数式接口中的抽象方法的参数列表来决定。</p><h3 id="3-2-引用特定对象的实例方法"><a href="#3-2-引用特定对象的实例方法" class="headerlink" title="3.2 引用特定对象的实例方法"></a>3.2 引用特定对象的实例方法</h3><p>假设定义有如下函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IndexGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取子串在字符串中出现的下标</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIndexOfSubStr</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用Lambda 表达式来创建一个 IndexGetter 对象，并调用其 getIndexOfSubStr 方法获取子串在字符串中出现的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IndexGetter indexGetter = str -&gt; <span class="string">"how to do?"</span>.indexOf(str);</span><br><span class="line">        <span class="keyword">int</span> index = indexGetter.getIndexOfSubStr(<span class="string">"to"</span>);</span><br><span class="line">        System.out.println(index);<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们完全可以将如下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndexGetter indexGetter = str -&gt; <span class="string">"how to do?"</span>.indexOf(str);</span><br></pre></td></tr></table></figure><p>替换成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndexGetter indexGetter = <span class="string">"how to do?"</span>::indexOf;</span><br></pre></td></tr></table></figure><p>对于上述的实例方法引用，也就是调用”how to do?”字符串对象的indexOf()实例方法来实现函数式接口 IndexGetter中的唯一抽象接口 getIndexOfSubStr。</p><h3 id="3-3-引用某类对象的实例方法"><a href="#3-3-引用某类对象的实例方法" class="headerlink" title="3.3 引用某类对象的实例方法"></a>3.3 引用某类对象的实例方法</h3><p>假设定义有如下函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubStrGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取str中从s-(e-1)的子串</span></span><br><span class="line">    <span class="function">String <span class="title">getSubStr</span><span class="params">(String str, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用Lambda 表达式来创建一个 SubStrGetter 对象，并调用其 getSubStr 方法获取字符串中指定范围的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInstance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//SubStrGetter subStrGetter = (str, s, e) -&gt; str.substring(s, e);</span></span><br><span class="line">        SubStrGetter subStrGetter = String::substring;</span><br><span class="line">        String subStr = subStrGetter.getSubStr(<span class="string">"Just do it!"</span>, <span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(subStr);<span class="comment">//do</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面的实例方法的引用，也就是调用某个String对象的substring()实例方法来实现ObjectInstance函数式接口中唯一的抽象方法，当调用getSubStr方法时，第一个调用参数将作为substring方法的调用者，剩下的调用参数会作为substring实例方法的调用参数。</p><h3 id="3-4-引用构造器"><a href="#3-4-引用构造器" class="headerlink" title="3.4 引用构造器"></a>3.4 引用构造器</h3><p>假设定义有如下函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JFrameGetter</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取以title为标题的JFrame对象</span></span><br><span class="line">    <span class="function">JFrame <span class="title">getJFrame</span><span class="params">(String title)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面使用Lambda 表达式来创建一个 JFrameGetter 对象，并调用其 getJFrame 方法获取 JFrame 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//JFrameGetter frameGetter = title -&gt; new JFrame(title);</span></span><br><span class="line">        <span class="comment">//真是令人懵逼的语法。。。</span></span><br><span class="line">        JFrameGetter frameGetter = JFrame::<span class="keyword">new</span>;</span><br><span class="line">        JFrame frame = frameGetter.getJFrame(<span class="string">"标题"</span>);</span><br><span class="line">        System.out.println(frame.hashCode());<span class="comment">//666641942</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述构造器引用，也就是调用某个JFrame类的构造器来实现JFrameGetter函数式接口中的抽象方法getJFrame，调用getJFrame时会将参数传给JFrame的构造器并获取一个JFrame对象。</p><h2 id="4-变量作用域"><a href="#4-变量作用域" class="headerlink" title="4. 变量作用域"></a>4. 变量作用域</h2><p>考虑下面一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;</span><br><span class="line">        System.out.println(text);</span><br><span class="line">        Toolkit.getDefaultToolkit().beep();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repeatMessage(<span class="string">"Hello"</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>可以知道，Lambda表达式中的text变量是通过repeatMessage传递的。但是有时候可能会在执行repeatMessage很久之后才会执行lambda表达式中的代码，这时repeatMessage方法中传递的text值”Hello”已经不存在了。</p><p><strong>其实，Lambda表达式是会存储传递进去的text变量的值的，这个过程可以称为捕获。</strong> 但是有一个重要的限制，就是text的值是不可更改的。例如，下面的做法是不合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    ActionListener listener = event -&gt; &#123;</span><br><span class="line"><span class="comment">//start--;//不合法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，在Java中，lambda表达式只能引用值不会改变的变量，显然上述的start在lambda表达式中被更改了。</p><p>另外如果在lambda表达式中引用变量，而这个变量可能会在外部改变，这也是不合法的。比如下述用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">        ActionListener listener = event -&gt; &#123;</span><br><span class="line"><span class="comment">//System.out.println(i);//不合法</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Timer(delay, listener).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总之，lambda表达式中捕获的变量必须实际上是最终变量，也就是该变量初始化之后就不会改变值的变量，相当于使用 final修饰的变量。</strong></p><hr><p>在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合适的。比如下述例子：<br><img src="/2020/01/05/Java之Lambda表达式/2019032616042449.png" alt="在这里插入图片描述"></p><hr><p>在一个lambda表达式中使用this关键字时，是指创建这个lambda表达式的方法的this参数。例如下述代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActionListener listener = event -&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.myPrint();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式this.myPrint()中的this是指代LambdaTest对象的引用，而不是ActionListener对象listener的引用。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDK8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型（三） 通配符的使用</title>
      <link href="/2020/01/05/java%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/05/java%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>通配符有如下三种：</p><ul><li>无限定通配符，形式&lt;?&gt;</li><li>上边界限定通配符，形式&lt; ? extends Number&gt;    //用Number举例</li><li>下边界限定通配符，形式&lt; ? super Number&gt;    //用Number举例</li></ul><a id="more"></a><h3 id="1-泛型中的-？通配符"><a href="#1-泛型中的-？通配符" class="headerlink" title="1. 泛型中的 ？通配符"></a>1. 泛型中的 ？通配符</h3><p>如果定义一个方法，该方法用于打印出任意参数化类型的集合中的所有数据，如果这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicclass GernericTest &#123;</span><br><span class="line">    <span class="function">publicstaticvoid <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;String&gt; listString = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        printCollection(listInteger);</span><br><span class="line">        printCollection(listString);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCollection</span><span class="params">(Collection&lt;Object&gt; collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:collection) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句 printCollection(listInteger); 报如下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The method <span class="title">printCollection</span><span class="params">(Collection&lt;Object&gt;)</span> in the type GernericTest is not applicable <span class="keyword">for</span> the <span class="title">arguments</span> <span class="params">(List&lt;Integer&gt;)</span></span></span><br></pre></td></tr></table></figure><p>这是因为泛型的参数是不考虑继承关系的所以就直接报错。</p><p>这时就得用 ？通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicclass GernericTest &#123;</span><br><span class="line">    <span class="function">publicstaticvoid <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; listInteger = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;String&gt; listString = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        printCollection(listInteger);</span><br><span class="line">        printCollection(listString);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">publicstaticvoid <span class="title">printCollection</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj:collection) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法 public static void printCollection(Collection&lt;?&gt; collection){…} 中不能出现与参数类型有关的方法比如 collection.add(); </p><p>因为程序调用这个方法的时候传入的参数不知道是什么类型的，但是可以调用与参数类型无关的方法比如 collection.size();</p><p><strong>总结</strong>：使用 ? 通配符可以引用其他各种参数化的类型，? 通配符定义的变量的主要用作引用，可以调用与参数化无关的方法，不能调用与参数化有关的方法。</p><h3 id="2-泛型中的-通配符的扩展"><a href="#2-泛型中的-通配符的扩展" class="headerlink" title="2. 泛型中的 ? 通配符的扩展"></a>2. 泛型中的 ? 通配符的扩展</h3><h4 id="2-1-界定通配符的上边界"><a href="#2-1-界定通配符的上边界" class="headerlink" title="2.1 界定通配符的上边界"></a>2.1 界定通配符的上边界</h4><p>Vector&lt;? extends 类型1&gt; x = new Vector&lt;类型2&gt;();</p><p>类型1指定一个数据类型，那么<strong>类型2就只能是类型1或者是类型1的子类</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;? extends Number&gt; x = <span class="keyword">new</span> Vector&lt;Integer&gt;();<span class="comment">//这是正确的</span></span><br><span class="line">Vector&lt;? extends Number&gt; x = <span class="keyword">new</span> Vector&lt;String&gt;();<span class="comment">//这是错误的</span></span><br></pre></td></tr></table></figure><h4 id="2-2-界定通配符的下边界"><a href="#2-2-界定通配符的下边界" class="headerlink" title="2.2 界定通配符的下边界"></a>2.2 界定通配符的下边界</h4><p>Vector&lt;? super 类型1&gt; x = new Vector&lt;类型2&gt;();</p><p>类型1指定一个数据类型，那么<strong>类型2就只能是类型1或者是类型1的父类</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> Vector&lt;Number&gt;();<span class="comment">//这是正确的</span></span><br><span class="line">Vector&lt;? <span class="keyword">super</span> Integer&gt; x = <span class="keyword">new</span> Vector&lt;Byte&gt;();<span class="comment">//这是错误的</span></span><br></pre></td></tr></table></figure><p><strong>提示</strong>：限定通配符总是包括自己。</p><p><a href="https://blog.csdn.net/LonelyRoamer/article/details/7927212" target="_blank" rel="noopener">原文链接</a>，侵删。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型（二） 泛型的内部原理：类型擦除以及类型擦除带来的问题</title>
      <link href="/2020/01/05/java%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/01/05/java%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86%EF%BC%9A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java泛型的实现方法：类型擦除"><a href="#1-Java泛型的实现方法：类型擦除" class="headerlink" title="1. Java泛型的实现方法：类型擦除"></a>1. Java泛型的实现方法：类型擦除</h2><p>前面已经说了，Java 的泛型是伪泛型。为什么说 Java 的泛型是伪泛型呢？因为，在编译期间，所有的泛型信息都会被擦除掉。正确理解泛型概念的首要前提是理解类型擦出（type erasure）。</p><p>Java 中的泛型基本上都是在<strong>编译器</strong>这个层次来实现的。在生成的 Java 字节码中是不包含泛型中的类型信息的。<strong>使用泛型的时候加上的类型参数，会在编译器编译的时候去掉。这个过程就称为类型擦除。</strong></p><p>如在代码中定义的 List&lt;object&gt; 和 List&lt;String&gt; 等类型，在编译后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。Java 编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法避免在运行时刻出现类型转换异常的情况。类型擦除也是 Java 的泛型实现方法与 C++ 模版机制实现方式之间的重要区别。</p><a id="more"></a><p><strong>可以通过两个简单的例子，来证明 Java 泛型的类型擦除。</strong></p><h3 id="2-1-例-1"><a href="#2-1-例-1" class="headerlink" title="2.1 例 1"></a>2.1 例 1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList1.add(<span class="string">"abc"</span>);</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        arrayList2.add(<span class="number">123</span>);</span><br><span class="line">        System.out.println(arrayList1.getClass() == arrayList2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个 ArrayList 数组，不过一个是 ArrayList&lt;String&gt; 泛型类型，只能存储字符串。一个是 ArrayList&lt; Integer&gt;泛型类型，只能存储整型。最后，我们通过 arrayList1 对象和 arrayList2 对象的 getClass 方法获取它们的类的信息，最后发现结果为 true。说明泛型类型String 和 Integer 都被擦除掉了，只剩下了原始类型。</p><h3 id="2-2-例-2"><a href="#2-2-例-2" class="headerlink" title="2.2 例 2"></a>2.2 例 2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalArgumentException, SecurityException, IllegalAccessException, InvocationTargetException, NoSuchMethodException </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList3 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        arrayList3.add(<span class="number">1</span>);<span class="comment">//这样调用add方法只能存储整型，因为泛型类型的实例为Integer</span></span><br><span class="line">        <span class="comment">//通过反射向arrayList3对象中存储字符串"asd"</span></span><br><span class="line">        arrayList3.getClass().getMethod(<span class="string">"add"</span>, Object.class).invoke(arrayList3, <span class="string">"asd"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList3.size(); i++) &#123;</span><br><span class="line">            System.out.println(arrayList3.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中定义了一个 ArrayList 泛型类型实例化为 Integer 的对象，如果直接调用 add 方法，那么只能存储整型的数据。不过当我们利用反射调用 add 方法的时候，却可以存储字符串。这说明了Integer 泛型实例在编译之后被擦除了，只保留了原始类型。</p><h2 id="2-类型擦除后保留的原始类型"><a href="#2-类型擦除后保留的原始类型" class="headerlink" title="2. 类型擦除后保留的原始类型"></a>2. 类型擦除后保留的原始类型</h2><p>在上面，两次提到了原始类型，什么是原始类型？<strong>原始类型（raw type）就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。</strong> 无论何时定义一个泛型类型，相应的原始类型都会被自动地提供。类型变量被擦除（crased），并使用其限定类型（无限定的变量用Object）替换。</p><h3 id="2-1-例-3"><a href="#2-1-例-3" class="headerlink" title="2.1 例 3"></a>2.1 例 3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T  value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair&lt;T&gt; 的原始类型为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在 Pair&lt;T&gt; 中，T 是一个无限定的类型变量，所以用 Object 替换。其结果就是一个普通的类，如同泛型加入 Java 编程语言之前已经实现的那样。在程序中可以包含不同类型的 Pair，如Pair&lt;String&gt; 或 Pair&lt;Integer&gt;。但是，擦除类型后它们就成为原始的 Pair 类型了，原始类型都是 Object。</p><p>从上面的那个例2中，我们也可以明白 ArrayList&lt;Integer&gt; 被擦除类型后，原始类型也变成了Object，所以通过反射我们就可以存储字符串了。</p><p>如果类型变量有限定，那么原始类型就用<strong>第一个</strong>边界的类型变量来替换。比如 Pair 这样声明：</p><h3 id="2-2-例-4"><a href="#2-2-例-4" class="headerlink" title="2.2 例 4"></a>2.2 例 4</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span> &amp; <span class="title">Serializable</span>&gt; </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>那么原始类型就是 Comparable。</p><p><strong>注意：</strong> 如果 Pair 这样声明 public class Pair&lt;T extends Serializable &amp; Comparable&gt; ，那么原始类型就用 Serializable 替换，而编译器在必要的时要向 Comparable 插入强制类型转换。为了提高效率，应该将标签（tagging）接口（即没有方法的接口）放在边界限定列表的末尾。</p><hr><p><strong>要区分原始类型和泛型变量的类型：</strong></p><p>在<strong>调用泛型方法</strong>的时候，可以指定泛型，也可以不指定泛型。</p><p>在不指定泛型的情况下，泛型变量的类型为该方法中的几种参数变量类型的同一个父类的最小级，直到Object。</p><p>在指定泛型的时候，该方法中的几种类型必须是该泛型实例类型或者其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span></span><br><span class="line">        <span class="keyword">int</span> i = Test2.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型</span></span><br><span class="line">        Number f = Test2.add(<span class="number">1</span>, <span class="number">1.2</span>);<span class="comment">//这两个参数一个是Integer，一个是Double，所以取同一父类的最小级，为Number</span></span><br><span class="line">        Object o = Test2.add(<span class="number">1</span>, <span class="string">"asd"</span>);<span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object</span></span><br><span class="line"> </span><br><span class="line">         <span class="comment">/**指定泛型的时候*/</span></span><br><span class="line">        <span class="keyword">int</span> a = Test2.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//指定了Integer，所以只能为Integer类型或者其子类</span></span><br><span class="line">        <span class="keyword">int</span> b = Test2.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);<span class="comment">//编译错误，指定了Integer，不能为Double</span></span><br><span class="line">        Number c = Test2.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Double</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型类型为 Object。比如ArrayList 中，如果不指定泛型，那么这个 ArrayList 中可以放任意类型的对象。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    arrayList.add(<span class="number">1</span>);</span><br><span class="line">    arrayList.add(<span class="string">"121"</span>);</span><br><span class="line">    arrayList.add(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-类型擦除引起的问题及解决方法"><a href="#3-类型擦除引起的问题及解决方法" class="headerlink" title="3. 类型擦除引起的问题及解决方法"></a>3. 类型擦除引起的问题及解决方法</h2><p>因为种种原因，Java 不能实现真正的泛型，只能使用类型擦除来实现伪泛型，这样虽然不会有类型膨胀的问题，但是也引起了许多新的问题。所以，Sun 对这些问题作出了许多限制，避免我们犯各种错误。</p><h3 id="3-1-先检查，再编译，以及检查编译的对象和引用传递的问题"><a href="#3-1-先检查，再编译，以及检查编译的对象和引用传递的问题" class="headerlink" title="3.1 先检查，再编译，以及检查编译的对象和引用传递的问题"></a>3.1 先检查，再编译，以及检查编译的对象和引用传递的问题</h3><p>既然说类型变量会在编译的时候擦除掉，那为什么我们往 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); 所创建的数组列表 arrayList 中，不能使用 add 方法添加整型呢？不是说泛型变量 Integer 会在编译时候擦除变为原始类型 Object 吗？为什么不能存别的类型呢？既然类型擦除了，如何保证我们只能使用泛型变量限定的类型呢？</p><p>Java是如何解决这个问题的呢？<strong>Java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，在进行编译的。</strong></p><p>举个例子说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    arrayList.add(<span class="string">"123"</span>);</span><br><span class="line">    arrayList.add(<span class="number">123</span>);<span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的程序中，使用 add 方法添加一个整型，在 Eclipse 中，直接就会报错，说明这就是在编译之前的检查。因为如果是在编译之后检查，类型擦除后，原始类型为 Object，是应该运行任意引用类型的添加的。可实际上却不是这样，这恰恰说明了关于泛型变量的使用，是会在编译之前检查的。</p><p>那么，这么<strong>类型检查是针对谁的呢</strong>？我们先看看参数化类型与原始类型的兼容：</p><p>以 ArrayList 举例子，以前的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure><p>现在的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt;  arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>如果是与以前的代码兼容，各种引用传值之间，必然会出现如下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList(); <span class="comment">//第一种情况</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//第二种情况</span></span><br></pre></td></tr></table></figure><p>这样是没有错误的，不过会有个编译时警告。</p><p><strong>不过在第一种情况，可以实现与完全使用泛型参数一样的效果，第二种则完全没效果。</strong></p><p>因为，本来类型检查就是编译时完成的。new ArrayList(); 只是在内存中开辟一个存储空间，可以存储任何的类型对象。而<strong>真正涉及类型检查的是它的引用</strong>，因为我们是使用它引用 arrayList1 来调用它的方法，比如说调用 add() 方法，所以 arrayList1 引用能完成泛型类型的检查，而引用 arrayList2 没有使用泛型，所以不行。</p><p>举例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        arrayList1.add(<span class="string">"1"</span>);<span class="comment">//编译通过</span></span><br><span class="line">        arrayList1.add(<span class="number">1</span>);<span class="comment">//编译错误</span></span><br><span class="line">        String str1 = arrayList1.get(<span class="number">0</span>);<span class="comment">//返回类型就是String</span></span><br><span class="line">        </span><br><span class="line">        ArrayList arrayList2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        arrayList2.add(<span class="string">"1"</span>);<span class="comment">//编译通过</span></span><br><span class="line">        arrayList2.add(<span class="number">1</span>);<span class="comment">//编译通过</span></span><br><span class="line">        Object object = arrayList2.get(<span class="number">0</span>);<span class="comment">//返回类型就是Object</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="string">"11"</span>);<span class="comment">//编译通过</span></span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;String&gt;().add(<span class="number">22</span>);<span class="comment">//编译错误</span></span><br><span class="line">        String string = <span class="keyword">new</span> ArrayList&lt;String&gt;().get(<span class="number">0</span>);<span class="comment">//返回类型就是String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的例子，我们可以明白，类型检查就是针对引用的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象。</p><hr><p><strong>从这里，我们可以再讨论下泛型中参数化类型为什么不考虑继承关系。</strong></p><p>在 Java 中，像下面形式的引用传递是不允许的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();<span class="comment">//编译错误</span></span><br><span class="line">ArrayList&lt;Object&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>我们先看第一种情况，将第一种情况拓展成下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">arrayList1.add(<span class="keyword">new</span> Object());</span><br><span class="line">arrayList1.add(<span class="keyword">new</span> Object());</span><br><span class="line">ArrayList&lt;String&gt; arrayList2 = arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>实际上，在第 4 行代码的时候，就会有编译错误。那么，我们先假设它编译没错。那么当我们使用arrayList2 引用用 get() 方法取值的时候，返回的都是 String 类型的对象（上面提到了，类型检测是根据引用来决定的。），可是它里面实际上已经被我们存放了 Object 类型的对象，这样，就会有ClassCastException了。所以为了避免这种极易出现的错误，Java 不允许进行这样的引用传递。（这也是泛型出现的原因，就是为了解决类型转换的问题，我们不能违背它的初衷）。</p><p>在看第二种情况，将第二种情况拓展成下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">arrayList1.add(<span class="keyword">new</span> String());</span><br><span class="line">arrayList1.add(<span class="keyword">new</span> String());</span><br><span class="line">ArrayList&lt;Object&gt; arrayList2 = arrayList1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>没错，这样的情况比第一种情况好的多，最起码，在我们用 arrayList2 取值的时候不会出现ClassCastException，因为是从String转换为Object。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以 Java 不允许这么干。再说，你如果又用 arrayList2 往里面 add() 新的对象，那么到时候取得时候，我怎么知道我取出来的到底是 String 类型的，还是 Object 类型的呢？</p><p>所以，要格外注意，泛型中的引用传递的问题。</p><h3 id="3-2-自动类型转换"><a href="#3-2-自动类型转换" class="headerlink" title="3.2 自动类型转换"></a>3.2 自动类型转换</h3><p>因为类型擦除的问题，所以所有的泛型类型变量最后都会被替换为原始类型。这样就引起了一个问题，既然都被替换为原始类型，那么为什么我们在获取的时候，不需要进行强制类型转换呢？看下 ArrayList 和 get 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    RangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 return 之前，会根据泛型变量进行强转。</p><p>写了个简单的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Date&gt; list = <span class="keyword">new</span> ArrayList&lt;Date&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Date());</span><br><span class="line">        Date myDate = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后反编了下字节码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class java/util/ArrayList</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">7</span>: astore_1</span><br><span class="line">       <span class="number">8</span>: aload_1</span><br><span class="line">       9: new           #4                  // class java/util/Date</span><br><span class="line">      <span class="number">12</span>: dup</span><br><span class="line">      13: invokespecial #5                  // Method java/util/Date."&lt;init&gt;":()V</span><br><span class="line">      16: invokevirtual #6                  // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z</span><br><span class="line">      <span class="number">19</span>: pop</span><br><span class="line">      <span class="number">20</span>: aload_1</span><br><span class="line">      <span class="number">21</span>: iconst_0</span><br><span class="line">      22: invokevirtual #7                  // Method java/util/ArrayList.get:(I)Ljava/lang/Object;</span><br><span class="line">      25: checkcast     #4                  // class java/util/Date</span><br><span class="line">      <span class="number">28</span>: astore_2</span><br><span class="line">      <span class="number">29</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看第22 ，它调用的是 ArrayList.get() 方法，方法返回值是 Object，说明类型擦除了。然后第25，它做了一个 checkcast 操作，即检查类型 #4， 在上面找#4引用的类型，他是 9: new #4 // class java/util/Date，是一个Date类型，即做Date类型的强转。所以不是在get方法里强转的，是在你调用的地方强转的。</p><p><em>附关于checkcast的解释：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">checkcast checks that the top item on the operand <span class="title">stack</span> <span class="params">(a reference to an object or array)</span> can be cast to a given type. For example, <span class="keyword">if</span> you write in Java:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">return</span> <span class="params">((String)</span>obj)</span>;</span><br><span class="line"></span><br><span class="line">then the Java compiler will generate something like:</span><br><span class="line"></span><br><span class="line">aload_1 ; push -obj- onto the stack</span><br><span class="line">checkcast java/lang/String ; check its a String</span><br><span class="line">areturn ; <span class="keyword">return</span> it</span><br><span class="line"></span><br><span class="line">checkcast is actually a shortand <span class="keyword">for</span> writing Java code like:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (! (obj == <span class="keyword">null</span> || obj <span class="keyword">instanceof</span> &lt;<span class="class"><span class="keyword">class</span>&gt;)) </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if this point is reached, then object is either null, or an instance of</span></span><br><span class="line"><span class="comment">// &lt;class&gt; or one of its superclasses.</span></span><br></pre></td></tr></table></figure><h3 id="3-3-类型擦除与多态的冲突和解决方法"><a href="#3-3-类型擦除与多态的冲突和解决方法" class="headerlink" title="3.3 类型擦除与多态的冲突和解决方法"></a>3.3 类型擦除与多态的冲突和解决方法</h3><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们想要一个子类继承它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setValue(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个子类中，我们设定父类的泛型类型为Pair&lt;Date&gt;。在子类中，我们<strong>覆盖</strong>了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的 @Override 标签中也可以看到，一点问题也没有，实际上是这样的吗？</p><h4 id="3-3-1-分析"><a href="#3-3-1-分析" class="headerlink" title="3.3.1 分析"></a>3.3.1 分析</h4><p>实际上，类型擦除后，父类的的泛型类型全部变为了原始类型 Object，所以父类编译之后会变成下面的样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看子类 DateInter 的两个重写的方法的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setValue(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来分析 setValue 方法，父类的类型是 Object，而子类的类型是 Date，参数类型不一样，这普通的继承关系中，根本就不会是重写，而是重载。</p><p>我们在一个main方法测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    DateInter dateInter = <span class="keyword">new</span> DateInter();</span><br><span class="line">    dateInter.setValue(<span class="keyword">new</span> Date());                </span><br><span class="line">    dateInter.setValue(<span class="keyword">new</span> Object());<span class="comment">//编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是重载，那么子类中有两个 setValue 方法，一个是参数 Object 类型，一个是 Date 类型，可是我们发现，根本就没有这样的一个子类继承自父类的 Object 类型参数的方法。所以说，确实是重写了，而不是重载了。</p><p>为什么会这样呢？原因是这样的，我们传入父类的泛型类型是 Date，Pair&lt;Date&gt;，我们的本意是将泛型类变为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在子类中重写参数类型为 Date 的那两个方法，实现继承中的多态。可是由于种种原因，虚拟机并不能将泛型类型变为 Date，只能将类型擦除掉，变为原始类型 Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM 知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的 Date 类型参数的方法啊。</p><p>于是 JVM 采用了一个特殊的方法，来完成这项功能，那就是<strong>桥方法</strong>。</p><p>首先，我们用 javap -c className 的方式反编译下 DateInter 子类的字节码，结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">Pair</span>&lt;<span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">  com.tao.test.DateInter();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #8                  // Method com/tao/test/Pair."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.util.Date)</span></span>;  <span class="comment">//我们重写的setValue方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V</span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getValue</span><span class="params">()</span></span>;    <span class="comment">//我们重写的getValue方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;</span><br><span class="line">       4: checkcast     #26                 // class java/util/Date</span><br><span class="line">       <span class="number">7</span>: areturn</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;     <span class="comment">//编译时由编译器生成的桥方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;</span><br><span class="line">       <span class="number">4</span>: areturn</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.lang.Object)</span></span>;   <span class="comment">//编译时由编译器生成的桥方法</span></span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: aload_1</span><br><span class="line">       2: checkcast     #26                 // class java/util/Date</span><br><span class="line">       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date;   去调用我们重写的setValue方法)V</span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从编译的结果来看，我们本意重写  setValue 和 getValue 方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是 Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue 和 getValue 方法上面的 @Oveerride 只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</p><p>不过，要提到一点，这里面的 setValue 和 getValue 这两个桥方法的意义又有不同。setValue 方法是为了解决类型擦除与多态之间的冲突，而 getValue 却有普遍的意义，怎么说呢，如果这是一个普通的继承关系，那么父类的 getValue 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这在普通的类继承中也是普遍存在的重写，这就是协变。</p><p>并且，还有一点也许会有疑问，子类中的桥方法  Object   getValue() 和 Date getValue() 是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的。如果是我们自己编写 Java 代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区分。</p><h3 id="3-4-泛型类型变量不能是基本数据类型"><a href="#3-4-泛型类型变量不能是基本数据类型" class="headerlink" title="3.4 泛型类型变量不能是基本数据类型"></a>3.4 泛型类型变量不能是基本数据类型</h3><p>不能用类型参数替换基本类型。就比如，没有 ArrayList&lt;double&gt;，只有 ArrayList&lt;Double&gt;。因为当类型擦除后，ArrayList 的原始类型变为 Object，但是 Object 类型不能存储 double 值，只能引用 Double 的值。</p><h3 id="3-5-运行时类型查询"><a href="#3-5-运行时类型查询" class="headerlink" title="3.5 运行时类型查询"></a>3.5 运行时类型查询</h3><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>因为类型擦除之后，ArrayList&lt;String&gt; 只剩下原始类型，泛型信息 String 不存在了。那么，运行时进行类型查询的时候使用下面的方法是错误的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;)</span><br></pre></td></tr></table></figure><p>Java 限定了这种类型查询的方式，比如下面的判断是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayList <span class="keyword">instanceof</span> ArrayList&lt;?&gt;) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>？ 是通配符的形式 ，将在后面一篇中介绍。</p><h3 id="3-6-异常中使用泛型的问题"><a href="#3-6-异常中使用泛型的问题" class="headerlink" title="3.6 异常中使用泛型的问题"></a>3.6 异常中使用泛型的问题</h3><ol><li><strong>不能抛出也不能捕获泛型类的对象。事实上，泛型类扩展 Throwable 都不合法。例如下面的定义将不会通过编译：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure></li></ol><p>为什么不能扩展 Throwable，因为异常都是在运行时捕获和抛出的，而在编译的时候，泛型信息全都会被擦除掉。那么，假设上面的编译可行。那么，在看下面的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Integer&gt; e1)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Number&gt; e2)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型信息被擦除后，那么两个地方的 catch 都变为原始类型 Object。也就是说，这两个地方的 catch 变的一模一样，就相当于下面的这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Object&gt; e1)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Problem&lt;Object&gt; e2)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个当然就是不行的。就好比，catch 两个一模一样的普通异常，不能通过编译一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception  e2)&#123;<span class="comment">//编译错误</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>不能在 catch 子句中使用泛型变量</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(T e)&#123; <span class="comment">//编译错误</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为泛型信息在编译的时候已经变为原始类型，也就是说上面的 T 会变为原始类型 Throwable，那么如果<strong>可以</strong>在 catch 子句中使用泛型变量，那么，下面的定义呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">          ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(T e)&#123; <span class="comment">//编译错误</span></span><br><span class="line">          ...</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IndexOutOfBoundsException e)&#123;</span><br><span class="line">    &#125;                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据异常捕获的原则，一定是子类在前面，父类在后面。那么上面就违背了这个原则。即使你在使用该静态方法的时候 T 是 ArrayIndexOutofBoundsException，在编译之后还是会变成 Throwable，Throwable 是 IndexOutOfBoundsException 的超类，违背了异常捕获的原则。所以 Java 为了避免这样的情况，禁止在 catch 子句中使用泛型变量。</p><p>但是在异常声明中可以使用类型变量。下面方法是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line">     <span class="keyword">try</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">     &#125;<span class="keyword">catch</span>(Throwable realCause)&#123;</span><br><span class="line">         t.initCause(realCause);</span><br><span class="line">         <span class="keyword">throw</span> t; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-数组（这个不属于类型擦除引起的问题）"><a href="#3-7-数组（这个不属于类型擦除引起的问题）" class="headerlink" title="3.7 数组（这个不属于类型擦除引起的问题）"></a>3.7 数组（这个不属于类型擦除引起的问题）</h3><p>不能声明参数化类型的数组。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><p>这是因为擦除后，table 的类型变为 Pair[]，可以转化成一个 Object[]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objarray = table;</span><br></pre></td></tr></table></figure><p><strong>数组可以记住自己的元素类型</strong>，下面的赋值会抛出一个 ArrayStoreException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objarray[<span class="number">0</span>] = <span class="string">"Hello"</span>; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><p>对于泛型而言，擦除降低了这个机制的效率。下面的赋值可以通过数组存储的检测，但仍然会导致类型错误。 出于这些原因，不允许创建参数化类型的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objarray[<span class="number">0</span>] = <span class="keyword">new</span> Pair&lt;Employee&gt;();</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：如果需要收集参数化类型对象，直接使用 ArrayList:ArrayList&lt;Pair&lt;String&gt;&gt; 最安全且有效。</p><h3 id="3-8-泛型类型的实例化"><a href="#3-8-泛型类型的实例化" class="headerlink" title="3.8 泛型类型的实例化"></a>3.8 泛型类型的实例化</h3><p>不能实例化泛型类型。如下面语句是错误的，类型擦除会使这个操作变成 new Object()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">first = <span class="keyword">new</span> T(); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><p>同样，我们也不能建立一个泛型数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] minMax(T[] a) &#123;</span><br><span class="line">     T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>]; <span class="comment">//ERROR</span></span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，擦除会使这个方法总是构造一个 Object[2] 数组。但是，可以用<strong>反射</strong>构造泛型对象和泛型数组。利用反射，调用 Array.newInstance：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123;</span><br><span class="line">    </span><br><span class="line">    T[] mm = (T[])Array.newInstance(a.getClass().getComponentType(), <span class="number">2</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 以替换掉以下代码</span></span><br><span class="line">    <span class="comment">// Obeject[] mm = new Object[2];</span></span><br><span class="line">    <span class="comment">// return (T[]) mm;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-类型擦除后的冲突"><a href="#3-9-类型擦除后的冲突" class="headerlink" title="3.9 类型擦除后的冲突"></a>3.9 类型擦除后的冲突</h3><p><strong>1</strong>.当泛型类型被擦除后，创建条件不能产生冲突。如果在Pair 类中添加下面的 equals 方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑一个 Pair&lt;String&gt;。从概念上，它有两个 equals 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(String)</span></span>; <span class="comment">//在Pair&lt;T&gt;中定义</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object)</span></span>; <span class="comment">//从object中继承</span></span><br></pre></td></tr></table></figure><p>但是，这只是一种错觉。实际上，擦除后方法 boolean equals(T) 变成了方法 boolean equals(Object)，这与 Object.equals 方法是冲突的！当然，补救的办法是重新命名引发错误的方法。</p><p><strong>2</strong>.泛型规范说明提及到了另一个原则“要支持擦除的转换，需要强制一个类或者类型变量不能同时成为两个接口的子类，而这两个子类是同一接口的不同参数化。”</p><p>比如，下面的代码是非法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义父类Calendar</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt;</span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义子类GregorianCalendar </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">GregorianCalendar</span>&gt;</span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><p>GregorianCalendar 会实现 Comparable&lt;Calender&gt; 和 Compable&lt;GregorianCalendar&gt;，这是同一个接口的不同参数化实现。这一限制与类型擦除的关系并不很明确。如下非泛型版本是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义父类Calendar</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义子类GregorianCalendar </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GregorianCalendar</span> <span class="keyword">extends</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;...&#125; <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure><h3 id="3-10-泛型在静态方法和静态类中的问题"><a href="#3-10-泛型在静态方法和静态类中的问题" class="headerlink" title="3.10 泛型在静态方法和静态类中的问题"></a>3.10 泛型在静态方法和静态类中的问题</h3><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数的。</p><p>举例说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">show</span><span class="params">(T one)</span></span>&#123; <span class="comment">//编译错误  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型类中的泛型参数的实例化是在定义对象的时候指定的，而静态变量和静态方法不需要使用对象来调用。对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。但是要注意区分下面的一种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">show</span><span class="params">(T one)</span> </span>&#123;<span class="comment">//这是正确的  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是一个泛型方法，在泛型方法中使用的 T 是自己在方法中定义的 T，而不是泛型类中的 T。</p><p><a href="https://blog.csdn.net/LonelyRoamer/article/details/7868820" target="_blank" rel="noopener">原文链接</a>，侵删。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型（一）泛型的基本介绍和使用</title>
      <link href="/2020/01/05/java%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/05/java%E6%B3%9B%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-泛型的基本概念"><a href="#1-泛型的基本概念" class="headerlink" title="1. 泛型的基本概念"></a>1. 泛型的基本概念</h2><p><strong>泛型的定义</strong>：泛型是 JDK 1.5 的一项新特性，它的本质是参数化类型（Parameterized Type）的应用，也就是说所操作的数据类型被指定为一个参数，在用到的时候再指定具体的类型。这种参数类型可以用在类、接口和方法的创建，分别称为泛型类、泛型接口和泛型方法。</p><a id="more"></a><p>泛型思想早在 C++ 语言的<strong>模板</strong>（Templates）中就开始生根发芽，<strong>在 Java 语言处于还没有出现泛型的版本时，只能通过 Object 是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。</strong> 例如在哈希表的存取中，JDK 1.5之前使用 HashMap 的 get() 方法，返回值就是一个 Object 对象。由于 Java 语言里面所有的类型都继承于 java.lang.Object，那 Object 转型为任何对象成都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个 Object 到底是个什么类型的对象。在编译期间，编译器无法检查这个 Object 的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多 ClassCastException 的风险就会被转嫁到程序运行期之中。</p><p><strong>泛型技术在 C# 和 Java 之中的使用方式看似相同，但实现上却有着根本性的分歧</strong>。C# 里面泛型无论在程序源码中、编译后的 IL 中（Intermediate Language，中间语言，这时候泛型是一个占位符）或是运行期的 CLR 中都是切实存在的，List&lt;int&gt; 与 List&lt;String&gt; 就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为<strong>类型膨胀</strong>，基于这种方法实现的泛型被称为<strong>真实泛型</strong>。</p><p>Java 语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原始类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList&lt;int&gt; 与 ArrayList&lt;String&gt; 就是同一个类。所以说泛型技术实际上是 Java 语言的一颗语法糖，Java 语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为<strong>伪泛型</strong>。（类型擦除在后面在学习）</p><p>使用泛型机制编写的程序代码要比那些杂乱的使用 Object 变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。泛型对于集合类来说尤其有用。</p><p>泛型程序设计（Generic Programming）意味着编写的代码可以被很多不同类型的对象所重用。</p><h3 id="1-1-实例分析"><a href="#1-1-实例分析" class="headerlink" title="1.1 实例分析"></a>1.1 实例分析</h3><p>在 JDK1.5 之前，Java 泛型程序设计是用<strong>继承</strong>来实现的。因为 Object 类是所有类的基类，所以只需要维持一个 Object 类型的引用即可。就比如 ArrayList 只维护一个 Object 引用的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>//<span class="title">JDK1</span>.5之前的</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;......&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>&#123;......&#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> Object[] elementData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会有两个问题：</p><p>1.没有错误检查，可以向数组列表中添加类的对象；</p><p>2.在取元素的时候，需要进行强制类型转换。</p><p>这样，很容易发生错误，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**jdk1.5之前的写法，容易出问题*/</span></span><br><span class="line">ArrayList arrayList1= <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList1.add(<span class="number">1</span>);</span><br><span class="line">arrayList1.add(<span class="number">1L</span>);</span><br><span class="line">arrayList1.add(<span class="string">"asa"</span>);</span><br><span class="line"><span class="keyword">int</span> i = (Integer) arrayList1.get(<span class="number">1</span>);<span class="comment">//因为不知道取出来的值的类型，类型转换的时候容易出错</span></span><br></pre></td></tr></table></figure><p>这里的第一个元素是一个长整型，而你以为是整型，所以在强转的时候发生了错误。</p><p>所以，在 JDK1.5 之后，加入了泛型来解决类似的问题。例如在 ArrayList 中使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** jdk1.5之后加入泛型*/</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();  <span class="comment">//限定数组列表中的类型</span></span><br><span class="line"><span class="comment">//arrayList2.add(1); //因为限定了类型，所以不能添加整形</span></span><br><span class="line"><span class="comment">//arrayList2.add(1L);//因为限定了类型，所以不能添加整长形</span></span><br><span class="line">arrayList2.add(<span class="string">"asa"</span>);<span class="comment">//只能添加字符串</span></span><br><span class="line">String str = arrayList2.get(<span class="number">0</span>);<span class="comment">//因为知道取出来的值的类型，所以不需要进行强制类型转换</span></span><br></pre></td></tr></table></figure><p>还要明白的是，<strong>泛型特性是向前兼容的</strong>。尽管 JDK 5.0 的标准类库中的许多类，比如集合框架，都已经泛型化了，但是使用集合类（比如 HashMap 和 ArrayList）的现有代码可以继续不加修改地在 JDK 1.5 中工作。当然，没有利用泛型的现有代码将不会赢得泛型的类型安全的好处。</p><h3 id="1-2-泛型相关术语"><a href="#1-2-泛型相关术语" class="headerlink" title="1.2 泛型相关术语"></a>1.2 泛型相关术语</h3><p>在学习泛型之前，简单介绍下泛型的一些基本术语，以 ArrayList&lt;E&gt; 和 ArrayList&lt;Integer&gt; 做简要介绍：</p><p>整个称为 ArrayList&lt;E&gt; 泛型类型，ArrayList&lt;E&gt;中的 E 称为类型变量或者类型参数；</p><p>整个 ArrayList&lt;Integer&gt; 称为参数化的类型，ArrayList&lt;Integer&gt;中的 Integer 称为类型变量的实例或者实际类型变量；</p><p>ArrayList&lt;Integer&gt; 中的 &lt;Integer&gt; 念为 typeof  Integer；</p><p>ArrayList 称为原始类型。</p><h2 id="2-泛型的使用"><a href="#2-泛型的使用" class="headerlink" title="2. 泛型的使用"></a>2. 泛型的使用</h2><p>泛型的参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。下面看看具体是如何定义的。</p><h3 id="2-1-泛型类的定义和使用"><a href="#2-1-泛型类的定义和使用" class="headerlink" title="2.1 泛型类的定义和使用"></a>2.1 泛型类的定义和使用</h3><p>一个泛型类（generic class）就是具有一个或多个类型变量的类。定义一个泛型类十分简单，只需要在类名后面加上&lt;&gt;，再在里面加上类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就可以使用这个泛型类了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Pair&lt;String&gt; pair = <span class="keyword">new</span> Pair&lt;String&gt;(<span class="string">"Hello"</span>);</span><br><span class="line">    String str = pair.getValue();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    pair.setValue(<span class="string">"World"</span>);</span><br><span class="line">    str = pair.getValue();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair 类引入了一个类型变量 T，用尖括号 &lt;&gt; 括起来，并放在类名的后面。泛型类可以有多个类型变量。例如，可以定义 Pair 类，其中第一个域和第二个域使用不同的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;</span>&#123;......&#125;</span><br></pre></td></tr></table></figure><p>注意：类型变量使用大写形式，且比较短，这是很常见的。在 Java 库中，使用变量 E 表示集合的元素类型，K 和 V 分别表示关键字与值的类型。（需要时还可以用临近的字母 U 和 S 表示“任意类型”。）</p><h3 id="2-2-泛型接口的定义和使用"><a href="#2-2-泛型接口的定义和使用" class="headerlink" title="2.2 泛型接口的定义和使用"></a>2.2 泛型接口的定义和使用</h3><p>定义泛型接口和泛型类差不多，看下面简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Show</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowTest</span> <span class="keyword">implements</span> <span class="title">Show</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str,Date date)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    ShowTest showTest = <span class="keyword">new</span> ShowTest();</span><br><span class="line">    showTest.show(<span class="string">"Hello"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-泛型方法的定义和使用"><a href="#2-3-泛型方法的定义和使用" class="headerlink" title="2.3 泛型方法的定义和使用"></a>2.3 泛型方法的定义和使用</h3><p>泛型类在多个<strong>方法签名</strong>间实施类型约束。在 List&lt;V&gt; 中，类型参数 V 出现在 get()、add()、contains() 等方法的签名中。当创建一个 Map&lt;K, V&gt; 类型的变量时，您就在方法之间宣称一个类型约束，您传递给 add() 的值将与 get() 返回的值的类型相同。</p><p>类似地，之所以声明泛型方法，一般是因为您想要<strong>在该方法的多个参数之间宣称一个类型约束</strong>。</p><p>举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    String str = get(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function">T <span class="title">get</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-泛型变量的类型限定"><a href="#3-泛型变量的类型限定" class="headerlink" title="3. 泛型变量的类型限定"></a>3. 泛型变量的类型限定</h2><p>在上面，我们简单的学习了泛型类、泛型接口和泛型方法。我们都是直接使用 &lt;T&gt; 这样的形式来完成泛型类型的声明。</p><p>有的时候，类、接口或方法需要对类型变量加以约束。看下面的例子：</p><p>有这样一个简单的泛型方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(T t1, T t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1.compareTo(t2) &gt;= <span class="number">0</span>);<span class="comment">//编译错误</span></span><br><span class="line">       <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，在编译之前，也就是我们还在定义这个泛型方法的时候，我们并不知道这个泛型类型 T，到底是什么类型。所以，只能默认 T 为原始类型 Object。所以它只能调用来自于 Object 的那几个方法，而不能调用 compareTo 方法。</p><p>可我的本意就是要比较 t1 和 t2，怎么办呢？这个时候，就要使用类型限定，对类型变量 T 设置限定（bound）来做到这一点。</p><p>我们知道，所有实现 Comparable 接口的方法，都会有 compareTo 方法。所以，可以对 &lt;T&gt; 做如下限定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">get</span><span class="params">(T t1, T t2)</span> </span>&#123; <span class="comment">//添加类型限定</span></span><br><span class="line">    <span class="keyword">if</span>(t1.compareTo(t2) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型限定在泛型类、泛型接口和泛型方法中都可以使用，不过要注意下面几点：</p><p>1.不管该限定是类还是接口，统一都使用关键字 extends；</p><p>2.可以使用 &amp; 符号给出多个限定，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable &amp; Serializable&gt; <span class="function">T <span class="title">get</span><span class="params">(T t1, T t2)</span></span></span><br></pre></td></tr></table></figure><p>3.如果限定既有接口也有类，那么类必须只有一个，并且放在首位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Object &amp; Comparable &amp; Serializable&gt; <span class="function">T <span class="title">get</span><span class="params">(T t1, T t2)</span></span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/LonelyRoamer/article/details/7864531" target="_blank" rel="noopener">原文链接</a>，侵删。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 泛型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）NIO - 非阻塞式网络通信</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89NIO-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89NIO-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-阻塞与非阻塞"><a href="#1-阻塞与非阻塞" class="headerlink" title="1. 阻塞与非阻塞"></a>1. 阻塞与非阻塞</h2><p>传统的 IO 流都是阻塞式的。也就是说，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取或写入，该线程在此期间不能执行其他任务。因此，在完成网络通信进行 IO 操作时，由于线程会阻塞，所以服务器端必须为每个客户端都提供一个独立的线程进行处理，当服务器端需要处理大量客户端时，性能急剧下降。</p><p>Java NIO 是非阻塞模式的。当线程从某通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行 IO 操作，所以单独的线程可以管理多个输入和输出通道。因此， NIO 可以让服务器端使用一个或有限几个线程来同时处理连接到服务器端的所有客户端。</p><a id="more"></a><p>下面演示了基于阻塞式的客户端和服务器之间的网络通信，具体代码如下所示：</p><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注：为了方便演示，这里直接将异常抛出，并直接close</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取客户端通道</span></span><br><span class="line">    SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line">    <span class="comment">//2. 获取文件通道</span></span><br><span class="line">    FileChannel fChannel = FileChannel.open(Paths.get(<span class="string">"1.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 分配指定大小的缓冲区</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.读取文件通道的数据并写入缓冲区中</span></span><br><span class="line">    <span class="keyword">while</span> (fChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//5. 读取缓冲区的数据写入客户端通道中</span></span><br><span class="line">        buf.flip();</span><br><span class="line">        sChannel.write(buf);</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须告知服务器客户端的数据已经发送完毕</span></span><br><span class="line">    sChannel.shutdownOutput();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.客户端接收服务端的反馈信息</span></span><br><span class="line">    <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = sChannel.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="comment">//将缓冲区的数据打印出来</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.关闭通道</span></span><br><span class="line">    fChannel.close();</span><br><span class="line">    sChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取服务器通道</span></span><br><span class="line">    ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 获取文件通道</span></span><br><span class="line">    FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"2.txt"</span>), </span><br><span class="line">            StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 绑定与客户端的连接</span></span><br><span class="line">    ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 绑定之后，通过服务器通道获取客户端连接的通道</span></span><br><span class="line">    SocketChannel sChannel = ssChannel.accept();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5. 分配指定大小的缓冲区</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.接收客户端的数据，并保存到本地</span></span><br><span class="line">    <span class="keyword">while</span> (sChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">        buf.flip();</span><br><span class="line">        outChannel.write(buf);</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//须告知客户端服务器的数据已经接收完毕</span></span><br><span class="line">    sChannel.shutdownInput();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7. 发送数据给客户端</span></span><br><span class="line">    buf.put(<span class="string">"服务器成功接收到客户端发来的数据！"</span>.getBytes());</span><br><span class="line">    buf.flip();</span><br><span class="line">    sChannel.write(buf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8. 关闭通道</span></span><br><span class="line">    outChannel.close();</span><br><span class="line">    sChannel.close();</span><br><span class="line">    ssChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要强调的是，如果注释掉客户端和服务器代码中的shutdownOutput和shutdownInput方法后，此时运行会一直处于阻塞状态。因为服务器无法确定客户端输出数据是否已经结束，也就是无法确定是否还需要执行sChannel.write(buf);该调用，那么运行就会一直处于阻塞状态。服务器端同理。</p><p>shutdownOutput 该方法的作用就是断开Socket的输出流，但是不关闭通道。调用该方法之后，我们无法再向通道中写入数据了，也就是表明客户端的输出已经结束。shutdownInput方法同理。</p><h2 id="2-选择器的使用"><a href="#2-选择器的使用" class="headerlink" title="2. 选择器的使用"></a>2. 选择器的使用</h2><p>前面我们已经说了，NIO是非阻塞模式的，而非阻塞的实现的核心就是选择器。选择器（Selector） 是 SelectableChannle 对象的多路复用器， Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。</p><p>SelectableChannle 的结构如下图：<br><img src="/2020/01/05/（三）NIO-非阻塞式网络通信/20190401100242916.png" alt="在这里插入图片描述"><br>下面列出来了Selector的一些常用的方法及其描述：<br><img src="/2020/01/05/（三）NIO-非阻塞式网络通信/20190401111550101.png" alt="在这里插入图片描述"><br>另外，我们可以通过Selector的静态方法open来获取选择器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><p>并可以使用通道的register方法向选择器注册通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><p>ssChannel为SocketServetChannel的一个对象，调用register方法时不仅指定了选择器，同时还指定了SelectKey.OP_ACCEPT，即选择器对通道指定的监听事件，这里为接收事件。</p><p>SelectionKey： <strong>表示 SelectableChannel 和 Selector 之间的注册关系</strong>。每次向选择器注册通道时就会选择一个事件(选择键)。SelectionKey可以监听的事件类型的常量表示如下：</p><ul><li>读 : SelectionKey.OP_READ </li><li>写 : SelectionKey.OP_WRITE</li><li>连接 : SelectionKey.OP_CONNECT</li><li>接收 : SelectionKey.OP_ACCEPT </li></ul><p>SelectKey的一些常用方法及其描述如下图示：<br><img src="/2020/01/05/（三）NIO-非阻塞式网络通信/20190401112535467.png" alt="在这里插入图片描述"></p><h3 id="2-1-示例"><a href="#2-1-示例" class="headerlink" title="2.1 示例"></a>2.1 示例</h3><p>下面的示例使用NIO实现了多人聊天室的功能。服务器通道使用了configureBlocking(false)将通道切换为非阻塞模式，并向选择器注册该通道时指定了监听服务器接收的事件，然后轮询的使用Selector的select方法来判断这些接收事件是否就绪。这些操作表明了只有服务器接收到监听事件时（select方法返回值大于0）才去处理接收事件，此时线程可以去干别的事而不用一直等待接收监听。</p><p>服务器端的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取通道</span></span><br><span class="line">    ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">    <span class="comment">//2. 切换为非阻塞模式</span></span><br><span class="line">    ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//3. 绑定连接</span></span><br><span class="line">    ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line">    <span class="comment">//4. 获取选择器</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">//5. 将通道注册到选择器上，并且执行“监听接收事件”</span></span><br><span class="line">    ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6. 轮询式的获取选择器上已经“准备就绪”的事件</span></span><br><span class="line">    <span class="comment">//select()返回值表示“准备就绪”的事件的数量</span></span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//7. 获取当前选择器中所有已就绪的监听事件的“选择键”</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="comment">//8. 获取准备“就绪”的事件</span></span><br><span class="line">            SelectionKey key = it.next();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//9. 判断具体是什么事件准备就绪</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                <span class="comment">//10. 若是接收事件就绪，获取客户端连接</span></span><br><span class="line">                SocketChannel sChannel = ssChannel.accept();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//11. 将客户端通道切换非阻塞模式</span></span><br><span class="line">                sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//12. 将通道注册到选择器上，客户端执行“读”就绪事件</span></span><br><span class="line">                sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">//13. 若是读事件就绪，则进行数据读取</span></span><br><span class="line">                SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                <span class="comment">//14，读取数据</span></span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> ((len = sChannel.read(buf)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buf.flip();</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">                    buf.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//15. 取消选择键</span></span><br><span class="line">            it.remove();</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="comment">//while</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取通道</span></span><br><span class="line">    SocketChannel sChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line">    <span class="comment">//2. 切换成非阻塞模式</span></span><br><span class="line">    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//3. 分配执行大小的缓冲区</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//4. 发送数据给客户端</span></span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span> (scan.hasNext()) &#123;</span><br><span class="line">        String content = scan.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (content.equals(<span class="string">"exit"</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        buf.put((<span class="keyword">new</span> Date() + <span class="string">":"</span> + content).getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="comment">//读取缓冲区并将数据写入通道中</span></span><br><span class="line">        sChannel.write(buf);</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    scan.close();</span><br><span class="line">    <span class="comment">//5. 关闭通道</span></span><br><span class="line">    sChannel.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当多个用户输出数据时，服务器端都会接收到数据并打印在控制台上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mon Apr 01 11:11:12 CST 2019:你好 </span><br><span class="line">Mon Apr 01 11:11:20 CST 2019:hello</span><br></pre></td></tr></table></figure><h2 id="3-DatagramChannel-数据传输"><a href="#3-DatagramChannel-数据传输" class="headerlink" title="3. DatagramChannel 数据传输"></a>3. DatagramChannel 数据传输</h2><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。下面使用该通道实现多人聊天室功能，具体代码如下所示：</p><p>接收端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    dc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</span><br><span class="line">    <span class="comment">// 获取选择器</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line">    <span class="comment">// 注册通道</span></span><br><span class="line">    dc.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = it.next();</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                <span class="comment">// 进行数据读取</span></span><br><span class="line">                ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">//接收数据包的数据并写进缓冲区中</span></span><br><span class="line">                dc.receive(buf);</span><br><span class="line">                buf.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, buf.limit()));</span><br><span class="line">                buf.clear();</span><br><span class="line">                <span class="comment">// 取消选择器</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125; <span class="comment">// if</span></span><br><span class="line">        &#125; <span class="comment">// while</span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramChannel dc = DatagramChannel.open();</span><br><span class="line">    dc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scan.hasNext()) &#123;</span><br><span class="line">        String content = scan.next();</span><br><span class="line">        buf.put((<span class="keyword">new</span> Date().toString() + <span class="string">"\n"</span> + content).getBytes());</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        dc.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">9898</span>));</span><br><span class="line">        buf.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    scan.close();</span><br><span class="line">    dc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Pipe-管道数据传输"><a href="#4-Pipe-管道数据传输" class="headerlink" title="4. Pipe 管道数据传输"></a>4. Pipe 管道数据传输</h2><p>Java NIO 管道是<strong>2个线程</strong>之间的<strong>单向</strong>数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。<br><img src="/2020/01/05/（三）NIO-非阻塞式网络通信/20190401135727606.png" alt="在这里插入图片描述"><br>下面演示一下管道之间的数据传输示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPipe</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Pipe pipe = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestPipe</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//获取管道</span></span><br><span class="line">        pipe = Pipe.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSink</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//2.获取sink通道</span></span><br><span class="line">        Pipe.SinkChannel sink = pipe.sink();</span><br><span class="line">        <span class="comment">//3. 向通道中写入数据</span></span><br><span class="line">        buffer.put(<span class="string">"通过单向管道写入数据"</span>.getBytes());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        sink.write(buffer);</span><br><span class="line">        <span class="comment">//4. 关闭通道</span></span><br><span class="line">        sink.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建缓冲区</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        <span class="comment">//2. 创建source通道</span></span><br><span class="line">        Pipe.SourceChannel source = pipe.source();</span><br><span class="line">        <span class="keyword">int</span> len = source.read(buffer);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(buffer.array(), <span class="number">0</span>, len));<span class="comment">//输出：通过单向管道写入数据</span></span><br><span class="line">        <span class="comment">//3. 关闭通道</span></span><br><span class="line">        source.close();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TestPipe testPipe = <span class="keyword">new</span> TestPipe();</span><br><span class="line">        testPipe.testSink();</span><br><span class="line">        testPipe.testSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）NIO - Channel</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89NIO-Channel/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89NIO-Channel/</url>
      
        <content type="html"><![CDATA[<h3 id="1-通道的概念"><a href="#1-通道的概念" class="headerlink" title="1. 通道的概念"></a>1. 通道的概念</h3><p>通道（Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。</p><a id="more"></a><h3 id="2-主要实现类"><a href="#2-主要实现类" class="headerlink" title="2. 主要实现类"></a>2. 主要实现类</h3><p>Java 为 Channel 接口提供的最主要实现类如下：</p><ul><li><strong>FileChannel</strong>：用于读取、写入、映射和操作文件的通道。</li><li><strong>DatagramChannel</strong>：通过 UDP 读写网络中的数据通道。</li><li><strong>SocketChannel</strong>：通过 TCP 读写网络中的数据。</li><li><strong>ServerSocketChannel</strong>：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3 id="3-获取通道"><a href="#3-获取通道" class="headerlink" title="3. 获取通道"></a>3. 获取通道</h3><p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p><p>FileInputStream、FileOutputStream、RandomAccessFile、DatagramSocket、Socket 和 ServerSocket。</p><p>获取通道的其他方式是使用 Files 类的静态方法 <strong>newByteChannel()</strong> 获取字节通道。或者通过通道的静态方法 <strong>open()</strong> 打开并返回指定通道。</p><h3 id="4-FileChannel-通道的数据传输"><a href="#4-FileChannel-通道的数据传输" class="headerlink" title="4. FileChannel 通道的数据传输"></a>4. FileChannel 通道的数据传输</h3><p>下图所示的是FileChannel类的一些常用方法：<br><img src="/2020/01/05/（二）NIO-Channel/2019033120483691.png" alt="在这里插入图片描述"></p><h4 id="4-1-文件复制"><a href="#4-1-文件复制" class="headerlink" title="4.1 文件复制"></a>4.1 文件复制</h4><p>示例一：下面演示一下使用通道和<strong>非直接缓冲区</strong>实现文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">    FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">"1.txt"</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"2.txt"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. 获取通道</span></span><br><span class="line">            inChannel = fis.getChannel();</span><br><span class="line">            outChannel = fos.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 分配指定大小的缓冲区</span></span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 读取通道中的数据并写入缓冲区中，position后移</span></span><br><span class="line">            <span class="keyword">while</span> (inChannel.read(buf) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 将缓冲区切换读取数据的模式，position为0，limit改变</span></span><br><span class="line">                buf.flip();</span><br><span class="line">                <span class="comment">// 4. 读取缓冲区中的数据并写入通道中</span></span><br><span class="line">                outChannel.write(buf);</span><br><span class="line">                buf.clear();<span class="comment">// 清空缓冲区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                outChannel.close();</span><br><span class="line">            <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>)</span><br><span class="line">                inChannel.close();</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>)</span><br><span class="line">                fos.close();</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例二：下面演示一下使用通道和<strong>直接缓冲区</strong>实现文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopyDirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//建立文件读取通道。StandardOpenOption.READ指明了以读取的方式打开文件</span></span><br><span class="line">            inChannel = FileChannel.open(Paths.get(<span class="string">"1.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="comment">//建立文件输出通道。StandardOpenOption.CREATE表明如果文件不存在则创建</span></span><br><span class="line">            outChannel = FileChannel.open(Paths.get(<span class="string">"3.txt"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ,</span><br><span class="line">                    StandardOpenOption.CREATE);</span><br><span class="line">            <span class="comment">//使用内存映射文件</span></span><br><span class="line">            <span class="comment">//第一个参数执行映射时的模式，分别有只读和读写等模式</span></span><br><span class="line">            <span class="comment">//第二个和第三个参数用于控制将Channel指定范围的数据映射成ByteBuffer</span></span><br><span class="line">            MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</span><br><span class="line">            MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</span><br><span class="line">            <span class="comment">//直接对缓冲区进行数据的读写操作</span></span><br><span class="line">            <span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</span><br><span class="line">            <span class="comment">//将缓冲区的数据存储进数组中</span></span><br><span class="line">            inMappedBuf.get(dst);</span><br><span class="line">            <span class="comment">//将数组中的数据存储进缓冲区中</span></span><br><span class="line">            outMappedBuf.put(dst);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inChannel != <span class="keyword">null</span>)</span><br><span class="line">                inChannel.close();</span><br><span class="line">            <span class="keyword">if</span> (outChannel != <span class="keyword">null</span>)</span><br><span class="line">                outChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例三：下面演示一下使用通道之间的数据传输来实现文件的复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileCopyDirect2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileChannel inChannel = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel outChannel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 建立文件读取通道。StandardOpenOption.READ指明了以读取的方式打开文件</span></span><br><span class="line">            inChannel = FileChannel.open(Paths.get(<span class="string">"1.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="comment">// 建立文件输出通道。StandardOpenOption.CREATE表明如果文件不存在则创建</span></span><br><span class="line">            outChannel = FileChannel.open(Paths.get(<span class="string">"5.txt"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ,</span><br><span class="line">                    StandardOpenOption.CREATE);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//将inChannel通道指定范围大小的数据传输到outChannel中</span></span><br><span class="line"><span class="comment">//inChannel.transferTo(0, inChannel.size(), outChannel);</span></span><br><span class="line">            <span class="comment">//从通道inChannel中以指定范围大小的数据传输到outChannel</span></span><br><span class="line">            outChannel.transferFrom(inChannel, <span class="number">0</span>, inChannel.size());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inChannel.close();</span><br><span class="line">            outChannel.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-分散-Scatter-和聚集-Gather"><a href="#4-2-分散-Scatter-和聚集-Gather" class="headerlink" title="4.2 分散(Scatter)和聚集(Gather)"></a>4.2 分散(Scatter)和聚集(Gather)</h4><p>分散读取（Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中。需要按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。而聚集写入（Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。如下图示：<br><img src="/2020/01/05/（二）NIO-Channel/2019033120524676.png" alt="在这里插入图片描述">     <img src="/2020/01/05/（二）NIO-Channel/2019033120534588.png" alt="在这里插入图片描述"> </p><p>下面演示<strong>分散读取和聚集写入</strong>的示例，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ScatteringRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        RandomAccessFile raf2 = <span class="keyword">null</span>;</span><br><span class="line">        FileChannel channel2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">"1.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">            <span class="comment">//获取通道</span></span><br><span class="line">            channel = raf.getChannel();</span><br><span class="line">            <span class="comment">//分配指定大小的缓冲区</span></span><br><span class="line">            ByteBuffer buf1 = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            ByteBuffer buf2 = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//分散读取</span></span><br><span class="line">            ByteBuffer[] bufs = &#123;buf1, buf2&#125;;</span><br><span class="line">            channel.read(bufs);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (ByteBuffer byteBuffer : bufs) &#123;</span><br><span class="line">                <span class="comment">//因为channel.read(bufs);执行时会将数据写入缓冲区中，即position已经改变，需flip</span></span><br><span class="line">                byteBuffer.flip();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">0</span>].array(), <span class="number">0</span>, bufs[<span class="number">0</span>].limit()));</span><br><span class="line">            System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bufs[<span class="number">1</span>].array(), <span class="number">0</span>, bufs[<span class="number">1</span>].limit()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//聚集写入</span></span><br><span class="line">            raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="string">"2.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">            channel2 = raf2.getChannel();</span><br><span class="line">            channel2.write(bufs);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>)</span><br><span class="line">                channel.close();</span><br><span class="line">            <span class="keyword">if</span> (raf != <span class="keyword">null</span>)</span><br><span class="line">                raf.close();</span><br><span class="line">            <span class="keyword">if</span> (channel2 != <span class="keyword">null</span>)</span><br><span class="line">                channel2.close();</span><br><span class="line">            <span class="keyword">if</span> (raf2 != <span class="keyword">null</span>)</span><br><span class="line">                raf2.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出如下结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">asfasfasfa</span><br><span class="line">----------------</span><br><span class="line">sf‘sa</span><br><span class="line">阿是大师大师的</span><br><span class="line">啊实打实的看见爱好</span><br></pre></td></tr></table></figure><p>文件 2.txt保存有文件1.txt中的如下数据，同时也是从多个缓冲区中读到的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">asfasfasfa</span><br><span class="line">sf‘sa</span><br><span class="line">阿是大师大师的</span><br><span class="line">啊实打实的看见爱好</span><br></pre></td></tr></table></figure><h3 id="5-字符集-Charset"><a href="#5-字符集-Charset" class="headerlink" title="5. 字符集 Charset"></a>5. 字符集 Charset</h3><p>Charset类提供了一个availableCharsets静态方法来获取当前JDK所支持的所有字符集。下面代码用于获取输出该JDK所支持的所有字符集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCharsets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SortedMap&lt;String,Charset&gt; map = Charset.availableCharsets();</span><br><span class="line">    </span><br><span class="line">    Set&lt;Entry&lt;String,Charset&gt;&gt; set = map.entrySet();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Charset&gt; entry : set) &#123;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Big5=Big5</span><br><span class="line">Big5-HKSCS=Big5-HKSCS</span><br><span class="line">CESU-<span class="number">8</span>=CESU-<span class="number">8</span></span><br><span class="line">EUC-JP=EUC-JP</span><br><span class="line">EUC-KR=EUC-KR</span><br><span class="line">GB18030=GB18030</span><br><span class="line">GB2312=GB2312</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面演示一下对缓冲区的数据进行指定编码和解码的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncoding</span><span class="params">()</span> <span class="keyword">throws</span> CharacterCodingException </span>&#123;</span><br><span class="line">    Charset cs = Charset.forName(<span class="string">"GBK"</span>);</span><br><span class="line">    <span class="comment">//获取编码器</span></span><br><span class="line">    CharsetEncoder encoder = cs.newEncoder();</span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    CharsetDecoder decoder = cs.newDecoder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//向字符缓冲区添加数据</span></span><br><span class="line">    CharBuffer cBuf = CharBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    cBuf.put(<span class="string">"你好"</span>);</span><br><span class="line">    cBuf.flip();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对缓冲区的数据进行编码,encode会改变cBuf的position位置</span></span><br><span class="line">    ByteBuffer bBuf = encoder.encode(cBuf);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出-60-29-70-61</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bBuf.limit(); i++) &#123;</span><br><span class="line">        System.out.print(bBuf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对缓冲区的数据进行解码</span></span><br><span class="line">    bBuf.flip();</span><br><span class="line">    <span class="comment">//decode会改变缓冲区中position的位置</span></span><br><span class="line">    CharBuffer cBuf2 = decoder.decode(bBuf);</span><br><span class="line">    System.out.println(cBuf2.toString());<span class="comment">//你好</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用其他解码器进行解码，会导致乱码</span></span><br><span class="line">    bBuf.flip();</span><br><span class="line">    Charset csUTF8 = Charset.forName(<span class="string">"ISO-8859-1"</span>);</span><br><span class="line">    CharsetDecoder decoderUTF8 = csUTF8.newDecoder();</span><br><span class="line">    CharBuffer cBufUTF8 = decoderUTF8.decode(bBuf);</span><br><span class="line">    System.out.println(cBufUTF8.toString());<span class="comment">//ÄãºÃ</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：要时刻注意缓冲区中position的位置！无论是get方法、put方法还是encode方法和decode方法都会改变缓冲区中的position位置。</p><p>对于 DatagramChannel、SocketChannel 和 ServerSocketChannel 这三个通道类将放于下一篇博客讲。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）NIO - Buffer</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89NIO-Buffer/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89NIO-Buffer/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java-NIO-简介"><a href="#1-Java-NIO-简介" class="headerlink" title="1. Java NIO 简介"></a>1. Java NIO 简介</h1><p> Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， <strong>NIO支持面向缓冲区（Buffer）的、基于通道（Channel）的IO操作。</strong> NIO能以更加高效的方式进行文件的读写操作，并且是<strong>非阻塞IO</strong>。</p><a id="more"></a><p>使用NIO进行数据的读取时，会将文件/网络/磁盘中的数据放入缓冲区中，然后通过通道进行传输，之后再通过程序代码进行数据的其他操作。当使用 NIO进行数据的写入时，通过程序代码将数据存放到缓冲区中，然后再经过通道传输并将缓冲区的数据存储到文件或者进行其他操作。简而言之， Channel 负责传输， Buffer 负责存储。大致流程如下图所示：<br><img src="/2020/01/05/（一）NIO-Buffer/20190331113626214.png" alt="在这里插入图片描述"><br>对于传统的IO，其是<strong>面向流</strong>的。传统的输入输出流都是通过字节的移动来处理的（即使不直接去处理字节流，但底层的实现还是依赖于字节处理），也就是说，面向流的输入/输出系统一次只能处理一个字节，因此面向流的输入/输出系统通常效率不高。另外，<strong>传统的IO是阻塞式IO</strong>。其数据传输的大致流程如下图所示：<br><img src="/2020/01/05/（一）NIO-Buffer/2019033111473055.png" alt="在这里插入图片描述"></p><h1 id="2-使用-Buffer"><a href="#2-使用-Buffer" class="headerlink" title="2. 使用 Buffer"></a>2. 使用 Buffer</h1><p>缓冲区（Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。</p><p>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p><p>ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer 和 DoubleBuffer。</p><p>上述 Buffer 类他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已，都是通如下方法获取一个 Buffer对象：</p><p>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象。</p><h2 id="2-1-Buffer-中的重要概念"><a href="#2-1-Buffer-中的重要概念" class="headerlink" title="2.1 Buffer 中的重要概念"></a>2.1 Buffer 中的重要概念</h2><ul><li><strong>容量 (capacity)</strong> ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。</li><li><strong>限制 (limit)</strong>： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。</li><li><strong>位置 (position)</strong>： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制。</li><li><strong>标记 (mark)与重置 (reset)</strong>： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position。</li></ul><p>标记、 位置、 限制、 容量遵守以下不变式： 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity，可以用下图表示：<br><img src="/2020/01/05/（一）NIO-Buffer/20190331150902388.png" alt="在这里插入图片描述"></p><h2 id="2-2-Buffer-的常用方法"><a href="#2-2-Buffer-的常用方法" class="headerlink" title="2.2 Buffer 的常用方法"></a>2.2 Buffer 的常用方法</h2><p>Buffer 的常用方法及其描述具体如下图所示：<br><img src="/2020/01/05/（一）NIO-Buffer/20190331151008853.png" alt="在这里插入图片描述"><br>Buffer 所有子类提供了两个用于数据操作的方法： get()与 put() 方法。</p><p><strong>获取 Buffer 中的数据</strong>：</p><ul><li>get() ：读取单个字节；</li><li>get(byte[] dst)：批量读取多个字节到 dst 中；</li><li>get(int index)：读取指定索引位置的字节(不会移动 position)。</li></ul><p><strong>放入数据到 Buffer 中：</strong></p><ul><li>put(byte b)：将给定单个字节写入缓冲区的当前位置；</li><li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置；</li><li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(<strong>不会移动 position</strong>)。<h3 id="2-2-1-示例"><a href="#2-2-1-示例" class="headerlink" title="2.2.1 示例"></a>2.2.1 示例</h3></li></ul><p>1.比如，我们可以先创建一个容量大小为10的缓冲区，然后输出其容量，界限等信息。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取指定大小的buffer</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">"------allocate()--------"</span>);</span><br><span class="line">    System.out.println(byteBuffer.capacity());<span class="comment">//10</span></span><br><span class="line">    System.out.println(byteBuffer.position());<span class="comment">//0</span></span><br><span class="line">    System.out.println(byteBuffer.limit());<span class="comment">//10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体图示如下示：<br><img src="/2020/01/05/（一）NIO-Buffer/20190331151638820.png" alt="在这里插入图片描述"><br>2.可以使用put方法向该缓冲区中存储数据，缓冲区的当前位置position会向后移动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向缓冲区存入5个数据</span></span><br><span class="line">byteBuffer.put(<span class="string">"abcde"</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">"------put()--------"</span>);</span><br><span class="line">System.out.println(byteBuffer.capacity());<span class="comment">//10</span></span><br><span class="line">System.out.println(byteBuffer.position());<span class="comment">//5</span></span><br><span class="line">System.out.println(byteBuffer.limit());<span class="comment">//10</span></span><br></pre></td></tr></table></figure><p>存入数据后，缓冲区中的具体图示如下示：<br><img src="/2020/01/05/（一）NIO-Buffer/2019033115192997.png" alt="在这里插入图片描述"><br>3.使用flip方法将缓冲区切换成读模式，具体代码和缓存区变化如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切换成读模式</span></span><br><span class="line">System.out.println(<span class="string">"------flip()--------"</span>);</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">System.out.println(byteBuffer.capacity());<span class="comment">//10</span></span><br><span class="line">System.out.println(byteBuffer.position());<span class="comment">//0</span></span><br><span class="line">System.out.println(byteBuffer.limit());<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p><img src="/2020/01/05/（一）NIO-Buffer/20190331152202880.png" alt="在这里插入图片描述"><br>4.接下来我们才可以进行缓冲区中数据的读取操作，这里使用到了get方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">System.out.println(<span class="string">"------get()--------"</span>);</span><br><span class="line"><span class="comment">//记得是限界以内的数据大小</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.limit()];</span><br><span class="line"><span class="comment">//读取数据到目标数组中</span></span><br><span class="line">byteBuffer.get(buf);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(buf, <span class="number">0</span>, buf.length));<span class="comment">//abcde</span></span><br><span class="line">System.out.println(byteBuffer.capacity());<span class="comment">//10</span></span><br><span class="line">System.out.println(byteBuffer.position());<span class="comment">//5</span></span><br><span class="line">System.out.println(byteBuffer.limit());<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>5.当然我们也可以使用rewind方法将position指针重新指向缓冲区0号位处，然后就可以再次进行数据的读取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复读数据</span></span><br><span class="line">System.out.println(<span class="string">"------rewind()--------"</span>);</span><br><span class="line">byteBuffer.rewind();</span><br><span class="line">System.out.println(byteBuffer.capacity());<span class="comment">//10</span></span><br><span class="line">System.out.println(byteBuffer.position());<span class="comment">//0</span></span><br><span class="line">System.out.println(byteBuffer.limit());<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>6.另外，我们可以使用clear方法清空缓冲区，恢复到缓冲区创建时的初始状态。但是缓冲区中的数据依然存在，但是处于被遗忘状态。所谓被遗忘就是我们无法在确定缓冲区的界限是多少，因此我们便无法自由准确的读取缓冲区中的数据。代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空缓冲区，但是缓冲区中的数据依然存在，但是是处于被遗忘状态</span></span><br><span class="line">System.out.println(<span class="string">"------clear()--------"</span>);</span><br><span class="line">byteBuffer.clear();</span><br><span class="line">System.out.println(byteBuffer.capacity());<span class="comment">//10</span></span><br><span class="line">System.out.println(byteBuffer.position());<span class="comment">//0</span></span><br><span class="line">System.out.println(byteBuffer.limit());<span class="comment">//10</span></span><br><span class="line"><span class="comment">//仍然可以获取缓冲区的数据，但是我们无法确定其界限。</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)byteBuffer.get(<span class="number">0</span>));<span class="comment">//a</span></span><br></pre></td></tr></table></figure><p>7.最后我们在演示一下mark和reset方法的使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRemark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String data = <span class="string">"abcde"</span>;</span><br><span class="line">    <span class="comment">//获取指定大小的buffer</span></span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    byteBuffer.put(data.getBytes());</span><br><span class="line">    <span class="comment">//标记当前位置</span></span><br><span class="line">    System.out.println(<span class="string">"mark position = "</span> + byteBuffer.position());<span class="comment">//5</span></span><br><span class="line">    byteBuffer.mark();</span><br><span class="line">    <span class="comment">//再次向缓冲区存取数据</span></span><br><span class="line">    byteBuffer.put(<span class="string">"fg"</span>.getBytes());</span><br><span class="line">    System.out.println(<span class="string">"before reset position = "</span> + byteBuffer.position());<span class="comment">//7</span></span><br><span class="line">    <span class="comment">//reset回到mark标记的位置</span></span><br><span class="line">    byteBuffer.reset();</span><br><span class="line">    System.out.println(<span class="string">"after reset position = "</span> + byteBuffer.position());<span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-直接缓冲区与非直接缓冲区"><a href="#3-直接缓冲区与非直接缓冲区" class="headerlink" title="3. 直接缓冲区与非直接缓冲区"></a>3. 直接缓冲区与非直接缓冲区</h1><p>前面，我们都是使用allocate方法来创建缓冲区的，其所创建的缓冲区为<strong>非直接缓冲区</strong>。该缓冲区是建立在 JVM 的内存中的。</p><p>若使用非直接缓冲区，那么当应用程序向操作系统的磁盘发出一次读写请求时，其过程涉及到内核地址空间和用户地址空间之间数据的来回拷贝操作，这无疑会增加数据的读写的操作时间。具体过程如下图所示：<br><img src="/2020/01/05/（一）NIO-Buffer/20190331154157596.png" alt="在这里插入图片描述"><br>当然，我们也可以使用allocateDirect方法（<strong>注：只有ByteBuffer有提供该方法</strong>）来创建直接缓冲区，直接缓冲区的读写过程如下图所示：<br><img src="/2020/01/05/（一）NIO-Buffer/20190331160053865.png" alt="在这里插入图片描述"><br>它避免了内核地址空间和用户地址空间之间的数据的来回拷贝，而是直接在物理磁盘和应用程序之间建立一个操作系统中的物理内存映射文件。当然，对直接缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。</p><p>直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区，毕竟直接缓冲区的创建成本比较高。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</p><p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBufferType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuffer allocateDirect = ByteBuffer.allocateDirect(<span class="number">100</span>);</span><br><span class="line">    System.out.println(allocateDirect.isDirect());<span class="comment">//true</span></span><br><span class="line">    </span><br><span class="line">    ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">    System.out.println(byteBuffer.isDirect());<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> NIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（十）Java集合框架内幕-WeakHashMap</title>
      <link href="/2020/01/05/%EF%BC%88%E5%8D%81%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-WeakHashMap/"/>
      <url>/2020/01/05/%EF%BC%88%E5%8D%81%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-WeakHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p>在Java集合框架系列文章的最后，笔者打算介绍一个特殊的成员：<em>WeakHashMap<em>，从名字可以看出它是某种 *Map</em>。它的特殊之处在于 *WeakHashMap</em> 里的<code>entry</code>可能会被GC自动删除，即使程序员没有调用<code>remove()</code>或者<code>clear()</code>方法。</p><a id="more"></a><p>更直观的说，当使用 <em>WeakHashMap</em> 时，即使没有显示的添加或删除任何元素，也可能发生如下情况：</p><blockquote><ul><li>调用两次<code>size()</code>方法返回不同的值；</li><li>两次调用<code>isEmpty()</code>方法，第一次返回<code>false</code>，第二次返回<code>true</code>；</li><li>两次调用<code>containsKey()</code>方法，第一次返回<code>true</code>，第二次返回<code>false</code>，尽管两次使用的是同一个<code>key</code>；</li><li>两次调用<code>get()</code>方法，第一次返回一个<code>value</code>，第二次返回<code>null</code>，尽管两次使用的是同一个对象。</li></ul></blockquote><p>遇到这么奇葩的现象，你是不是觉得使用者一定会疯掉？其实不然，<strong><em>WeekHashMap</em> 的这个特点特别适用于需要缓存的场景</strong>。在缓存场景下，由于内存是有限的，不能缓存所有对象；对象缓存命中可以提高系统效率，但缓存MISS也不会造成错误，因为可以通过计算重新得到。</p><p>要明白 <em>WeekHashMap</em> 的工作原理，还需要引入一个概念：<strong>弱引用（WeakReference）</strong>。我们都知道Java中内存是通过GC自动管理的，GC会在程序运行过程中自动判断哪些对象是可以被回收的，并在合适的时机进行内存释放。GC判断某个对象是否可被回收的依据是，<strong>是否有有效的引用指向该对象</strong>。如果没有有效引用指向该对象（基本意味着不存在访问该对象的方式），那么该对象就是可回收的。这里的<strong>“有效引用”</strong>并不包括<strong>弱引用</strong>。也就是说，<strong>虽然弱引用可以用来访问对象，但进行垃圾回收时弱引用并不会被考虑在内，仅有弱引用指向的对象仍然会被GC回收</strong>。</p><p><em>WeakHashMap</em> 内部是通过弱引用来管理<code>entry</code>的，弱引用的特性对应到 <em>WeakHashMap</em> 上意味着什么呢？<strong>将一对<code>key, value</code>放入到 <em>WeakHashMap</em> 里并不能避免该<code>key</code>值被GC回收，除非在 <em>WeakHashMap</em> 之外还有对该<code>key</code>的强引用</strong>。</p><p>关于强引用，弱引用等概念以后再具体讲解，这里只需要知道Java中引用也是分种类的，并且不同种类的引用对GC的影响不同就够了。</p><h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2. 具体实现"></a>2. 具体实现</h1><p>WeakHashMap的存储结构类似于HashMap，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="noopener">参考前文</a>，这里不再赘述。</p><p>关于强弱引用的管理方式，博主将会另开专题单独讲解。</p><h1 id="3-Weak-HashSet"><a href="#3-Weak-HashSet" class="headerlink" title="3. Weak HashSet?"></a>3. Weak HashSet?</h1><p>如果你看过前几篇关于 <em>Map</em> 和 <em>Set</em> 的讲解，一定会问：既然有 <em>WeekHashMap*，是否有 *WeekHashSet</em> 呢？答案是没有:( 。不过Java <em>Collections</em>工具类给出了解决方案，<code>Collections.newSetFromMap(Map&lt;E,Boolean&gt; map)</code>方法可以将任何 <em>Map</em>包装成一个<em>Set</em>。通过如下方式可以快速得到一个 <em>Weak HashSet</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将WeakHashMap包装成一个Set</span></span><br><span class="line">Set&lt;Object&gt; weakHashSet = Collections.newSetFromMap(</span><br><span class="line">        <span class="keyword">new</span> WeakHashMap&lt;Object, Boolean&gt;());</span><br></pre></td></tr></table></figure><p>不出你所料，<code>newSetFromMap()</code>方法只是对传入的 <em>Map</em>做了简单包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.newSetFromMap()用于将任何Map包装成一个Set</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">newSetFromMap</span><span class="params">(Map&lt;E, Boolean&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SetFromMap&lt;&gt;(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SetFromMap</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;E, Boolean&gt; m;  <span class="comment">// The backing map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;E&gt; s;       <span class="comment">// Its keySet</span></span><br><span class="line">    SetFromMap(Map&lt;E, Boolean&gt; map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Map is non-empty"</span>);</span><br><span class="line">        m = map;</span><br><span class="line">        s = map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123;        m.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> m.size(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> m.isEmpty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> m.containsKey(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> m.remove(o) != <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; <span class="keyword">return</span> m.put(e, Boolean.TRUE) == <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> s.iterator(); &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray()         &#123; <span class="keyword">return</span> s.toArray(); &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)     &#123; <span class="keyword">return</span> s.toArray(a); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> s.toString(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>             </span>&#123; <span class="keyword">return</span> s.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span>   </span>&#123; <span class="keyword">return</span> o == <span class="keyword">this</span> || s.equals(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;<span class="keyword">return</span> s.containsAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.removeAll(c);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span>   </span>&#123;<span class="keyword">return</span> s.retainAll(c);&#125;</span><br><span class="line">    <span class="comment">// addAll is the only inherited implementation</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h1><p>至此<em>Java Collections Framework Internals</em>系列已经全部讲解完毕，希望这几篇简短的博文能够帮助各位读者对Java容器框架建立基本的理解。通过这里可以返回<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/0-Introduction.md" target="_blank" rel="noopener">本系列文章目录</a></p><p>如果对各位有哪怕些微的帮助，博主将感到非常高兴！如果博文中有任何的纰漏和谬误，欢迎各位博友指正。</p><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（九）Java集合框架内幕-PriorityQueue</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B9%9D%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-PriorityQueue/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B9%9D%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-PriorityQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p>前面以Java <em>ArrayDeque</em>为例讲解了<em>Stack</em>和<em>Queue</em>，其实还有一种特殊的队列叫做<em>PriorityQueue</em>，即优先队列。<strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，<strong>元素大小的评判可以通过元素本身的自然顺序（<em>natural ordering</em>），也可以通过构造时传入的比较器</strong>（<em>Comparator</em>，类似于C++的仿函数）。</p><a id="more"></a><p>Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是通过完全二叉树（<em>complete binary tree</em>）实现的<strong>小顶堆</strong>（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。</p><p><img src="/2020/01/05/（九）Java集合框架内幕-PriorityQueue/20190115151242961.png" alt="在这里插入图片描述"></p><p>上图中我们给每个元素按照层序遍历的方式进行了编号，如果你足够细心，会发现父节点和子节点的编号是有联系的，更确切的说父子节点的编号之间有如下关系：</p><p><code>leftNo = parentNo*2+1</code></p><p><code>rightNo = parentNo*2+2</code></p><p><code>parentNo = (nodeNo-1)/2</code></p><p>通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。</p><p><em>PriorityQueue</em>的<code>peek()</code>和<code>element</code>操作是常数时间，<code>add()</code>, <code>offer()</code>, 无参数的<code>remove()</code>以及<code>poll()</code>方法的时间复杂度都是<em>log(N)</em>。</p><h1 id="2-方法剖析"><a href="#2-方法剖析" class="headerlink" title="2. 方法剖析"></a>2. 方法剖析</h1><h2 id="2-1-add-和offer"><a href="#2-1-add-和offer" class="headerlink" title="2.1 add()和offer()"></a>2.1 add()和offer()</h2><p><code>add(E e)</code>和<code>offer(E e)</code>的语义相同，都是向优先队列中插入元素，只是<code>Queue</code>接口规定二者对插入失败时的处理不同，前者在插入失败时抛出异常，后则则会返回<code>false</code>。对于<em>PriorityQueue</em>这两个方法其实没什么差别。</p><p><img src="/2020/01/05/（九）Java集合框架内幕-PriorityQueue/20190115151306563.png" alt="在这里插入图片描述"></p><p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//offer(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null元素</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);<span class="comment">//自动扩容</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)<span class="comment">//队列原来为空，这是插入的第一个元素</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，扩容函数<code>grow()</code>类似于<code>ArrayList</code>里的<code>grow()</code>函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是<code>siftUp(int k, E x)</code>方法，该方法用于插入元素<code>x</code>并维持堆的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftUp()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//parentNo = (nodeNo-1)/2</span></span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)<span class="comment">//调用比较器的比较方法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入的元素<code>x</code>可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层与当前点的<code>parent</code>进行比较并交换，直到满足<code>x &gt;= queue[parent]</code>为止</strong>。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。</p><h2 id="2-2-element-和peek"><a href="#2-2-element-和peek" class="headerlink" title="2.2 element()和peek()"></a>2.2 element()和peek()</h2><p><code>element()</code>和<code>peek()</code>的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回<code>null</code>。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，<code>0</code>下标处的那个元素既是堆顶元素。所以<strong>直接返回数组<code>0</code>下标处的那个元素即可</strong>。</p><p><img src="/2020/01/05/（九）Java集合框架内幕-PriorityQueue/20190115151354545.png" alt="在这里插入图片描述"></p><p>代码也就非常简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//peek()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-remove-和poll"><a href="#2-3-remove-和poll" class="headerlink" title="2.3 remove()和poll()"></a>2.3 remove()和poll()</h2><p><code>remove()</code>和<code>poll()</code>方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回<code>null</code>。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。</p><p><img src="/2020/01/05/（九）Java集合框架内幕-PriorityQueue/20190115151421407.png" alt="在这里插入图片描述"><br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];<span class="comment">//0下标处的那个元素就是最小的那个</span></span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);<span class="comment">//调整</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码首先记录<code>0</code>下标处的元素，并用最后一个元素替换<code>0</code>下标位置的元素，之后调用<code>siftDown()</code>方法对堆进行调整，最后返回原来<code>0</code>下标处的那个元素（也就是最小的那个元素）。重点是<code>siftDown(int k, E x)</code>方法，该方法的作用是<strong>从<code>k</code>指定的位置开始，将<code>x</code>逐层向下与当前点的左右孩子中较小的那个交换，直到<code>x</code>小于或等于左右孩子中的任何一个为止</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//siftDown()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">    <span class="comment">//首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;<span class="comment">//leftNo = parentNo*2+1</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;<span class="comment">//然后用c取代原来的值</span></span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-remove-Object-o"><a href="#2-4-remove-Object-o" class="headerlink" title="2.4 remove(Object o)"></a>2.4 remove(Object o)</h2><p><code>remove(Object o)</code>方法用于删除队列中跟<code>o</code>相等的某一个元素（如果有多个相等，只删除一个），该方法不是<em>Queue</em>接口内的方法，而是<em>Collection</em>接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，<code>remove(Object o)</code>可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次<code>siftDown()</code>即可。此处不再赘述。</p><p><img src="/2020/01/05/（九）Java集合框架内幕-PriorityQueue/20190115151452348.png" alt="在这里插入图片描述"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//remove(Object o)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(o);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="keyword">if</span> (s == i) <span class="comment">//情况1</span></span><br><span class="line">        queue[i] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        E moved = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        siftDown(i, moved);<span class="comment">//情况2</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（八）Java集合框架内幕-LinkedHashSet and LinkedHashMap</title>
      <link href="/2020/01/05/%EF%BC%88%E5%85%AB%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-LinkedHashSet-and-LinkedHashMap/"/>
      <url>/2020/01/05/%EF%BC%88%E5%85%AB%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-LinkedHashSet-and-LinkedHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p>如果你已看过前面关于<em>HashSet</em>和<em>HashMap</em>，以及<em>TreeSet</em>和<em>TreeMap</em>的讲解，一定能够想到本文将要讲解的<em>LinkedHashSet</em>和<em>LinkedHashMap</em>其实也是一回事。<em>LinkedHashSet</em>和<em>LinkedHashMap</em>在Java里也有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>LinkedHashSet</em>里面有一个<em>LinkedHashMap</em>（适配器模式）</strong>。因此本文将重点分析<em>LinkedHashMap</em>。</p><a id="more"></a><p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。<strong>可将<em>LinkedHashMap</em>看作采用<em>linked list</em>增强的<em>HashMap</em>。</strong></p><p><img src="/2020/01/05/（八）Java集合框架内幕-LinkedHashSet-and-LinkedHashMap/20190115150820231.png" alt="在这里插入图片描述"></p><p>事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，<strong>二者唯一的区别是<em>LinkedHashMap</em>在<em>HashMap</em>的基础上，采用双向链表（doubly-linked list）的形式将所有<code>entry</code>连接起来，这样是为保证元素的迭代顺序跟插入顺序相同</strong>。上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部（是一个哑元），<strong>该双向链表的迭代顺序就是<code>entry</code>的插入顺序</strong>。</p><p>除了可以保迭代历顺序，这种结构还有一个好处：<strong>迭代<em>LinkedHashMap</em>时不需要像<em>HashMap</em>那样遍历整个<code>table</code>，而只需要直接遍历<code>header</code>指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p><p>有两个参数可以影响<em>LinkedHashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>LinkedHashMap<em>或</em>LinkedHashSet<em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。*</em><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到<code>LinkedHashMap</code>或<code>LinkedHashSet</code>中，需要</em>@Override*<code>hashCode()</code>和<code>equals()</code>方法。</p><p>通过如下方式可以得到一个跟源<em>Map</em> <strong>迭代顺序</strong>一样的<em>LinkedHashMap</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</span><br><span class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于性能原因，<em>LinkedHashMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成（wrapped）同步的：</p><p><code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p><h1 id="2-方法剖析"><a href="#2-方法剖析" class="headerlink" title="2. 方法剖析"></a>2. 方法剖析</h1><h2 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get()"></a>2.1 get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>。该方法跟<code>HashMap.get()</code>方法的流程几乎完全一样，读者可自行<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md#get" target="_blank" rel="noopener">参考前文</a>，这里不再赘述。</p><h2 id="2-2-put"><a href="#2-2-put" class="headerlink" title="2.2 put()"></a>2.2 put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p><p>注意，这里的<strong>插入有两重含义</strong>：</p><blockquote><ol><li>从<code>table</code>的角度看，新的<code>entry</code>需要插入到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入到冲突链表的头部。</li><li>从<code>header</code>的角度看，新的<code>entry</code>需要插入到双向链表的尾部。</li></ol></blockquote><p><img src="/2020/01/05/（八）Java集合框架内幕-LinkedHashSet-and-LinkedHashMap/20190115150909163.png" alt="在这里插入图片描述"></p><p><code>addEntry()</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">// 自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">// hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.在冲突链表头部插入新的entry</span></span><br><span class="line">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, old);</span><br><span class="line">    table[bucketIndex] = e;</span><br><span class="line">    <span class="comment">// 2.在双向链表的尾部插入新的entry</span></span><br><span class="line">    e.addBefore(header);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中用到了<code>addBefore()</code>方法将新<code>entry e</code>插入到双向链表头引用<code>header</code>的前面，这样<code>e</code>就成为双向链表中的最后一个元素。<code>addBefore()</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.Entry.addBefor()，将this插入到existingEntry的前面</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addBefore</span><span class="params">(Entry&lt;K,V&gt; existingEntry)</span> </span>&#123;</span><br><span class="line">    after  = existingEntry;</span><br><span class="line">    before = existingEntry.before;</span><br><span class="line">    before.after = <span class="keyword">this</span>;</span><br><span class="line">    after.before = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码只是简单修改相关<code>entry</code>的引用而已。</p><h2 id="2-3-remove"><a href="#2-3-remove" class="headerlink" title="2.3 remove()"></a>2.3 remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>get()</code>方法类似。</p><p>注意，这里的<strong>删除也有两重含义</strong>：</p><blockquote><ol><li>从<code>table</code>的角度看，需要将该<code>entry</code>从对应的<code>bucket</code>里删除，如果对应的冲突链表不空，需要修改冲突链表的相应引用。</li><li>从<code>header</code>的角度来看，需要将该<code>entry</code>从双向链表中删除，同时修改链表中前面以及后面元素的相应引用。</li></ol></blockquote><p><img src="/2020/01/05/（八）Java集合框架内幕-LinkedHashSet-and-LinkedHashMap/20190115150952872.png" alt="在这里插入图片描述"></p><p><code>removeEntryForKey()</code>对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.removeEntryForKey()，删除key值对应的entry</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">// hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">// 得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">// 遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">// 找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="comment">// 1. 将e从对应bucket的冲突链表中删除</span></span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;</span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="comment">// 2. 将e从双向链表中删除</span></span><br><span class="line">            e.before.after = e.after;</span><br><span class="line">            e.after.before = e.before;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-LinkedHashSet"><a href="#3-LinkedHashSet" class="headerlink" title="3. LinkedHashSet"></a>3. LinkedHashSet</h1><p>前面已经说过<em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// LinkedHashSet里面有一个LinkedHashMap</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-LinkedHashMap经典用法"><a href="#4-LinkedHashMap经典用法" class="headerlink" title="4. LinkedHashMap经典用法"></a>4. LinkedHashMap经典用法</h1><p><em>LinkedHashMap</em>除了可以保证迭代顺序外，还有一个非常有用的用法：可以轻松实现一个采用了FIFO替换策略的缓存。具体说来，LinkedHashMap有一个子类方法<code>protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)</code>，该方法的作用是告诉Map是否要删除“最老”的Entry，所谓最老就是当前Map中最早插入的Entry，如果该方法返回<code>true</code>，最老的那个元素就会被删除。在每次插入新元素的之后LinkedHashMap会自动询问removeEldestEntry()是否要删除最老的元素。这样只需要在子类中重载该方法，当元素个数超过一定数量时让removeEldestEntry()返回true，就能够实现一个固定大小的FIFO策略的缓存。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个固定大小的FIFO替换策略的缓存 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FIFOCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> cacheSize;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FIFOCache</span><span class="params">(<span class="keyword">int</span> cacheSize)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheSize = cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当Entry个数超过cacheSize时，删除最老的Entry</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> size() &gt; cacheSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（七）Java集合框架内幕-HashSet and HashMap</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%83%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-HashSet-and-HashMap/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%83%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-HashSet-and-HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p>之所以把<em>HashSet</em>和<em>HashMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>HashSet</em>里面有一个<em>HashMap</em>（适配器模式）</strong>。因此本文将重点分析<em>HashMap</em>。</p><p><em>HashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素；除该类未实现同步外，其余跟<code>Hashtable</code>大致相同；跟<em>TreeMap</em>不同，该容器不保证元素顺序，根据需要该容器可能会对元素重新哈希，元素的顺序也会被重新打散，因此不同时间迭代同一个<em>HashMap</em>的顺序可能会不同。</p><a id="more"></a><p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式（Open addressing），另一种是冲突链表方式（Separate chaining with linked lists）。<strong>Java <em>HashMap</em>采用的是冲突链表方式</strong>。<br><img src="/2020/01/05/（七）Java集合框架内幕-HashSet-and-HashMap/20190115150349167.png" alt="在这里插入图片描述"><br>从上图容易看出，如果选择合适的哈希函数，<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</p><p>有两个参数可以影响<em>HashMap</em>的性能：初始容量（inital capacity）和负载系数（load factor）。初始容量指定了初始<code>table</code>的大小，负载系数用来指定自动扩容的临界值。当<code>entry</code>的数量超过<code>capacity*load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p><p>将对象放入到<em>HashMap<em>或</em>HashSet<em>中时，有两个方法需要特别关心：<code>hashCode()</code>和<code>equals()</code>。*</em><code>hashCode()</code>方法决定了对象会被放到哪个<code>bucket</code>里，当多个对象的哈希值冲突时，<code>equals()</code>方法决定了这些对象是否是“同一个对象”**。所以，如果要将自定义的对象放入到<code>HashMap</code>或<code>HashSet</code>中，需要</em>@Override*<code>hashCode()</code>和<code>equals()</code>方法。</p><h1 id="2-方法剖析"><a href="#2-方法剖析" class="headerlink" title="2. 方法剖析"></a>2. 方法剖析</h1><h2 id="2-1-get"><a href="#2-1-get" class="headerlink" title="2.1 get()"></a>2.1 get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。<br>算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。<br><img src="/2020/01/05/（七）Java集合框架内幕-HashSet-and-HashMap/20190115150429415.png" alt="在这里插入图片描述"><br>上图中<code>hash(k)&amp;(table.length-1)</code>等价于<code>hash(k)%table.length</code>，原因是<em>HashMap</em>要求<code>table.length</code>必须是2的指数，因此<code>table.length-1</code>就是二进制低位全是1，跟<code>hash(k)</code>相与会将哈希值的高位全抹掉，剩下的就是余数了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class="number">1</span>)];<span class="comment">//得到冲突链表</span></span><br><span class="line">         e != <span class="keyword">null</span>; e = e.next) &#123;<span class="comment">//依次遍历冲突链表中的每个entry</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="comment">//依据equals()方法判断是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-put"><a href="#2-2-put" class="headerlink" title="2.2 put()"></a>2.2 put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。<br><img src="/2020/01/05/（七）Java集合框架内幕-HashSet-and-HashMap/20190115150455221.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);<span class="comment">//自动扩容，并重新哈希</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = hash &amp; (table.length-<span class="number">1</span>);<span class="comment">//hash%table.length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在冲突链表头部插入新的entry</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法的具体逻辑是在<code>removeEntryForKey(Object key)</code>里实现的。<code>removeEntryForKey()</code>方法会首先找到<code>key</code>值对应的<code>entry</code>，然后删除该<code>entry</code>（修改链表的相应引用）。查找过程跟<code>getEntry()</code>过程类似。<br><img src="/2020/01/05/（七）Java集合框架内幕-HashSet-and-HashMap/20190115150519656.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//removeEntryForKey()</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);<span class="comment">//hash&amp;(table.length-1)</span></span><br><span class="line">    Entry&lt;K,V&gt; prev = table[i];<span class="comment">//得到冲突链表</span></span><br><span class="line">    Entry&lt;K,V&gt; e = prev;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//遍历冲突链表</span></span><br><span class="line">        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<span class="comment">//找到要删除的entry</span></span><br><span class="line">            modCount++; size--;</span><br><span class="line">            <span class="keyword">if</span> (prev == e) table[i] = next;<span class="comment">//删除的是冲突链表的第一个entry</span></span><br><span class="line">            <span class="keyword">else</span> prev.next = next;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = e; e = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-HashSet"><a href="#3-HashSet" class="headerlink" title="3. HashSet"></a>3. HashSet</h1><p>前面已经说过<em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet是对HashMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;<span class="comment">//HashSet里面有一个HashMap</span></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;<span class="comment">//简单的方法转换</span></span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（六）Java集合框架内幕-TreeSet and TreeMap</title>
      <link href="/2020/01/05/%EF%BC%88%E5%85%AD%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-TreeSet-and-TreeMap/"/>
      <url>/2020/01/05/%EF%BC%88%E5%85%AD%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-TreeSet-and-TreeMap/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p>之所以把<em>TreeSet</em>和<em>TreeMap</em>放在一起讲解，是因为二者在Java里有着相同的实现，前者仅仅是对后者做了一层包装，也就是说<strong><em>TreeSet</em>里面有一个<em>TreeMap</em>（适配器模式）</strong>。因此本文将重点分析<em>TreeMap</em>。</p><p>Java <em>TreeMap</em>实现了<em>SortedMap</em>接口，也就是说会按照<code>key</code>的大小顺序对<em>Map</em>中的元素进行排序，<code>key</code>大小的评判可以通过其本身的自然顺序（natural ordering），也可以通过构造时传入的比较器（Comparator）。</p><p><strong><em>TreeMap</em>底层通过红黑树（Red-Black tree）实现</strong>，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。其具体算法实现参照了《算法导论》。</p><a id="more"></a><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115145759432.png" alt="在这里插入图片描述"></p><p>出于性能原因，<em>TreeMap</em>是非同步的（not synchronized），如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成（wrapped）同步的：</p><p><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></p><p><strong>红黑树是一种近似平衡的二叉查找树，它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一陪</strong>。具体来说，红黑树是满足如下条件的二叉查找树（binary search tree）：</p><ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色</li><li>红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</li><li>对于每个节点，从该点至<code>null</code>（树尾端）的任何路径，都含有相同个数的黑色节点。</li></ol><p>在树的结构发生改变时（插入或者删除操作），往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的约束条件。</p><h1 id="2-预备知识"><a href="#2-预备知识" class="headerlink" title="2. 预备知识"></a>2. 预备知识</h1><p>前文说到当查找树的结构发生改变时，红黑树的约束条件可能被破坏，需要通过调整使得查找树重新满足红黑树的约束条件。调整可以分为两类：一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：<strong>左旋（Rotate Left），右旋（RotateRight）</strong>。</p><h2 id="2-1-左旋"><a href="#2-1-左旋" class="headerlink" title="2.1 左旋"></a>2.1 左旋</h2><p>左旋的过程是将<code>x</code>的右子树绕<code>x</code>逆时针旋转，使得<code>x</code>的右子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115145826979.png" alt="在这里插入图片描述"></p><p><em>TreeMap</em>中左旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Left</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-右旋"><a href="#2-2-右旋" class="headerlink" title="2.2 右旋"></a>2.2 右旋</h2><p>右旋的过程是将<code>x</code>的左子树绕<code>x</code>顺时针旋转，使得<code>x</code>的左子树成为<code>x</code>的父亲，同时修改相关节点的引用。旋转之后，二叉查找树的属性仍然满足。</p><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115145903786.png" alt="在这里插入图片描述"></p><p><em>TreeMap</em>中右旋代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Rotate Right</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-寻找节点后继"><a href="#2-3-寻找节点后继" class="headerlink" title="2.3 寻找节点后继"></a>2.3 寻找节点后继</h2><p>对于一棵二叉查找树，给定节点t，其后继（树中比大于t的最小的那个元素）可以通过如下方式找到：</p><blockquote><ol><li>t的右子树不空，则t的后继是其右子树中最小的那个元素。</li><li>t的右孩子为空，则t的后继是其第一个向左走的祖先。</li></ol></blockquote><p>后继节点在红黑树的删除操作中将会用到。</p><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115145929167.png" alt="在这里插入图片描述"></p><p><em>TreeMap</em>中寻找节点后继的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找节点后继函数successor()</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;<span class="comment">// 1. t的右子树不空，则t的后继是其右子树中最小的那个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.right;</span><br><span class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2. t的右孩子为空，则t的后继是其第一个向左走的祖先</span></span><br><span class="line">        Entry&lt;K,V&gt; p = t.parent;</span><br><span class="line">        Entry&lt;K,V&gt; ch = t;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</span><br><span class="line">            ch = p;</span><br><span class="line">            p = p.parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-方法剖析"><a href="#3-方法剖析" class="headerlink" title="3. 方法剖析"></a>3. 方法剖析</h1><h2 id="3-1-get"><a href="#3-1-get" class="headerlink" title="3.1 get()"></a>3.1 get()</h2><p><code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.value</code>。因此<code>getEntry()</code>是算法的核心。算法思想是根据<code>key</code>的自然顺序（或者比较器顺序）对二叉查找树进行查找，直到找到满足<code>k.compareTo(p.key) == 0</code>的<code>entry</code>。</p><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115145950981.png" alt="在这里插入图片描述"></p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//getEntry()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//不允许key值为null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">//向左找</span></span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">//向右找</span></span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-put"><a href="#3-2-put" class="headerlink" title="3.2 put()"></a>3.2 put()</h2><p><code>put(K key, V value)</code>方法是将指定的<code>key</code>, <code>value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到则会在红黑树中插入新的<code>entry</code>，如果插入之后破坏了红黑树的约束条件，还需要进行调整（旋转，改变某些节点的颜色）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);<span class="comment">//调整</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的插入部分并不难理解：首先在红黑树上找到合适的位置，然后创建新的<code>entry</code>并插入（当然，新插入的节点一定是树的叶子）。难点是调整函数<code>fixAfterInsertion()</code>，前面已经说过，调整往往需要1.改变某些节点的颜色，2.对某些节点进行旋转。</p><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115150014927.png" alt="在这里插入图片描述"></p><p>调整函数<code>fixAfterInsertion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况2其实是落在情况3内的。情况4～情况6跟前三种情况是对称的，因此图解中并没有画出后三种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//红黑树调整函数fixAfterInsertion()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况1</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况1</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况2</span></span><br><span class="line">                    rotateLeft(x);                         <span class="comment">// 情况2</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况3</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况3</span></span><br><span class="line">                rotateRight(parentOf(parentOf(x)));        <span class="comment">// 情况3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况4</span></span><br><span class="line">                setColor(y, BLACK);                        <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况4</span></span><br><span class="line">                x = parentOf(parentOf(x));                 <span class="comment">// 情况4</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);                       <span class="comment">// 情况5</span></span><br><span class="line">                    rotateRight(x);                        <span class="comment">// 情况5</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);              <span class="comment">// 情况6</span></span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);      <span class="comment">// 情况6</span></span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));         <span class="comment">// 情况6</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-remove"><a href="#3-3-remove" class="headerlink" title="3.3 remove()"></a>3.3 remove()</h2><p><code>remove(Object key)</code>的作用是删除<code>key</code>值对应的<code>entry</code>，该方法首先通过上文中提到的<code>getEntry(Object key)</code>方法找到<code>key</code>值对应的<code>entry</code>，然后调用<code>deleteEntry(Entry&lt;K,V&gt; entry)</code>删除对应的<code>entry</code>。由于删除操作会改变红黑树的结构，有可能破坏红黑树的约束条件，因此有可能要进行调整。</p><p><code>getEntry()</code>函数前面已经讲解过，这里重点放<code>deleteEntry()</code>上，该函数删除指定的<code>entry</code>并在红黑树的约束被破坏时进行调用<code>fixAfterDeletion(Entry&lt;K,V&gt; x)</code>进行调整。</p><p><strong>由于红黑树是一棵增强版的二叉查找树，红黑树的删除操作跟普通二叉查找树的删除操作也就非常相似，唯一的区别是红黑树在节点删除之后可能需要进行调整</strong>。现在考虑一棵普通二叉查找树的删除过程，可以简单分为两种情况：</p><blockquote><ol><li>删除点p的左右子树都为空，或者只有一棵子树非空。</li><li>删除点p的左右子树都非空。</li></ol></blockquote><p>对于上述情况1，处理起来比较简单，直接将p删除（左右子树都为空时），或者用非空子树替代p（只有一棵子树非空时）；对于情况2，可以用p的后继s（树中大于x的最小的那个元素）代替p，然后使用情况1删除s（此时s一定满足情况1.可以画画看）。</p><p>基于以上逻辑，红黑树的节点删除函数<code>deleteEntry()</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树entry删除函数deleteEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;<span class="comment">// 2. 删除点p的左右子树都非空。</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);<span class="comment">// 后继</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 1. 删除点p只有一棵子树非空。</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);<span class="comment">// 调整</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 1. 删除点p的左右子树都为空</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);<span class="comment">// 调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中占据大量代码行的，是用来修改父子节点间引用关系的代码，其逻辑并不难理解。下面着重讲解删除后调整函数<code>fixAfterDeletion()</code>。首先请思考一下，删除了哪些点才会导致调整？<strong>只有删除点是BLACK的时候，才会触发调整函数</strong>，因为删除RED节点不会破坏红黑树的任何约束，而删除BLACK节点会破坏规则4。</p><p>跟上文中讲过的<code>fixAfterInsertion()</code>函数一样，这里也要分成若干种情况。记住，<strong>无论有多少情况，具体的调整操作只有两种：1.改变某些节点的颜色，2.对某些节点进行旋转。</strong></p><p><img src="/2020/01/05/（六）Java集合框架内幕-TreeSet-and-TreeMap/20190115150051448.png" alt="在这里插入图片描述"></p><p>上述图解的总体思想是：将情况1首先转换成情况2，或者转换成情况3和情况4。当然，该图解并不意味着调整过程一定是从情况1开始。通过后续代码我们还会发现几个有趣的规则：a).如果是由情况1之后紧接着进入的情况2，那么情况2之后一定会退出循环（因为x为红色）；b).一旦进入情况3和情况4，一定会退出循环（因为x为root）。</p><p>删除后调整函数<code>fixAfterDeletion()</code>的具体代码如下，其中用到了上文中提到的<code>rotateLeft()</code>和<code>rotateRight()</code>函数。通过代码我们能够看到，情况3其实是落在情况4内的。情况5～情况8跟前四种情况是对称的，因此图解中并没有画出后四种情况，读者可以参考代码自行理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况1</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况1</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况1</span></span><br><span class="line">                sib = rightOf(parentOf(x));             <span class="comment">// 情况1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况2</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);       <span class="comment">// 情况3</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况3</span></span><br><span class="line">                    rotateRight(sib);                   <span class="comment">// 情况3</span></span><br><span class="line">                    sib = rightOf(parentOf(x));         <span class="comment">// 情况3</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况4</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况4</span></span><br><span class="line">                setColor(rightOf(sib), BLACK);          <span class="comment">// 情况4</span></span><br><span class="line">                rotateLeft(parentOf(x));                <span class="comment">// 情况4</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况4</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 跟前四种情况对称</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);                   <span class="comment">// 情况5</span></span><br><span class="line">                setColor(parentOf(x), RED);             <span class="comment">// 情况5</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况5</span></span><br><span class="line">                sib = leftOf(parentOf(x));              <span class="comment">// 情况5</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);                     <span class="comment">// 情况6</span></span><br><span class="line">                x = parentOf(x);                        <span class="comment">// 情况6</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);      <span class="comment">// 情况7</span></span><br><span class="line">                    setColor(sib, RED);                 <span class="comment">// 情况7</span></span><br><span class="line">                    rotateLeft(sib);                    <span class="comment">// 情况7</span></span><br><span class="line">                    sib = leftOf(parentOf(x));          <span class="comment">// 情况7</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));    <span class="comment">// 情况8</span></span><br><span class="line">                setColor(parentOf(x), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                setColor(leftOf(sib), BLACK);           <span class="comment">// 情况8</span></span><br><span class="line">                rotateRight(parentOf(x));               <span class="comment">// 情况8</span></span><br><span class="line">                x = root;                               <span class="comment">// 情况8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-TreeSet"><a href="#4-TreeSet" class="headerlink" title="4. TreeSet"></a>4. TreeSet</h1><p>前面已经说过<code>TreeSet</code>是对<code>TreeMap</code>的简单包装，对<code>TreeSet</code>的函数调用都会转换成合适的<code>TreeMap</code>方法，因此<code>TreeSet</code>的实现非常简单。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TreeSet是对TreeMap的简单包装</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m = <span class="keyword">new</span> TreeMap&lt;E,Object&gt;();<span class="comment">// TreeSet里面有一个TreeMap</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（五）Java集合框架内幕-Stack and Queue</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-Stack-and-Queue/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%94%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-Stack-and-Queue/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em>；既然<em>Queue</em>只是一个接口，当需要使用队列时也就首选<em>ArrayDeque</em>了（次选是<em>LinkedList</em>）。</p><a id="more"></a><h1 id="2-总体介绍"><a href="#2-总体介绍" class="headerlink" title="2. 总体介绍"></a>2. 总体介绍</h1><p>要讲栈和队列，首先要讲<em>Deque</em>接口。<em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。下表列出了<em>Deque</em>与<em>Queue</em>相对应的接口：</p><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>add(e)</code></td><td><code>addLast(e)</code></td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td><code>offer(e)</code></td><td><code>offerLast(e)</code></td><td>向队尾插入元素，失败则返回<code>false</code></td></tr><tr><td><code>remove()</code></td><td><code>removeFirst()</code></td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td><code>poll()</code></td><td><code>pollFirst()</code></td><td>获取并删除队首元素，失败则返回<code>null</code></td></tr><tr><td><code>element()</code></td><td><code>getFirst()</code></td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除队首元素，失败则返回<code>null</code></td></tr></tbody></table><p>下表列出了<em>Deque</em>与<em>Stack</em>对应的接口：</p><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td><code>push(e)</code></td><td><code>addFirst(e)</code></td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>offerFirst(e)</code></td><td>向栈顶插入元素，失败则返回<code>false</code></td></tr><tr><td><code>pop()</code></td><td><code>removeFirst()</code></td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>pollFirst()</code></td><td>获取并删除栈顶元素，失败则返回<code>null</code></td></tr><tr><td><code>peek()</code></td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td><code>peekFirst()</code></td><td>获取但不删除栈顶元素，失败则返回<code>null</code></td></tr></tbody></table><p>上面两个表共定义了<em>Deque</em>的12个接口。添加，删除，取值都有两套接口，它们功能相同，区别是对失败情况的处理不同。<strong>一套接口遇到失败就会抛出异常，另一套遇到失败会返回特殊值（<code>false</code>或<code>null</code>）</strong>。除非某种实现对容量有限制，大多数情况下，添加操作是不会失败的。<strong>虽然<em>Deque</em>的接口有12个之多，但无非就是对容器的两端进行操作，或添加，或删除，或查看</strong>。明白了这一点讲解起来就会非常简单。</p><p><em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，由于官方更推荐使用<em>AarryDeque</em>用作栈和队列，加之上一篇已经讲解过<em>LinkedList</em>，本文将着重讲解<em>ArrayDeque</em>的具体实现。</p><p>从名字可以看出<em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即<strong>循环数组（circular array）</strong>，也就是说数组的任何一点都可能被看作起点或者终点。<em>ArrayDeque</em>是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p><p><img src="/2020/01/05/（五）Java集合框架内幕-Stack-and-Queue/20190115144447803.png" alt="在这里插入图片描述"></p><p>上图中我们看到，<strong><code>head</code>指向首端第一个有效元素，<code>tail</code>指向尾端第一个可以插入元素的空位</strong>。因为是循环数组，所以<code>head</code>不一定总等于0，<code>tail</code>也不一定总是比<code>head</code>大。</p><h1 id="3-方法剖析"><a href="#3-方法剖析" class="headerlink" title="3. 方法剖析"></a>3. 方法剖析</h1><h2 id="3-1-addFirst"><a href="#3-1-addFirst" class="headerlink" title="3.1 addFirst()"></a>3.1 addFirst()</h2><p><code>addFirst(E e)</code>的作用是在<em>Deque</em>的首端插入元素，也就是在<code>head</code>的前面插入元素，在空间足够且下标没有越界的情况下，只需要将<code>elements[--head] = e</code>即可。</p><p><img src="/2020/01/05/（五）Java集合框架内幕-Stack-and-Queue/20190115144512947.png" alt="在这里插入图片描述"></p><p>实际需要考虑：1.空间是否够用，以及2.下标是否越界的问题。上图中，如果<code>head</code>为<code>0</code>之后接着调用<code>addFirst()</code>，虽然空余空间还够用，但<code>head</code>为<code>-1</code>，下标越界了。下列代码很好的解决了这两个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addFirst(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;<span class="comment">//2.下标是否越界</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail)<span class="comment">//1.空间是否够用</span></span><br><span class="line">        doubleCapacity();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码我们看到，<strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p><p>下标越界的处理解决起来非常简单，<code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数（其实只可能是-1），则相当于对其取相对于<code>elements.length</code>的补码。</p><p>下面再说说扩容函数<code>doubleCapacity()</code>，其逻辑是申请一个更大的数组（原数组的两倍），然后将原数组复制过去。过程如下图所示：</p><p><img src="/2020/01/05/（五）Java集合框架内幕-Stack-and-Queue/20190115144543371.png" alt="在这里插入图片描述"></p><p>图中我们看到，复制分两次进行，第一次复制<code>head</code>右边的元素，第二次复制<code>head</code>左边的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doubleCapacity()</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="keyword">int</span> p = head;</span><br><span class="line">    <span class="keyword">int</span> n = elements.length;</span><br><span class="line">    <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//原空间的2倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制右半部分，对应上图中绿色部分</span></span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制左半部分，对应上图中灰色部分</span></span><br><span class="line">    elements = (E[])a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-addLast"><a href="#3-2-addLast" class="headerlink" title="3.2 addLast()"></a>3.2 addLast()</h2><p><code>addLast(E e)</code>的作用是在<em>Deque</em>的尾端插入元素，也就是在<code>tail</code>的位置插入元素，由于<code>tail</code>总是指向下一个可以插入的空位，因此只需要<code>elements[tail] = e;</code>即可。插入完成后再检查空间，如果空间已经用光，则调用<code>doubleCapacity()</code>进行扩容。</p><p><img src="/2020/01/05/（五）Java集合框架内幕-Stack-and-Queue/20190115144738982.png" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)<span class="comment">//不允许放入null</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    elements[tail] = e;<span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)<span class="comment">//下标越界处理</span></span><br><span class="line">        doubleCapacity();<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下标越界处理方式<code>addFirt()</code>中已经讲过，不再赘述。</p><h2 id="3-3-pollFirst"><a href="#3-3-pollFirst" class="headerlink" title="3.3 pollFirst()"></a>3.3 pollFirst()</h2><p><code>pollFirst()</code>的作用是删除并返回<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素。如果容器不空，只需要直接返回<code>elements[head]</code>即可，当然还需要处理下标的问题。由于<code>ArrayDeque</code>中不允许放入<code>null</code>，当<code>elements[head] == null</code>时，意味着容器为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E result = elements[head];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[h] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    head = (head + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//下标越界处理</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-pollLast"><a href="#3-4-pollLast" class="headerlink" title="3.4 pollLast()"></a>3.4 pollLast()</h2><p><code>pollLast()</code>的作用是删除并返回<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//tail的上一个位置是最后一个元素</span></span><br><span class="line">    E result = elements[t];</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)<span class="comment">//null值意味着deque为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    elements[t] = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    tail = t;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-peekFirst"><a href="#3-5-peekFirst" class="headerlink" title="3.5 peekFirst()"></a>3.5 peekFirst()</h2><p><code>peekFirst()</code>的作用是返回但不删除<em>Deque</em>首端元素，也即是<code>head</code>位置处的元素，直接返回<code>elements[head]</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[head]; <span class="comment">// elements[head] is null if deque empty</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-peekLast"><a href="#3-6-peekLast" class="headerlink" title="3.6 peekLast()"></a>3.6 peekLast()</h2><p><code>peekLast()</code>的作用是返回但不删除<em>Deque</em>尾端元素，也即是<code>tail</code>位置前面的那个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（四）Java集合框架内幕-LinkedList</title>
      <link href="/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-LinkedList/"/>
      <url>/2020/01/05/%EF%BC%88%E5%9B%9B%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-LinkedList/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p><em>LinkedList</em>同时实现了<em>List</em>接口和<em>Deque</em>接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（<em>Queue</em>），同时又可以看作一个栈（<em>Stack</em>）。这样看来，<em>LinkedList</em>简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用<em>LinkedList</em>，一方面是因为Java官方已经声明不建议使用<em>Stack</em>类，更遗憾的是，Java里根本没有一个叫做<em>Queue</em>的类（它是个接口名字）。关于栈或队列，现在的首选是<em>ArrayDeque</em>，它有着比<em>LinkedList</em>（当作栈或队列使用时）有着更好的性能。</p><a id="more"></a><p><img src="/2020/01/05/（四）Java集合框架内幕-LinkedList/20190115144110467.png" alt="在这里插入图片描述"></p><p><em>LinkedList</em>底层<strong>通过双向链表实现</strong>，本节将着重讲解插入和删除元素时双向链表的维护过程，也即是直接跟<em>List</em>接口相关的函数，而将<em>Queue</em>和<em>Stack</em>以及<em>Deque</em>相关的知识放在下一节讲。双向链表的每个节点用内部类<em>Node</em>表示。<em>LinkedList</em>通过<code>first</code>和<code>last</code>引用分别指向链表的第一个和最后一个元素。注意这里没有所谓的哑元，当链表为空的时候<code>first</code>和<code>last</code>都指向<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>LinkedList</em>的实现方式决定了所有跟下标相关的操作都是线性时间，而在首段或者末尾删除元素只需要常数时间。为追求效率<em>LinkedList</em>没有实现同步（synchronized），如果需要多个线程并发访问，可以先采用<code>Collections.synchronizedList()</code>方法对其进行包装。</p><h1 id="2-方法剖析"><a href="#2-方法剖析" class="headerlink" title="2. 方法剖析"></a>2. 方法剖析</h1><h2 id="2-1-add"><a href="#2-1-add" class="headerlink" title="2.1 add()"></a>2.1 add()</h2><p><em>add()</em>方法有两个版本，一个是<code>add(E e)</code>，该方法在<em>LinkedList</em>的末尾插入元素，因为有<code>last</code>指向链表末尾，在末尾插入元素的花费是常数时间。只需要简单修改几个相关引用即可；另一个是<code>add(int index, E element)</code>，该方法是在指定下表处插入元素，需要先通过线性查找找到具体位置，然后修改相关引用完成插入操作。</p><p><img src="/2020/01/05/（四）Java集合框架内幕-LinkedList/20190115144140462.png" alt="在这里插入图片描述"></p><p>结合上图，可以看出<code>add(E e)</code>的逻辑非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add(E e)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;<span class="comment">//原来链表为空，这是插入的第一个元素</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add(int index, E element)</code>的逻辑稍显复杂，可以分成两部分，1.先根据index找到要插入的位置；2.修改引用，完成插入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add(int index, E element)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt;= size;</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//插入位置是末尾，包括列表为空的情况</span></span><br><span class="line">        add(element);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    Node&lt;E&gt; succ = node(index);<span class="comment">//1.先根据index找到要插入的位置</span></span><br><span class="line">        <span class="comment">//2.修改引用，完成插入操作。</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)<span class="comment">//插入位置为0</span></span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>node(int index)</code>函数有一点小小的trick，因为链表双向的，可以从开始往后找，也可以从结尾往前找，具体朝那个方向找取决于条件<code>index &lt; (size &gt;&gt; 1)</code>，也即是index是靠近前端还是后端。</p><h2 id="2-2-remove"><a href="#2-2-remove" class="headerlink" title="2.2 remove()"></a>2.2 remove()</h2><p><code>remove()</code>方法也有两个版本，一个是删除跟指定元素相等的第一个元素<code>remove(Object o)</code>，另一个是删除指定下标处的元素<code>remove(int index)</code>。</p><p><img src="/2020/01/05/（四）Java集合框架内幕-LinkedList/20190115144211546.png" alt="在这里插入图片描述"></p><p>两个删除操作都要1.先找到要删除元素的引用，2.修改相关引用，完成删除操作。在寻找被删元素引用的时候<code>remove(Object o)</code>调用的是元素的<code>equals</code>方法，而<code>remove(int index)</code>使用的是下标计数，两种方式都是线性时间复杂度。在步骤2中，两个<code>revome()</code>方法都是通过<code>unlink(Node&lt;E&gt; x)</code>方法完成的。这里需要考虑删除元素是第一个或者最后一个时的边界情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unlink(Node&lt;E&gt; x)，删除一个Node</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是第一个元素</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;<span class="comment">//删除的是最后一个元素</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;<span class="comment">//let GC work</span></span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-get"><a href="#2-3-get" class="headerlink" title="2.3 get()"></a>2.3 get()</h2><p><code>get(int index)</code>得到指定下标处元素的引用，通过调用上文中提到的<code>node(int index)</code>方法实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);<span class="comment">//index &gt;= 0 &amp;&amp; index &lt; size;</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-set"><a href="#2-4-set" class="headerlink" title="2.4 set()"></a>2.4 set()</h2><p><code>set(int index, E element)</code>方法将指定下标处的元素修改成指定值，也是先通过<code>node(int index)</code>找到对应下表元素的引用，然后修改<code>Node</code>中<code>item</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;<span class="comment">//替换新值</span></span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）Java集合框架内幕-ArrayList</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-ArrayList/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%89%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="1-总体介绍"><a href="#1-总体介绍" class="headerlink" title="1. 总体介绍"></a>1. 总体介绍</h1><p><em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。除该类未实现同步外，其余跟<em>Vector</em>大致相同。每个<em>ArrayList</em>都有一个容量（capacity），表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。</p><a id="more"></a><p><img src="/2020/01/05/（三）Java集合框架内幕-ArrayList/20190115143539152.png" alt="在这里插入图片描述"></p><p>size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>为追求效率，ArrayList没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用Vector替代。</p><h1 id="2-方法剖析"><a href="#2-方法剖析" class="headerlink" title="2. 方法剖析"></a>2. 方法剖析</h1><h2 id="2-1-set"><a href="#2-1-set" class="headerlink" title="2.1 set()"></a>2.1 set()</h2><p>既然底层是一个数组<em>ArrayList</em>的<code>set()</code>方法也就变得非常简单，直接对数组的指定位置赋值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//下标越界检查</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;<span class="comment">//赋值到指定位置，复制的仅仅是引用</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-get"><a href="#2-2-get" class="headerlink" title="2.2 get()"></a>2.2 get()</h2><p><code>get()</code>方法同样很简单，唯一要注意的是由于底层数组是Object[]，得到元素后需要进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];<span class="comment">//注意类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-add"><a href="#2-3-add" class="headerlink" title="2.3 add()"></a>2.3 add()</h2><p>跟C++ 的<em>vector</em>不同，<em>ArrayList</em>没有<code>push_back()</code>方法，对应的方法是<code>add(E e)</code>，<em>ArrayList</em>也没有<code>insert()</code>方法，对应的方法是<code>add(int index, E e)</code>。这两个方法都是向容器中添加新元素，这可能会导致<em>capacity</em>不足，因此在添加元素之前，都需要进行剩余空间检查，如果需要则自动扩容。扩容操作最终是通过<code>grow()</code>方法完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//原来的1.5倍</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//扩展空间并复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Java GC自动管理了内存，这里也就不需要考虑源数组释放的问题。</p><p><img src="/2020/01/05/（三）Java集合框架内幕-ArrayList/20190115143633300.png" alt="在这里插入图片描述"></p><p>空间的问题解决后，插入过程就显得非常简单。</p><p><img src="/2020/01/05/（三）Java集合框架内幕-ArrayList/20190115143703471.png" alt="在这里插入图片描述"></p><p><code>add(int index, E e)</code>需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p><h2 id="2-4-addAll"><a href="#2-4-addAll" class="headerlink" title="2.4 addAll()"></a>2.4 addAll()</h2><p><code>addAll()</code>方法能够一次添加多个元素，根据位置不同也有两个版本，一个是在末尾添加的<code>addAll(Collection&lt;? extends E&gt; c)</code>方法，一个是从指定位置开始插入的<code>addAll(int index, Collection&lt;? extends E&gt; c)</code>方法。跟<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。<br><code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p><h2 id="2-5-remove"><a href="#2-5-remove" class="headerlink" title="2.5 remove()"></a>2.5 remove()</h2><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。需要注意的是为了让GC起作用，必须显式的为最后一个位置赋<code>null</code>值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">//清除该位置的引用，让GC起作用</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Java GC这里需要特别说明一下，<strong>有了垃圾收集器并不意味着一定不会有内存泄漏</strong>。对象能否被GC的依据是是否还有引用指向它，上面代码中如果不手动赋<code>null</code>值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）Java集合框架内幕-Overview</title>
      <link href="/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-Overview/"/>
      <url>/2020/01/05/%EF%BC%88%E4%BA%8C%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-Overview/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概览"><a href="#1-概览" class="headerlink" title="1. 概览"></a>1. 概览</h1><p>容器，就是可以容纳其他Java对象的对象。<em>Java Collections Framework（JCF）</em>为Java开发者提供了通用的容器，其始于JDK 1.2，优点是：</p><ul><li>降低编程难度</li><li>提高程序性能</li><li>提高API间的互操作性</li><li>降低学习难度</li><li>降低设计和实现相关API的难度</li><li>增加程序的重用性</li></ul><p>Java容器里只能放对象，对于基本类型（int, long, float, double等），需要将其包装成对象类型后（Integer, Long, Float, Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p><a id="more"></a><h1 id="2-泛型（Generics）"><a href="#2-泛型（Generics）" class="headerlink" title="2. 泛型（Generics）"></a>2. 泛型（Generics）</h1><p>Java容器能够容纳任何类型的对象，这一点表面上是通过泛型机制完成，Java泛型不是什么神奇的东西，只是编译器为我们提供的一个“语法糖”，泛型本身并不需要Java虚拟机的支持，只需要在编译阶段做一下简单的字符串替换即可。实质上Java的单继承机制才是保证这一特性的根本，因为所有的对象都是Object的子类，容器里只要能够存放Object对象就行了。<br>事实上，所有容器的内部存放的都是Object对象，泛型机制只是简化了编程，由编译器自动帮我们完成了强制类型转换而已。JDK 1.4以及之前版本不支持泛型，类型转换需要程序员显式完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 1.4 or before</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    String weekday = (String)list.get(i);<span class="comment">//显式类型转换</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 1.5 or latter</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">//参数化类型</span></span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">    String weekday = list.get(i);<span class="comment">//隐式类型转换，编译器自动完成</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h1><p>跟C++复杂的内存管理机制不同，Java GC自动包揽了一切，Java程序并不需要处理令人头疼的内存问题，因此JCF并不像C++ STL那样需要专门的空间适配器（alloctor）。<br>另外，由于Java里对象都在堆上，且对象只能通过引用（reference，跟C++中的引用不是同一个概念，可以理解成经过包装后的指针）访问，容器里放的其实是对象的引用而不是对象本身，也就不存在C++容器的复制拷贝问题。</p><h1 id="4-接口和实现（Interfaces-and-Implementations）"><a href="#4-接口和实现（Interfaces-and-Implementations）" class="headerlink" title="4. 接口和实现（Interfaces and Implementations）"></a>4. 接口和实现（Interfaces and Implementations）</h1><h2 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h2><p>为了规范容器的行为，统一设计，JCF定义了14种容器接口（collection interfaces），它们的关系如下图所示：<br><img src="/2020/01/05/（二）Java集合框架内幕-Overview/20190115142722606.png" alt="在这里插入图片描述"><br><em>Map</em>接口没有继承自<em>Collection</em>接口，因为<em>Map</em>表示的是关联式容器而不是集合。但Java为我们提供了从<em>Map</em>转换到<em>Collection</em>的方法，可以方便的将<em>Map</em>切换到集合视图。<br>上图中提供了<em>Queue</em>接口，却没有<em>Stack</em>，这是因为<em>Stack</em>的功能已被JDK 1.6引入的<em>Deque</em>取代。</p><h2 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h2><p>上述接口的通用实现见下表：</p><table align="center"><tr><td colspan="2" rowspan="2" align="center" border="0"></td><th colspan="5" align="center">Implementations</th></tr><tr><th>Hash Table</th><th>Resizable Array</th><th>Balanced Tree</th><th>Linked List</th><th>Hash Table + Linked List</th></tr><tr><th rowspan="4">Interfaces</th><th>Set</th><td><tt>HashSet</tt></td><td></td><td><tt>TreeSet</tt></td><td></td><td><tt>LinkedHashSet</tt></td></tr><tr><th>List</th><td></td><td><tt>ArrayList</tt></td><td></td><td><tt>LinkedList</tt></td><td></td></tr><tr><th>Deque</th><td></td><td><tt>ArrayDeque</tt></td><td></td><td><tt>LinkedList</tt></td><td></td></tr><tr><th>Map</th><td><tt>HashMap</tt></td><td></td><td><tt>TreeMap</tt></td><td></td><td><tt>LinkedHashMap</tt></td></tr></table><p>接下来的篇幅，会逐个介绍上表中容器的数据结构以及用到的算法。</p><h1 id="5-迭代器（Iterator）"><a href="#5-迭代器（Iterator）" class="headerlink" title="5. 迭代器（Iterator）"></a>5. 迭代器（Iterator）</h1><p>跟C++ STL一样，JCF的迭代器（Iterator）为我们提供了遍历容器中元素的方法。只有容器本身清楚容器里元素的组织方式，因此迭代器只能通过容器本身得到。每个容器都会通过内部类的形式实现自己的迭代器。相比STL的迭代器，JCF的迭代器更容易使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//visit a list with iterator</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();<span class="comment">//得到迭代器</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String weekday = it.next();<span class="comment">//访问元素</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK 1.5 引入了增强的for循环，简化了迭代容器时的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用增强for迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Monday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Tuesday"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"Wensday"</span>));</span><br><span class="line"><span class="keyword">for</span>(String weekday : list)&#123;<span class="comment">//enhanced for statement</span></span><br><span class="line">    System.out.println(weekday.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-源代码"><a href="#6-源代码" class="headerlink" title="6. 源代码"></a>6. 源代码</h1><p>JDK安装目录下的src.zip包含了Java core API的源代码，本文采用的是JDK 1.7u79的源码，<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html" target="_blank" rel="noopener">下载地址</a>。<a href="https://github.com/CarpenterLee/JCFInternals/blob/master/source/src.zip" target="_blank" rel="noopener">这里复制了一份</a>。</p><h1 id="7-参考文献"><a href="#7-参考文献" class="headerlink" title="7. 参考文献"></a>7. 参考文献</h1><ul><li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/collections/overview.html" target="_blank" rel="noopener">Collections Framework Overview</a></li><li><a href="http://docs.oracle.com/javase/1.5.0/docs/guide/language/foreach.html" target="_blank" rel="noopener">The For-Each Loop</a></li></ul><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）Java集合框架内幕-Introduction</title>
      <link href="/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-Introduction/"/>
      <url>/2020/01/05/%EF%BC%88%E4%B8%80%EF%BC%89Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Collections-Framework-Internals"><a href="#Java-Collections-Framework-Internals" class="headerlink" title="Java Collections Framework Internals"></a>Java Collections Framework Internals</h1><h1 id="Authors"><a href="#Authors" class="headerlink" title="Authors"></a>Authors</h1><table><thead><tr><th align="left">Name</th><th align="left">Weibo Id</th><th align="left">Blog</th><th align="left">Mail</th></tr></thead><tbody><tr><td align="left">李豪</td><td align="left"><a href="http://weibo.com/icttinymouse" target="_blank" rel="noopener">@计算所的小鼠标</a></td><td align="left"><a href="http://www.cnblogs.com/CarpenterLee/" target="_blank" rel="noopener">CarpenterLee</a></td><td align="left"><a href="mailto:hooleeucas@163.com" target="_blank" rel="noopener">hooleeucas@163.com</a></td></tr></tbody></table><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>关于<em>C++标准模板库(Standard Template Library, STL)</em>的书籍和资料有很多，关于<em>Java集合框架(Java Collections Framework, JCF)</em>的资料却很少，甚至很难找到一本专门介绍它的书籍，这给Java学习者们带来不小的麻烦。我深深的不解其中的原因。<strong>虽然JCF设计参考了STL，但其定位不是Java版的STL，而是要实现一个精简紧凑的容器框架</strong>，对STL的介绍自然不能替代对JCF的介绍。</p><p>本系列文章主要从<strong>数据结构和算法</strong>层面分析JCF中List, Set, Map, Stack, Queue等典型容器，<strong>结合生动图解和源代码，帮助读者对Java集合框架建立清晰而深入的理解</strong>。本文并不特意介绍Java的语言特性，但会在需要的时候做出简洁的解释。</p><a id="more"></a><h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><p>具体内容安排如下：</p><ol><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/1-Overview.md" target="_blank" rel="noopener">Overview</a> 对Java Collections Framework，以及Java语言特性做出基本介绍。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md" target="_blank" rel="noopener">ArrayList</a> 结合源码对<em>ArrayList</em>进行讲解。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/3-LinkedList.md" target="_blank" rel="noopener">LinkedList</a> 结合源码对<em>LinkedList</em>进行讲解。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/4-Stack%20and%20Queue.md" target="_blank" rel="noopener">Stack and Queue</a> 以<em>AarryDeque</em>为例讲解<em>Stack</em>和<em>Queue</em>。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/5-TreeSet%20and%20TreeMap.md" target="_blank" rel="noopener">TreeSet and TreeMap</a> 结合源码对<em>TreeSet</em>和<em>TreeMap</em>进行讲解。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet%20and%20HashMap.md" target="_blank" rel="noopener">HashSet and HashMap</a> 结合源码对<em>HashSet</em>和<em>HashMap</em>进行讲解。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/7-LinkedHashSet%20and%20LinkedHashMap.md" target="_blank" rel="noopener">LinkedHashSet and LinkedHashMap</a> 结合源码对<em>LinkedHashSet</em>和<em>LinkedHashMap</em>进行讲解。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/8-PriorityQueue.md" target="_blank" rel="noopener">PriorityQueue</a> 结合源码对<em>PriorityQueue</em>进行讲解。</li><li><a href="https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/9-WeakHashMap.md" target="_blank" rel="noopener">WeakHashMap</a> 对<em>WeakHashMap</em>做出基本介绍。</li></ol><p><a href="https://github.com/CarpenterLee/JCFInternals" target="_blank" rel="noopener">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合框架总结</title>
      <link href="/2020/01/05/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/05/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>原文作者：chenssy<br>出处：<a href="http://www.cnblogs.com/chenssy/p/3495238.html" target="_blank" rel="noopener">http://www.cnblogs.com/chenssy/p/3495238.html</a></p><hr><p> 在编写java程序时，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！</p><a id="more"></a><p><img src="/2020/01/05/Java集合框架总结/20190115165304832.png" alt="在这里插入图片描述"><br> 上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(<strong>主要介绍各个集合的特点，区别</strong>)，更加详细的介绍会在不久的将来一一讲解。</p><h2 id="一、Collection接口"><a href="#一、Collection接口" class="headerlink" title="一、Collection接口"></a>一、Collection接口</h2><p>Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h2 id="二、List接口"><a href="#二、List接口" class="headerlink" title="二、List接口"></a>二、List接口</h2><p>List接口为Collection直接接口。List所代表的是<strong>有序的Collection，即它用某种特定的插入顺序来维护元素顺序。</strong> 用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h3 id="2-1、ArrayList"><a href="#2-1、ArrayList" class="headerlink" title="2.1、ArrayList"></a>2.1、ArrayList</h3><p> ArrayList是一个<strong>动态数组</strong>，也是我们最常用的集合。它<strong>允许任何符合规则的元素插入甚至包括null</strong>。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以<strong>如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</strong></p><p> size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p><p> ArrayList擅长于随机访问。同时<strong>ArrayList是非同步的</strong>。</p><h3 id="2-2、LinkedList"><a href="#2-2、LinkedList" class="headerlink" title="2.2、LinkedList"></a>2.2、LinkedList</h3><p>同样实现List接口的LinkedList与ArrayList不同，<strong>LinkedList是一个双向链表</strong>。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p><p>与ArrayList一样，<strong>LinkedList也是非同步的</strong>。如果多个线程同时访问一个List，则必须自己实现访问同步。</p><p><strong>一种解决方法是在创建List时构造一个同步的List：<br>List list = Collections.synchronizedList(new LinkedList(…));</strong></p><h3 id="2-3、Vector"><a href="#2-3、Vector" class="headerlink" title="2.3、Vector"></a>2.3、Vector</h3><p> 与ArrayList相似，但是<strong>Vector是同步的</strong>。所以说<strong>Vector是线程安全的动态数组</strong>。它的操作与ArrayList几乎一样。</p><h3 id="2-4、Stack"><a href="#2-4、Stack" class="headerlink" title="2.4、Stack"></a>2.4、Stack</h3><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h2 id="三、Set接口"><a href="#三、Set接口" class="headerlink" title="三、Set接口"></a>三、Set接口</h2><p>Set是一种<strong>不包括重复元素的Collection</strong>。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样<strong>允许null的存在但是仅有一个</strong>。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><h3 id="3-1、EnumSet"><a href="#3-1、EnumSet" class="headerlink" title="3.1、EnumSet"></a>3.1、EnumSet</h3><p>是枚举的专用Set。所有的元素都是枚举类型。</p><h3 id="3-2、HashSet"><a href="#3-2、HashSet" class="headerlink" title="3.2、HashSet"></a>3.2、HashSet</h3><p>HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它<strong>不保证set 的迭代顺序</strong>；特别是它<strong>不保证该顺序恒久不变。</strong>另外它<strong>不是线程同步的。</strong></p><h3 id="3-3、TreeSet"><a href="#3-3、TreeSet" class="headerlink" title="3.3、TreeSet"></a>3.3、TreeSet</h3><p>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的<strong>自然顺序对元素进行排序</strong>，<strong>或者根据创建Set 时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。另外它<strong>不是线程同步的。</strong></p><h2 id="四、Map接口"><a href="#四、Map接口" class="headerlink" title="四、Map接口"></a>四、Map接口</h2><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它<strong>不能存在相同的key值，当然value值可以相同。</strong> 实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p><h3 id="4-1、HashMap"><a href="#4-1、HashMap" class="headerlink" title="4.1、HashMap"></a>4.1、HashMap</h3><p>以<strong>哈希表数据结构</strong>实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用<strong>散列链表</strong>的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。<strong>其不是同步的，且允许空值作为键和值。</strong></p><h3 id="4-2、TreeMap"><a href="#4-2、TreeMap" class="headerlink" title="4.2、TreeMap"></a>4.2、TreeMap</h3><p> <strong>‘键’以自然顺序或自定义比较器来规则排序</strong>，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口。它<strong>不是线程同步的</strong>。</p><h3 id="4-3、HashTable"><a href="#4-3、HashTable" class="headerlink" title="4.3、HashTable"></a>4.3、HashTable</h3><p>也是以<strong>哈希表数据结构</strong>实现的，解决冲突时与HashMap也一样也是采用了<strong>散列链表</strong>的形式，不过性能比HashMap要低。<strong>其不允许空值作为键和值。</strong></p><h2 id="五、Queue"><a href="#五、Queue" class="headerlink" title="五、Queue"></a>五、Queue</h2><p>队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：<strong>ArrayDeque</strong>、LinkedBlockingDeque、<strong>LinkedList</strong>。</p><h2 id="六、异同点"><a href="#六、异同点" class="headerlink" title="六、异同点"></a>六、异同点</h2><p>出处：<a href="http://blog.csdn.net/softwave/article/details/4166598" target="_blank" rel="noopener">http://blog.csdn.net/softwave/article/details/4166598</a></p><h3 id="6-1、Vector和ArrayList"><a href="#6-1、Vector和ArrayList" class="headerlink" title="6.1、Vector和ArrayList"></a>6.1、Vector和ArrayList</h3><ol><li><strong>vector是线程同步</strong>的，所以它也是线程安全的，而<strong>arraylist是线程异步</strong>的，是不安全的。如果不考虑到线程的安全因素，一般用<strong>arraylist效率比较高</strong>。 </li><li>如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。 </li><li>如果<strong>查找一个指定位置的数据，vector和arraylist使用的时间是相同的</strong>，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</li><li><strong>ArrayList 和Vector是采用数组方式存储数据</strong>，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</li></ol><h3 id="6-2、Aarraylist和Linkedlist"><a href="#6-2、Aarraylist和Linkedlist" class="headerlink" title="6.2、Aarraylist和Linkedlist"></a>6.2、Aarraylist和Linkedlist</h3><ol><li><strong>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</strong> </li><li><strong>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针</strong>。 </li><li><strong>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</strong> 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</li></ol><h3 id="6-3、HashMap与TreeMap"><a href="#6-3、HashMap与TreeMap" class="headerlink" title="6.3、HashMap与TreeMap"></a>6.3、HashMap与TreeMap</h3><ol><li>HashMap通过hashcode对其内容进行快速查找，而<strong>TreeMap中所有的元素都保持着某种固定的顺序</strong>，如果你需要得到一个有序的结果你就应该使用TreeMap。<strong>HashMap中元素的排列顺序是不固定的</strong>。</li><li><strong>在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</strong>使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。</li></ol><h3 id="6-4、Hashtable与Hashmap"><a href="#6-4、Hashtable与Hashmap" class="headerlink" title="6.4、Hashtable与Hashmap"></a>6.4、Hashtable与Hashmap</h3><ol><li>历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</li><li><strong>同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</strong></li><li><strong>值：只有HashMap可以让你将空值作为一个表的条目的key或value</strong> 。</li></ol><h2 id="七、对集合的选择"><a href="#七、对集合的选择" class="headerlink" title="七、对集合的选择"></a>七、对集合的选择</h2><h3 id="7-1、对List的选择"><a href="#7-1、对List的选择" class="headerlink" title="7.1、对List的选择"></a>7.1、对List的选择</h3><ol><li>对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList</li><li>LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。</li><li>对于Vector而已，我们一般都是避免使用。</li><li>将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。<h3 id="7-2、对Set的选择"><a href="#7-2、对Set的选择" class="headerlink" title="7.2、对Set的选择"></a>7.2、对Set的选择</h3></li><li>HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。</li><li>虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。<h3 id="7-3、对Map的选择"><a href="#7-3、对Map的选择" class="headerlink" title="7.3、对Map的选择"></a>7.3、对Map的选择</h3></li><li>HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。</li><li>由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap排序题</title>
      <link href="/2020/01/05/HashMap%E6%8E%92%E5%BA%8F%E9%A2%98/"/>
      <url>/2020/01/05/HashMap%E6%8E%92%E5%BA%8F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>已知一个 HashMap&lt;Integer， User&gt;集合， User 有 name（String）和 age（int）属性。请写一个方法实现对HashMap 的排序功能，该方法接收 HashMap&lt;Integer， User&gt;为形参，返回类型为 HashMap&lt;Integer， User&gt;，要求对 HashMap 中的 User 的 age 倒序进行排序。排序时 key=value 键值对不得拆散。</p><a id="more"></a><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jcf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer,User&gt; <span class="title">sortHashMap</span><span class="params">(HashMap&lt;Integer,User&gt; users)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.首先拿到users的键值对映射的集合</span></span><br><span class="line">        Set&lt;Entry&lt;Integer,User&gt;&gt; usersEntrySet = users.entrySet();</span><br><span class="line">        <span class="comment">//2.将集合usersEntrySet转换为List集合，以方便进行排序</span></span><br><span class="line">        ArrayList&lt;Entry&lt;Integer,User&gt;&gt; usersList = <span class="keyword">new</span> ArrayList&lt;&gt;(usersEntrySet);</span><br><span class="line">        <span class="comment">//3.使用Collections工具列对usersList按照年龄逆序进行排序</span></span><br><span class="line">        Collections.sort(usersList, <span class="keyword">new</span> Comparator&lt;Entry&lt;Integer,User&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Integer,User&gt; o1, Entry&lt;Integer,User&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//按照要求根据 User 的 age 的倒序进行排序</span></span><br><span class="line">                <span class="comment">/*自然排序下：</span></span><br><span class="line"><span class="comment"> * 如果o1中的age小于o2中的age，则返回负数</span></span><br><span class="line"><span class="comment"> * 如果o1中的age大于o2中的age，则返回正数</span></span><br><span class="line"><span class="comment"> * 相等则返回0</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 逆序排序则采取相反操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                <span class="keyword">return</span> o2.getValue().getAge() - o1.getValue().getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//4.将usersList中的数据存放在LinkHashMap集合中</span></span><br><span class="line">        LinkedHashMap&lt;Integer, User&gt; usersLinkHashMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;Integer, User&gt; entry : usersList) &#123;</span><br><span class="line">            usersLinkHashMap.put(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> usersLinkHashMap;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,User&gt; users = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        users.put(<span class="number">1</span>, <span class="keyword">new</span> User(<span class="string">"张三"</span>,<span class="number">25</span>));</span><br><span class="line">        users.put(<span class="number">2</span>, <span class="keyword">new</span> User(<span class="string">"李四"</span>,<span class="number">28</span>));</span><br><span class="line">        users.put(<span class="number">3</span>, <span class="keyword">new</span> User(<span class="string">"王五"</span>,<span class="number">23</span>));</span><br><span class="line">        <span class="comment">//调用sortHashMap方法对map集合进行按年龄从大到小排序</span></span><br><span class="line">        HashMap&lt;Integer, User&gt; sortHashMap = sortHashMap(users);</span><br><span class="line">        System.out.println(sortHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jcf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;2=User [name=李四, age=28], 1=User [name=张三, age=25], 3=User [name=王五, age=23]&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Callable 接口的使用</title>
      <link href="/2020/01/01/Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/01/Callable-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式： Callable 接口。</p><p>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。</p><p>Callable 需要依赖FutureTask 类，其中FutureTask 实现了Runnable接口。</p><a id="more"></a><p>下面我们演示一下Callable 接口的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程的方式3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="comment">//使用FutureTask用于接收结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">        <span class="comment">//执行线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">        <span class="comment">//打印接收的结果</span></span><br><span class="line">        System.out.println(ft.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算0 - 100 之间的和</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与Runnable 接口不同的是，实现Callable接口的类需要覆盖call方法，该方法具有返回值并且能够抛出异常。</p><p>Callable所依赖的FutureTask类保存了call方法的返回值，可以用get方法获取。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池及线程调度</title>
      <link href="/2020/01/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/01/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。线程池内部提供了一个线程队列，队列中保存着所有等待状态的线程，在开发过程中，合理地使用线程池能够带来以下3个好处：</p><p>第一：<strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：<strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p>第三：<strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p><a id="more"></a><h3 id="二、线程池的体系结构"><a href="#二、线程池的体系结构" class="headerlink" title="二、线程池的体系结构"></a>二、线程池的体系结构</h3><p><img src="/2020/01/01/线程池及线程调度/20190710162902289.png" alt="在这里插入图片描述"></p><h3 id="三、Executors-工具类"><a href="#三、Executors-工具类" class="headerlink" title="三、Executors 工具类"></a>三、Executors 工具类</h3><p>Executors 具有许多工厂方法，可以很方便的创建线程池，下面是其常用的几个创建线程池的方法：<br><img src="/2020/01/01/线程池及线程调度/20190710163550767.png" alt="在这里插入图片描述"><br>下面演示一下Executors工具类的使用，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 创建具有5个线程的线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 为线程池中的线程分配任务</span></span><br><span class="line">        ThreadPoolDemo tpd = <span class="keyword">new</span> ThreadPoolDemo();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(tpd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-5</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-2</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-4</span><br><span class="line">pool-1-thread-5</span><br></pre></td></tr></table></figure><p>由运行结果可知，线程池中的5个线程都执行了打印其线程名的任务。</p><h3 id="四、线程调度"><a href="#四、线程调度" class="headerlink" title="四、线程调度"></a>四、线程调度</h3><p>线程池的体系结构中，ExecutorService 接口具有一个 ScheduledExecutorService 的子接口。该接口负责线程的调度，我们可以使用工具类的Executors 的 newScheduleThreadPool 方法来创建固定大小的线程池，它<code>可以延迟或定时的执行任务，多数情况下可用来替代Timer类</code>。</p><p>下面演示ScheduledExecutorService 接口的线程池线程延迟调度执行的事例，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduleThreadPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建可进行线程调度的固定大小的线程池</span></span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建5个线程，每个线程延迟1秒打印一次,并将随机数结果返回再打印</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            ScheduledFuture&lt;Integer&gt; result = pool.schedule(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> num = (<span class="keyword">int</span>) (Math.random() * <span class="number">101</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num);</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            System.out.println(result.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fork/Join框架</title>
      <link href="/2020/01/01/Fork-Join%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/01/01/Fork-Join%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。<br><img src="/2020/01/01/Fork-Join框架/20190710171656452.png" alt></p><a id="more"></a><h3 id="二、Fork-Join-框架与线程池的区别"><a href="#二、Fork-Join-框架与线程池的区别" class="headerlink" title="二、Fork/Join 框架与线程池的区别"></a>二、Fork/Join 框架与线程池的区别</h3><ul><li>采用 “工作窃取”模式（work-stealing）：<br>当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</li><li>相对于一般的线程池实现， fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中， 如果一个线程正在执行的任务由于某些原因无法继续运行， 那么该线程会处于等待状态。 而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。 那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间， 提高了性能。</li></ul><h3 id="三、Fork-Join框架的使用"><a href="#三、Fork-Join框架的使用" class="headerlink" title="三、Fork/Join框架的使用"></a>三、Fork/Join框架的使用</h3><p>下面使用Fork/Join框架来将两个数值之间的数累加计算的任务拆分为小任务，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算start - end之间的数字之和</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">100000000L</span>);</span><br><span class="line">        </span><br><span class="line">        Long sum = pool.invoke(task);</span><br><span class="line">        </span><br><span class="line">        System.out.println(sum);<span class="comment">//5000000050000000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界值，拆分到此临界值便不再拆分成子任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long THURSHOLD = <span class="number">10000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Long len = end - start;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= THURSHOLD) &#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Long middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 1. 拆分成左右两个子任务</span></span><br><span class="line">            ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle);</span><br><span class="line">            left.fork(); <span class="comment">// 进行拆分，并压入线程队列</span></span><br><span class="line"></span><br><span class="line">            ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle + <span class="number">1</span>, end);</span><br><span class="line">            right.fork();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 合并子任务</span></span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程&amp;并发知识体系图</title>
      <link href="/2020/01/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%9B%BE/"/>
      <url>/2020/01/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>最近在复习整理多线程与并发的知识，并整理成脑图，以方便查看。</p><a id="more"></a><p><img src="/2020/01/01/多线程-并发知识体系图/20190723161434819.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/01/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/01/01/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h2><p>所谓类的单例设计模式，就是采取一定的方法保证<code>在整个的软件系统中， 对某个类只能存在一个对象实例</code>，并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>比如 Hibernate 的 SessionFactory， 它充当数据存储源的代理， 并负责创建 Session 对象。SessionFactory 并不是轻量级的， 一般情况下， 一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。</p><h2 id="七种单例模式"><a href="#七种单例模式" class="headerlink" title="七种单例模式"></a>七种单例模式</h2><p>单例模式有七种方式之多，分别为 饿汉式(静态常量)、饿汉式（静态代码块）、懒汉式(线程不安全)、懒汉式(线程安全， 同步方法)、双重检查、静态内部类和枚举。</p><a id="more"></a><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式（静态常量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.构造器私有化 (防止 new )</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.类的内部创建对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.向外暴露一个静态的公共方法getInstance。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明"><a href="#优缺点说明" class="headerlink" title="优缺点说明"></a>优缺点说明</h4><p><strong>优点</strong>： 这种写法比较简单， 就是在<strong>类装载</strong>的时候就完成实例化， 避免了线程同步问题。<br><strong>缺点</strong>： 在类装载的时候就完成实例化， <strong>没有达到 Lazy Loading 的效果</strong>。 如果从始至终从未使用过这个实例， 则会造成内存的浪费。</p><p><strong>结论</strong>： 这种单例模式可用， 可能造成内存浪费。</p><h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在静态代码块中， 创建单例对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明-1"><a href="#优缺点说明-1" class="headerlink" title="优缺点说明"></a>优缺点说明</h4><p>这种方式和上面的方式其实类似， 只不过将类实例化的过程放在了静态代码块中， 也是在类装载的时候就执行静态代码块中的代码以初始化类的实例。 优缺点和上面是一样的。</p><p><strong>结论：</strong> 这种单例模式可用， 但是可能造成内存浪费。</p><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明-2"><a href="#优缺点说明-2" class="headerlink" title="优缺点说明"></a>优缺点说明</h4><p>1.<strong>起到了 Lazy Loading 的效果， 但是只能在单线程下使用</strong>。<br>2.如果在多线程下， 一个线程进入了 if (singleton == null)判断语句块， 还未来得及往下执行， 另一个线程也通过了这个判断语句， 这时便会产生多个实例。 所以在多线程环境下不可使用这种方式</p><p> <strong>结论</strong>： 在实际开发中， <code>不要使用</code>这种方式。</p><h3 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式(线程安全)"></a>懒汉式(线程安全)</h3><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式（线程安全）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明-3"><a href="#优缺点说明-3" class="headerlink" title="优缺点说明"></a>优缺点说明</h4><p><strong>优点</strong> ：解决了线程安全问题<br><strong>缺点</strong>：效率太低， 每个线程在想获得类的实例时候， 执行 getInstance()方法都要进行同步。 而其实这个方法只执行一次实例化代码就够了， 后面的想获得该类实例， 直接 return 就行了。 </p><p><strong>结论：</strong> 在实际开发中， <code>不推荐使用</code>这种方式。</p><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// volatile 关键字防止instance实例化与instance赋值（地址）的指令重排序</span></span><br><span class="line">    <span class="comment">// 因为当线程1执行了instance = new Singleton5()；操作时，可能仅给变量instance赋了地址而还没实例化，</span></span><br><span class="line">    <span class="comment">// 这就会导致线程2在判断完第一个if语句后直接返回未实例化完成的instance。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// synchronized保持线程同步及内存可见性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明-4"><a href="#优缺点说明-4" class="headerlink" title="优缺点说明"></a>优缺点说明</h4><p>Double-Check 概念是多线程开发中常使用到的， 如代码中所示， 我们保证了线程安全。同时有延迟加载效率较高的优点。</p><p><strong>结论：</strong> 在实际开发中， <code>推荐使用</code>这种单例设计模式。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="优缺点说明-5"><a href="#优缺点说明-5" class="headerlink" title="优缺点说明"></a>优缺点说明</h5><p>静态内部类方式在 Singleton 类被装载时并不会立即实例化， 而是在需要实例化时。即调用 getInstance 方法时， 才会装载 SingletonInstance 类， 从而完成 Singleton 的实例化。所以这种方式<code>支持延迟加载</code>。</p><p>类的静态属性只会在第一次加载类的时候初始化， 所以在这里， JVM 帮助我们<code>保证了线程的安全性</code>， 在类进行初始化时， 别的线程是无法进入的。</p><p><strong>结论：</strong> <code>推荐使用</code>。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton7 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优缺点说明-6"><a href="#优缺点说明-6" class="headerlink" title="优缺点说明"></a>优缺点说明</h4><p>这借助枚举来实现单例模式。 不仅能避免多线程同步问题， 而且还能防止反序列化重新创建新的对象。</p><p><strong>结论</strong>： <code>推荐使用</code>。</p><h2 id="单例模式在-JDK-应用的源码分析"><a href="#单例模式在-JDK-应用的源码分析" class="headerlink" title="单例模式在 JDK 应用的源码分析"></a>单例模式在 JDK 应用的源码分析</h2><p>在 JDK 中， java.lang.Runtime 就是经典的单例模式(饿汉式)，具体如下图所示：<br><img src="/2020/01/01/单例模式/20190821173637611.png" alt="在这里插入图片描述"></p><h2 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明"></a>单例模式注意事项和细节说明</h2><p>单例模式保证了系统内存中该类只存在一个对象， 节省了系统资源， <code>对于一些需要频繁创建销毁的对象， 使用单例模式可以提高系统性能</code>。</p><p>当想实例化一个单例类的时候， 必须要记住使用相应的获取对象的方法， 而不是使用 new。</p><p>单例模式使用的场景： <code>需要频繁的进行创建和销毁的对象、 创建对象时耗时过多或耗费资源过多(即： 重量级对象)， 但又经常用到的对象、 工具类对象、 频繁访问数据库或文件的对象(比如数据源、 session 工厂等)。</code></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式七大原则</title>
      <link href="/2020/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2020/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>设计模式原则，其实就是程序员在编程时，应当遵守的原则，也是各种设计模式的基础。</p><h2 id="一、单一职责原则"><a href="#一、单一职责原则" class="headerlink" title="一、单一职责原则"></a>一、单一职责原则</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>单一职责原则是对类来说的， <strong>即一个类应该只负责一项职责</strong>。 如类 A 负责两个不同职责： 职责 1， 职责 2。 当职责 1 需求变更而改变 A 时， 可能造成职责 2 执行错误， 所以需要将类 A 的粒度分解为 A1， A2。</p><a id="more"></a><h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>以交通工具案例讲解：</p><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">        vehicle.run(<span class="string">"飞机"</span>);<span class="comment">//错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，我们可以发现虽然飞机属于交通工具，但是却不是在公路上运行的，因此run方法的职责过大，违反了单一职责原则。</p><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>解决方式1的方案非常的简单， 根据交通工具运行方法不同， 分解成不同类即可，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">        roadVehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">        roadVehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">        AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">        airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RoadVehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"公路运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirVehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"天空运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WaterVehicle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">"水中运行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2 遵守单一职责原则，但是这样做的改动很大，即将类分解， 同时修改了客户端的代码。我们可以直接修改 Vehicle 类， 改动的代码会比较少。</p><h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleResponsibility3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vehicle2 vehicle2 = <span class="keyword">new</span> Vehicle2();</span><br><span class="line">        vehicle2.run(<span class="string">"汽车"</span>);</span><br><span class="line">        vehicle2.runWater(<span class="string">"核潜艇"</span>);</span><br><span class="line">        vehicle2.runAir(<span class="string">"飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在公路上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在天空上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span><span class="params">(String vehicle)</span> </span>&#123;</span><br><span class="line">        System.out.println(vehicle + <span class="string">" 在水中行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式3没有对原来的类做大的修改，只是增加方法。这里虽然没有<strong>在类这个级别上遵守单一职责原则</strong>， 但是<strong>在方法级别上， 仍然是遵守单一职责</strong>。</p><h3 id="注意事项和细节"><a href="#注意事项和细节" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><ol><li>降低类的复杂度， 一个类只负责一项职责</li><li>提高类的可读性， 可维护性</li><li>降低变更引起的风险</li><li>通常情况下， 我们应当遵守单一职责原则， 只有逻辑足够简单， 才可以在代码级违反单一职责原则； <code>只有类中方法数量足够少， 可以在方法级别保持单一职责原则</code></li></ol><h2 id="二、接口隔离原则"><a href="#二、接口隔离原则" class="headerlink" title="二、接口隔离原则"></a>二、接口隔离原则</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>客户端不应该依赖它不需要的接口， 即一个类对另一个类的依赖应该建立在最小的接口上。我们先查看下图，我们可以知道类 A 通过接口 Interface1 依赖类 B， 类 C 通过接口 Interface1 依赖类 D， 因为接口 Interface1 对于类 A 和类 C来说不是最小接口， 那么类 B 和类 D 必须去实现他们<code>不需要</code>的方法。<br><img src="/2020/01/01/设计模式七大原则/20190819164605722.png" alt="在这里插入图片描述"><br>按隔离原则应当将接口 Interface1 拆分为独立的几个接口(这里我们拆分成 3 个接口)， 类 A 和类 C 分别与他们需要的接口建立依赖关系。 也就是采用接口隔离原则。</p><h3 id="应用实例-1"><a href="#应用实例-1" class="headerlink" title="应用实例"></a>应用实例</h3><h4 id="方式1-1"><a href="#方式1-1" class="headerlink" title="方式1"></a>方式1</h4><p>下面我们以<code>没有使用</code>接口隔离原则所实现的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现了 operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现了 operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现了 operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多余实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多余实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D 实现了 operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多余实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 多余实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D 实现了 operation4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D 实现了 operation5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口 Interface1 依赖(使用) B 类， 但是只会用到 1,2,3 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C 类通过接口 Interface1 依赖(使用) D 类， 但是只会用到 1,4,5 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2-1"><a href="#方式2-1" class="headerlink" title="方式2"></a>方式2</h4><p>按隔离原则应当将接口 Interface1 拆分为独立的如下三个接口，具体依赖关系如下所示：<br><img src="/2020/01/01/设计模式七大原则/2019081916511165.png" alt="在这里插入图片描述"><br>按照接口隔离原则所实现的代码具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Segregation1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">        a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">        a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">        C c = <span class="keyword">new</span> C();</span><br><span class="line">        c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">        c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">        c.depend5(<span class="keyword">new</span> D());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现了 operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现了 operation2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 实现了 operation3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D 实现了 operation1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D 实现了 operation4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"D 实现了 operation5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">        i.operation2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span><span class="params">(Interface2 i)</span> </span>&#123;</span><br><span class="line">        i.operation3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span><span class="params">(Interface1 i)</span> </span>&#123;</span><br><span class="line">        i.operation1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">        i.operation4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span><span class="params">(Interface3 i)</span> </span>&#123;</span><br><span class="line">        i.operation5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、依赖倒转原则"><a href="#三、依赖倒转原则" class="headerlink" title="三、依赖倒转原则"></a>三、依赖倒转原则</h2><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>依赖倒转原则(Dependence Inversion Principle)是指：</p><ol><li>高层模块不应该依赖低层模块， 二者都应该依赖其抽象</li><li>抽象不应该依赖细节， 细节应该依赖抽象</li><li><code>依赖倒转(倒置)的中心思想是面向接口编程</code></li><li>依赖倒转原则是基于这样的设计理念： 相对于细节的多变性， 抽象的东西要稳定的多。 以抽象为基础搭建的架构比以细节为基础的架构要稳定得多。 在 java 中， 抽象指的是接口或抽象类， 细节就是具体的实现类</li><li>使用接口或抽象类的目的是制定好规范， 而不涉及任何具体的操作， 把展现细节的任务交给他们的实现类去完成</li></ol><h3 id="应用实例-2"><a href="#应用实例-2" class="headerlink" title="应用实例"></a>应用实例</h3><p>编程完成 Person 接收消息的功能。</p><h4 id="方式1-2"><a href="#方式1-2" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Email email )</span> </span>&#123;</span><br><span class="line">        System.out.println(email.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，Person类里的receive接收的是具体的Email参数，那么当我们获取的对象是 微信，短信等其他类的对象时，<strong>则Perons类也要增加相应的接收方法</strong>。</p><h4 id="方式2-2"><a href="#方式2-2" class="headerlink" title="方式2"></a>方式2</h4><p>为了解决方式1的不足之处，我们可以引入一个抽象的接口IReceiver接收者, 这样Person类与接口IReceiver发生依赖。由于多态的特性，微信，短信等其他类他们各自实现IReceiver 接口即可，这样我们就符合依赖倒转原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//客户端无需改变</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">        </span><br><span class="line">        person.receive(<span class="keyword">new</span> WeiXin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword">implements</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"微信信息: hello,ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(IReceiver receiver )</span> </span>&#123;</span><br><span class="line">        System.out.println(receiver.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="依赖关系传递的三种方式和应用案例"><a href="#依赖关系传递的三种方式和应用案例" class="headerlink" title="依赖关系传递的三种方式和应用案例"></a>依赖关系传递的三种方式和应用案例</h3><p>依赖关系传递的三种方式分别有<code>接口传递</code>、<code>构造方法传递</code>和<code>setter 方法传递</code>，以下是相关的应用案例代码：</p><p>接口依赖传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; <span class="comment">// 抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长虹电视机，打开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法依赖传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ITV接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长虹电视机，打开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ITV tv; <span class="comment">// 成员</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV tv)</span> </span>&#123; <span class="comment">// 构造器</span></span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setter 方法依赖传递：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长虹电视机，打开"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项和细节-1"><a href="#注意事项和细节-1" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><ol><li>低层模块尽量都要有抽象类或接口，或者两者都有， 程序稳定性更好.</li><li>变量的声明类型尽量是抽象类或接口，这样我们的变量引用和实际对象间， 就存在一个缓冲层， 利于程序扩展和优化</li><li>继承时遵循里氏替换原则（后面讲）</li></ol><h2 id="四、里氏替换原则"><a href="#四、里氏替换原则" class="headerlink" title="四、里氏替换原则"></a>四、里氏替换原则</h2><h3 id="OO-中的继承性的思考和说明"><a href="#OO-中的继承性的思考和说明" class="headerlink" title="OO 中的继承性的思考和说明"></a>OO 中的继承性的思考和说明</h3><p>1.继承包含这样一层含义： 父类中凡是已经实现好的方法， 实际上是在<strong>设定规范和契约</strong>， 虽然它不强制要求所有的子类必须遵循这些契约， 但是如果子类对这些已经实现的方法任意修改， 就会对整个继承体系造成破坏。</p><p>2.继承在给程序设计带来便利的同时， 也带来了弊端。 比如使用继承会给程序带来侵入性， 程序的可<strong>移植性降低</strong>，<strong>增加对象间的耦合性</strong>， 如果一个类被其他的类所继承， 则当这个类需要修改时， 必须考虑到所有的子类， 并且父类修改后， 所有涉及到子类的功能都有可能产生故障。</p><p>3.问题提出： 在编程中， 如何正确的使用继承? 可以使用里氏替换原则。</p><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>里氏替换原则指：如果对每个类型为 T1 的对象 o1， 都有类型为 T2 的对象 o2， 使得以 T1 定义的所有程序 P 在所有的对象 o1 都代换成 o2 时， 程序 P 的行为没有发生变化， 那么类型 T2 是类型 T1 的子类型。 换句话说， 所有引用基类的地方必须能透明地使用其子类的对象。</p><p>里氏替换原则可以通俗的表述为：<strong>在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立。</strong></p><p>在使用继承时， 遵循里氏替换原则， <strong>在子类中尽量不要重写父类的方法</strong>。</p><p><code>里氏替换原则告诉我们， 继承实际上让两个类耦合性增强了， 在适当的情况下， 可以通过聚合， 组合， 依赖 来替换类的继承</code>。 .</p><h3 id="问题和思考"><a href="#问题和思考" class="headerlink" title="问题和思考"></a>问题和思考</h3><p>查看以下程序，思考下问题和解决思路</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">"11-3="</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"1-8="</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.out.println(<span class="string">"11-3="</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">        System.out.println(<span class="string">"1-8="</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">        System.out.println(<span class="string">"11+3+9="</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>我们发现原来运行正常的相减功能发生了错误，原因就是类 B 无意中重写了父类的方法， 造成原有功能出现错误。 在实际编程中， 我们常常会通过重写父类的方法完成新的功能， 这样写起来虽然简单， 但整个继承体系的复用性会比较差。 特别是运行多态比较频繁的时候。</p><p>通用的做法是： 原来的父类和子类都继承一个更通俗的基类， 原有的继承关系去掉， 采用依赖， 聚合， 组合等关系代替。以下是继承体系图：<br><img src="/2020/01/01/设计模式七大原则/20190820161435689.png" alt="在这里插入图片描述"><br>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回两个数的差</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B类继承了A</span></span><br><span class="line"><span class="comment">//增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用组合关系</span></span><br><span class="line">    <span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Liskov</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(<span class="string">"11-3="</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">"1-8="</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        <span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">        <span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">        System.out.println(<span class="string">"11+3="</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">        System.out.println(<span class="string">"1+8="</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">        System.out.println(<span class="string">"11+3+9="</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">        System.out.println(<span class="string">"11-3="</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实现遵循里氏代换原则，即在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反过来则不成立。</p><h2 id="五、开闭原则"><a href="#五、开闭原则" class="headerlink" title="五、开闭原则"></a>五、开闭原则</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>开闭原则（Open Closed Principle） 是编程中最基础、 最重要的设计原则。一个软件实体如类， 模块和函数应该对扩展开放(对提供方)， 对修改关闭(对使用方)。 用抽象构建框架， 用实现扩展细节。</p><p><code>当软件需求变化时， 尽量通过扩展软件实体的行为来实现变化， 而不是通过修改已有的代码来实现变化。</code></p><p>编程中遵循其它原则， 以及使用设计模式的目的就是遵循开闭原则。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>看一个画图形的功能。</p><h4 id="方式1-3"><a href="#方式1-3" class="headerlink" title="方式1"></a>方式1</h4><p>类图设计， 如下:<br><img src="/2020/01/01/设计模式七大原则/20190820163348919.png" alt="在这里插入图片描述"><br>具体代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">            drawCircle(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制矩形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绘制圆形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类【提供方】</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上述代码，当我们需要增加如下的一个三角形类时，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方GraphicEditor 类则需要进行大量的代码修改，具体如下。显然这种方式并不遵循开闭原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">            drawRectangle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">            drawCircle(s);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)<span class="comment">//这是新增代码</span></span><br><span class="line">            drawTriangle(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这是新增代码，绘制三角形</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawTriangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式2-3"><a href="#方式2-3" class="headerlink" title="方式2"></a>方式2</h4><p>改进思路： 把创建 Shape 类做成抽象类， 并提供一个抽象的 draw 方法， 让子类去实现即可， 这样我们有新的图形种类时， 只需要让新的图形类继承 Shape， 并实现 draw 方法即可， 使用方的代码就不需要修改，这种方式满足了开闭原则。</p><p>改进的代码具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GraphicEditor graphicEditor = <span class="keyword">new</span> GraphicEditor();</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Rectangle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Circle());</span><br><span class="line">        graphicEditor.drawShape(<span class="keyword">new</span> Triangle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">        s.draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m_type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Rectangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Circle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Triangle() &#123;</span><br><span class="line">        <span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、迪米特法则"><a href="#六、迪米特法则" class="headerlink" title="六、迪米特法则"></a>六、迪米特法则</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>迪米特法则(Demeter Principle)又叫<code>最少知道原则</code>， 即一个类对自己依赖的类知道的越少越好。 也就是说， 对于被依赖的类不管多么复杂， 都尽量将逻辑封装在类的内部。 对外除了提供的公开 方法， 不对外泄露任何信息。</p><p>迪米特法则还有个更简单的定义： 只与直接的朋友通信。所谓<code>直接的朋友</code>指每个对象都会与其他对象有耦合关系， 只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。 耦合的方式很多， 依赖， 关联， 组合， 聚合等。 其中，我们称出现<code>成员变量， 方法参数， 方法返回值</code>中的类为直接的朋友， 而出现在<code>局部变量</code>中的类不是直接的朋友。 <code>也就是说， 迪米特法则强调陌生的类最好不要以局部变量的形式出现在类的内部。</code></p><h3 id="应用实例-3"><a href="#应用实例-3" class="headerlink" title="应用实例"></a>应用实例</h3><p>假如现在有一个学校， 下属有各个学院和总部， 现要求打印出<strong>学校总部员工 ID</strong> 和<strong>学院员工的 ID</strong>。</p><h4 id="方式1-4"><a href="#方式1-4" class="headerlink" title="方式1"></a>方式1</h4><p>我们需要编程实现上面的功能, 看代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;<span class="comment">//返回值CollegeEmployee是直接朋友</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;<span class="comment">//返回值Employee是直接朋友</span></span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;<span class="comment">//方法参数CollegeManager 是直接朋友</span></span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();<span class="comment">//局部变量CollegeEmployee非直接朋友</span></span><br><span class="line">        System.out.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码的SchoolManager 的printAllEmployee方法，方法里面的类CollegeEmployee 是以局部变量方式出现在 SchoolManager中，违反了迪米特法则。</p><h4 id="方式2-4"><a href="#方式2-4" class="headerlink" title="方式2"></a>方式2</h4><p>前面方式1设计的问题在于 SchoolManager 中， CollegeEmployee 类并不是 SchoolManager 类的直接朋友，按照迪米特法则， 应该避免类中出现这样非直接朋友关系的耦合。以下是改进的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"~~~使用迪米特法则的改进~~~"</span>);</span><br><span class="line">        <span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">        SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">        <span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">        schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学院的所有员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">            CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">            emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增如下方法</span></span><br><span class="line">    <span class="comment">//输出学院员工的信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取到学院员工</span></span><br><span class="line">        List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回学校总部的员工</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">            Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">            emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">            list.add(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        sub.printEmployee();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//获取到学校总部员工</span></span><br><span class="line">        List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">        System.out.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">            System.out.println(e.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上述代码，我们将打印学院员工id的代码抽取成CollegeManager 类的一个printEmployee方法，这样就遵循了迪米特方法。</p><h3 id="注意事项和细节-2"><a href="#注意事项和细节-2" class="headerlink" title="注意事项和细节"></a>注意事项和细节</h3><p>迪米特法则的核心是<code>降低类之间的耦合</code>，但是注意： 由于每个类都减少了不必要的依赖， 因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系。</p><h2 id="七、合成复用原则"><a href="#七、合成复用原则" class="headerlink" title="七、合成复用原则"></a>七、合成复用原则</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>合成复用原则是尽量使用组合/聚合的方式， 而不是使用继承。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC的使用</title>
      <link href="/2020/01/01/JDBC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/01/JDBC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>JDBC 即为 Java 数据库连接（JAVA Database Connectivity ），其是SUN公司提供的一种数据库访问规则、规范。由于数据库种类较多，并且Java语言使用比较广泛，SUN公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的Java程序只要使用SUN公司提供的JDBC驱动即可。</p><p>以下使用MySQL数据库介绍JDBC的使用。</p><a id="more"></a><h3 id="一、基本步骤"><a href="#一、基本步骤" class="headerlink" title="一、基本步骤"></a>一、基本步骤</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 建立连接。参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span></span><br><span class="line">    conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/student"</span>, <span class="string">"root"</span>, <span class="string">"abc123!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建statement ， 跟数据库打交道，一定需要这个对象</span></span><br><span class="line">    stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 执行sql ，得到ResultSet</span></span><br><span class="line">    String sql = <span class="string">"select * from student"</span>;</span><br><span class="line">    rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 遍历结果集</span></span><br><span class="line">    <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">        String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">        System.out.println(<span class="string">"id="</span> + id + <span class="string">", name="</span> + name + <span class="string">", age="</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 6. 释放资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>)</span><br><span class="line">            rs.close();</span><br><span class="line">        <span class="keyword">if</span> (stmt != <span class="keyword">null</span>)</span><br><span class="line">            stmt.close();</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">            conn.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、工具类构建"><a href="#二、工具类构建" class="headerlink" title="二、工具类构建"></a>二、工具类构建</h3><p>为了更为简单合理的使用JDBC去连接数据库，我们可以构建JDBC工具类。</p><p><strong>1.</strong> 首先需要将数据库连接配置信息抽取出来，并使用<code>properties</code>文件保存，比如mysql数据库的连接配置信息如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#数据库驱动名称</span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">#数据库连接路径</span><br><span class="line">url=jdbc:mysql://localhost/student</span><br><span class="line">#用户名及连接密码</span><br><span class="line">user=root</span><br><span class="line">jdbcPassword=abc123!</span><br></pre></td></tr></table></figure><p><strong>2.</strong> 在工具类JDBCUtil里面，使用静态代码块，读取连接配置文件信息。其他功能如连接获取和释放等详见如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> String driverClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> String user = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> String jdbcPassword = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用properties配置文件读取数据库驱动名等</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建配置对象</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream inStream = <span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">            <span class="comment">//加载配置文件</span></span><br><span class="line">            pro.load(inStream);</span><br><span class="line">            <span class="comment">//读取文件内容</span></span><br><span class="line">            driverClass = pro.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">            url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            jdbcPassword = pro.getProperty(<span class="string">"jdbcPassword"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数据库加载与注册和连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载与注册</span></span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">            <span class="comment">//2.建立连接</span></span><br><span class="line">            conn = DriverManager.getConnection(url, user, jdbcPassword);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement stmt)</span> </span>&#123;</span><br><span class="line">        closeStmt(stmt);</span><br><span class="line">        closeConn(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        closeRs(rs);</span><br><span class="line">        closeStmt(stmt);</span><br><span class="line">        closeConn(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeRs</span><span class="params">(ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs != <span class="keyword">null</span>)</span><br><span class="line">                rs.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeStmt</span><span class="params">(Statement stmt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="keyword">null</span>)</span><br><span class="line">                stmt.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConn</span><span class="params">(Connection conn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、CRUD-操作"><a href="#三、CRUD-操作" class="headerlink" title="三、CRUD 操作"></a>三、CRUD 操作</h3><h4 id="insert-操作"><a href="#insert-操作" class="headerlink" title="insert 操作"></a>insert 操作</h4><p>插入操作使用到Statement类的executeUpdate方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">//3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"insert into student values(null , 'aobama' , 59)"</span>;</span><br><span class="line"><span class="comment">//4. 返回影响的行数，如果大于0 表明操作成功。，否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">    System.out.println(<span class="string">"添加成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"添加失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-操作"><a href="#delete-操作" class="headerlink" title="delete 操作"></a>delete 操作</h4><p>删除操作使用到Statement类的executeUpdate方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"><span class="comment">//3. 执行删除</span></span><br><span class="line">String sql = <span class="string">"delete from student where name='aobama'"</span>;</span><br><span class="line"><span class="comment">//影响的行数，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">    System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"删除失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="update-操作"><a href="#update-操作" class="headerlink" title="update 操作"></a>update 操作</h4><p>更新操作使用到Statement类的executeUpdate方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取连接对象</span></span><br><span class="line">conn = JDBCUtil.getConn();</span><br><span class="line"><span class="comment">// 2. 根据连接对象，得到statement</span></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 执行添加</span></span><br><span class="line">String sql = <span class="string">"update student set age = 26 where name ='qyq'"</span>;</span><br><span class="line"><span class="comment">//影响的行数，如果大于0 表明操作成功。 否则失败</span></span><br><span class="line"><span class="keyword">int</span> result = st.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &gt;<span class="number">0</span> )&#123;</span><br><span class="line">    System.out.println(<span class="string">"更新成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"更新失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="select-操作"><a href="#select-操作" class="headerlink" title="select 操作"></a>select 操作</h4><p>查询操作使用到了executeQuery方法，该方法会返回查询结果集，具体使用可查看上文的<strong>基本步骤</strong>的代码。</p><h3 id="四、Statement-安全问题"><a href="#四、Statement-安全问题" class="headerlink" title="四、Statement 安全问题"></a>四、Statement 安全问题</h3><p>Statement在执行时 ，其实是拼接sql语句的。 即先拼接sql语句，然后在一起执行，而这可能会导致SQL注入的安全问题。</p><p>比如现在有一登录功能，当我们需要使用用户名和密码去查询数据库具体的某一用户时，会使用如下查询语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"select * from t_user where username='"</span>+ username  +<span class="string">"' and password='"</span>+ password +<span class="string">"'"</span>;</span><br></pre></td></tr></table></figure><p>但是由于Statement在执行时 ，其实是拼接sql语句的。所以如果传入的变量username为<code>zhangsan</code>，password的值为<code>abc123&#39; or &#39;1</code>，此时sql语句就会被拼接为如下语句，此时会查出所有用户而导致SQL注入安全问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> username=<span class="string">'zhangsan'</span> <span class="keyword">and</span> <span class="keyword">password</span>=<span class="string">'abc123'</span> <span class="keyword">or</span> <span class="string">'1'</span></span><br></pre></td></tr></table></figure><h3 id="五、PrepareStatement"><a href="#五、PrepareStatement" class="headerlink" title="五、PrepareStatement"></a>五、PrepareStatement</h3><blockquote><p>该对象就是替换前面的statement对象，其不会发生SQL注入问题。</p></blockquote><p>相比较Statement， PrepareStatement 会预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。</p><p>示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"insert into t_user values(null , ? , ?)"</span>;</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//给占位符赋值 从左到右数过来，1 代表第一个问号， 永远是1开始。</span></span><br><span class="line"> ps.setString(<span class="number">1</span>, userName);</span><br><span class="line"> ps.setString(<span class="number">2</span>, password);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 数据类型及命令</title>
      <link href="/2020/01/01/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/01/01/Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>Redis中存储数据是通过key-value存储的，对于value的类型有：String类型、Hash类型、List类型、Set类型和SortedSet（zset）类型。</p><p>在redis中的命令语句中，命令是忽略大小写的，而key是不忽略大小写的。下面介绍一下这些数据结构的使用及其应用。</p><h2 id="一、String-类型"><a href="#一、String-类型" class="headerlink" title="一、String 类型"></a>一、String 类型</h2><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="1. 命令"></a>1. 命令</h3><h4 id="1-1-赋值"><a href="#1-1-赋值" class="headerlink" title="1.1 赋值"></a>1.1 赋值</h4><p><em>语法：SET key value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707145501449.png" alt="在这里插入图片描述"></p><a id="more"></a><h4 id="1-2-取值"><a href="#1-2-取值" class="headerlink" title="1.2 取值"></a>1.2 取值</h4><p><em>语法：GET key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707145533973.png" alt="在这里插入图片描述"></p><h4 id="1-3-设置-获取多个键值"><a href="#1-3-设置-获取多个键值" class="headerlink" title="1.3 设置/获取多个键值"></a>1.3 设置/获取多个键值</h4><p><em>语法：<br>    MSET key value [key value …]<br>    MGET key [key …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707145708912.png" alt="在这里插入图片描述"></p><h4 id="1-4-取值并赋值"><a href="#1-4-取值并赋值" class="headerlink" title="1.4 取值并赋值"></a>1.4 取值并赋值</h4><p><em>语法：GETSET key value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707145823402.png" alt="在这里插入图片描述"><br>这里返回的值为s2更新之前的值，执行上述语句后，s2的值变为222。</p><h4 id="1-5-删除"><a href="#1-5-删除" class="headerlink" title="1.5 删除"></a>1.5 删除</h4><p><em>语法：DEL key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707150130432.png" alt="在这里插入图片描述"><br>返回1表示删除1行。</p><h4 id="1-6-数值增减"><a href="#1-6-数值增减" class="headerlink" title="1.6 数值增减"></a>1.6 数值增减</h4><p><strong>递增数字</strong><br>当存储的字符串是整数时，Redis提供了一个实用的命令INCR，其作用是让当前键值递增，并返回递增后的值。</p><p><em>语法：INCR key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707150701799.png" alt="在这里插入图片描述"><br><strong>增加指定的整数</strong></p><p><em>语法：INCRBY key increment</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707150813640.png" alt="在这里插入图片描述"><br><strong>递减数值</strong></p><p><em>语法：DECR key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707150908832.png" alt="在这里插入图片描述"><br><strong>减少指定的整数</strong></p><p><em>语法：DECRBY key decrement</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707151103701.png" alt="在这里插入图片描述"></p><h4 id="1-7-向尾部追加值"><a href="#1-7-向尾部追加值" class="headerlink" title="1.7 向尾部追加值"></a>1.7 向尾部追加值</h4><p>APPEND的作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后字符串的总长度。 </p><p><em>语法：APPEND key value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707153017863.png" alt="在这里插入图片描述"></p><h4 id="1-8-获取字符串长度"><a href="#1-8-获取字符串长度" class="headerlink" title="1.8 获取字符串长度"></a>1.8 获取字符串长度</h4><p>STRLEN命令返回键值的长度，如果键不存在则返回0。</p><p><em>语法：STRLEN key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707153139965.png" alt="在这里插入图片描述"></p><h2 id="二、Hash-类型"><a href="#二、Hash-类型" class="headerlink" title="二、Hash 类型"></a>二、Hash 类型</h2><h3 id="1-使用String的问题"><a href="#1-使用String的问题" class="headerlink" title="1. 使用String的问题"></a>1. 使用String的问题</h3><p>假设有User对象以JSON序列化的形式存储到Redis中，User对象有id，username、password、age等属性，存储的过程如下：<br><img src="/2020/01/01/Redis-数据类型及命令/20190707154543557.png" alt="在这里插入图片描述"><br>如果在业务上只是更新age属性，其他的属性并不做更新我应该怎么做呢？ 如果仍然采用上边的方法那么就需要每次都更新整个user对象字符串并造成传输、处理时会造成资源浪费，下边讲的hash数据类型可以很好的解决这个问题。</p><h3 id="2-Redis-Hash介绍"><a href="#2-Redis-Hash介绍" class="headerlink" title="2. Redis Hash介绍"></a>2. Redis Hash介绍</h3><p>hash叫散列类型，它提供了字段和字段值的映射。字段值只能是<strong>字符串类型</strong>，不支持散列类型、集合类型等其它类型。如下：<br><img src="/2020/01/01/Redis-数据类型及命令/20190707154849447.png" alt="在这里插入图片描述"></p><h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3. 命令"></a>3. 命令</h3><h4 id="3-1-赋值"><a href="#3-1-赋值" class="headerlink" title="3.1 赋值"></a>3.1 赋值</h4><p>HSET命令不区分插入和更新操作，当执行插入操作时HSET命令返回1，当执行更新操作时返回0。</p><p><strong>一次只能设置一个字段值：</strong></p><p><em>语法：HSET key field value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707155251847.png" alt="在这里插入图片描述"><br><strong>一次可以设置多个字段值：</strong></p><p><em>语法：HMSET key field value [field value …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707155434501.png" alt="在这里插入图片描述"><br><strong>当字段不存在时赋值，类似HSET，区别在于如果字段存在，该命令不执行任何操作：</strong></p><p><em>语法：HSETNX key field value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707155743497.png" alt="在这里插入图片描述"><br>如果user中没有age字段则设置age值为30，否则不做任何操作。</p><h4 id="3-2-取值"><a href="#3-2-取值" class="headerlink" title="3.2 取值"></a>3.2 取值</h4><p><strong>一次只能获取一个字段值：</strong></p><p><em>语法：HGET key field</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707160017156.png" alt="在这里插入图片描述"><br><strong>一次可以获取多个字段值：</strong></p><p><em>语法：HMGET key field [field …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707160109325.png" alt="在这里插入图片描述"><br><strong>获取所有字段值：</strong></p><p><em>语法：HGETALL key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707160313174.png" alt="在这里插入图片描述"></p><h4 id="3-3-删除字段"><a href="#3-3-删除字段" class="headerlink" title="3.3 删除字段"></a>3.3 删除字段</h4><p>可以删除一个或多个字段，返回值是被删除的字段个数 。</p><p><em>语法：HDEL key field [field …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707160458150.png" alt="在这里插入图片描述"></p><h4 id="3-4-增加数字"><a href="#3-4-增加数字" class="headerlink" title="3.4 增加数字"></a>3.4 增加数字</h4><p><em>语法：HINCRBY key field increment</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707160729650.png" alt="在这里插入图片描述"></p><h4 id="3-5-判断字段是否存在"><a href="#3-5-判断字段是否存在" class="headerlink" title="3.5 判断字段是否存在"></a>3.5 判断字段是否存在</h4><p>若返回值为1则表示字段存在，若返回0则表示字段不存在。</p><p><em>语法：HEXISTS key field</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707160848635.png" alt="在这里插入图片描述"></p><h4 id="3-6-只获取字段名或字段值"><a href="#3-6-只获取字段名或字段值" class="headerlink" title="3.6 只获取字段名或字段值"></a>3.6 只获取字段名或字段值</h4><p><em>语法：<br>HKEYS key<br>HVALS key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707161129566.png" alt="在这里插入图片描述"></p><h4 id="3-7-获取字段数量"><a href="#3-7-获取字段数量" class="headerlink" title="3.7 获取字段数量"></a>3.7 获取字段数量</h4><p><em>语法：HLEN key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707161239835.png" alt="在这里插入图片描述"></p><h2 id="三、List-类型"><a href="#三、List-类型" class="headerlink" title="三、List 类型"></a>三、List 类型</h2><h3 id="1-Redis-List-介绍"><a href="#1-Redis-List-介绍" class="headerlink" title="1. Redis List 介绍"></a>1. Redis List 介绍</h3><p>列表类型（list）可以存储一个<strong>有序</strong>（按添加顺序）的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段。</p><p>列表类型内部是使用双向链表（double linked list）实现的，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是极快的。</p><h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><h4 id="2-1-向列表两端增加元素"><a href="#2-1-向列表两端增加元素" class="headerlink" title="2.1 向列表两端增加元素"></a>2.1 向列表两端增加元素</h4><p><strong>向列表左边增加元素：</strong></p><p><em>语法：LPUSH key value [value …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/2019070716445699.png" alt="在这里插入图片描述"><br><strong>向列表右边增加元素：</strong></p><p><em>语法：RPUSH key value [value …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707164749109.png" alt="在这里插入图片描述"></p><h4 id="2-2-查看列表"><a href="#2-2-查看列表" class="headerlink" title="2.2 查看列表"></a>2.2 查看列表</h4><p>LRANGE命令是列表类型最常用的命令之一，获取列表中的某一片段，将返回start、stop之间的所有元素（包含两端的元素），索引从0开始。索引可以是负数，如：“-1”代表最后边的一个元素，“-2”代表最后第二个元素。</p><p><em>语法：LRANGE key start stop</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707165005523.png" alt="在这里插入图片描述"></p><h4 id="2-3-从列表两端弹出元素"><a href="#2-3-从列表两端弹出元素" class="headerlink" title="2.3 从列表两端弹出元素"></a>2.3 从列表两端弹出元素</h4><p>LPOP（RPOP）命令从列表左（右）边弹出一个元素，会分两步完成：</p><p>第一步是将列表左（右）边的元素从列表中移除，第二步是返回被移除的元素值。</p><p><em>语法：<br>LPOP key<br>RPOP key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707165338740.png" alt="在这里插入图片描述"></p><h4 id="2-4-获取列表中元素的个数"><a href="#2-4-获取列表中元素的个数" class="headerlink" title="2.4 获取列表中元素的个数"></a>2.4 获取列表中元素的个数</h4><p><em>语法：LLEN key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707170917488.png" alt="在这里插入图片描述"></p><h4 id="2-5-删除列表中指定的值"><a href="#2-5-删除列表中指定的值" class="headerlink" title="2.5 删除列表中指定的值"></a>2.5 删除列表中指定的值</h4><p>LREM命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会有所不同： </p><ul><li>当count&gt;0时， LREM会从列表左边开始删除。 </li><li>当count&lt;0时， LREM会从列表后边开始删除。 </li><li>当count=0时， LREM删除所有值为value的元素。</li></ul><p><em>语法：LREM key count value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707171442385.png" alt="在这里插入图片描述"></p><h4 id="2-6-获得-设置指定索引的元素值"><a href="#2-6-获得-设置指定索引的元素值" class="headerlink" title="2.6 获得/设置指定索引的元素值"></a>2.6 获得/设置指定索引的元素值</h4><p>需要注意的是索引从0开始算起。</p><p><strong>获得指定索引的元素值：</strong></p><p><em>语法：LINDEX key index</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707171734171.png" alt="在这里插入图片描述"><br><strong>设置指定索引的元素值：</strong></p><p><em>语法：LSET key index value</em><br><img src="/2020/01/01/Redis-数据类型及命令/2019070717181123.png" alt="在这里插入图片描述"></p><h4 id="2-7-只保留列表指定片段"><a href="#2-7-只保留列表指定片段" class="headerlink" title="2.7 只保留列表指定片段"></a>2.7 只保留列表指定片段</h4><p>指定范围和LRANGE一致 。</p><p><em>语法：LTRIM key start stop</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707172138452.png" alt="在这里插入图片描述"></p><h4 id="2-8-向列表中插入元素"><a href="#2-8-向列表中插入元素" class="headerlink" title="2.8 向列表中插入元素"></a>2.8 向列表中插入元素</h4><p>该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。</p><p><em>语法：LINSERT key BEFORE|AFTER pivot value</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707172409192.png" alt="在这里插入图片描述"></p><h4 id="2-9-将元素从一个列表转移到另一个列表中"><a href="#2-9-将元素从一个列表转移到另一个列表中" class="headerlink" title="2.9 将元素从一个列表转移到另一个列表中"></a>2.9 将元素从一个列表转移到另一个列表中</h4><p><em>语法：RPOPLPUSH source destination</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707172803243.png" alt="在这里插入图片描述"></p><h2 id="四、Set-类型"><a href="#四、Set-类型" class="headerlink" title="四、Set 类型"></a>四、Set 类型</h2><h3 id="1-Redis-Set介绍"><a href="#1-Redis-Set介绍" class="headerlink" title="1. Redis Set介绍"></a>1. Redis Set介绍</h3><p>集合中的数据是不重复且没有顺序（添加顺序）。</p><p>集合类型和列表类型的对比：<br><img src="/2020/01/01/Redis-数据类型及命令/20190707194824334.png" alt="在这里插入图片描述"><br>集合类型的常用操作是向集合中加入或删除元素、判断某个元素是否存在等，由于集合类型的Redis内部是使用值为空的散列表实现，所有这些操作的时间复杂度都为0(1)。 </p><p>Redis还提供了多个集合之间的交集、并集、差集的运算。</p><h3 id="2-命令-1"><a href="#2-命令-1" class="headerlink" title="2. 命令"></a>2. 命令</h3><h4 id="2-1-增加-删除元素"><a href="#2-1-增加-删除元素" class="headerlink" title="2.1 增加/删除元素"></a>2.1 增加/删除元素</h4><p><em>语法：SADD key member [member …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/2019070720070361.png" alt="在这里插入图片描述"><br><em>语法：SREM key member [member …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707200736225.png" alt="在这里插入图片描述"></p><h4 id="2-2-获得集合中的所有元素"><a href="#2-2-获得集合中的所有元素" class="headerlink" title="2.2 获得集合中的所有元素"></a>2.2 获得集合中的所有元素</h4><p><em>语法：SMEMBERS key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707200837252.png" alt="在这里插入图片描述"></p><h4 id="2-3-判断元素是否在集合中"><a href="#2-3-判断元素是否在集合中" class="headerlink" title="2.3 判断元素是否在集合中"></a>2.3 判断元素是否在集合中</h4><p><em>语法：SISMEMBER key member</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707200925386.png" alt="在这里插入图片描述"></p><h4 id="2-4-获得集合中元素的个数"><a href="#2-4-获得集合中元素的个数" class="headerlink" title="2.4 获得集合中元素的个数"></a>2.4 获得集合中元素的个数</h4><p><em>语法：SCARD key</em><br><img src="/2020/01/01/Redis-数据类型及命令/2019070720285160.png" alt="在这里插入图片描述"></p><h4 id="2-5-从集合中弹出一个元素"><a href="#2-5-从集合中弹出一个元素" class="headerlink" title="2.5 从集合中弹出一个元素"></a>2.5 从集合中弹出一个元素</h4><p>注意：由于集合是无序的，所有SPOP命令会从集合中<strong>随机</strong>选择一个元素弹出 </p><p><em>语法：SPOP key</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707203021583.png" alt="在这里插入图片描述"></p><h3 id="3-运算命令"><a href="#3-运算命令" class="headerlink" title="3. 运算命令"></a>3. 运算命令</h3><h4 id="3-1-集合的差集运算-A-B"><a href="#3-1-集合的差集运算-A-B" class="headerlink" title="3.1 集合的差集运算 A-B"></a>3.1 集合的差集运算 A-B</h4><p>属于A并且不属于B的元素构成的集合。<br><img src="/2020/01/01/Redis-数据类型及命令/20190707201045127.png" alt="在这里插入图片描述"><br><em>语法：SDIFF key [key …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707202232432.png" alt="在这里插入图片描述"></p><h4 id="3-2-集合的交集运算-A-∩-B"><a href="#3-2-集合的交集运算-A-∩-B" class="headerlink" title="3.2 集合的交集运算 A ∩ B"></a>3.2 集合的交集运算 A ∩ B</h4><p>属于A且属于B的元素构成的集合。<br><img src="/2020/01/01/Redis-数据类型及命令/2019070720252575.png" alt="在这里插入图片描述"><br><em>语法：SINTER key [key …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707202553382.png" alt="在这里插入图片描述"></p><h4 id="3-3-集合的并集运算-A-∪-B"><a href="#3-3-集合的并集运算-A-∪-B" class="headerlink" title="3.3 集合的并集运算 A ∪ B"></a>3.3 集合的并集运算 A ∪ B</h4><p>属于A或者属于B的元素构成的集合。<br><img src="/2020/01/01/Redis-数据类型及命令/20190707202655501.png" alt="在这里插入图片描述"><br><em>语法：SUNION key [key …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707202723441.png" alt="在这里插入图片描述"></p><h2 id="五、SortedSet-类型"><a href="#五、SortedSet-类型" class="headerlink" title="五、SortedSet 类型"></a>五、SortedSet 类型</h2><h3 id="1-Redis-Sorted-Set介绍"><a href="#1-Redis-Sorted-Set介绍" class="headerlink" title="1. Redis Sorted Set介绍"></a>1. Redis Sorted Set介绍</h3><p>在集合类型的基础上，有序集合类型为集合中的每个元素都<strong>关联一个分数</strong>，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。 </p><p>在某些方面有序集合和列表类型有些相似：</p><ol><li>有序集合是按分数递增有序的，而列表类型是按添加顺序有序的。</li><li>二者都可以获得某一范围的元素。 </li></ol><p>但是，二者有着很大区别： </p><ol><li>列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会变慢。 </li><li>有序集合类型使用散列表实现，所有即使读取位于中间部分的数据也很快。 </li><li>列表中不能简单的调整某个元素的位置，但是有序集合可以（通过更改分数实现） </li><li>有序集合要比列表类型更耗内存。 </li></ol><h3 id="2-命令-2"><a href="#2-命令-2" class="headerlink" title="2. 命令"></a>2. 命令</h3><h4 id="2-1-增加元素"><a href="#2-1-增加元素" class="headerlink" title="2.1 增加元素"></a>2.1 增加元素</h4><p>向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。返回值是此次新加入到集合中的元素个数。</p><p><em>语法：ZADD key score member [score member …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707203838765.png" alt="在这里插入图片描述"></p><h4 id="2-2-获取元素的分数"><a href="#2-2-获取元素的分数" class="headerlink" title="2.2 获取元素的分数"></a>2.2 获取元素的分数</h4><p><em>语法：ZSCORE key member</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707204129225.png" alt="在这里插入图片描述"></p><h4 id="2-3-删除元素"><a href="#2-3-删除元素" class="headerlink" title="2.3 删除元素"></a>2.3 删除元素</h4><p>移除有序集key中的一个或多个成员，不存在的成员将被忽略。当key存在但不是有序集类型时，返回一个错误。</p><p><em>语法：ZREM key member [member …]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707204327434.png" alt="在这里插入图片描述"></p><h4 id="2-4-获得排名在某个范围的元素列表"><a href="#2-4-获得排名在某个范围的元素列表" class="headerlink" title="2.4 获得排名在某个范围的元素列表"></a>2.4 获得排名在某个范围的元素列表</h4><ul><li><p>按照元素分数<strong>从小到大</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）。</p><p><em>语法：ZRANGE key start stop [WITHSCORES]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707204545878.png" alt="在这里插入图片描述"></p></li><li><p>按照元素分数<strong>从大到小</strong>的顺序返回索引从start到stop之间的所有元素（包含两端的元素）。</p><p><em>语法：ZREVRANGE key start stop [WITHSCORES]</em><br><img src="/2020/01/01/Redis-数据类型及命令/20190707204721636.png" alt="在这里插入图片描述"><br>如果需要获得元素的分数的可以在命令尾部加上WITHSCORES参数 ：<br><img src="/2020/01/01/Redis-数据类型及命令/20190707205154941.png" alt="在这里插入图片描述"></p><h4 id="2-5-获得指定分数范围的元素"><a href="#2-5-获得指定分数范围的元素" class="headerlink" title="2.5 获得指定分数范围的元素"></a>2.5 获得指定分数范围的元素</h4><p><img src="/2020/01/01/Redis-数据类型及命令/20190707205401196.png" alt="在这里插入图片描述"></p><h4 id="2-6-增加某个元素的分数"><a href="#2-6-增加某个元素的分数" class="headerlink" title="2.6 增加某个元素的分数"></a>2.6 增加某个元素的分数</h4><p>返回值是更改后的分数 </p></li></ul><p><em>语法：ZINCRBY  key increment member</em><br><img src="/2020/01/01/Redis-数据类型及命令/201907072056309.png" alt="在这里插入图片描述"></p><h4 id="2-7-获得集合中元素的数量"><a href="#2-7-获得集合中元素的数量" class="headerlink" title="2.7 获得集合中元素的数量"></a>2.7 获得集合中元素的数量</h4><p><img src="/2020/01/01/Redis-数据类型及命令/20190707205806936.png" alt="在这里插入图片描述"></p><h4 id="2-8-获得指定分数范围内的元素个数"><a href="#2-8-获得指定分数范围内的元素个数" class="headerlink" title="2.8 获得指定分数范围内的元素个数"></a>2.8 获得指定分数范围内的元素个数</h4><p><img src="/2020/01/01/Redis-数据类型及命令/20190707205911377.png" alt="在这里插入图片描述"></p><h4 id="2-9-按照排名范围删除元素"><a href="#2-9-按照排名范围删除元素" class="headerlink" title="2.9 按照排名范围删除元素"></a>2.9 按照排名范围删除元素</h4><p><img src="/2020/01/01/Redis-数据类型及命令/20190707210019529.png" alt="在这里插入图片描述"></p><h4 id="2-10-按照分数范围删除元素"><a href="#2-10-按照分数范围删除元素" class="headerlink" title="2.10 按照分数范围删除元素"></a>2.10 按照分数范围删除元素</h4><p><img src="/2020/01/01/Redis-数据类型及命令/20190707210222585.png" alt="在这里插入图片描述"></p><h4 id="2-11-获取元素的排名"><a href="#2-11-获取元素的排名" class="headerlink" title="2.11 获取元素的排名"></a>2.11 获取元素的排名</h4><p>返回值即为元素在有序集合中的索引。<br><img src="/2020/01/01/Redis-数据类型及命令/2019070721032295.png" alt="在这里插入图片描述"></p><h2 id="六、Keys命令"><a href="#六、Keys命令" class="headerlink" title="六、Keys命令"></a>六、Keys命令</h2><h3 id="1-1-设置key的生存时间"><a href="#1-1-设置key的生存时间" class="headerlink" title="1.1 设置key的生存时间"></a>1.1 设置key的生存时间</h3><p>Redis在实际使用过程中更多的用作缓存，然而缓存的数据一般都是需要设置生存时间的，即：到期后数据销毁。<br><img src="/2020/01/01/Redis-数据类型及命令/20190707212354806.png" alt="在这里插入图片描述"><br><img src="/2020/01/01/Redis-数据类型及命令/20190707212412678.png" alt="在这里插入图片描述"></p><h3 id="1-2-keys"><a href="#1-2-keys" class="headerlink" title="1.2 keys"></a>1.2 keys</h3><p>返回满足给定pattern 的所有key<br><img src="/2020/01/01/Redis-数据类型及命令/2019070721251225.png" alt="在这里插入图片描述"></p><h3 id="1-3-exists"><a href="#1-3-exists" class="headerlink" title="1.3 exists"></a>1.3 exists</h3><p>确认一个key 是否存在。</p><p>示例：从结果来看，数据库中不存在HongWan 这个key，但是age 这个key 是存在的<br><img src="/2020/01/01/Redis-数据类型及命令/20190707212602330.png" alt="在这里插入图片描述"></p><h3 id="1-4-del"><a href="#1-4-del" class="headerlink" title="1.4 del"></a>1.4 del</h3><p>删除一个key<br><img src="/2020/01/01/Redis-数据类型及命令/20190707212653484.png" alt="在这里插入图片描述"></p><h3 id="1-5-rename"><a href="#1-5-rename" class="headerlink" title="1.5 rename"></a>1.5 rename</h3><p>重命名key</p><p>示例：age 成功的被我们改名为age_new 了<br><img src="/2020/01/01/Redis-数据类型及命令/2019070721274853.png" alt="在这里插入图片描述"></p><h3 id="1-6-type"><a href="#1-6-type" class="headerlink" title="1.6 type"></a>1.6 type</h3><p>返回值的类型</p><p>示例：这个方法可以非常简单的判断出值的类型<br><img src="/2020/01/01/Redis-数据类型及命令/20190707212858869.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jedis 的使用</title>
      <link href="/2020/01/01/Jedis-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/01/Jedis-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Jedis-介绍"><a href="#一、Jedis-介绍" class="headerlink" title="一、Jedis 介绍"></a>一、Jedis 介绍</h3><p>Redis不仅支持使用命令来操作，现在许多主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 </p><p>在 Java 的官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis 等，其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis。</p><p>Jedis同样也是托管在github上，地址：<a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">https://github.com/xetorthio/jedis</a></p><a id="more"></a><h3 id="二、依赖-Jar-包"><a href="#二、依赖-Jar-包" class="headerlink" title="二、依赖 Jar 包"></a>二、依赖 Jar 包</h3><p><img src="/2020/01/01/Jedis-的使用/20190708155222863.png" alt="在这里插入图片描述"></p><h3 id="三、单实例连接"><a href="#三、单实例连接" class="headerlink" title="三、单实例连接"></a>三、单实例连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个Jedis连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.121.133"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择 Redis 数据库，默认为0号数据库</span></span><br><span class="line">    jedis.select(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行redis命令</span></span><br><span class="line">    jedis.set(<span class="string">"strtype"</span>, <span class="string">"Hello World"</span>);<span class="comment">// 添加String类型值</span></span><br><span class="line">    jedis.lpush(<span class="string">"listtype"</span>, <span class="string">"list1"</span>, <span class="string">"list2"</span>, <span class="string">"list3"</span>);<span class="comment">//添加list类型值</span></span><br><span class="line">    jedis.sadd(<span class="string">"settype"</span>, <span class="string">"set1"</span>, <span class="string">"set2"</span>, <span class="string">"set3"</span>); <span class="comment">//添加set类型值</span></span><br><span class="line">    jedis.hset(<span class="string">"user"</span>, <span class="string">"username"</span>, <span class="string">"zhangsan"</span>); <span class="comment">// 添加Hash类型值</span></span><br><span class="line">    jedis.hset(<span class="string">"user"</span>, <span class="string">"age"</span>, <span class="string">"42"</span>);</span><br><span class="line">    jedis.hset(<span class="string">"user"</span>, <span class="string">"male"</span>, <span class="string">"男"</span>);</span><br><span class="line">    jedis.zadd(<span class="string">"scoreboard"</span>, <span class="number">63</span>, <span class="string">"lisi"</span>);<span class="comment">// 添加sortedSet类型值</span></span><br><span class="line">    jedis.zadd(<span class="string">"scoreboard"</span>, <span class="number">85</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 redis中取值并打印</span></span><br><span class="line">    System.out.println(jedis.get(<span class="string">"strtype"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，控制台会打印“Hello World”字样，同时Redis的1号数据库会存储进数据，如下图示：<br><img src="/2020/01/01/Jedis-的使用/20190708161011998.png" alt="在这里插入图片描述"></p><h3 id="四、连接池连接"><a href="#四、连接池连接" class="headerlink" title="四、连接池连接"></a>四、连接池连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个连接池对象</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.121.133"</span>, <span class="number">6379</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从连接池中获得连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 选择数据库</span></span><br><span class="line">    jedis.select(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取并打印数据</span></span><br><span class="line">    String result = jedis.get(<span class="string">"strtype"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关闭连接池</span></span><br><span class="line">    jedisPool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Spring-整合-JedisPool"><a href="#五、Spring-整合-JedisPool" class="headerlink" title="五、Spring 整合 JedisPool"></a>五、Spring 整合 JedisPool</h3><h4 id="1-添加Spring的Jar包"><a href="#1-添加Spring的Jar包" class="headerlink" title="1. 添加Spring的Jar包"></a>1. 添加Spring的Jar包</h4><h4 id="2-配置spring配置文件applicationContext-xml"><a href="#2-配置spring配置文件applicationContext-xml" class="headerlink" title="2. 配置spring配置文件applicationContext.xml"></a>2. 配置spring配置文件applicationContext.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-3.2.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-3.2.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-3.2.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 连接池配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"numTestsPerEvictionRun"</span> <span class="attr">value</span>=<span class="string">"1024"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"30000"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"1800000"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"softMinEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1500"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blockWhenExhausted"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- redis单机 通过连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPool"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPool"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"6379"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-测试代码"><a href="#3-测试代码" class="headerlink" title="3. 测试代码"></a>3. 测试代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisPool pool = (JedisPool) applicationContext.getBean(<span class="string">"jedisPool"</span>);</span><br><span class="line">    Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line"></span><br><span class="line">        jedis.set(<span class="string">"name"</span>, <span class="string">"lisi"</span>);</span><br><span class="line">        String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、Jedis-连接集群"><a href="#六、Jedis-连接集群" class="headerlink" title="六、Jedis 连接集群"></a>六、Jedis 连接集群</h3><h4 id="1-简单实现"><a href="#1-简单实现" class="headerlink" title="1. 简单实现"></a>1. 简单实现</h4><p>创建JedisCluster类连接redis集群，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisCluster</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建一连接，JedisCluster对象,在系统中是单例存在</span></span><br><span class="line">    Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.121.133"</span>, <span class="number">7001</span>));</span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.121.133"</span>, <span class="number">7002</span>));</span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.121.133"</span>, <span class="number">7003</span>));</span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.121.133"</span>, <span class="number">7004</span>));</span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.121.133"</span>, <span class="number">7005</span>));</span><br><span class="line">    nodes.add(<span class="keyword">new</span> HostAndPort(<span class="string">"192.168.121.133"</span>, <span class="number">7006</span>));</span><br><span class="line">    JedisCluster cluster = <span class="keyword">new</span> JedisCluster(nodes);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//执行JedisCluster对象中的方法，方法和redis一一对应。</span></span><br><span class="line">    <span class="comment">//JedisCluster对象同Jedis对象一样来使用</span></span><br><span class="line">    cluster.set(<span class="string">"cluster-test"</span>, <span class="string">"my jedis cluster test"</span>);</span><br><span class="line">    String result = cluster.get(<span class="string">"cluster-test"</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//程序结束时需要关闭JedisCluster对象</span></span><br><span class="line">    cluster.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-整合-Spring"><a href="#2-整合-Spring" class="headerlink" title="2. 整合 Spring"></a>2. 整合 Spring</h4><p>applicationContext.xml进行如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 连接池配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最大连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 最大空闲连接数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每次释放连接的最大数目 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"numTestsPerEvictionRun"</span> <span class="attr">value</span>=<span class="string">"1024"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 释放连接的扫描间隔（毫秒） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"30000"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接最小空闲时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"1800000"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接空闲多久后释放, 当空闲时间&gt;该值 且 空闲连接&gt;最大空闲连接数 时直接释放 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"softMinEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWaitMillis"</span> <span class="attr">value</span>=<span class="string">"1500"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在获取连接的时候检查有效性, 默认false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在空闲时检查有效性, 默认false --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blockWhenExhausted"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- redis集群 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisCluster"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisCluster"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"7001"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"7002"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"7003"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"7004"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"7005"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.HostAndPort"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"192.168.121.133"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"7006"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redis集群</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJedisCluster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    JedisCluster jedisCluster = (JedisCluster) applicationContext.getBean(<span class="string">"jedisCluster"</span>);</span><br><span class="line">    jedisCluster.set(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">    String value = jedisCluster.get(<span class="string">"name"</span>);</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Log4J 的使用</title>
      <link href="/2020/01/01/Log4J-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/01/Log4J-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>日志是应用软件中不可缺少的部分，Apache 的开源项目 log4j 是一个功能强大的日志组件，提供方便的日志记录。在 apache 网站：jakarta.apache.org/log4j 可以免费下载到 Log4j 最新版本的软件包。</p><h2 id="一、入门实例"><a href="#一、入门实例" class="headerlink" title="一、入门实例"></a>一、入门实例</h2><p>1.新建一个 Java 工程，导入包 log4j-1.2.17.jar，整个工程最终目录如下：<br><img src="/2020/01/01/Log4J-的使用/20190327111924438.png" alt="在这里插入图片描述"><br>2.src 同级创建并设置 log4j.properties，具体内容如下所示：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">### 设置 ###</span><br><span class="line">log4j.rootLogger = debug,stdout,D,E</span><br><span class="line"></span><br><span class="line">### 输出信息到控制台 ###</span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class="line"></span><br><span class="line">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><br><span class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.D.File = E://logs/log.log</span><br><span class="line">log4j.appender.D.Append = true</span><br><span class="line">log4j.appender.D.Threshold = DEBUG </span><br><span class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"></span><br><span class="line">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br><span class="line">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.E.File =E://logs/error.log </span><br><span class="line">log4j.appender.E.Append = true</span><br><span class="line">log4j.appender.E.Threshold = ERROR </span><br><span class="line">log4j.appender.E.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure><p>3.设置日志内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mucfc;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@author</span> linbingwen</span></span><br><span class="line"><span class="comment"> *@2015年5月18日9:14:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取日志记录器，使用static修饰，防止logger变量被GC</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(Test.class);  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// System.out.println("This is println message.");  </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 记录debug级别的信息  </span></span><br><span class="line">        logger.debug(<span class="string">"This is debug message."</span>);  </span><br><span class="line">        <span class="comment">// 记录info级别的信息  </span></span><br><span class="line">        logger.info(<span class="string">"This is info message."</span>);  </span><br><span class="line">        <span class="comment">// 记录error级别的信息  </span></span><br><span class="line">        logger.error(<span class="string">"This is error message."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.输出结果：</p><ul><li>首先是控制台的信息：<br><img src="/2020/01/01/Log4J-的使用/20190327112626747.png" alt="在这里插入图片描述"></li><li>再来看输出的文件：<br><img src="/2020/01/01/Log4J-的使用/20190327112711781.png" alt="在这里插入图片描述"><br>内容如下，发现已按照要求输出到对应的文档中。<br><img src="/2020/01/01/Log4J-的使用/20190327112756925.png" alt="在这里插入图片描述"><br><img src="/2020/01/01/Log4J-的使用/20190327112810402.png" alt="在这里插入图片描述"><h2 id="二、Log4j-基本使用方法"><a href="#二、Log4j-基本使用方法" class="headerlink" title="二、Log4j 基本使用方法"></a>二、Log4j 基本使用方法</h2>Log4j 由三个重要的组件构成：<strong>日志信息的优先级</strong>，<strong>日志信息的输出目的地</strong>，<strong>日志信息的输出格式</strong>。日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</li></ul><h3 id="1-定义配置文件"><a href="#1-定义配置文件" class="headerlink" title="1.定义配置文件"></a>1.定义配置文件</h3><p>其实你也可以完全不使用配置文件，而是在代码中配置 Log4j 环境。但是，使用配置文件将使您的应用程序更加灵活。Log4j 支持两种配置文件格式，一种是XML格式的文件，一种是Java特性文件（键=值）。下面我们介绍使用Java特性文件做为配置文件的方法：</p><p>（1）：配置根 Logger，其语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger = [ level ] , appenderName, appenderName, …</span><br></pre></td></tr></table></figure><p>其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j 建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了 INFO 级别，则应用程序中所有 DEBUG 级别的日志信息将不被打印出来。 appenderName 就是指日志信息输出到哪个地方。你可以同时指定多个输出目的地。</p><p>（2）：配置日志信息输出目的地 Appender，其语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.appenderName = fully.qualified.name.of.appender.class  </span><br><span class="line">log4j.appender.appenderName.option1 = value1  </span><br><span class="line">…  </span><br><span class="line">log4j.appender.appenderName.option = valueN</span><br></pre></td></tr></table></figure><p>其中，Log4j 提供的 appender 有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.apache.log4j.ConsoleAppender（控制台），  </span><br><span class="line">org.apache.log4j.FileAppender（文件），  </span><br><span class="line">org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），  </span><br><span class="line">org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  </span><br><span class="line">org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</span><br></pre></td></tr></table></figure><p>（3）：配置日志信息的格式（布局），其语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class  </span><br><span class="line">log4j.appender.appenderName.layout.option1 = value1  </span><br><span class="line">…  </span><br><span class="line">log4j.appender.appenderName.layout.option = valueN</span><br></pre></td></tr></table></figure><p>其中，Log4j 提供的 layout 有以下几种：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.apache.log4j.HTMLLayout（以HTML表格形式布局），  </span><br><span class="line">org.apache.log4j.PatternLayout（可以灵活地指定布局模式），  </span><br><span class="line">org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），  </span><br><span class="line">org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</span><br></pre></td></tr></table></figure><p>Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息，打印参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%m 输出代码中指定的消息</span><br><span class="line">%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  </span><br><span class="line">%r 输出自应用启动到输出该log信息耗费的毫秒数  </span><br><span class="line">%c 输出所属的类目，通常就是所在类的全名  </span><br><span class="line">%t 输出产生该日志事件的线程名  </span><br><span class="line">%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  </span><br><span class="line">%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  </span><br><span class="line">%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)</span><br></pre></td></tr></table></figure><h3 id="2-在代码中使用-Log4j"><a href="#2-在代码中使用-Log4j" class="headerlink" title="2.在代码中使用 Log4j"></a>2.在代码中使用 Log4j</h3><h4 id="1-获取日志记录器"><a href="#1-获取日志记录器" class="headerlink" title="1. 获取日志记录器"></a>1. 获取日志记录器</h4><p>使用 Log4j，第一步就是获取日志记录器，这个记录器将负责控制日志信息。其语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getLogger</span><span class="params">( String name)</span></span></span><br></pre></td></tr></table></figure><p>通过指定的名字获得记录器，如果必要的话，则为这个名字创建一个新的记录器。Name一般取本类的名字，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(ServerWithLog4j.class.getName());</span><br></pre></td></tr></table></figure><h4 id="2-读取配置文件"><a href="#2-读取配置文件" class="headerlink" title="2. 读取配置文件"></a>2. 读取配置文件</h4><p>当获得了日志记录器之后，第二步将配置 Log4j 环境，其语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BasicConfigurator.configure()： 自动快速地使用缺省 Log4j 环境。  </span><br><span class="line">PropertyConfigurator.configure(String configFilename)：读取使用 Java 的特性文件编写的配置文件。  </span><br><span class="line">DOMConfigurator.configure(String filename)：读取 XML 形式的配置文件。</span><br></pre></td></tr></table></figure><h4 id="3-插入记录信息（格式化日志信息）"><a href="#3-插入记录信息（格式化日志信息）" class="headerlink" title="3. 插入记录信息（格式化日志信息）"></a>3. 插入记录信息（格式化日志信息）</h4><p>当上两个必要步骤执行完毕，您就可以轻松地使用不同优先级别的日志记录语句插入到您想记录日志的任何地方，其语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Logger.debug(Object message); </span><br><span class="line">Logger.info(Object message); </span><br><span class="line">Logger.warn(Object message); </span><br><span class="line">Logger.error(Object message);</span><br></pre></td></tr></table></figure><h3 id="3-日志级别"><a href="#3-日志级别" class="headerlink" title="3. 日志级别"></a>3. 日志级别</h3><p>每个 Logger 都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：<br>A：off 最高等级，用于关闭所有日志记录。<br>B：fatal 指出每个严重的错误事件将会导致应用程序的退出。<br>C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。<br>D：warm 表明会出现潜在的错误情形。<br>E：info 一般和在粗粒度级别上，强调应用程序的运行全程。<br>F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。<br>G：all 最低等级，用于打开所有日志记录。</p><p>上面这些级别定义在 org.apache.log4j.Level 类中。Log4j 只建议使用4个级别，优先级从高到低分别是 error，warn，info 和 debug。通过使用日志级别，可以控制应用程序中相应级别日志信息的输出。例如，如果使用了 info 级别，则应用程序中所有低于 info 级别的日志信息(如debug)将不会被打印出来。</p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 相关</title>
      <link href="/2020/01/01/Maven-%E7%9B%B8%E5%85%B3/"/>
      <url>/2020/01/01/Maven-%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>该网站可以搜索获取pom.xml中的依赖坐标配置 <a href="https://mvnrepository.com/artifact/junit/junit/4.12" target="_blank" rel="noopener">点击进入</a></p>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA中Git的使用</title>
      <link href="/2020/01/01/IDEA%E4%B8%ADGit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/01/IDEA%E4%B8%ADGit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>本篇文章讲述在IDEA开发工具中git的详细使用过程,提高开发效率</p></blockquote><h1 id="IDEA配置git"><a href="#IDEA配置git" class="headerlink" title="IDEA配置git"></a>IDEA配置git</h1><p>1.电脑必须已经装好了git 的客户端git客户端 .下载地址<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git</a><br>2.打开IDEA设置界面找到git选好git安装的路径点击Test测试如果出这个提示就是成功了<br><img src="/2020/01/01/IDEA中Git的使用/2019052716533081.png" alt="配置git"></p><a id="more"></a><h1 id="使用详情"><a href="#使用详情" class="headerlink" title="使用详情"></a>使用详情</h1><h3 id="把项目上传到本地库和远程库"><a href="#把项目上传到本地库和远程库" class="headerlink" title="把项目上传到本地库和远程库"></a>把项目上传到本地库和远程库</h3><p>1.为新建的项目添加本地git库<br><img src="/2020/01/01/IDEA中Git的使用/20190527165451402.png" alt><br>2.选择项目根目录点击确定<br><img src="/2020/01/01/IDEA中Git的使用/20190527165512525.png" alt><br> 3.可以看到现在文件都是红色的说明还没被跟踪<br> <img src="/2020/01/01/IDEA中Git的使用/20190527165533106.png" alt><br> 4.把所有文件跟踪添加到stage区文件都变成了绿色<br> <img src="/2020/01/01/IDEA中Git的使用/20190527165552262.png" alt><br>  5.提交到本地库远程库<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527165611902.png" alt><br>  6.可以在commitmessage里面写本次提交的详情然后Commit and Push<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527165643589.png" alt><br>  <img src="/2020/01/01/IDEA中Git的使用/20190527165737419.png" alt><br>  7.第一次提交到远程库需要配置一下远程库的地址输入账号密码点Push提交<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527165805925.png" alt><br>  <img src="/2020/01/01/IDEA中Git的使用/20190527165818549.png" alt><br>  Git图解：<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527165847831.png" alt></p><h3 id="从远程Git仓库获取项目源码"><a href="#从远程Git仓库获取项目源码" class="headerlink" title="从远程Git仓库获取项目源码"></a>从远程Git仓库获取项目源码</h3><p>  1.如果有人要下载项目源码需要先配置好git点击Configure&gt;settings剩下的按照IDEA配置git的步骤<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170227344.png" alt><br>  2.下载项目源码,填写地址下载路径,点击clone下载<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170256377.png" alt><br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170321966.png" alt></p><h3 id="获取别人提交的代码提交自己更新的代码"><a href="#获取别人提交的代码提交自己更新的代码" class="headerlink" title="获取别人提交的代码提交自己更新的代码"></a>获取别人提交的代码提交自己更新的代码</h3><p>  1.在每次提交更新的代码前先把别人提交的代码下载下来<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170413582.png" alt><br>  2.提交更新的代码<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170456407.png" alt><br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170506816.png" alt></p><h3 id="创建分支并在分支上开发"><a href="#创建分支并在分支上开发" class="headerlink" title="创建分支并在分支上开发"></a>创建分支并在分支上开发</h3><p>  建分支也是一个常用的操作，例如临时修改bug、开发不确定是否加入的功能等，都可以创建一个分支，再等待合适的时机合并到主干<br>  1.创建一个分支<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170550663.png" alt><br>  2.可以看到右下角已经切换到了新创建的分支上面LocalBranches是本地分支RemotBranches是远程分支<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170611462.png" alt><br>   3.把新的分支提交到远程库<br>   <img src="/2020/01/01/IDEA中Git的使用/20190527170632979.png" alt><br>   <img src="/2020/01/01/IDEA中Git的使用/20190527170656173.png" alt></p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>  1.如果分支上的代码已经没有问题需要合并到主分支先切换到主分支<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170730715.png" alt><br>  2.把分支合并到主分支点击merge合并<br>  <img src="/2020/01/01/IDEA中Git的使用/20190527170753490.png" alt><br>  <img src="/2020/01/01/IDEA中Git的使用/2019052717080551.png" alt><br>  <a href="https://cloud.tencent.com/developer/article/1333958" target="_blank" rel="noopener">文章来源</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(四) SpringBoot-web</title>
      <link href="/2019/12/29/%E5%9B%9B-SpringBoot-web/"/>
      <url>/2019/12/29/%E5%9B%9B-SpringBoot-web/</url>
      
        <content type="html"><![CDATA[<h2 id="1-静态资源"><a href="#1-静态资源" class="headerlink" title="1. 静态资源"></a>1. 静态资源</h2><p>默认情况下，SpringBoot 支持映射获取当前项目下的任何静态资源，其中静态资源需要放在特定的静态资源文件夹下，如所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;classpath:/META-INF/resources/&quot;, </span><br><span class="line">&quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, </span><br><span class="line">&quot;classpath:/public/&quot;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/2019/12/29/四-SpringBoot-web/1575202320474.png" alt="静态资源文件夹"></p><p>这些静态资源文件夹的定义在 <code>org.springframework.boot.autoconfigure.web.ResourceProperties</code> 中便有体现，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="string">"spring.resources"</span>,</span><br><span class="line">    ignoreUnknownFields = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> String[]&#123;<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/resources/"</span>, <span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> String[] staticLocations;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要访问 jar 中的静态资源（webjars 中的资源），那么我们需要去对应 jar 中的 <code>classpath:/META-INF/resources/webjars/</code> 路径下找资源。我们以访问 <code>jquery/3.3.1/jquery.js</code> 为例。</p><p>首先我们需要导入 JQuery 的依赖，具体如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jquery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2019/12/29/四-SpringBoot-web/1575204002346.png" alt="具体目录结构"></p><p>在访问 jar 包中的资源的时候我们只需要写 webjars 下面资源的名称即可，例如访问路径为 <code>localhost:8080/webjars/jquery/3.3.1/jquery.js</code> ，浏览器上便可以显示 jquery.js 的数据。</p><h2 id="2-欢迎页面"><a href="#2-欢迎页面" class="headerlink" title="2. 欢迎页面"></a>2. 欢迎页面</h2><p>SpringBoot 支持自动识别<code>静态资源文件夹</code>下的<code>欢迎页面 index.html</code>。当我们请求路径为 <code>localhost:8080/</code>的时候，在存在 index.html 的情况下会显示该页面。</p><h2 id="3-网站图标"><a href="#3-网站图标" class="headerlink" title="3. 网站图标"></a>3. 网站图标</h2><p>与其他静态资源一样，Spring Boot 在已配置的静态文件夹中查找 favicon.ico。如果存在这样的文件，它将自动用作应用程序的图标。</p><h2 id="4-模板引擎"><a href="#4-模板引擎" class="headerlink" title="4. 模板引擎"></a>4. 模板引擎</h2><p>Thymeleaf 是一款用于渲染 XML/XHTML/HTML5 内容的模板引擎。类似 JSP，Velocity，FreeMaker 等，它也可以轻易的与 Spring MVC 等Web 框架进行集成作为 Web 应用的模板引擎。与其它模板引擎相比，Thymeleaf 最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个 Web 应用（按 ctrl + F9 重新编译页面）。</p><p>Spring Boot 推荐使用 <a href="https://www.thymeleaf.org/" target="_blank" rel="noopener">Thymeleaf</a>、<a href="https://freemarker.apache.org/docs/" target="_blank" rel="noopener">Freemarker</a> 等后现代的模板引擎技术；一但导入相关依赖，会自动配置ThymeleafAutoConfiguration、FreeMarkerAutoConfiguration 等自动配置类。</p><p>下图描述了模板引擎的工作原理，模板引擎通过将静态页面和 Model 中的数据结合渲染输出我们需要的页面。如下图所示：</p><p> <img src="/2019/12/29/四-SpringBoot-web/1575257109887.png" alt="模板引擎工作原理"></p><p>下面我们介绍一个 SpringBoot 中如何使用 Thymeleaf 吧。</p><h3 id="4-1-引入-Thymeleaf"><a href="#4-1-引入-Thymeleaf" class="headerlink" title="4.1 引入 Thymeleaf"></a>4.1 引入 Thymeleaf</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--导入模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-2-使用-Thymeleaf"><a href="#4-2-使用-Thymeleaf" class="headerlink" title="4.2 使用 Thymeleaf"></a>4.2 使用 Thymeleaf</h3><p>我们查看自动配置包中关于模板引擎 Thymeleaf 的自动配置绑定文件类，以下是相关的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="string">"spring.thymeleaf"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_ENCODING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_SUFFIX = <span class="string">".html"</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们也可以知道 Thymeleaf 模板是存放在 templates 文件夹中的 html 文件，这样 Thymeleaf 就能自动渲染页面。</p><p>下面我们来简单的演示一下 Thymeleaf 的使用，首先我们编写如下控制器类 IndexController，具体内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"hello"</span>, <span class="string">"Hello Thymeleaf!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在编写模板文件 home.html，具体内容如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Test Thymeleaf<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>成功！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--th:text 将span里面的文本内容设置为$&#123;hello&#125;的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;hello&#125;"</span>&gt;</span>这段文本将会被替代掉<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，我们需要导入 Thymeleaf 的名称空间，即<code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code>。关于该模板引擎的具体使用如语法规则之类的我们可以查看其<a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="5-定制web扩展配置"><a href="#5-定制web扩展配置" class="headerlink" title="5. 定制web扩展配置"></a>5. 定制web扩展配置</h2><h3 id="5-1-定制-SpringMVC-配置"><a href="#5-1-定制-SpringMVC-配置" class="headerlink" title="5.1 定制 SpringMVC 配置"></a>5.1 定制 SpringMVC 配置</h3><p>SpringBoot 自动配置好了 SpringMVC。以下是 SpringBoot 对 SpringMVC 的一些默认配置，除此之外，我们还介绍了如何自定义 SpringMVC 的一些配置。关于 SpringBoot 对 SpringMVC 自动配置的详细信息，我们可以在自动配置包中的 WebMvcAutoConfiguration 类中找到其中的源码定义。</p><h4 id="5-1-1-定制视图解析器"><a href="#5-1-1-定制视图解析器" class="headerlink" title="5.1.1 定制视图解析器"></a>5.1.1 定制视图解析器</h4><p>SpringBoot 自动配置了多种视图解析器，包括组合所有的视图解析器的 <code>ContentNegotiatingViewResolver</code>以及解析各种 Bean 的<code>BeanNameViewResolver</code> 。</p><p>我们可以自己给容器中添加一个视图解析器，SpringBoot 会自动的将其组合进来。<span id="inline-green">自定义视图解析器</span>的方法很简单。首先我们需要编写自己的视图解析器类，该类需要实现 <code>ViewResolver</code> 接口，然后重写 resolveViewName 方法。具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义视图解析器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/4 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewResolver</span> <span class="keyword">implements</span> <span class="title">ViewResolver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">resolveViewName</span><span class="params">(String s, Locale locale)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在配置类中编写一个方法，并将该方法返回的自定义视图解析器对象 MyViewResolver 加入到 IoC 容器中即可。至此，自定义视图解析的添加边完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 郑松涛</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/12/4 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">myViewReolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyViewResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 DispatchServlet 类的 都 doDispatch 方法上打上断点进行测试，其中我们自定义的视图解析器是有起作用的，如下图所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1575443211470.png" alt="自定义视图解析器"></p><h4 id="5-1-2-定制转换器和格式化器"><a href="#5-1-2-定制转换器和格式化器" class="headerlink" title="5.1.2 定制转换器和格式化器"></a>5.1.2 定制转换器和格式化器</h4><p>SpringBoot 自动注册了 <code>Converter</code>，<code>GenericConverter</code>，<code>Formatter</code>等组件，其中 <code>Converter</code>即为转换器，比如请求时可以将表单内容自动封装转换为一个类；<code>Formatter</code>即为格式化器，如对时间的进行格式化等。与自定义视图解析器一样，我们也可以通过同样的方式来自定义转换器和格式化器等。</p><p>另外，SpringBoot 还支持 <code>HttpMessageConverters</code>，其是 SpringMVC 用来转换 Http 请求和响应的，比如将 User 转换为 Json 格式。假如我们需要自己给容器中添加 <code>HttpMessageConverter</code>，只需要类似前面自定义视图解析器一样的方法将自己的组件注册容器中即可。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建并自定义自己的HttpMessageConverters</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：前面 5.1.1 和 5.1.2 使用的方法都是一样的，都是在配置类中将自定义的类作为组件加入到容器中，这样 SpringBoot 在自动配置很多组件的时候，会先看容器中有没有用户自己配置的（@Bean、@Component）组件。<strong>如果有就用用户配置的，如果没有，才自动配置；</strong>如果有些组件可以有多个（ViewResolver）则会将用户配置的和自己默认的组合起来。</p><h4 id="5-1-3-定制拦截器"><a href="#5-1-3-定制拦截器" class="headerlink" title="5.1.3 定制拦截器"></a>5.1.3 定制拦截器</h4><p>与前面使用普通的配置类配置自定义组件不同的是，下面我们使用 <code>WebMvcConfigurer</code> 类型的配置类来实现添加自定义的拦截器。使用这种方法，可以避免用户自定义组件替代 SpringBoot 自动配置组件的情况。相反的，用户自定义配置的组件会和 SpringBoot 自动配置的组件一起其作用。下面我们就以定义拦截器为例演示一下该功能的使用。</p><p>首先我们自然需要先编写一个自定义的拦截器类，其需要实现 HandlerInteceptor 接口，并实现需要的方法，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(IndexInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"拦截器的 preHandle 方法运行了。。。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们需要编写 <code>WebMvcConfigurer</code> 类型的配置类来注册该拦截器，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册自定义的拦截器，</span></span><br><span class="line"><span class="comment">     * addPathPatterns("/**")表明所有请求都要经过该拦截器</span></span><br><span class="line"><span class="comment">     * .excludePathPatterns("/index.html", "/", "/usr/login"); 用于排除这三个请求路径会经过拦截器的拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor()).addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                        .excludePathPatterns(<span class="string">"/index.html"</span>, <span class="string">"/"</span>, <span class="string">"/usr/login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后，我们可以在控制台上发现<code>拦截器的 preHandle 方法运行了。。。</code>的信息被输出了，说明我们拦截器添加成功了。</p><p><strong>原理</strong>：</p><p>我们查看 MVC 的自动配置类 WebMvcAutoConfiguration ，该类中的静态内部类 EnableWebMvcConfiguration 的父类 DelegatingWebMvcConfiguration 存在如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(</span><br><span class="line">    proxyBeanMethods = <span class="keyword">false</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span>(</span><br><span class="line">        required = <span class="keyword">false</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigurers</span><span class="params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察 setConfigurers 方法，该方法会从容器中获取所有的 WebMvcConfigurer（含有我们自定义的 WebMvcConfig），并添加到 WebMvcConfigurerComposite 中。最后，我们配置类 WebMvcConfig 中拦截器也会一并被调用执行。</p><h3 id="5-2-全面接管-SpringMVC"><a href="#5-2-全面接管-SpringMVC" class="headerlink" title="5.2 全面接管 SpringMVC"></a>5.2 全面接管 SpringMVC</h3><p>假如我们不需要 SpringBoot 对 SpringMVC 的自动配置，也就是所有的 SpringMVC 的配置都要我们自己手动配置，我们只需要在配置类中添加 @EnableWebMvc 即可。</p><p><strong>原理</strong>：</p><p>为什么 @EnableWebMvc 会使 SpringMVC 的自动配置实效，我们来查看一下其源码，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;DelegatingWebMvcConfiguration.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableWebMvc &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 @EnableWebMvc 本身需要导入 DelegatingWebMvcConfiguration 该类，而 DelegatingWebMvcConfiguration 是 WebMvcConfigurationSupport 的子类。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebMvcConfigurerComposite configurers = <span class="keyword">new</span> WebMvcConfigurerComposite();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegatingWebMvcConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，MVC 自动配置类中定义了 <code>@ConditionalOnMissingBean({WebMvcConfigurationSupport.class})</code>。它表明Spring 容器中缺少 WebMvcConfigurationSupport 类时，该自动配置类才会生效。由于前面我们在自定义的配置类中使用了 @EnableWebMvc 注解，该注解会导入 WebMvcConfigurationSupport 该类，所以我们才能全面接管 SpringMVC 的配置。</p><h2 id="6-国际化"><a href="#6-国际化" class="headerlink" title="6. 国际化"></a>6. 国际化</h2><p>步骤：</p><p>1）、编写国际化配置文件，抽取页面需要显示的国际化消息</p><p><img src="/2019/12/29/四-SpringBoot-web/1575859867469.png" alt="国际化配置文件"></p><p>2）、SpringBoot 自动配置好了管理国际化资源文件的组件 ResourceBundleMessageSource，所以这一步我们不需要自己配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.messages"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSourceAutoConfiguration</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String basename = <span class="string">"messages"</span>;  </span><br><span class="line">    <span class="comment">//我们的配置文件可以直接放在类路径下叫messages.properties；</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ResourceBundleMessageSource messageSource = <span class="keyword">new</span> ResourceBundleMessageSource();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.basename)) &#123;</span><br><span class="line">            <span class="comment">//设置国际化资源文件的基础名（去掉语言国家代码的）</span></span><br><span class="line">            messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">                    StringUtils.trimAllWhitespace(<span class="keyword">this</span>.basename)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.encoding != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageSource.setDefaultEncoding(<span class="keyword">this</span>.encoding.name());</span><br><span class="line">        &#125;</span><br><span class="line">        messageSource.setFallbackToSystemLocale(<span class="keyword">this</span>.fallbackToSystemLocale);</span><br><span class="line">        messageSource.setCacheSeconds(<span class="keyword">this</span>.cacheSeconds);</span><br><span class="line">        messageSource.setAlwaysUseMessageFormat(<span class="keyword">this</span>.alwaysUseMessageFormat);</span><br><span class="line">        <span class="keyword">return</span> messageSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>3）、页面获取国际化的值，具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试国际化<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">th:text</span>=<span class="string">"#&#123;login.username&#125;"</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4）、在 SpringBoot 的配置文件中配置国际化的命名空间，具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 配置命名空间，用于指明国际化文件的位置</span><br><span class="line">spring.messages.basename=i18n.login</span><br></pre></td></tr></table></figure><p>最后的效果就是会根据浏览器语言设置的信息切换了国际化。</p><h2 id="7-错误处理机制"><a href="#7-错误处理机制" class="headerlink" title="7. 错误处理机制"></a>7. 错误处理机制</h2><h3 id="7-1-默认错误处理机制"><a href="#7-1-默认错误处理机制" class="headerlink" title="7.1 默认错误处理机制"></a>7.1 默认错误处理机制</h3><p>当我们向 SpringBoot 应用发送一个不存在的请求地址的时候，在浏览器中则会显示服务端响应返回一个默认的错误页面，如下所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1575972078583.png" alt="浏览器错误响应页面"></p><p>不过当我们使用其他客户端向 SpringBoot 应用发送一个不存在的请求地址的时候，比如使用 Postman 发送。此时则会显示服务端发送回来的 Json 数据，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2019-01-21T14:36:48.573+0000"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">404</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Not Found"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"No message available"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/index.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从各自的发送请求中得到这种差异的原因，比如浏览器的请求头表明其想要接收的数据是 <code>text/html</code>的数据，如下：</p><p><img src="/2019/12/29/四-SpringBoot-web/1575972392691.png" alt="浏览器的请求头"></p><p>相反地，我们使用 Postman 发送的请求的请求头则不是要求接收 <code>text/html</code>类型的数据，具体如下所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1575972510875.png" alt="Postman的请求头"></p><p>当然这种差异的具体原因我们可以在源码中找到，我们可以参照 ErrorMvcAutoConfiguration 自动配置类的具体内容，该类主要是用于错误处理的自动配置类。这里不再详述。</p><h3 id="7-2-自定义错误响应"><a href="#7-2-自定义错误响应" class="headerlink" title="7.2 自定义错误响应"></a>7.2 自定义错误响应</h3><h4 id="7-2-1-定制错误页面"><a href="#7-2-1-定制错误页面" class="headerlink" title="7.2.1 定制错误页面"></a>7.2.1 定制错误页面</h4><p><strong>1）、</strong>在有配置模板引擎的情况下，如果发生指定状态类型的错误时，Springboot 会将模板文件夹里面的 error 文件夹下命名为对应状态码的 <code>错误状态码.html</code>的文件作为自定义的错误页面。比如请求时发生404错误，那么就会将对应的名为<code>404.html</code>文件作为自定义错误页面。</p><p>另外，我们也可以使用名为<code>4xx.html</code>或<code>5xx.html</code>作为自定义错误页面来匹配这种类型的所有错误，但是如果发生指定状态类型的错误时，会优先寻找名为对应状态码的自定义错误页面。</p><p><strong>2）</strong>、在没有配置模板引擎或者模板文件夹下没有需要的错误页面的情况下，那么就会在静态资源文件夹下找。</p><p><strong>3）、</strong>以上的情况下都没有找到需要的错误页面是，就会默认来到 SpringBoot 默认的错误提示页面。</p><p>需要说明的是，我们在页面能获取的信息有：</p><ul><li>timestamp：时间戳</li><li>status：状态码</li><li>errors：错误提示</li><li>exception：异常对象</li><li>message：异常消息</li><li>errors：JSR303数据校验的错误都在这里</li></ul><p>假如我在 Controller 的 index 方法中故意导致服务器除零异常，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index.html"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟除〇异常</span></span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板引擎 Thymeleaf 的页面编写示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>错误响应页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>错误消息：<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;timestamp&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;status&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;error&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;exception&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;message&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;errors&#125;"</span>&gt;</span>JSR303数据校验错误<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行测试之后，浏览器页面上的异常信息显示具体如下图所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1579587179589.png" alt="1579587179589"></p><h4 id="7-2-2-自定义错误响应数据"><a href="#7-2-2-自定义错误响应数据" class="headerlink" title="7.2.2 自定义错误响应数据"></a>7.2.2 自定义错误响应数据</h4><p>当出现错误的时候，框架底层会进行 /error 请求，然后被 BasicErrorController 处理，其中异常响应出去的数据是由 getErrorAttributes 得到的。该方法是 AbstractErrorController 或 ErrorController 规定的方法：</p><ol><li><p>完全自己编写一个 ErrorController 的实现类（或编写 AbstractErrorController 的子类），并加入到 IoC 容器中；</p></li><li><p>页面上显示的异常响应数据，或者是 Json 返回的异常响应数据都是通过 ErrorAttributes.getErrorAttributes 方法得到的。</p></li></ol><p>下面，我们自定义 ErrorAttributes 类，具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorAttributes</span> <span class="keyword">extends</span> <span class="title">DefaultErrorAttributes</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getErrorAttributes</span><span class="params">(RequestAttributes requestAttributes, <span class="keyword">boolean</span> includeStackTrace)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">super</span>.getErrorAttributes(requestAttributes, includeStackTrace);</span><br><span class="line">        map.put(<span class="string">"shoto"</span>, <span class="string">"郑松涛自定义异常信息！"</span>);</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，当 Controller 的 index 方法发生除零异常的时候，页面会显示自定义异常响应信息，如下图所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1579592581505.png" alt="1579592581505"></p><h2 id="8-配置嵌入式Servlet容器"><a href="#8-配置嵌入式Servlet容器" class="headerlink" title="8. 配置嵌入式Servlet容器"></a>8. 配置嵌入式Servlet容器</h2><p>SpringBoot 默认使用 Tomcat 作为嵌入式的 Servlet 容，如下图所示。开发时，我们可以根据自身需要更改 Tomcat 的 Servlet 容器配置。</p><p><img src="/2019/12/29/四-SpringBoot-web/1579593804258.png" alt="1579593804258"></p><h3 id="8-1-定制或配置-Servlet-容器"><a href="#8-1-定制或配置-Servlet-容器" class="headerlink" title="8.1 定制或配置 Servlet 容器"></a>8.1 定制或配置 Servlet 容器</h3><ol><li><p>修改和 server 有关的配置，其中 application.propertise 中可以配置的内容我们可以从 ServerProperties 类中找到。具体配置的实现可以从 EmbeddedServletContainerCustomizer 接口的之类找到。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 通用的Servlet容器设置</span><br><span class="line"># server.xxx</span><br><span class="line"># Tomcat的设置</span><br><span class="line"># server.tomcat.xxx</span><br><span class="line">server.port=8080</span><br><span class="line">server.tomcat.uri-encoding=UTF-8</span><br></pre></td></tr></table></figure></li><li><p>编写一个 <strong>EmbeddedServletContainerCustomizer</strong>，即 SpringBoot 提供的一个嵌入式的 Servlet 容器定制器，同样也是用来修改 Servlet 容器的配置。具体代码如下所示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">embeddedServletContainerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 定制嵌入式的Servlet容器相关的规则，比如设置端口号</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> container</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 设置访问端口</span></span><br><span class="line">                container.setPort(<span class="number">8081</span>);</span><br><span class="line">                <span class="comment">// 设置访问路径</span></span><br><span class="line">                container.setContextPath(<span class="string">"/shoto"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试结果如下所示</p><p> <img src="/2019/12/29/四-SpringBoot-web/1579594639211.png" alt="1579594639211"></p></li></ol><h3 id="8-2-注册-Servlet、Filter、Listener"><a href="#8-2-注册-Servlet、Filter、Listener" class="headerlink" title="8.2 注册 Servlet、Filter、Listener"></a>8.2 注册 Servlet、Filter、Listener</h3><p>由于 SpringBoot 默认是以 jar 包的方式启动嵌入式的 Servlet 容器来启动 SpringBoot 的 web 应用，因此没有 web.xml 文件，我们便也就数不能在 web.xml 文件中注册 Servlet、Filter 和 Listener。下面讲一下 SpringBoot 是如何进行这三大组件的注册的。</p><h4 id="8-2-1-注册Servlet"><a href="#8-2-1-注册Servlet" class="headerlink" title="8.2.1 注册Servlet"></a>8.2.1 注册Servlet</h4><ol><li>首先编写一个自定义的 Servlet，部分代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyServlet.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"MyServlet 初始化啦...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后在配置类中编写如下代码，这里使用到了FilterRegistrationBean 类，具体代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">myServlet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletRegistrationBean registrationBean = <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MyServlet(),<span class="string">"/myServlet"</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>接着在浏览器中访问<code>http:/localhost:8080/MyServlet</code>，此时 MyServlet 会开始进行初始化，也就是 MyServlet 中的 init 方法会开始执行。</li></ol><h4 id="8-2-2-注册-Filter"><a href="#8-2-2-注册-Filter" class="headerlink" title="8.2.2 注册 Filter"></a>8.2.2 注册 Filter</h4><ol><li><p>首先编写一个 Filter。</p></li><li><p>然后在配置类中编写如下代码，这里使用到了FilterRegistrationBean 类，具体代码如下所示：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    registrationBean.setUrlPatterns(Arrays.asList(<span class="string">"/hello"</span>,<span class="string">"/myServlet"</span>));</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-4-注册-Listener"><a href="#8-2-4-注册-Listener" class="headerlink" title="8.2.4 注册 Listener"></a>8.2.4 注册 Listener</h4><p>使用 ServletListenerRegistrationBean 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletListenerRegistrationBean <span class="title">myListener</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = <span class="keyword">new</span> ServletListenerRegistrationBean&lt;&gt;(<span class="keyword">new</span> MyListener());</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBoot 帮我们自动装载 SpringMVC 的时候，自动的注册 SpringMVC 的前端控制器，即 DIspatcherServlet。</p><p>DispatcherServletAutoConfiguration中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)</span><br><span class="line"><span class="meta">@ConditionalOnBean</span>(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">dispatcherServletRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      DispatcherServlet dispatcherServlet)</span> </span>&#123;</span><br><span class="line">   ServletRegistrationBean registration = <span class="keyword">new</span> ServletRegistrationBean(</span><br><span class="line">         dispatcherServlet, <span class="keyword">this</span>.serverProperties.getServletMapping());</span><br><span class="line">    <span class="comment">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span></span><br><span class="line">    <span class="comment">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span></span><br><span class="line">    </span><br><span class="line">   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);</span><br><span class="line">   registration.setLoadOnStartup(</span><br><span class="line">         <span class="keyword">this</span>.webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.multipartConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">      registration.setMultipartConfig(<span class="keyword">this</span>.multipartConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-使用外置的Servlet容器"><a href="#9-使用外置的Servlet容器" class="headerlink" title="9. 使用外置的Servlet容器"></a>9. 使用外置的Servlet容器</h2><p>SpringBoot 默认支持的是嵌入式 Servlet 容器，因此应用打成可执行的 Jar。这样的优点是简单和便携。但是缺点就是默认不支持 JSP，而且优化定制也比较复杂。</p><p>下面我们来为 SpringBoot 配置外置的 Servlet 容器，以使 SpringBoot 能够兼容 JSP 且支持 SpringBoot 应用以 war 包的方式进行打包。</p><p>1.首先是先创建一个war项目，并创建好目录结构，需要注意的关键步骤如下所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1582708126544.png" alt="1582708126544"></p><p><img src="/2019/12/29/四-SpringBoot-web/1582708935401.png" alt="1582708935401"></p><p><img src="/2019/12/29/四-SpringBoot-web/1582709251343.png" alt="1582709251343"></p><p>2.IDEA 中配置 Tomcat 启动容器，配置后的结果如下所示：</p><p><img src="/2019/12/29/四-SpringBoot-web/1582709605061.png" alt="1582709605061"></p><p>3.接着需要确保 POM.xml 文件中进行了如下依赖的配置，具体如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.然后需要注意的是 SpringBootApplication 主程序所在的包下是否生成 ServletInitializer 类，该类是一个核心类，具体内容如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//传入SpringBoot应用的主程序</span></span><br><span class="line">        <span class="keyword">return</span> application.sources(Springboot04WebJspApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.最后我们可以在 webapp 目录下编写如下两个 jsp 文件，分别是 hello.jsp 和 success.jsp，具体内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello JSP&lt;/h1&gt;</span><br><span class="line">    &lt;a href="abc"&gt;点击&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;SUCCESS&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>6.然后编写一个 HelloController 类，具体内容如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloContoller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/abc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 跳转到 success.jsp 页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.最后一步是在 application.properties 配置文件中进行配置，即配置 jsp 文件的前缀和后缀，具体如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.prefix=/WEB-INF/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure><p>如此 SpringBoot 便可以兼容 JSP 页面了，SpringBoot 使用外置的 Servlet 容器便完成了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(三) SpringBoot-日志</title>
      <link href="/2019/11/30/%E4%B8%89-SpringBoot-%E6%97%A5%E5%BF%97/"/>
      <url>/2019/11/30/%E4%B8%89-SpringBoot-%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1. 日志框架"></a>1. 日志框架</h2><p>目前市场上存在非常多的日志框架，比如 JUL（java.util.logging），JCL（Apache Commons Logging），Log4j，Log4j2，Logback、SLF4j、jboss-logging 等。</p><a id="more"></a><p>由于日志框架繁多复杂，所以除了日志的具体实现框架之外，另外还定义了相关的门面框架，也就是具体实现框架的抽象框架。门面框架定义了一套统一的接口，用户可以更为方便的去使用不同的实现框架。下面是其对应的关系：</p><table><thead><tr><th align="left">日志门面框架</th><th>日志实现框架</th></tr></thead><tbody><tr><td align="left"><del>JCL（Jakarta  Commons Logging）</del> <strong>SLF4j</strong>（Simple  Logging Facade for Java）    <del>jboss-logging</del></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>对于日志门面框架，我们推荐使用 SLF4J，而日志实现框架则推荐使用 Logback，它是 Log4j 的新版本。另外 SpringBoot 底层选用的也是 SLF4j 和 Logback 这两个框架。</p><h2 id="2-SLF4j-使用"><a href="#2-SLF4j-使用" class="headerlink" title="2. SLF4j 使用"></a>2. SLF4j 使用</h2><p>对于 SLF4j 的使用，我们可以参考其<a href="http://www.slf4j.org" target="_blank" rel="noopener">官方文档</a>，下面我们就结合着官方文档来介绍一下 SLF4j 的使用吧。</p><p>在开发的时候，日志记录方法的调用，不应该来直接调用日志的具体实现类的方法，而是调用日志抽象层类里面的方法。比如下面的示例，我们在导入 SLF4j 和 Logback 的 jar 之后，我们应该直接调用日志抽象层类（即 SLF4j）的方法来使用日志框架。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是官网给出了一个图例，该图介绍了 SLF4j 与具体的日志实现框架，比如 Logback、Log4j 或者  JUL 之间进行绑定时底层具体的 jar 之间的具体关系。比如 SLF4j 与 Logback 之间进行绑定时，需要 slf4j-api.jar 和 logback-classic.jar 及 logback-core.jar。</p><p><img src="/2019/11/30/三-SpringBoot-日志/1575094159655.png" alt="jar依赖关系图"></p><p>当 SLF4j 与 Log4j 进行绑定时，因为 log4j.jar 的出现比 slf4j.jar 的出现要早的多。为了使两者能够相互适配，需在中间多加一个适配层的 slf4j-log412.jar。</p><p>需要说明的一点是，每一个日志的实现框架都有自己的配置文件。使用 slf4j 以后，<strong>配置文件还是做成其日志实现框架自己本身的配置文件。</strong></p><p>在实际的开发中，我们有时候会遇到日志框架冲突的情况。比如现在我们有一个 SpringBoot 应用，并且该应用整合了其他含有 commons-logging 日志框架的框架。由于 SpringBoot 自身使用的日志实现框架是 Logback，其会与 commons-logging 日志框架发生冲突。那么如何统一日志框架，避免出现日志框架冲突的情况呢？我们先来查看 slf4j 给出的图例：</p><p><img src="/2019/11/30/三-SpringBoot-日志/legacy.png" alt="统一日志框架"></p><p>查看上图左上角的示例，当使用 SLF4j 与 Logback 进行绑定时，此时当前应用可能存在其他日志实现框架 commons-logging，为了避免 commons-logging 与  Logback 冲突，可以使用 jcl-over-slf4j.jar 将 commons-logging <code>替代</code>掉，其作用相当于替换了 commons-logging 这个日志框架。</p><p>最后，我们还需要在配置文件中使用 &lt;exclusions&gt; 将 commons-logging 排除掉，这样才能真正的避免日志框架冲突问题。</p><h2 id="3-SpringBoot-日志关系"><a href="#3-SpringBoot-日志关系" class="headerlink" title="3. SpringBoot 日志关系"></a>3. SpringBoot 日志关系</h2><p>查看 SpringBoot 的 pom 配置文件，我们可以发现 SpringBoot 是使用如下依赖来做日志功能的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以在 pom 文件右键点击 Show Dependencies，如下图所示：</p><p><img src="/2019/11/30/三-SpringBoot-日志/1575096869337.png" alt></p><p>点击后，我们可以以下图的形式查看 SpringBoot 中各个依赖之间的关系。观察下图，我们可以发现 logback 和 slf4j 作为其日志框架，并且使用了如 log4j-to-slf4j 等中间 jar 排除了 log4j 等日志框架，避免日志框架冲突的情况。</p><p><img src="/2019/11/30/三-SpringBoot-日志/1575096731820.png" alt="SpringBoot日志依赖图"></p><p>当我们要整合其他框架且出现日志冲突时，我们在引入该框架的依赖时可以使用 exclusions 标签来排除该框架所引用的日志框架。比如早期的 Spring 使用的是 commons-logging 日志框架，所以 SpringBoot 1.x 在整合早期的 Spring 时不得不排除掉 commons-logging，代码示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可。</p><h2 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4. 日志使用"></a>4. 日志使用</h2><h3 id="4-1-默认配置"><a href="#4-1-默认配置" class="headerlink" title="4.1 默认配置"></a>4.1 默认配置</h3><p>SpringBoot 本身默认帮我们配置好了日志，我们可以使用单元测试进行校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot03LoggingApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slf4j 日志记录器</span></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不同的日志级别输出</span></span><br><span class="line">        logger.trace(<span class="string">"这是 trace 日志"</span>);</span><br><span class="line">        logger.debug(<span class="string">"这是 debug 日志"</span>);</span><br><span class="line">        logger.info(<span class="string">"这是 info 日志"</span>);</span><br><span class="line">        logger.warn(<span class="string">"这是 warn 日志"</span>);</span><br><span class="line">        logger.error(<span class="string">"这是 error 日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，日志级别由低到高分别为 trace &lt; debug &lt; info &lt; warn &lt; error。其中 SpringBoot 的默认日志输出级别是 info，所以上述的代码的单元测试仅输出 info 级别及以上的信息。具体输出结果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019-11-30 16:29:22.584  INFO 8928 --- [           main] c.s.Springboot03LoggingApplicationTests  : 这是 info 日志</span><br><span class="line">2019-11-30 16:29:22.584  WARN 8928 --- [           main] c.s.Springboot03LoggingApplicationTests  : 这是 warn 日志</span><br><span class="line">2019-11-30 16:29:22.584 ERROR 8928 --- [           main] c.s.Springboot03LoggingApplicationTests  : 这是 error 日志</span><br></pre></td></tr></table></figure><h4 id="4-1-1-日志级别"><a href="#4-1-1-日志级别" class="headerlink" title="4.1.1 日志级别"></a>4.1.1 日志级别</h4><p>由于 SpringBoot 的默认日志输出级别是 info，我们也可以修改器默认配置。我们可以在 application.properties 中进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.shoto=trace</span><br></pre></td></tr></table></figure><p>其中 com.shoto 为当前的项目 main/java 下的包名，也就是说以上方法仅适用于程序包级别的日志记录。</p><h4 id="4-1-2-日志文件输出"><a href="#4-1-2-日志文件输出" class="headerlink" title="4.1.2 日志文件输出"></a>4.1.2 日志文件输出</h4><p>默认情况下，Spring Boot 仅将记录输出到控制台，不写到日志文件中。如果除了控制台输出外还想写日志文件，则需要设置一个<code>logging.file.name</code>或<code>logging.file.path</code>属性（例如，在中<code>application.properties</code>）。</p><p>下表描述了<code>logging.file.name</code>或<code>logging.file.path</code> 两者之间的区别，具体如下：</p><table><thead><tr><th align="left"><code>logging.file.name</code></th><th align="left"><code>logging.file.path</code></th><th align="left">例子</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>（未指定）</em></td><td align="left"><em>（未指定）</em></td><td align="left"></td><td align="left">仅控制台记录输出。</td></tr><tr><td align="left">特定日志文件</td><td align="left"><em>（未指定）</em></td><td align="left"><code>my.log</code></td><td align="left">写入指定的日志文件。名称可以是确切位置，也可以是相对于当前目录的位置。</td></tr><tr><td align="left"><em>（未指定）</em></td><td align="left">具体目录</td><td align="left"><code>/var/log</code></td><td align="left">写入<code>spring.log</code>指定的目录。名称可以是确切位置，也可以是相对于当前目录的位置。</td></tr></tbody></table><p>配置文件示例如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 将日志记录到当前项目路径下的my.log中</span><br><span class="line"># logging.file.name=my.log</span><br><span class="line"># 将日志记录到指定路径下的my.log中</span><br><span class="line"># logging.file.name=E:/my.log</span><br><span class="line"></span><br><span class="line"># 将日志记录到指定路径下的默认生成文件 spring.log中</span><br><span class="line">logging.file.path=e:/log</span><br></pre></td></tr></table></figure><h4 id="4-1-3-输出格式"><a href="#4-1-3-输出格式" class="headerlink" title="4.1.3 输出格式"></a>4.1.3 输出格式</h4><p> SpringBoot 的默认日志输出格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>具体参数说明如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d表示日期时间，</span><br><span class="line">%thread表示线程名，</span><br><span class="line">%-5level：级别从左显示5个字符宽度</span><br><span class="line">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><br><span class="line">%msg：日志消息，</span><br><span class="line">%n是换行符</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-11-30 16:29:22.584  INFO 8928 --- [           main] c.s.Springboot03LoggingApplicationTests  : 这是 info 日志</span><br></pre></td></tr></table></figure><p>当然，我们也可以修改日志输出格式，比如在 application.properties 中进行如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"># 指定文件中日志输出的格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span><br></pre></td></tr></table></figure><h3 id="4-2-自定义配置"><a href="#4-2-自定义配置" class="headerlink" title="4.2 自定义配置"></a>4.2 自定义配置</h3><p>我们可以还通过在类路径的根目录下添加适当的配置文件来进一步自定义各种日志记录，这样 SpringBoot 就不需要使用其本身的默认配置了。根据不同的日志记录系统，将加载以下名称的文件：</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>比如对于 Logback 日志框架，我们在类路径直接编写 logback.xml 文件就可以被日志框架自动识别出来了；而对于 logback-spring.xml 这些带 -spring 的日志配置文件（推荐使用），则不直接由日志框架去加载日志的配置内容，而是由 SpringBoot 去解析日志配置。</p><p>带 -spring 的日志配置文件可以使用 SpringBoot 的高级Profile功能（根据不同环境（如开发环境或生产环境）使用不同的日志配置），因此只能由 SpringBoot 去解析日志配置。</p><h4 id="4-2-1-示例1"><a href="#4-2-1-示例1" class="headerlink" title="4.2.1 示例1"></a>4.2.1 示例1</h4><p>我们在类路径 resource 下添加 logback.xml 日志配置文件，具体配置如下所示。可以自行运行测试一下控制台和日志文件的输出。日志框架会自动识别该文件的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</span></span><br><span class="line"><span class="comment">scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。</span></span><br><span class="line"><span class="comment">debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"false"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志的根目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"LOG_HOME"</span> <span class="attr">value</span>=<span class="string">"d:/app/log"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志文件名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"appName"</span> <span class="attr">value</span>=<span class="string">"shoto-springboot"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">%d表示日期时间，</span></span><br><span class="line"><span class="comment">%thread表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">%msg：日志消息，</span></span><br><span class="line"><span class="comment">%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] $$$ %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"appLogAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定日志文件的名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名</span></span><br><span class="line"><span class="comment">        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 </span></span><br><span class="line"><span class="comment">            %i：当文件大小超过maxFileSize时，按照i进行文件滚动</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动，</span></span><br><span class="line"><span class="comment">            且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是，</span></span><br><span class="line"><span class="comment">            那些为了归档而创建的目录也会被删除。</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>365<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">            当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志文件输出格式： --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">logger主要用于存放日志对象，也可以定义日志类型、级别</span></span><br><span class="line"><span class="comment">name：表示匹配的logger类型前缀，也就是包的前半部分</span></span><br><span class="line"><span class="comment">level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</span></span><br><span class="line"><span class="comment">additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，</span></span><br><span class="line"><span class="comment">false：表示只用当前logger的appender-ref，true：</span></span><br><span class="line"><span class="comment">表示当前logger的appender-ref和rootLogger的appender-ref都有效</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hibernate logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.shoto"</span> <span class="attr">level</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring framework logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.springframework"</span> <span class="attr">level</span>=<span class="string">"debug"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，</span></span><br><span class="line"><span class="comment">    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"appLogAppender"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-示例2"><a href="#4-2-2-示例2" class="headerlink" title="4.2.2 示例2"></a>4.2.2 示例2</h4><p>我们在类路径 resource 下修改 logback.xml 为 logback-spring.xml 日志配置文件。与 logback.xml 配置的不同仅仅在于控制台日志输出格式的配置上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt;</span><br><span class="line">&lt;appender name=&quot;stdout&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        日志输出格式：</span><br><span class="line">            %d表示日期时间，</span><br><span class="line">            %thread表示线程名，</span><br><span class="line">            %-5level：级别从左显示5个字符宽度</span><br><span class="line">            %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><br><span class="line">            %msg：日志消息，</span><br><span class="line">            %n是换行符</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">     &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;</span><br><span class="line">     &lt;!--开发环境--&gt;</span><br><span class="line">            &lt;springProfile name=&quot;dev&quot;&gt;</span><br><span class="line">                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;/springProfile&gt;</span><br><span class="line">            &lt;!--非开发环境--&gt;</span><br><span class="line">            &lt;springProfile name=&quot;!dev&quot;&gt;</span><br><span class="line">                &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;</span><br><span class="line">            &lt;/springProfile&gt;</span><br><span class="line">     &lt;/layout&gt;</span><br><span class="line">&lt;/appender&gt;</span><br></pre></td></tr></table></figure><p>然后在 application.properties 中配置如下内容来激活开发环境，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure><p>单元测试在控制台输出日志记录后，其输出格式便是符合这种 <code>%d{yyyy-MM-dd HH:mm:ss.SSS} ----&gt; [%thread] ---&gt; %-5level %logger{50} - %msg%n</code> 格式的。</p><h2 id="5-日志框架切换"><a href="#5-日志框架切换" class="headerlink" title="5. 日志框架切换"></a>5. 日志框架切换</h2><p>为了演示日志框架的切换，我们可以将 SpringBoot 的日志框架 Logback 替换成 Log4j（当然实际情况是不推荐的，因为Log4j 不是个很好的日志框架）。</p><p>我们修改 pom 文件，首先排除掉 Logback 相关的依赖，然后在导入 slf4j 与 log4j 之间适配层的依赖。由于 SpringBoot 本身已有 Log4j 的依赖，所以这里并不要导入该依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--排除掉 Logback 相关的依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该 jar 用于替换 log4j 的，需排除掉--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--导入 slf4j 与 log4j 之间适配层的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以将 SpringBoot 的日志框架 Logback 替换成 Log4j2，以下是 pom 文件中的相关配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为 spring-boot-starter-logging 中的 log4j-to-slf4j 不能与 Log4j2 中的 log4j-slf4j-impl 一起出现，所以这里我们一并将 spring-boot-starter-logging 排除掉了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(二) SpringBoot-配置</title>
      <link href="/2019/11/27/%EF%BC%88%E4%BA%8C%EF%BC%89SpringBoot-%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/11/27/%EF%BC%88%E4%BA%8C%EF%BC%89SpringBoot-%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>关于 SpringBoot 的配置的相关详细信息，可以参考<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h2><p>创建 SpringBoot  项目时会默认创建一个<span id="inline-blue"> 全局配置文件 </span>，配置文件名是固定的，即 application.properties。另外，我们也可以创建另一种格式的全局配置文件，即 application.yml。它与  application.properties 相同，只是书写规范不一样。</p><p>全局配置文件的作用是<code>修改 SpringBoot 自动配置的默认值</code>，SpringBoot 在底层都给我们自动配置好。关于配置文件能配置的属性可参照<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">附录 A</a> 。</p><a id="more"></a><h2 id="2-YAML"><a href="#2-YAML" class="headerlink" title="2. YAML"></a>2. YAML</h2><p>前面我们讲过 SpringBoot 的默认配置文件可以是 application.yml，其中 .yml 是 YAML（YAML Ain’t Markup Language）语言的文件，YAML 以数据为中心，比 json、xml 等更适合做配置文件。我们可以在 <a href="http://www.yaml.org/" target="_blank" rel="noopener">YAML 的官方文档</a>参考其语法规范。当然， SpringBoot 也有关于如何使用 YAML 的<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config-yaml" target="_blank" rel="noopener">使用文档</a>，里面有具体的说明。下面我们来了解一下 YAML 的一些简单语法吧。</p><h3 id="2-1-YAML-语法"><a href="#2-1-YAML-语法" class="headerlink" title="2.1 YAML 语法"></a>2.1 YAML 语法</h3><h4 id="2-1-1-IDEA-环境"><a href="#2-1-1-IDEA-环境" class="headerlink" title="2.1.1 IDEA 环境"></a>2.1.1 IDEA 环境</h4><p>首先为了我们更为方便正确地操作 application.yml 来使用 YAML 语法，我们可以调用 IDEA 的提示功能，首先我们需要在项目的 pom 文件导入下面的依赖，重新运行项目即可生效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-基本语法"><a href="#2-1-2-基本语法" class="headerlink" title="2.1.2 基本语法"></a>2.1.2 基本语法</h4><p>下面是 YAML 的一个实例，其用于更改 SpringBoot 应用的启动端口号：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8090</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>YAML  的基本语法遵循如下几个约定：</p><ul><li>使用缩进表示层级关系；</li><li>缩进时不允许使用 Tab 键，只允许使用空格；</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可；</li><li>大小写敏感；</li><li>key 和 value 之间必须使用空格分隔。</li></ul><h4 id="2-1-3-数据结构"><a href="#2-1-3-数据结构" class="headerlink" title="2.1.3 数据结构"></a>2.1.3 数据结构</h4><p>YAML 支持的三种数据结构，分别为对象、数组和字面量。下面我们分别来了解一下 YAML 如何对这些数据的支持。</p><p><strong>字面量</strong>：即普通的值（数字，字符串，布尔，日期），示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  last-name: 张三</span><br><span class="line">  age: 18</span><br><span class="line">  boss: false</span><br><span class="line">  birth: 2019/11/27</span><br></pre></td></tr></table></figure><p>这里需要注意的是字符串默认不用加上单引号或者双引号的，当加上引号后，它们符合不一样的规则，如下：</p><ul><li>“”：双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思输出，比如：</li></ul><p>​    输入：<code>name: &quot;zhangsan\nlisi&quot;</code>，</p><p>​        输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan</span><br><span class="line">list</span><br></pre></td></tr></table></figure><ul><li>‘’：单引号，会转义特殊字符，特殊字符最终只是一个普通的字符串数据。</li></ul><p>​    输入：<code>name:   ‘zhangsan \n lisi’</code></p><p>​        输出；<code>zhangsan \n  lisi</code></p><p><strong>对象</strong>：即普通的对象，Map</p><p>我们平常写的普通对象和 Map 数据结构，YAML 都是一个 key: value 的形式表示，使用冒号分隔，冒号后需要带上空格。如：username: admin。示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通对象 person</span></span><br><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  last-name:</span> <span class="string">"张三"</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2019</span><span class="string">/11/27</span></span><br><span class="line"><span class="comment"># Map 数据结构</span></span><br><span class="line"><span class="attr">myMap:</span></span><br><span class="line"><span class="attr">  k1:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">  k2:</span> <span class="string">v2</span></span><br></pre></td></tr></table></figure><p>以上的示例是块内写法，其也支持行内写法，示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">object:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2&#125;</span></span><br></pre></td></tr></table></figure><p><strong>数组</strong>：普通数组，List，Set</p><p>块内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">list:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">abc</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">efg</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">jhg</span></span><br></pre></td></tr></table></figure><p>行内写法:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">list:</span> <span class="string">[abc,</span> <span class="string">efg</span> <span class="string">jhg]</span></span><br></pre></td></tr></table></figure><h2 id="3-配置文件值注入"><a href="#3-配置文件值注入" class="headerlink" title="3.  配置文件值注入"></a>3.  配置文件值注入</h2><p>SpringBoot  提供了一个功能，我们可以将全局配置文件与具体的 Bean 进行绑定，并将配置文件中配置的值注入到指定的 Bean 中。下面我们来了解一下这个功能的使用。</p><h3 id="3-1-ConfigurationProperties"><a href="#3-1-ConfigurationProperties" class="headerlink" title="3.1 @ConfigurationProperties"></a>3.1 @ConfigurationProperties</h3><p>比如，我们在 application.yml 进行了如下配置，我们可以视 person 和 dog 为两个普通对象的别名：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  last-name:</span> <span class="string">张三</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2019</span><span class="string">/11/27</span></span><br><span class="line"><span class="attr">  list:</span> <span class="string">[a,b,c,d]</span></span><br><span class="line"><span class="attr">  map:</span> <span class="string">&#123;k1:</span> <span class="string">v1,</span> <span class="attr">k2:</span> <span class="string">v2&#125;</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">旺财</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>当然，除了 application.yml 之外，我们也可以在 application.properties 进行如下配置，其和 application.yml 中的配置作用一样的，只是不是 YAML 格式的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 配置 Person 类</span><br><span class="line">person.last-name=张三</span><br><span class="line">person.age=18</span><br><span class="line">person.boss=false</span><br><span class="line">person.birth=2019/11/27</span><br><span class="line">person.list=a,b,c,d</span><br><span class="line">person.map.k1=v1</span><br><span class="line">person.map.k2=v2</span><br><span class="line">person.dog.name=旺财</span><br><span class="line">person.dog.age=3</span><br></pre></td></tr></table></figure><p>另外，需要说明的是，在 IDEA 中需要设置 application.properties 文件的编码，如下图所示：</p><p><img src="/2019/11/27/（二）SpringBoot-配置/1574925673973.png" alt="1574925673973"></p><p>紧接着我们同时定义了如下两个类 ，分别为 Person 和 Dog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Lombok 注解解释：</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Data</span> 提供类的get、set、equals、hashCode、canEqual、toString方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@AllArgsConstructor</span> 提供拥有所有参数的构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@NoArgsConstructor</span> 提供无参构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了 Lombok，Lombok 的使用请自行在网上查找，相关注解的作用已经在注释给了说明。一般情况下，Java Bean 的构造方法（有参和无参）、 getter 以及 setter 方法都是不可忽略的，而 Lombok 可以简化代码的编写。</p><p>观察上述的 Person 类，我们使用到了 <code>@ConfigurationProperties(prefix = &quot;person&quot;)</code>  注解，这个注解用于将配置文件（默认是全局配置文件）的每一个属性的值，映射并绑定到当前的 Person 类中，从而实现属性的注入。其中 prefix = “person” 表示与全局配置文件中的 person 进行绑定，切忌出错，否则将无法映射成功。</p><p>另外，需要注意的是，我们在使用  @ConfigurationProperties 注解时，同时也要将该类加入到 IoC 容器中，故这里也使用了 @Component 注解。</p><p>最后，我们使用单元测试来验证是否实现配置文件值得注入，测试的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Springboot01ConfigApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后输出如下结果，说明配置文件值得注入成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(lastName=张三, age=<span class="number">18</span>, boss=<span class="keyword">false</span>, birth=Wed Nov <span class="number">27</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">2019</span>, list=[a, b, c, d], map=&#123;k1=v1, k2=v2&#125;, dog=Dog(name=旺财, age=<span class="number">3</span>), arr=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h4 id="3-1-1-属性名匹配规则（松散绑定）"><a href="#3-1-1-属性名匹配规则（松散绑定）" class="headerlink" title="3.1.1 属性名匹配规则（松散绑定）"></a>3.1.1 属性名匹配规则（松散绑定）</h4><p>前面我们在 application.properties 进行了如下配置，这里我们注意 person.last-name 的编写规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 配置 Person 类</span><br><span class="line">person.last-name=张三</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在 Person 类中定义了属性 lastName，其是符合驼峰命名规则的，因此在 application.properties  中我们可以有如下几种表示方法，它们的作用是相同的，即是一种松散绑定的规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.last-name=张三</span><br><span class="line">person.last_name=张三</span><br><span class="line">person.lastName=张三</span><br><span class="line">PERSON_LAST_NAME=张三</span><br></pre></td></tr></table></figure><h3 id="3-2-Value"><a href="#3-2-Value" class="headerlink" title="3.2 @Value"></a>3.2 @Value</h3><p>除了 @ConfigurationProperties 注解能够实现 JavaBean 值的注入之外，@Value 注解同样也是可以实现的。</p><p>首先我们定义如下的 JavaBean，其中注解 @Value 遵循 <code>${key}，普通字面量和 #{SpEL}</code>三种格式，具体使用参考如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * $&#123;key&#125;从环境变量或配置文件中获取值</span></span><br><span class="line"><span class="comment">     * 下面实现会从全局配置文件（.yml/.properties）中获取person.last-name的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;user.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给password 注入普通字面量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"abc123"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Value</span> 中可以写#&#123;SpEL&#125; 的格式来给属性注入值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;11*2&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在application.properties 中编写如下代码，这样 <code>@Value(&quot;${user.last-name}&quot;)</code>便可以从中获取值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 配置 User 类</span><br><span class="line">user.last-name=李四</span><br></pre></td></tr></table></figure><p>单元测试输出 User 对象后，我们可以发现是能够成功的进行属性的注入的。</p><h4 id="3-2-1-与-ConfigurationProperties-的比较"><a href="#3-2-1-与-ConfigurationProperties-的比较" class="headerlink" title="3.2.1 与@ConfigurationProperties 的比较"></a>3.2.1 与@ConfigurationProperties 的比较</h4><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>观察上表，如果我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，推荐使用 @Value；如果我们专门编写了一个 JavaBean 来和配置文件进行映射，我们就直接使用 @ConfigurationProperties。</p><p>@Value 是不支持松散绑定的，比如我们在 application.properties 编写了 <code>user.last-name</code>，那么我们使用 <code>@Value(${user.lastName})</code> 或者使用 <code>@Value(${user.last_name})</code> 是不支持的。</p><p>@Value 同样不支持复杂类型的封装，比如向 Map 数据类型的属性注入值等等。对于 @ConfigurationProperties 与 @Value 在 JSR303 数据校验方面的使用和其区别，下面我们对其进行了解。</p><h3 id="3-3-Validated"><a href="#3-3-Validated" class="headerlink" title="3.3 @Validated"></a>3.3 @Validated</h3><p>使用上述 @Value 的代码示例，我们在类前加上注解 <code>@Validated</code>来开启数据校验的功能，然后在属性 lastName 上加上注解 <code>@Email</code>，表明该属性必须符合邮箱的格式。单元测试后，我们是可以正常输出 User 对象的，那么就说明数据校验未成功（lastName 的值<code>李四</code>并不符合邮箱格式，但是还是正常输出了），因此<code>@Value</code>并不支持 JSR303 数据校验功能。</p><p>下面我们更改代码如下，我们使用注解 @ConfigurationProperties 来验证数据校验功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * $&#123;key&#125;从环境变量或配置文件中获取值</span></span><br><span class="line"><span class="comment">     * 下面实现从 application.properties 中获取person.last-name的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;user.last-name&#125;")</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给password 注入普通字面量值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Value("abc123")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Value</span> 中可以写#&#123;SpEL&#125; 的格式来给属性注入值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局配置文件的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 配置 User 类</span><br><span class="line">user.last-name=李四</span><br><span class="line">user.password=abc123</span><br><span class="line">user.age=22</span><br></pre></td></tr></table></figure><p>单元测试输出 User 对象时，会报如下错误。因此注解 @ConfigurationProperties 是支持数据校验功能的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;user&apos; to com.shoto.bean.User failed:</span><br><span class="line"></span><br><span class="line">    Property: user.lastName</span><br><span class="line">    Value: 李四</span><br><span class="line">    Origin: class path resource [application.properties]:13:16</span><br><span class="line">    Reason: 不是一个合法的电子邮件地址</span><br></pre></td></tr></table></figure><h3 id="3-4-PropertySource"><a href="#3-4-PropertySource" class="headerlink" title="3.4 @PropertySource"></a>3.4 @PropertySource</h3><p>由于注解 @ConfigurationProperties 是默认从全局配置文件中获取值的，为了避免全局配置文件过于臃肿，我们可以另外创建一个配置文件，然后配合使用 @PropertySource 注解来获取该配置文件的内容。</p><p>现在我们定义如下的一个 JavaBean，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cat"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:cat.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解 @PropertySource(value = {“classpath:cat.properties”}) 表明我们在类路径下创建了一个配置文件 cat.properties，其内容如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat.name=cat</span><br><span class="line">cat.age=3</span><br></pre></td></tr></table></figure><p>单元测试输出 Cat 对象可以发现对象是成功注入属性值的。</p><h3 id="3-5-ImportResource"><a href="#3-5-ImportResource" class="headerlink" title="3.5 @ImportResource"></a>3.5 @ImportResource</h3><p>该注解可以导入外部的配置文件，比如导入 Spring 的配置文件。由于 SpringBoot 本身是没有 Spring 的配置文件的，我们自己编写的配置文件，也不能自动识别。为了让 Spring 的配置文件生效，我们可以将 @ImportResource 标注在一个配置类上。</p><p>首先我们编写如下一个配置类，注解 @Configuration 表明该类是一个配置类，@ImportResource 指明 Spring 配置文件的位置。具体内容如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在类路径下编写 Spring 的配置文件 beans.xml，用于将 IndexController 类作为组件加入到 IoC 容器中，配置文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"indexController"</span> <span class="attr">class</span>=<span class="string">"com.shoto.controller.IndexController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，编写如下单元测试代码，判断 IndexController 类是否成功加入到 IoC 容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBeanConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(BeanConfig.class);</span><br><span class="line">    Map&lt;String, IndexController&gt; map = applicationContext.getBeansOfType(IndexController.class);</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，SpringBoot 推荐以全注解的方式给容器中添加组件，利用 @Bean 注解我们可以免去 beans.xml 配置文件，编写如下配置类即可实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注解 <span class="doctag">@Bean</span> 用于将返回的对象加入到 IoC 容器中</span></span><br><span class="line"><span class="comment">     * 方法名即为 Bean IndexController 的ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IndexController <span class="title">indexController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IndexController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-配置文件占位符"><a href="#4-配置文件占位符" class="headerlink" title="4. 配置文件占位符"></a>4. 配置文件占位符</h2><h3 id="4-1-随机数"><a href="#4-1-随机数" class="headerlink" title="4.1 随机数"></a>4.1 随机数</h3><p>SpringBoot 的配置文件支持使用随机数的相关命令，参考如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;</span><br><span class="line">$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><p>比如我们在全局配置文件中进行如下配置，当将配置文件的值注入到 Bean RandomNumber  中并打印对象后，可能输出如下结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 随机数演示</span><br><span class="line">rand.secret=$&#123;random.value&#125;</span><br><span class="line">rand.number=$&#123;random.int&#125;</span><br><span class="line">rand.bigNumber=$&#123;random.long&#125;</span><br><span class="line">rand.uuid=$&#123;random.uuid&#125;</span><br><span class="line">rand.numberLessThanTen=$&#123;random.int(10)&#125;</span><br><span class="line">rand.numberInRange=$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RandomNumber(secret=cbe7ca3fdd7583e6f71313fe1f2889ed, number=-1697810257, bigNumber=6284689835040742963, uuid=4b166086-4263-4dcf-b102-6b97cdd889e0, numberLessThanTen=7, numberInRange=18200)</span><br></pre></td></tr></table></figure><h3 id="4-2-配置占位符"><a href="#4-2-配置占位符" class="headerlink" title="4.2 配置占位符"></a>4.2 配置占位符</h3><p>占位符的值除了可以产生随机数之外，还可以引用前面配置过的属性，比如以下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name=MyApp</span><br><span class="line">app.description=$&#123;app.name&#125; is a String Boot application</span><br></pre></td></tr></table></figure><p>除此之外，假设没有引用到前面配置过得属性，这时我们还可以给他一个默认值，比如给 app.name 默认设为 chatApp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.description=$&#123;app.name:chatApp&#125; is a String Boot application</span><br></pre></td></tr></table></figure><h2 id="5-Profile"><a href="#5-Profile" class="headerlink" title="5. Profile"></a>5. Profile</h2><p>Profile 是 Spring 对<code>不同环境提供不同配置功能</code>的支持，可以通过激活、指定参数等方式快速切换环境，即可以根据不同的环境快速的切换相应的配置文件（文档块）。</p><h3 id="5-1-多-Profile-文件方式"><a href="#5-1-多-Profile-文件方式" class="headerlink" title="5.1 多 Profile 文件方式"></a>5.1 多 Profile 文件方式</h3><p>比如现在有默认、开发和生产三种环境，它们需要不同的配置文件，分别为 application.properties（默认文件）、application-dev.properties 以及 application-prod.properties。文件的命名格式遵循 application-{profile}.properties/yml 这种格式。下面是上述三个个文件的具体内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># application.properties</span><br><span class="line">server.port=8080</span><br><span class="line"># 表示激活开发环境，配置文件会由默认的配置文件转为application-dev配置文件</span><br><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># application-dev.properties</span><br><span class="line">server.port=8081</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># application-peod.properties</span><br><span class="line">server.port=8082</span><br></pre></td></tr></table></figure><p>启动 SpringBoot 应用后，我们会发现 application-dev.properties 配置文件中的配置会生效，即启动端口变为 8081。</p><h3 id="5-2-多文档块方式（yml文件）"><a href="#5-2-多文档块方式（yml文件）" class="headerlink" title="5.2 多文档块方式（yml文件）"></a>5.2 多文档块方式（yml文件）</h3><p>除了可以使用多 profile 文件的形式之外，对于 .yml 格式的配置文件，我们还可以以多文档块（以符号—来分隔）的形式来实现相同的功能，具体如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span> <span class="comment"># 表示激活开发环境</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="5-3-激活方式"><a href="#5-3-激活方式" class="headerlink" title="5.3 激活方式"></a>5.3 激活方式</h3><p>前面我们已经在配置文件中使用 <code>spring:profiles:active</code> 来激活切换其他环境，除此之外，我们还有另外两种方式：</p><ol><li><p><strong>命令行</strong>：我们可以在命令行工具输入如下命令，通过传入命令行参数来激活指定的环境。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</span><br></pre></td></tr></table></figure></li><li><p><strong>虚拟机参数</strong>：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=dev</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-配置文件加载位置"><a href="#6-配置文件加载位置" class="headerlink" title="6. 配置文件加载位置"></a>6. 配置文件加载位置</h2><p>SpringBoot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 SpringBoot 的默认全局配置文件:</p><ul><li>file:./config/</li><li>file:./</li><li>classpath:/config/</li><li>classpath:/</li></ul><p><img src="/2019/11/27/（二）SpringBoot-配置/1574946419344.png" alt="文件加载位置示意图"></p><p>以上是按照<code>优先级从高到低</code>的顺序，<code>所有位置的文件都会被加载</code>，高优先级配置内容会覆盖低优先级的<code>相同的</code>配置内容，也就是互补配置。</p><p>另外，我们还可以通过 spring.config.location 来改变默认的配置文件位置。比如项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置。命令行参数指定的配置文件和项目中的这些配置文件共同起作用形成互补配置。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-02-config-0.0.1-SNAPSHOT.jar --spring.config.location=G:/application.properties</span><br></pre></td></tr></table></figure><h2 id="7-外部配置加载顺序"><a href="#7-外部配置加载顺序" class="headerlink" title="7. 外部配置加载顺序"></a>7. 外部配置加载顺序</h2><p>SpringBoot 也可以从以下位置加载配置， 优先级从高到低，高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置。</p><ol><li><p><strong>命令行参数</strong></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar springboot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087  --server.s</span><br><span class="line">ervlet.context-path=/index</span><br></pre></td></tr></table></figure></li><li><p>来自java:comp/env的JNDI属性</p></li><li><p>Java系统属性（System.getProperties()）</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p></li><li><p><strong>jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p></li><li><p><strong>jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p></li><li><p>@Configuration注解类上的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol><p>SpringBoot 还支持其他外部化配置，所有的外部化配置加载顺序可访问<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html#boot-features-external-config" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="8-自动配置原理"><a href="#8-自动配置原理" class="headerlink" title="8. 自动配置原理"></a>8. 自动配置原理</h2><h3 id="8-1-配置原理详情"><a href="#8-1-配置原理详情" class="headerlink" title="8.1 配置原理详情"></a>8.1 配置原理详情</h3><p>1) 、SpringBoot 启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration：</p><p><img src="/2019/11/27/（二）SpringBoot-配置/1574995742386.png" alt="8.1"></p><p><img src="/2019/11/27/（二）SpringBoot-配置/1574995794740.png" alt="8.2"></p><p><strong>2）、</strong>@EnableAutoConfiguration 作用：</p><p>首先我们点击 @EnableAutoConfiguration  的子注解 @Import({AutoConfigurationImportSelector.class}) ，在类 AutoConfigurationImportSelector 中我们可以看到 getCandidateConfigurations 方法：</p><p><img src="/2019/11/27/（二）SpringBoot-配置/1574996170491.png" alt="8.3"></p><p>点击 loadFactoryNames 方法后点击其调用的 loadSpringFactories 方法，该方法的内容如下所示：</p><p><img src="/2019/11/27/（二）SpringBoot-配置/1574996396600.png" alt="8.4"></p><p>该方法会扫描所有jar包类路径下 META-INF/spring.factories 的文件，并将文件的内容包装成 Properties 对象，并从中获取到xxxAutoConfiguration 类（类名），然后把他们添加在容器中。也就是会将类路径下  META-INF/spring.factories 里面配置的所有xxxAutoConfiguration 的值加入到了容器中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每一个这样的  xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中，从而实现自动配置的功能。</p><p>3）、以 <strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties.class)  <span class="comment">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)  <span class="comment">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//它已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter.class) <span class="comment">//判断容器没有这个组件？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>4）、所有在配置文件中能配置的属性都是与其对应的封装类 xxxxProperties（比如上面的 HttpEncodingProperties 类） 一一对应的，因此配置文件能配置什么就可以参照某个功能对应的这个属性类。我们可以从类 HttpEncodingProperties  中知道它是与配置文件中的 spring.http 进行绑定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(</span><br><span class="line">    prefix = <span class="string">"spring.http"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自动配置原理的总结如下：</strong></p><ol><li>SpringBoot 的 @EnableAutoConfiguration 用于开启自动配置功能；</li><li>然后 SpringBoot 会扫描 spring.factories 文件中的所有自动配置类，并给容器中添加相关的组件；</li><li>其中每个自动配置类都与配置文件中的属性进行绑定，而这些配置文件的体现便是相关的 Properties 类。</li></ol><h3 id="8-1-其他细节"><a href="#8-1-其他细节" class="headerlink" title="8.1 其他细节"></a>8.1 其他细节</h3><p>上面中的 HttpEncodingAutoConfiguration 的源码，我们可以发现注解 @ConditionalOnWebApplication，它是 Spring 注解 @Conditional 的派生注解，其可以根据 @Conditional 指定的条件是否成立，来选择给容器中添加组件，条件成立时配置配里面的所有内容才生效。比如 @ConditionalOnWebApplication 只有在当前应用是 web 应用时配置类才会生效。</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p>我们可以通过在 application.properties 中启用  <code>debug=true</code>属性，来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &apos;org.springframework.web.servlet.DispatcherServlet&apos;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)</span><br><span class="line">      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">Negative matches:（没有启动，没有匹配成功的自动配置类）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required classes &apos;javax.jms.ConnectionFactory&apos;, &apos;org.apache.activemq.ActiveMQConnectionFactory&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required classes &apos;org.aspectj.lang.annotation.Aspect&apos;, &apos;org.aspectj.lang.reflect.Advice&apos; (OnClassCondition)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一) SpringBoot-HelloWorld</title>
      <link href="/2019/11/25/%EF%BC%88%E4%B8%80%EF%BC%89SpringBoot-HelloWorld/"/>
      <url>/2019/11/25/%EF%BC%88%E4%B8%80%EF%BC%89SpringBoot-HelloWorld/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringBoot-HelloWorld"><a href="#1-SpringBoot-HelloWorld" class="headerlink" title="1. SpringBoot HelloWorld"></a>1. SpringBoot HelloWorld</h1><p>在使用 SpringBoot 框架时，个人推荐参考<a href="https://docs.spring.io/spring-boot/docs/" target="_blank" rel="noopener">官方网站</a>，虽然是英文文档也比较难懂些，但是也是最权威的。好吧，下面开始从基础上来创建一个 SpringBoot 项目吧！</p><p>假设现在需要一个简单的功能，即浏览器向 SpringBoot 项目发送一个 hello 请求，服务器接受请求并处理后，在页面上显示Hello World字符串。</p><a id="more"></a><h2 id="1-1-创建-Maven-项目"><a href="#1-1-创建-Maven-项目" class="headerlink" title="1.1 创建 Maven 项目"></a>1.1 创建 Maven 项目</h2><h2 id="1-2-导入-SpringBoot-依赖"><a href="#1-2-导入-SpringBoot-依赖" class="headerlink" title="1.2 导入 SpringBoot 依赖"></a>1.2 导入 SpringBoot 依赖</h2><p>首先我们需要在 pom.xml 文件中导入SpringBoot 相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里我们只需简单地知道，<code>spring-boot-starter-parent</code> 表示与 SpringBoot 相关的依赖，而 <code>spring-boot-starter-web</code> 则表示与 web 相关的依赖，比如 web-mvc 依赖。</p><h2 id="1-3-编写主程序类"><a href="#1-3-编写主程序类" class="headerlink" title="1.3 编写主程序类"></a>1.3 编写主程序类</h2><p>我们在包 com.shoto 下创建一个主程序类 HelloWorldMainApplication，该类是 SpringBoot 程序的入口，其中的 main 中的 run 方法用于启动 SpringBoot 应用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @SpringBootApplication 该注解用于指明该类是 SpringBoot 的主程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法用于启动 SpringBoot 应用</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-编写-Controller-类"><a href="#1-4-编写-Controller-类" class="headerlink" title="1.4  编写 Controller 类"></a>1.4  编写 Controller 类</h2><p>在com.shoto.controller 包下编写一个控制器类，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-运行主程序测试"><a href="#1-5-运行主程序测试" class="headerlink" title="1.5 运行主程序测试"></a>1.5 运行主程序测试</h2><h2 id="1-6-简化部署"><a href="#1-6-简化部署" class="headerlink" title="1.6 简化部署"></a>1.6 简化部署</h2><p>如果我们需要快速的创建一个可运行 jar 包，首先我们需要在 pom.xml 中导入相关的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--生成可执行jar包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后使用 maven 执行 <code>mvn package</code> 命令，此时会在 target 目录下生成相应的可运行 jar。我们可以使用命令<code>java -jar jar名称</code> 来运行该 jar 包。</p><h1 id="2-Hello-World-探究"><a href="#2-Hello-World-探究" class="headerlink" title="2. Hello World 探究"></a>2. Hello World 探究</h1><p>在前面我们已经创建和运行了一个简单的 SpringBoot 应用，下面我们来解释一下该 HelloWorld 程序的一些细节。</p><h2 id="2-1-pom-文件"><a href="#2-1-pom-文件" class="headerlink" title="2.1 pom 文件"></a>2.1 pom 文件</h2><h3 id="2-1-1-父项目"><a href="#2-1-1-父项目" class="headerlink" title="2.1.1 父项目"></a>2.1.1 父项目</h3><p>前面我们在 pom 文件中配置了如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它是 SpringBoot 应用的核心配置，我们点击 <code>spring-boot-starter-parent</code> 可以发现其父项目是 <code>spring-boot-dependencies</code>，具体内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击<code>spring-boot-dependencies</code> 后我们可以发现其管理了 SpringBoot 应用里面的所有依赖版本，因此以后我们导入依赖默认是不需要写版本的，当然如果没有在 <code>dependencies</code> 里面管理的依赖自然需要声明版本号。<img src="/2019/11/25/（一）SpringBoot-HelloWorld/1574666927148.png" alt="依赖"></p><h3 id="2-1-2-启动器"><a href="#2-1-2-启动器" class="headerlink" title="2.1.2 启动器"></a>2.1.2 启动器</h3><p>同样的，前面我们在 pom 文件中也配置了如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置web相关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-web</code> 表示 web 相关的启动器，它帮我们导入了 web 模块正常运行所依赖的所有组件，这样就可以减少我们的配置以及配置出错的情况。该 web 启动器包含的依赖有：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--内置 Tomcat 配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Hibernate 校验器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--与 Jackson 绑定--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SpringMVC 配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器），我们只需要在项目里面引入这些 starter，那么相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p><p>SpringBoot 支持的启动器的相关详细信息可参考<a href="https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/using-spring-boot.html#using-boot-starter" target="_blank" rel="noopener">官方文档</a>.</p><h2 id="2-2-主程序类"><a href="#2-2-主程序类" class="headerlink" title="2.2 主程序类"></a>2.2 主程序类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @SpringBootApplication 该注解用于指明该类是 SpringBoot 的主程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run 方法用于启动 SpringBoot 应用</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要注意的是 @SpringBootApplication 注解，其声明了 HelloWorldMainApplication 是一个主程序类，SpringBoot 会运行这个类的 main 方法来启动 SpringBoot 应用。</p><h3 id="2-2-1-SpringBootApplication"><a href="#2-2-1-SpringBootApplication" class="headerlink" title="2.2.1 @SpringBootApplication"></a>2.2.1 @SpringBootApplication</h3><p>点击 @SpringBootApplication 该注解，我们可以发现其部分内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">        <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">    ...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>在这里，我们只需关注 @SpringBootConfiguration 和 @EnableAutoConfiguration 这两个注解。</p><ul><li><p>@SpringBootConfiguration ：标注在某个类上，用于表示这是一个Spring Boot的配置类；</p><p>  点击 @SpringBootConfiguration 后我们可以发现其也是由以下多个注解组成的：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">...</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>  其中，注解 @Configuration 表明当前类是 Spring 的一个配置类，相当于我们 Spring 的一个配置文件，不过这里是以一个 Java 类的形式，该类也是一个组件（Component）。</p></li><li><p>@EnableAutoConfiguration ：开启 SpringBoot 的自动配置功能，这样自动配置才能生效。</p><p>  我们点击 @EnableAutoConfiguration 注解，我们可以发现其部分内容如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在这里，我们需关注 @AutoConfigurationPackage 和 @Import(EnableAutoConfigurationImportSelector.class) 这两个注解：</p><ul><li><p>点击 @AutoConfigurationPackage 注解，我们发现其是由 @Import({Registrar.class}) 等注解构成的，其作用是将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring 容器中。本项目中我们的主程序类的包是 <code>com.shoto</code>，所以如果我们在该包外创建一个 controller 类，其是不会加入 Spring 容器中的，这一点需要额外注意；</p></li><li><p>@Import(EnableAutoConfigurationImportSelector.class)  注解会将 EnableAutoConfigurationImportSelector 类加入到 IoC 容器中，同时也会将自动配置类（xxxAutoConfiguration）及其相应的组件一并导入。</p><p>  SpringBoot 的自动配置类位于 spring-boot-autoconfigure-2.2.1.RELEASE.jar 中，我们可以在 META-INF/spring.factories 中查看，其部分内容如下所示：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">...</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>  其中 RedisAutoConfiguration 中则实现了 Redis 相关的自动配置，比如 RedisTemplate 的配置，不同的于 Spring 中使用 &lt;bean&gt; 标签，这里直接使用如下代码来实现。@Bean 可以将方法的返回值加入到 IoC 容器中。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(</span><br><span class="line">    name = &#123;<span class="string">"redisTemplate"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 RedisTemplate</span></span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>以上即是注解 <code>@SpringBootApplication</code>和其相关注解的一些作用，其标注的类即为一个主程序类，同时也是一个配置类。其作用是 SpringBoot 应用的启动入口，同时引发 SpringBoot 的自动配置生效等功能。</p><h1 id="3-快速创建-SpringBoot-项目"><a href="#3-快速创建-SpringBoot-项目" class="headerlink" title="3. 快速创建 SpringBoot 项目"></a>3. 快速创建 SpringBoot 项目</h1><h2 id="3-1-网站在线创建"><a href="#3-1-网站在线创建" class="headerlink" title="3.1 网站在线创建"></a>3.1 网站在线创建</h2><p>我们可以访问该网站<a href="https://start.spring.io/" target="_blank" rel="noopener">（点击）</a>，在线配置并下载 SpringBoot 项目，然后使用 IDEA 等软件打开即可。</p><h2 id="3-2-Spring-Initializer-创建"><a href="#3-2-Spring-Initializer-创建" class="headerlink" title="3.2 Spring Initializer 创建"></a>3.2 Spring Initializer 创建</h2><p>IDEA 支持使用 Spring 的项目创建向导来快速创建一个 SpringBoot 项目，如下图所示。点击 next 后，具体的配置按需求来就好了。<img src="/2019/11/25/（一）SpringBoot-HelloWorld/1574669367938.png" alt="Initializer创建SpringBoot项目"></p><p>默认生成的项目我们需要注意的是 resources 文件夹。</p><ul><li>resources 文件夹中的目录结构：<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（SpringBoot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：SpringBoot 应用的全局配置文件，比如配置与数据库的连接信息和 Tomcat 的端口号等等。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Markdown 注意事项</title>
      <link href="/2019/11/24/Hexo-Markdown%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2019/11/24/Hexo-Markdown%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="1-文章标题"><a href="#1-文章标题" class="headerlink" title="1. 文章标题"></a>1. 文章标题</h2><p>目前 Hexo 建议使用顺序的文章标题，也就是使用如下格式的标题结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">...</span><br></pre></td></tr></table></figure><a id="more"></a><p>简单地说就是文章标题建议使用由大号标题到小号标题过渡而不要出现跨级的标题结构，比如下面的标题结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">### 三级标题</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因为这样可能会出现如下的错误显示，所以只要遵循这种标题格式即可。</p><p><img src="/2019/11/24/Hexo-Markdown注意事项/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95%E9%94%99%E8%AF%AF.jpg" alt="文章目录错误"></p><h2 id="2-文章头格式"><a href="#2-文章头格式" class="headerlink" title="2. 文章头格式"></a>2. 文章头格式</h2><p><code>front-matter</code> 的基本格式示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">top: false 是否文章置顶</span><br><span class="line">mathjax: false 是否开启数学公式支持 </span><br><span class="line">date: 日期时间</span><br><span class="line">author: 作者名</span><br><span class="line">password: 文章阅读密码，前提是在主题的 config.yml 中激活了 verifyPassword 选项</span><br><span class="line">summary: 文章摘要，自定义的文章摘要内容</span><br><span class="line">tags: 表示文章标签，格式：[标签1, 标签2, ]</span><br><span class="line">categories: 表示文章分类，格式：[分类1, 分类2, ]</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>需要注意的是，上述的<code>title: 文章标题</code> 之间必须使用空格隔开，其他的也一样，否则 Hexo 运行时会报错。</p><h2 id="3-显示阅读全文"><a href="#3-显示阅读全文" class="headerlink" title="3. 显示阅读全文"></a>3. 显示阅读全文</h2><p>Hexo 首页默认是会显示每篇文章的全部内容的，为了更为合理的浏览首页的内容，我们无需显示整篇文章，而是增添一个<code>阅读全文</code>的按钮，并只在首页显示文章指定的部分内容，若要查看该篇文章则只需点击阅读全文即可。</p><p>因此我们可以在文章的某个位置增加如下语句，那么位于该语句之前的文章内容则会显示在首页，而不是简单地显示全文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>添加后的显示如下所示：</p><p><img src="/2019/11/24/Hexo-Markdown注意事项/1574582056125.png" alt="阅读全文"></p><h2 id="4-文本高亮"><a href="#4-文本高亮" class="headerlink" title="4. 文本高亮"></a>4. 文本高亮</h2><p>本人的 Hexo 系统并支持如下的文本高亮的 Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;高亮文本&apos;&apos;&apos;</span><br><span class="line">==高亮文本==</span><br></pre></td></tr></table></figure><p>其中三个单引号`的高亮语法会导致显示格式错误，而两个等号=的高亮语法则无高亮效果。目前支持的高亮语法则是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`高亮文本`</span><br></pre></td></tr></table></figure><h2 id="5-Latex-公式"><a href="#5-Latex-公式" class="headerlink" title="5. Latex 公式"></a>5. Latex 公式</h2><p>数学公式的默认定界符是<code>$...$</code>（对于行内公式），以及<code>$$...$$</code>(对于块级公式）。例如，质能守恒方程如下所示：</p><p>行内公式： $E = mc^2$ </p><p>块内公式： $$E = mc^2$$</p><p>例如如下块级公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\Delta_A(\lambda)=\det(\lambda I-A)$$</span><br></pre></td></tr></table></figure><p>$$\Delta_A(\lambda)=\det(\lambda I-A)$$</p><h2 id="6-文字增加背景色块"><a href="#6-文字增加背景色块" class="headerlink" title="6. 文字增加背景色块"></a>6. 文字增加背景色块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;inline-blue&quot;&gt; 站点配置文件 &lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;inline-purple&quot;&gt; 主题配置文件 &lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;inline-yellow&quot;&gt; 站点配置文件 &lt;/span&gt;</span><br><span class="line">&lt;span id=&quot;inline-green&quot;&gt; 主题配置文件 &lt;/span&gt;</span><br></pre></td></tr></table></figure><p>效果如下所示：<br><span id="inline-blue"> 站点配置文件 </span><br><span id="inline-purple"> 主题配置文件 </span><br><span id="inline-yellow"> 站点配置文件 </span><br><span id="inline-green"> 主题配置文件 </span></p><h2 id="7-在文档中增加图标-Font-Awesome-提供图标"><a href="#7-在文档中增加图标-Font-Awesome-提供图标" class="headerlink" title="7. 在文档中增加图标, Font Awesome 提供图标"></a>7. 在文档中增加图标, <a href="https://link.zhihu.com/?target=http%3A//fontawesome.dashgame.com/" target="_blank" rel="noopener">Font Awesome</a> 提供图标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-pencil&quot;&gt;郑松涛&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>显示效果：<i class="fa fa-pencil">郑松涛</i></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;list-group&quot;&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-home fa-fw&quot;&gt;&lt;/i&gt;&amp;nbsp; Home&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-book fa-fw&quot;&gt;&lt;/i&gt;&amp;nbsp; Library&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-pencil fa-fw&quot;&gt;&lt;/i&gt;&amp;nbsp; Applications&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-cog fa-fw&quot;&gt;&lt;/i&gt;&amp;nbsp; Settings&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>显示效果：</p><div class="list-group"><a class="list-group-item" href="#"><i class="fa fa-home fa-fw"></i>&nbsp; Home</a><a class="list-group-item" href="#"><i class="fa fa-book fa-fw"></i>&nbsp; Library</a><a class="list-group-item" href="#"><i class="fa fa-pencil fa-fw"></i>&nbsp; Applications</a><a class="list-group-item" href="#"><i class="fa fa-cog fa-fw"></i>&nbsp; Settings</a></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-circle-o-notch fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-refresh fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-cog fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-spinner fa-pulse&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>显示效果：</p><p><i class="fa fa-spinner fa-spin">旋转</i><br><i class="fa fa-circle-o-notch fa-spin">旋转</i><br><i class="fa fa-refresh fa-spin">旋转</i><br><i class="fa fa-cog fa-spin">旋转</i><br><i class="fa fa-spinner fa-pulse">旋转</i></p><h2 id="8-mermaid-支持"><a href="#8-mermaid-支持" class="headerlink" title="8. mermaid 支持"></a>8. mermaid 支持</h2><p>使用 mermaid 该插件可以画甘特图和时序图等图标，但是使用语法并非标准的 Markdown 语法，并不友好。Hexo 支持的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125; ... &#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure><p>效果图如下所示：</p><pre class="mermaid" style="text-align: center;">                             gantt    dateFormat  YYYY-MM-DD    title 软件开发甘特图    section 设计    需求                      :done,    des1, 2014-01-06,2014-01-08    原型                      :active,  des2, 2014-01-09, 3d    UI设计                     :         des3, after des2, 5d未来任务                     :         des4, after des3, 5d    section 开发    学习准备理解需求                      :crit, done, 2014-01-06,24h    设计框架                             :crit, done, after des2, 2d    开发                                 :crit, active, 3d    未来任务                              :crit, 5d    耍                                   :2d    section 测试    功能测试                              :active, a1, after des3, 3d    压力测试                               :after a1  , 20h    测试报告                               : 48h          </pre><pre class="mermaid" style="text-align: center;">                         graph TBstart(开始)-->inputA[输入用户名密码]inputA-->opA{数据库查询子类}opA-->conditionA{是否有此用户}conditionA--yes-->conditionB{密码是否正确}conditionA--no-->inputAconditionB--yes-->opB[读入用户信息]conditionB--no-->inputAopB-->en(登录)          </pre><h2 id="9-自定义图片样式"><a href="#9-自定义图片样式" class="headerlink" title="9. 自定义图片样式"></a>9. 自定义图片样式</h2><div>    <img src="/2019/11/24/Hexo-Markdown注意事项/文章目录错误.jpg" style="margin-left: 20px; width: 200px; height: 300px"></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"2019-11-24-Hexo-Markdown注意事项/文章目录错误.jpg"</span> <span class="attr">style</span>=<span class="string">"margin-left: 20px; width: 200px; height: 300px"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Morris 遍历</title>
      <link href="/2019/09/15/2019-9-15-Morris-%E9%81%8D%E5%8E%86/"/>
      <url>/2019/09/15/2019-9-15-Morris-%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>我们先来看一个题目：给定一颗二叉树的头节点 head，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数为 N，要求时间复杂度为 O(N)，额外空间复杂度为 O(1)。</p><a id="more"></a><h3 id="1-Morris-遍历流程"><a href="#1-Morris-遍历流程" class="headerlink" title="1. Morris 遍历流程"></a>1. Morris 遍历流程</h3><p>Morris 遍历的实质就是避免用栈结构，而是让下层到上层有指针，具体是通过让底层节点指向 null 的空闲指针指回上层的某个节点，从而完成下层到上层的移动。</p><p>在讲 Morris 遍历之前，我们可以先了解一下 Morris 遍历的大体流程：</p><ol><li>我们记当前节点的指针为 cur，如果 cur 所指向的节点没有左孩子，那么 cur 指针向右移动，即 cur = cur.right。</li><li>如果 cur 所指向的节点有左孩子，那么先找到 cur 左子树的最右的节点，并使用 mostright 指针指向该最右节点。<br> 1）如果 mostright  所指向的节点的 right 指针为空，那么让mostright 的 right 指针指向 cur，然后cur 指针向左移动；<br> 2）如果 mostright  所指向的节点的 right 指向 cur，那么让 right 重新指向空，然后 cur 向右移动。</li></ol><h3 id="2-Morris-中序遍历"><a href="#2-Morris-中序遍历" class="headerlink" title="2. Morris 中序遍历"></a>2. Morris 中序遍历</h3><p>在介绍 Morris 先序和后序遍历之前，我们先举例展示 Morris 中序遍历的过程。</p><p>假设一颗二叉树如图1.1所示， Morris 中序遍历的具有步骤如下：<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568537108760.png" alt="图1.1"><br>1.首先当前指针 cur 会指向根节点4，然后发现其左孩子存在，那么让 mostright 指针指向左子树的最右节点3，然后发现 mostright  所指向的节点的 right 指针为空，那么让mostright 的 right 指针指向 cur，然后 cur 指针向左移动（上述流程2第一点）。如下图1.2所示：<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568537585414.png" alt="图1.2"><br>2.同步骤1一样，当前指针 cur 会指向节点2，然后发现其左孩子存在，那么让 mostright 指针指向左子树的最右节点1，然后发现 mostright  所指向的节点的 right 指针为空，那么让mostright 的 right 指针指向 cur，然后 cur 指针向左移动（上述流程2的第一点）。如下图1.3所示：<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568537928060.png" alt="图1.3"><br>3.此时发现当前节点 cur 的左孩子为空，打印节点。然后 cur 指针向右移动，即 cur = cur.right。（流程1）此时 cur 指针指向节点2，如下图1.4所示：<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568538227052.png" alt="图1.4"><br>4.接着再次判断当前节点 cur ，并让 mostright 指针重新定位到当前节点2的左子树最右的节点1，然后发现 mostright  所指向的节点的 right 指针指向 cur，那么让 right 指针重新指向空，然后 打印当前节点且 cur 向右移动到节点3。如图1.5所示:<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568539196758.png" alt="图1.5"><br>5.判断发现当前节点 cur 的左孩子为空，打印当前节点然后 cur 指针向右移动，即 cur = cur.right，此时 cur 指针重新指向节点4。同样地，让 mostright 指针重新定位到当前节点4的左子树最右的节点3，然后发现 mostright  所指向的节点的 right 指针指向 cur，那么让 right 指针重新指向空，然后打印当前节点且 cur 向右移动到节点6。如图1.6所示:<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568539896120.png" alt="图1.6"><br>后续过程基本同遍历根节点的左子树一样，需要注意的是当 cur 走到节点7时，会发现其没有左孩子，然后向右走变为空，然后 Morris 的中序遍历结束。<br><strong>注意</strong>：打印节点的时机为左子树为空时或左子树已经打印过了！</p><p>以下是具体的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Morris 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisIn</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostright = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostright = cur.left; <span class="comment">// cur左孩子</span></span><br><span class="line">        <span class="comment">// 如果当前节点的左子树存在</span></span><br><span class="line">        <span class="keyword">if</span> (mostright != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到左子树最右的节点，并让mostright指向它</span></span><br><span class="line">            <span class="comment">// mostright.right != null可以保证第一次定位mostright</span></span><br><span class="line">            <span class="comment">// mostright.right != cur可以保证第二次定位mostright</span></span><br><span class="line">            <span class="keyword">while</span> (mostright.right != <span class="keyword">null</span> &amp;&amp; mostright.right != cur) &#123;</span><br><span class="line">                mostright = mostright.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左子树最右节点的右孩子为空，那么让其指向cur,cur往左走</span></span><br><span class="line">            <span class="keyword">if</span> (mostright.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostright.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// mostright的right指向cur（之前设置过），right重新置为空</span></span><br><span class="line">                mostright.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树已处理完（左子树为空或已经访问过），然后打印当前的根节点的值</span></span><br><span class="line">        System.out.print(cur.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="comment">// 如果当前节点的左子树不存在或已经访问过，那么cur往右走</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Morris-先序遍历"><a href="#3-Morris-先序遍历" class="headerlink" title="3. Morris 先序遍历"></a>3. Morris 先序遍历</h3><p>Morris 的先序遍历基本与 Morris 中序遍历基本相同，不同之处在于打印节点的时机。如下代码即是 Morris 先序遍历的实现。Morris 的先序遍历打印节点的时机如下代码的1和2所示，第一是当 cur 要走向左子树之前先打印根节点的值，第二则是当左子树为空时打印根节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Morris先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">morrisPre</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostright = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostright = cur.left;<span class="comment">// 当前节点的左孩子</span></span><br><span class="line">        <span class="comment">// 当前节点的左子树存在，则将mostright定位到该左子树的最右节点</span></span><br><span class="line">        <span class="keyword">if</span> (mostright != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostright.right != <span class="keyword">null</span> &amp;&amp; mostright.right != cur) &#123;</span><br><span class="line">                mostright = mostright.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果左子树最右节点的right指针为空，让其指向当前节点，cur往左走</span></span><br><span class="line">            <span class="keyword">if</span> (mostright.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostright.right = cur;</span><br><span class="line">                <span class="comment">// 1. cur 要走向左子树之前先打印根节点</span></span><br><span class="line">                System.out.print(cur.val + <span class="string">" "</span>);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">// 继续访问左子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明mostright的right指向了cur，重新置为空</span></span><br><span class="line">                mostright.right = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 左子树为空时打印根节点</span></span><br><span class="line">            System.out.print(cur.val + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前节点的左子树不存在或已经访问过，cur往右走</span></span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Morris-后序遍历"><a href="#4-Morris-后序遍历" class="headerlink" title="4. Morris 后序遍历"></a>4. Morris 后序遍历</h3><p>Morris 后序遍历的实现同先序遍历一样可以由 Morris 中序遍历改写过来，但是包含更复杂的调整过程。总的来说，逻辑很简单，就是依次<strong>逆序打印</strong>所有节点的左子树的右边界。打印的时机即是当 cur 依靠右指针从底层向上移动的时候。查看下图，当 cur 指针第一次向上移动时，会按下图逆序打印1；当 cur 指针第二次向上移动时，会逆序打印2；当 cur 指针第三次向上移动时，会逆序打印3。最后一次则是当 cur 为空时退出循环时，逆序打印4。<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568552394222.png" alt="图4.1"><br>那么又应该如何实现逆序打印呢？查看下图4.2，当我们要打印根节点 A 的左子树的右边界时，我们将其看成一个单链表，先进行逆序（查看下图4.3）并打印节点，最后再次进行逆序还原回来。<br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568552785159.png" alt="图4.2"><br><img src="/2019/09/15/2019-9-15-Morris-遍历/1568552918631.png" alt="图4.3"></p><p>以下是 Morris 后序遍历的具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Morris 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">morrisPos</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TreeNode cur = root;</span><br><span class="line">    TreeNode mostright = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mostright = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostright != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostright.right != <span class="keyword">null</span> &amp;&amp; mostright.right != cur) &#123;</span><br><span class="line">                mostright = mostright.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mostright.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mostright.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mostright.right = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 逆序打印左子树右边界</span></span><br><span class="line">                printEdge(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逆序打印该树的右边界</span></span><br><span class="line">    printEdge(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印右边界</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">    TreeNode tail = reverseEdge(head);</span><br><span class="line">    <span class="keyword">while</span> (tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.print(tail.val + <span class="string">" "</span>);</span><br><span class="line">        tail = tail.right;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseEdge(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边界逆序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reverseEdge</span><span class="params">(TreeNode from)</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (from != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = pre;</span><br><span class="line">        pre = from;</span><br><span class="line">        from = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的定义</title>
      <link href="/2019/09/14/2019-9-14-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
      <url>/2019/09/14/2019-9-14-%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>在线性表，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继，即存在一对一的关系。在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关，即存在一对多的关系。图是一种较线性表和数更加复杂的数据结构。在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关，图存在多对多的关系。</p><a id="more"></a><p>如下图1所示，先来看图的定义。<br><img src="/2019/09/14/2019-9-14-图的定义/1568427350804.png" alt="图1"></p><blockquote><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V, E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</p></blockquote><p>对于图的定义，我们需要明确几个注意的地方。</p><ul><li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素我们则称之为顶点（Vertex）。</li><li>在图结构中，不允许没有顶点，在定义中，若 V 是顶点的集合，则强调了顶点集合 V 有穷非空。但是允许边集 E 为空。</li></ul><h2 id="1-各种图定义"><a href="#1-各种图定义" class="headerlink" title="1. 各种图定义"></a>1. 各种图定义</h2><p><strong>无向边</strong>：若顶点 $v_i$ 到 $v_j$ 之间的边没有方向，则称这条边为无向边（Edge），用无序偶对（$v_i$，$v_j$）来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。图1.1就是一个无向图，由于是无方向的，连接顶点 A 与 D 的边，可以表示成无序对（A，D），也可以写成（D，A）。<br><img src="/2019/09/14/2019-9-14-图的定义/1568427965224.png" alt="图1.1"><br><strong>有向边</strong>：若从顶点 $v_i$ 到 $v_j$ 的边有方向，则称这条边为有向边，也称为弧。用有序偶&lt;$v_i, v_j$&gt;来表示，$v_i$ 称为弧尾，$v_j$ 称为弧头。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。图1.2就是一个有向图。连接顶点 A 到 D 的有向边就是弧，A 就是弧尾，D 是弧头，&lt;A, D&gt;表示弧，注意不能写成&lt;D，A&gt;。<br><img src="/2019/09/14/2019-9-14-图的定义/1568428586161.png" alt="图1.2"><br><strong>简单图</strong>：在图中，若不存在顶点到其自身的边，且同一条边不重复出现，则称这样的图为简单图。我们所讨论的范畴也都简单图。下图1.3便不属于我们讨论的范围。<br><img src="/2019/09/14/2019-9-14-图的定义/1568429427242.png" alt="图1.3"><br><strong>无向完全图</strong>：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图有 $\frac{n \times{(n - 1)}}{2}$ 条边。比如图1.4就是无向完全图。<br><img src="/2019/09/14/2019-9-14-图的定义/1568429715982.png" alt="图1.4"><br><strong>有向完全图</strong>：在有向图中，如果任意两个顶点之间都存在边，则称该图为有向完全图。含有 n 个顶点的有向完全图有 $n \times{(n - 1)}$ 条边。比如图1.5就是有向完全图。<br><img src="/2019/09/14/2019-9-14-图的定义/1568429802901.png" alt="图1.5"><br><strong>权与网</strong>：些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权（Weight）。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这些带权的图通常称为网。图1.6就是一张带权的图，权表示城市的直线距离。<br><img src="/2019/09/14/2019-9-14-图的定义/1568430045873.png" alt="图1.6"><br><strong>子图</strong>：假设有两个图$ G = (V, {E}) 和 G’ = (V’, {E’})$，如果 $V’ \subseteq{V}$  且 $E’ \subseteq{E}$，则称$ G’ 为 G $的子图。例如图1.7带底纹的图均为左侧无向图与有向图的子图。<br><img src="/2019/09/14/2019-9-14-图的定义/1568430303895.png" alt="图1.7"></p><h2 id="2-图的顶点与边间关系"><a href="#2-图的顶点与边间关系" class="headerlink" title="2. 图的顶点与边间关系"></a>2. 图的顶点与边间关系</h2><p><strong>邻接</strong>：对于无向图 G=(V, {E})，如果边$(v, v’) \in E$，则称顶点 v 和 v’ 互为邻接点，即 v 和 v’相邻接。对于有向图 G=(V, {E})，如果弧$&lt;v,v’&gt;\in E$，则称顶点 v 邻接到顶点v’，顶点v’邻接自顶点 v。<br><strong>度</strong>：顶点 v 的度（Degree）是和 v 相关联边的数目，即为 TD(v)。在无向图中，边数起始就是各顶点度数和的一半。简记之，$e=\frac{1}{2}\sum_{i=1}^{n}TD(v_i)$。<br><strong>入度与出度</strong>：在有向图中，以顶点 v 为头的弧的数目称为 v 的入度（InDegree），记为ID(v)；以 v 为尾的弧的数目称为 v 的出度（OutDegree），记为OD(v)；顶点 v 的度为 TD(v) = ID(v) + OD(v)。我们可以发现，有向图的边数会等于出度数及入度数，简记之，$e=\sum_{i=1}^{n}ID(v_i)=\sum_{i=1}^{n}OD(v_i)$。<br><strong>路径</strong>：无向图 G=(V,{E}) 中从顶点 v 到顶点 v’的路径（Path）是一个顶点序列$(v=v_{i,0},v_{i,1},…,v_{i,m})$，其中$(v_{i,j-1},v_{i,j})\in E，i\le j \le m$。例如图2.1中列举了顶点 B 到顶点 D 四种不同的路径。<br><img src="/2019/09/14/2019-9-14-图的定义/1568433120311.png" alt="图2.1"><br>如果 G 是有向图，则路径也是有向的，顶点序列应满足$&lt;v_{i,j-1},v_{i,j}&gt;\in E，i \le j \le m$。例如下图2.2，顶点 B 到 D 有两种路径。<br><img src="/2019/09/14/2019-9-14-图的定义/1568433326260.png" alt="图2.2"><br>路径的长度是路径上的边或弧的数目。<br><strong>简单路径</strong>：序列中顶点不重复出现的路径称为简单路径。<br><strong>回路或环</strong>：第一个顶点到最后一个顶点相同的路径称为回路或环（Cycle）。其中除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。例如下图2.3，其中图即为简单回路，而右图则不是，因为出现重复顶点 C。<br><img src="/2019/09/14/2019-9-14-图的定义/1568433574457.png" alt="图2.3"></p><h2 id="3-连通图相关术语"><a href="#3-连通图相关术语" class="headerlink" title="3. 连通图相关术语"></a>3. 连通图相关术语</h2><p><strong>连通图</strong>：在无向图 G 中，如果从顶点 v 到顶点 v’有路径，则称 v 和 v’是<strong>连通</strong>的。如果对于图中任意两个顶点 $v_i、v_j \in E，v_i 和 v_j$ 都是连通的，则称 G 是连通图。<br>比如图3.1就不是连通图，因为顶点 A 到 顶点 E 或 F 并不连通。而图3.2就是连通图，其中顶点 A、B、C 和 D 两两都是连通的。<br><img src="/2019/09/14/2019-9-14-图的定义/1568444071067.png" alt="图3.1"><br><img src="/2019/09/14/2019-9-14-图的定义/1568444087269.png" alt="图3.2"><br><strong>连通分量</strong>：无向图的极大连通子图称为连通分量。注意连通分量的概念，它强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通<strong>子图</strong>含有极大顶点数；</li><li>具有<strong>极大顶点数</strong>的连通子图包含依附于这些顶点的<strong>所有</strong>边。</li></ul><p>上面的图3.1具有两个连通分量，分别为上面的图3.1和下面的图3.3。但是图3.4则不是连通分量，因为其不符合极大顶点数的条件。<br><img src="/2019/09/14/2019-9-14-图的定义/1568444555546.png" alt="图3.3"> <img src="/2019/09/14/2019-9-14-图的定义/1568444667846.png" alt="图3.4"><br><strong>强连通图</strong>：在有向图 G 中，如果对于每一对 $v_i、v_j \in V、v_i \ne v_j$，从 $v_i$ 到 $v_j$ 和从 $v_j$ 到 $v_i$ 都存在路径，则称 G 是强连通图。<br><strong>强连通分量</strong>：有向图中的极大强连通子图称作有向图的强连通分量。与连通分量所强调的相似，唯一不同的是强连通分量要求子图要是强连通的。<br>比如下图中图1不是强连通图，而图2则是强连通图。同时图2也是图1的强连通分量。<br><img src="/2019/09/14/2019-9-14-图的定义/1568445045077.png" alt="图3.5"><br><strong>连通图生成树</strong>：所谓的一个连通图的生成树是一个极小的连通子图。该极小的连通子图强调：</p><ul><li>要是子图；</li><li>子图要是连通的；</li><li>连通<strong>子图</strong>含有极大顶点数；</li><li>具有<strong>极大顶点数</strong>的连通子图包含依附于这些顶点的<strong>最少</strong>边。</li></ul><p>所以一个含有 n 个顶点的连通图，它的生成树是也含有 n 个顶点，并且只有足以构成一棵树的 n - 1 条边。比如下图的图2就是图1生成树。<br><img src="/2019/09/14/2019-9-14-图的定义/1568445529768.png" alt="图3.6"><br>从这里我们也可以知道，如果一个图有 n 个顶点和少于 n - 1 条边，则是非连通图，如果它多于 n - 1 条边，必定构成环。另外，有n - 1 条边并不一定是生成树，比如下图图3.7。<br><img src="/2019/09/14/2019-9-14-图的定义/1568445766494.png" alt="图3.7"><br>如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一颗有向树。</p><p>[1] 参考书籍：大话数据结构</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存泄漏与内存溢出</title>
      <link href="/2019/09/13/2019-9-13-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
      <url>/2019/09/13/2019-9-13-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-内存泄漏"><a href="#1-内存泄漏" class="headerlink" title="1. 内存泄漏"></a>1. 内存泄漏</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p><strong>内存泄漏是指一个不再被程序使用的对象或变量还在内存中占有存储空间</strong>。在C/C++语言中，内存的分配与释放是由开发人员来负责的，如果开发人员忘记释放已分配的内存就会造成内存泄漏。而在Java语言中引进了垃圾回收机制，由垃圾回收器负责回收不再使用的对象。既然有垃圾回收器来负责回收垃圾，那么是否还会存在内存泄漏的问题呢？</p><p>其实，在Java语言中，判断一个内存空间是否符合垃圾回收的标准有两个：第一，给对象赋了空值null，以后再也没有被使用过；第二，给对象赋予了新值，重新分配了内存空间。一般来讲，<strong>内存泄漏主要有两种情况：一是在堆中申请的空间没有被释放；二是对象已经不再被使用，但还仍然在内存中保留着。</strong> 垃圾回收机制的引入可以有效地解决第一种情况；而对于第二种情况，垃圾回收机制则无法保证不再使用的对象会被释放。<strong>因此，Java语言中的内存泄漏主要指的是第二种情况。</strong></p><a id="more"></a><p>下面通过一个示例来介绍Java语言中的内存泄漏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子的循环中，不断创建新的对象并加到Vector集合中，当退出循环后，对象o的作用域将会结束，但是由于v在使用这些对象，因此垃圾回收器无法将其回收，此时就造成了内存泄漏。只有将这些对象从Vector中删除才能释放创建的这些对象。</p><p>内存泄漏的典型例子是一个没有重写 hashCode 和 equals 方法的 Key 类在 HashMap 中作为键保存的情况， 最后会生成很多重复的对象。 所有的内存泄露最后都会抛出OutOfMemoryError 异常 （ Exception in thread “main”java.lang.OutOfMemoryError: Java heap space） 。</p><h2 id="1-2-内存泄露原因"><a href="#1-2-内存泄露原因" class="headerlink" title="1.2 内存泄露原因"></a>1.2 内存泄露原因</h2><p>在Java语言中，容易引起内存泄漏的原因有很多，主要有以下几个方面的内容：</p><ol><li><p>静态集合类，例如HashMap和Vector。如果这些容器是静态的，由于他们的生命周期与程序一致，那么容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏；</p></li><li><p>各种连接，例如数据库连接、网络连接以及IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显式地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏；</p></li><li><p>监听器。在Java语言中，往往会使用到监听器。通常一个应用中会用到多个监听器，但在释放对象的同时往往没有相应地删除监听器，这也可能导致内存泄漏。</p></li><li><p>变量不合理的作用域。一般而言，如果一个变量定义的作用范围大于其使用范围，有可能会造成内存泄漏，另一方面如果没有及时地把对象设置为null，很有可能会导致内存泄漏的发生，示例如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recieveMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readFromNet(); <span class="comment">// 从网络接收数据保存到msg中</span></span><br><span class="line">        saveDB(); <span class="comment">// 把msg保存到数据库中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在上述伪代码中，通过 readFromNet() 方法接收的消息保存在变量 msg 中，然后调用 saveDB() 方法把 msg 的内容保存到数据库中，此时 msg 已经没用了，但是由于 msg 的生命周期与对象的生命周期相同，此时 msg 还不能被回收，因此造成了内存泄漏。对于这个问题，有如下两种解决方法：第一种方法，由于 msg 的作用范围只在recieveMsg() 方法内，因此可以把 msg 定义为这个方法的局部变量，当方法结束后， msg 的生命周期就会结束，此时垃圾回收器就可以回收 msg  的内容了；第二种方法，在使用完 msg 后就把 msg 设置为 null，这样垃圾回收器就会自动回收 msg 内容所占的内存空间。</p></li><li><p>单例模式可能会造成内存泄漏。单例模式的实现方法有很多种，下例中所使用的单例模式就可能会造成内存泄漏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigClass bc;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance =  <span class="keyword">new</span> Singleton(<span class="keyword">new</span> BigClass());</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(BigClass bc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bc = bc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述实现的单例模式中，Singleton 存在一个对对象 BigClass 的引用，由于单例对象以静态变量的方式存储，因此它在 JVM 的整个生命周期中都存在，同时由于它有一个对对象 BigClass 的引用，这样会导致 BigClass类的对象不能被回收。</p></li></ol><h2 id="1-3-内存泄露解决方案"><a href="#1-3-内存泄露解决方案" class="headerlink" title="1.3 内存泄露解决方案"></a>1.3 内存泄露解决方案</h2><ol><li>避免在循环中创建对象。</li><li>尽早释放无用对象的引用。 （最基本的建议）</li><li>尽量少用静态变量， 因为静态变量存放在永久代（方法区） ， 永久代基本不参与垃圾回收。</li><li>使用字符串处理时， 避免使用 String， 应大量使用 StringBuffer，。因为每一个 String对象都得独立占用内存一块区域。</li></ol><h2 id="1-4-查找内存泄露"><a href="#1-4-查找内存泄露" class="headerlink" title="1.4 查找内存泄露"></a>1.4 查找内存泄露</h2><p>我们可以使用 JConsole 工具来查找是否存在内存泄漏现象。</p><p>没有内存泄露的：<br><img src="/2019/09/13/2019-9-13-内存泄漏与内存溢出/1568365028876.png" alt><br>造成内存泄露的： 如果内存的大小持续地增长， 则说明系统存在内存泄漏。<br><img src="/2019/09/13/2019-9-13-内存泄漏与内存溢出/1568365076467.png" alt></p><h1 id="2-内存溢出"><a href="#2-内存溢出" class="headerlink" title="2. 内存溢出"></a>2. 内存溢出</h1><p>内存溢出是指程序运行过程中无法申请到足够的内存而导致的一种错误。</p><p>内存溢出的几种情况（OOM 异常）：</p><p>除了程序计数器外， 虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError(OOM)异常的可能。</p><ol><li><p>虚拟机栈和本地方法栈溢出：如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError 异常；如果虚拟机在扩展栈时无法申请到足够的内存空间 ， 则抛出OutOfMemoryError 异常。</p></li><li><p>堆溢出：一般的异常信息如 java.lang.OutOfMemoryError:Java heap spaces。出现这种异常， 一般手段是先通过内存映像分析工具(如 Eclipse MemoryAnalyzer)对 dump 出来的堆转存快照进行分析， 重点是确认内存中的对象是否是必要的， 先分清是因为内存泄漏(Memory Leak)还是内存溢出(MemoryOverflow)。</p><p> 如果是内存泄漏， 可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收。</p><p> 如果不存在泄漏， 那就应该检查虚拟机的参数(-Xmx 与-Xms)的设置是否适当。</p></li><li><p>方法区溢出：异常信息如 java.lang.OutOfMemoryError:PermGen space。</p></li><li><p>运行时常量池溢出：异常信息如 java.lang.OutOfMemoryError:PermGen space</p></li></ol><h2 id="2-1-内存溢出原因"><a href="#2-1-内存溢出原因" class="headerlink" title="2.1 内存溢出原因"></a>2.1 内存溢出原因</h2><ol><li>内存中加载的数据量过于庞大， 如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用， 使用完后未清空， 使得 JVM 不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>启动参数内存值设定的过小。</li></ol><h2 id="2-2-内存溢出解决方案"><a href="#2-2-内存溢出解决方案" class="headerlink" title="2.2 内存溢出解决方案"></a>2.2 内存溢出解决方案</h2><p>第一步， 修改 JVM 启动参数， 直接增加内存。 (-Xms， -Xmx 参数一定不要忘记加。一般要将-Xms 和-Xmx 选项设置为相同， 以避免在每次 GC 后调整堆的大小； 建议堆的最大值设置为可用内存的最大值的 80%)。<br>第二步， 检查错误日志， 查看“OutOfMemory” 错误前是否有其它异常或错误。<br>第三步， 对代码进行走查和分析， 找出可能发生内存溢出的位置。<br>第四步， 使用内存查看工具动态查看内存使用情况（Jconsole）。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2019/09/13/2019-9-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/13/2019-9-13-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-贪心算法简介"><a href="#1-贪心算法简介" class="headerlink" title="1. 贪心算法简介"></a>1. 贪心算法简介</h1><h2 id="1-1-基本定义"><a href="#1-1-基本定义" class="headerlink" title="1.1 基本定义"></a>1.1 基本定义</h2><p>在贪婪算法(greedy method) 中，我们要逐步构造一个全局最优解。<strong>每一步，我们都在一定的标准下，做出一个最优决策</strong>。也就是说，不从整体最优上加以考虑，它所做出的仅是在某种意义上的<strong>局部最优解</strong>。做出决策所依据的标准称为贪心准则(greedy criterion)。</p><a id="more"></a><p>贪心算法每一步必须满足以下条件：</p><ol><li>可行的：即必须满足问题的约束。</li><li>局部最优：即当前步骤中所有可行选择中最佳的局部选择。</li><li>不可更改：即局部最优选择一旦做出，在算法的后面步骤就不可改变了。</li></ol><p><strong>注意</strong>：贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备<strong>无后效性</strong>，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><h2 id="1-2-贪心算法基本思路"><a href="#1-2-贪心算法基本思路" class="headerlink" title="1.2 贪心算法基本思路"></a>1.2 贪心算法基本思路</h2><ol><li>建立数学模型来描述问题。</li><li>把求解的问题分成若干个子问题。</li><li>对每一子问题求解，得到子问题的局部最优解。</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><h1 id="2-贪心算法最优性证明"><a href="#2-贪心算法最优性证明" class="headerlink" title="2. 贪心算法最优性证明"></a>2. 贪心算法最优性证明</h1><h2 id="2-1-贪心算法的前提"><a href="#2-1-贪心算法的前提" class="headerlink" title="2.1 贪心算法的前提"></a>2.1 贪心算法的前提</h2><p>贪心策略适用的前提是：<strong>局部最优策略能导致产生全局最优解。</strong></p><h2 id="2-2-最优子结构"><a href="#2-2-最优子结构" class="headerlink" title="2.2 最优子结构"></a>2.2 最优子结构</h2><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有<strong>最优子结构性质</strong>。</p><p>运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。</p><h2 id="2-3-贪心算法与动态规划的区别"><a href="#2-3-贪心算法与动态规划的区别" class="headerlink" title="2.3 贪心算法与动态规划的区别"></a>2.3 贪心算法与动态规划的区别</h2><ul><li>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</li><li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li><li>能用贪心解决的问题，也可以用动态规划解决。</li></ul><p>本文参考<a href="https://blog.csdn.net/Africa_South/article/details/87924966" target="_blank" rel="noopener">五大常用算法之一——贪心算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC日志</title>
      <link href="/2019/09/12/2019-9-12-GC%E6%97%A5%E5%BF%97/"/>
      <url>/2019/09/12/2019-9-12-GC%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p><strong>以ParallelGC为例</strong></p><p>YoungGC日志解释如下:</p><p><img src="/2019/09/12/2019-9-12-GC日志/1568302531360.jpg" alt></p><a id="more"></a><p>FullGC日志解释如下:</p><p><img src="/2019/09/12/2019-9-12-GC日志/1568302532317.jpg" alt></p><p>参考文章：<a href="https://blog.csdn.net/wanglha/article/details/48713217" target="_blank" rel="noopener">https://blog.csdn.net/wanglha/article/details/48713217</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Explain 工具的使用</title>
      <link href="/2019/09/12/2019-9-12-Explain-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/12/2019-9-12-Explain-%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">from</span> user_info <span class="keyword">WHERE</span>  <span class="keyword">id</span> &lt; <span class="number">300</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="二、准备"><a href="#二、准备" class="headerlink" title="二、准备"></a>二、准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span>   <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`age`</span>  <span class="built_in">INT</span>(<span class="number">11</span>)              <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_index`</span> (<span class="string">`name`</span>) <span class="comment">--索引</span></span><br><span class="line">)</span><br><span class="line">  <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'xys'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'a'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'b'</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'c'</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'d'</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'e'</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'f'</span>, <span class="number">21</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'g'</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'h'</span>, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_info (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (<span class="string">'i'</span>, <span class="number">15</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`order_info`</span> (</span><br><span class="line">  <span class="string">`id`</span>           <span class="built_in">BIGINT</span>(<span class="number">20</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`user_id`</span>      <span class="built_in">BIGINT</span>(<span class="number">20</span>)           <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`product_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`productor`</span>    <span class="built_in">VARCHAR</span>(<span class="number">30</span>)          <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`user_product_detail_index`</span> (<span class="string">`user_id`</span>, <span class="string">`product_name`</span>, <span class="string">`productor`</span>)</span><br><span class="line">)</span><br><span class="line">  <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span> = utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p2'</span>, <span class="string">'WL'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'p1'</span>, <span class="string">'DX'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">'p5'</span>, <span class="string">'WL'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="string">'p3'</span>, <span class="string">'MA'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">4</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">6</span>, <span class="string">'p1'</span>, <span class="string">'WHH'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> order_info (user_id, product_name, productor) <span class="keyword">VALUES</span> (<span class="number">9</span>, <span class="string">'p8'</span>, <span class="string">'TE'</span>);</span><br></pre></td></tr></table></figure><h2 id="三、EXPLAIN-输出格式"><a href="#三、EXPLAIN-输出格式" class="headerlink" title="三、EXPLAIN 输出格式"></a>三、EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from user_info where id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: user_info</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 8</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>各列的含义如下:</p><ul><li><p>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p>select_type: SELECT 查询的类型.</p></li><li><p>table: 查询的是哪个表</p></li><li><p>partitions: 匹配的分区</p></li><li><p>type: join 类型</p></li><li><p>possible_keys: 此次查询中可能选用的索引</p></li><li><p>key: 此次查询中确切使用到的索引.</p></li><li><p>key_len: 此次查询中使用到的索引的字节长度</p></li><li><p>ref: 哪个字段或常数与 key 一起被使用</p></li><li><p>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p>filtered: 表示此查询条件所过滤的数据的百分比</p></li><li><p>extra: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>select_type 表示了查询的类型, 它的常用取值有:</p><h4 id="1-SIMPLE"><a href="#1-SIMPLE" class="headerlink" title="1. SIMPLE"></a>1. SIMPLE</h4><p>SIMPLE 表示此查询不包含 UNION 查询或子查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301434.png" alt></p><h4 id="2-PRIMARY"><a href="#2-PRIMARY" class="headerlink" title="2. PRIMARY"></a>2. PRIMARY</h4><p>PRIMARY 表示此查询是最外层的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info  <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301436.png" alt></p><h4 id="3-UNION"><a href="#3-UNION" class="headerlink" title="3. UNION"></a>3. UNION</h4><p>UNION 表示此查询是 UNION 的第二或随后的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info  <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">IN</span> (<span class="number">6</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><p><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301438.png" alt></p><h4 id="4-UNION-RESULT"><a href="#4-UNION-RESULT" class="headerlink" title="4. UNION RESULT"></a>4. UNION RESULT</h4><p>UNION RESULT 表示 UNION 的结果</p><p>如上面3的例子：<br><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301439.png" alt></p><h4 id="5-DEPENDENT-UNION"><a href="#5-DEPENDENT-UNION" class="headerlink" title="5. DEPENDENT UNION"></a>5. DEPENDENT UNION</h4><p>DEPENDENT UNION 表示 UNION 中的第二个或后面的查询语句, 依赖于外面的查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> </span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> user_info x <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> </span><br><span class="line">    (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> user_info y </span><br><span class="line">     <span class="keyword">union</span> </span><br><span class="line">     <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> user_info z <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301440.png" alt></p><h4 id="6-SUBQUERY"><a href="#6-SUBQUERY" class="headerlink" title="6. SUBQUERY"></a>6. SUBQUERY</h4><p>SUBQUERY 表示子查询中的中的 SELECT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> user_info <span class="keyword">where</span> <span class="keyword">id</span> =</span><br><span class="line">(<span class="keyword">select</span> user_id <span class="keyword">from</span> order_info <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301442.png" alt></p><h4 id="7-DEPENDENT-SUBQUERY"><a href="#7-DEPENDENT-SUBQUERY" class="headerlink" title="7. DEPENDENT SUBQUERY"></a>7. DEPENDENT SUBQUERY</h4><p>DEPENDENT SUBQUERY 表示子查询中的= SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p><p>如上面6的例子：<br><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301444.png" alt></p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 字段比较重要, 它提供了判断查询是否高效的重要依据. 通过 type 字段, 我们判断此次查询是<strong>全表扫描</strong>还是<strong>索引扫描</strong>等.</p><h4 id="1-type-常用类型"><a href="#1-type-常用类型" class="headerlink" title="1. type 常用类型"></a>1. type 常用类型</h4><p>type 常用的取值有:</p><ul><li><p>system: 表中只有一条数据. 这个类型是特殊的 const 类型.</p></li><li><p>const: 针对<strong>主键或唯一索引的等值查询</strong>扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.<br><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301445.png" alt></p></li><li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info, order_info <span class="keyword">WHERE</span> user_info.id = order_info.user_id</span><br></pre></td></tr></table></figure><p>  <img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301446.png" alt></p></li><li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. 例如下面这个例子中, 就使用到了 ref 类型的查询:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info, order_info <span class="keyword">WHERE</span> user_info.id = order_info.user_id <span class="keyword">AND</span> order_info.user_id = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301447.png" alt></p></li><li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.</p><p>  例如下面的例子就是一个范围查询:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_info <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301490.png" alt></p></li><li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.</p><p>  index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.</p><p>  例如:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span>  user_info;</span><br></pre></td></tr></table></figure><p>  <img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301498.png" alt><br>  上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.</p></li><li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.</p><p>  下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> age <span class="keyword">FROM</span>  user_info <span class="keyword">WHERE</span> age = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301499.png" alt></p><h4 id="2-type-类型的性能比较"><a href="#2-type-类型的性能比较" class="headerlink" title="2. type 类型的性能比较"></a>2. type 类型的性能比较</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</span><br></pre></td></tr></table></figure><p>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.</p><p>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p><p>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.</p><p>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li></ul><ul><li>MEDIUMINT: 3字节</li></ul><ul><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li></ul></li><li><p>时间类型</p><ul><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li></ul></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul><p>我们来举两个简单的栗子:<br><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301500.png" alt><br>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEY user_product_detail_index (user_id, product_name, productor)</span><br></pre></td></tr></table></figure><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code>中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 key_length 应该是8.</p><p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:<br><img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301502.png" alt><br>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code>中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.</p><p>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都<strong>建议优化去掉</strong>, 因为这样的查询 CPU 资源消耗大.</p><p>  例如下面的例子:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> product_name</span><br></pre></td></tr></table></figure><p>  <img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301509.png" alt><br>  我们的索引是</p><p>  <code>KEY user_product_detail_index (user_id, product_name, productor)</code></p><p>  但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.</p><p>  如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id, product_name</span><br></pre></td></tr></table></figure><p>  <img src="/2019/09/12/2019-9-12-Explain-工具的使用/1568297301510.png" alt></p></li><li><p>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul><p>文章来源：<a href="https://segmentfault.com/a/1190000008131735#articleHeader8" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008131735#articleHeader8</a></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域</title>
      <link href="/2019/09/12/2019-9-12-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2019/09/12/2019-9-12-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一、运行时区域数据"><a href="#一、运行时区域数据" class="headerlink" title="一、运行时区域数据"></a>一、运行时区域数据</h2><p>Java 虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><p><img src="/2019/09/12/2019-9-12-Java内存区域/1577883510636.png" alt="1577883510636"></p><a id="more"></a><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong>程序计数器</strong></h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的<strong>字节码的行号指示器</strong>，即记录正在执行的虚拟机字节码指令的地址。如果正在执行的是本地方法则为空，因为该内存区域是唯一在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a><strong>Java虚拟机栈</strong></h3><p>其为虚拟机执行Java方法（也就是字节码）服务。每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><p><img src="/2019/09/12/2019-9-12-Java内存区域/1577883530934.png" alt="1577883530934"></p><p>可以通过 -Xss 这个虚拟机参数来指定一个程序的 Java 虚拟机栈内存大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xss=<span class="number">512</span>M HackTheJava</span><br></pre></td></tr></table></figure><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong>本地方法栈</strong></h3><p>与虚拟机栈相似，但其为虚拟机使用到的Native方法服务。</p><p>本地方法栈中方法使用的语言、使用方法与数据结构并没有强制规定，因此具体的虚拟机可以自由的实现它。</p><p><img src="/2019/09/12/2019-9-12-Java内存区域/1577883546602.png" alt="1577883546602"></p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong>Java堆</strong></h3><p>对大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。此区域的唯一目的是存放<strong>对象实例</strong>，几乎所有的对象实例都里分配内存。</p><p>Java堆是垃圾收集器管理的主要区域，因此也被成为“GC”堆。</p><p>现代的垃圾收集器基本都是采用分代收集算法，主要思想是针对不同的对象采取不同的垃圾回收算法。大部分虚拟机把 Java 堆分成以下两块（早期的Hotspot虚拟机把方法区当做堆的永久代）：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul><p>当一个对象被创建时，它首先进入新生代，之后有可能被转移到老年代中。</p><p>新生代存放着大量的生命很短的对象，因此新生代在三个区域中垃圾回收的频率最高。为了更高效地进行垃圾回收，把新生代继续划分成以下三个空间：</p><ul><li>Eden（伊甸园）</li><li>From Survivor（幸存者）</li><li>To Survivor</li></ul><p><img src="/2019/09/12/2019-9-12-Java内存区域/1577883561808.png" alt="1577883561808"></p><p>Java 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><p>可以通过 -Xms 和 -Xmx 两个虚拟机参数来指定一个程序的 Java 堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms=<span class="number">1</span>M -Xmx=<span class="number">2</span>M HackTheJava</span><br></pre></td></tr></table></figure><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong>方法区</strong></h3><p>方法区其用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、及时编译器编译后的代码等数据</strong>。</p><p>和 Java 堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p>JDK 1.7 之前，HotSpot 虚拟机把它当成永久代来进行垃圾回收，JDK 1.8 之后，取消了永久代，用 metaspace（元数据）区替代。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong>运行时常量池</strong></h3><p>运行时常量池是方法区的一部分。</p><p>Class文件中除了有类的版本、字段、方法、接口等<strong>描述信息</strong>外，还有一项信息是常量池（Constant Pool Table）用于存放编译期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a><strong>直接内存</strong></h3><p>直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。</p><p>在 JDK 1.4 中新加入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，即直接内存，然后通过一个存储在 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><h2 id="二、HotSpot虚拟机对象探秘"><a href="#二、HotSpot虚拟机对象探秘" class="headerlink" title="二、HotSpot虚拟机对象探秘"></a><strong>二、HotSpot虚拟机对象探秘</strong></h2><blockquote><p>探讨HotSpot虚拟机在Java堆中的对象分配、布局和访问的全过程</p></blockquote><h3 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a><strong>对象的创建过程</strong></h3><p>以下过程仅限于普通Java对象，不包括数组和Class对象等</p><ul><li>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在运行时常量池中定位到一个类的符号引用，并且检查这个符号引用的代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li><li>在类加载检查通过后，虚拟机将为新生对象分配内存。</li><li>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。</li><li>虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</li><li>执行new指令之后会接着执行<init>方法，按程序员的意愿进行对象的初始化，这样真正可用的对象才算完全产生。</init></li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a><strong>对象的内存布局</strong></h3><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><ul><li>对象头（Mark word）分为两部分：<ul><li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</li><li>第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。</li><li>另外，如果对象是一个Java数组，那个对象头中还必须有一块用于记录数组长度的数据。下表的即为对象头的的存储内容表：<br><img src="/2019/09/12/2019-9-12-Java内存区域/1577883574750.png" alt="1577883574750"></li></ul></li><li>实例数据：该部分是对象真正存储的有效信息，也是在程序代码中所要定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li><li>对齐填充：起占位符的作用。因为对象的大小必须是8字节的整数倍，而对象头的部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a><strong>对象的访问定位</strong></h3><p>Java程序通过栈上的reference数据来操作堆上的具体对象。主流的访问方式有使用<strong>句柄和直接指针方式。</strong></p><ul><li>如果使用句柄访问的话,那么Java堆中将会划分出一块内存来作为句柄池, reference中存储的就是对象的句柄地址,而句柄中包含了对象实例数据与类型数据各自的具体地址信息,如图2-2所示。</li></ul><p><img src="/2019/09/12/2019-9-12-Java内存区域/1577883584195.png" alt="1577883584195"></p><ul><li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关类型信息，而refrence中存储的直接就是对象地址，如图2-3所示。</li></ul><p><img src="/2019/09/12/2019-9-12-Java内存区域/1577883603412.png" alt="1577883603412"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收算法</title>
      <link href="/2019/09/12/2019-9-12-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/12/2019-9-12-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。<strong>垃圾回收主要是针对 Java 堆和方法区进行。</strong></p><a id="more"></a><h2 id="二、判断对象已死"><a href="#二、判断对象已死" class="headerlink" title="二、判断对象已死"></a>二、判断对象已死</h2><p>垃圾回收需要回收堆和方法区中的已死的对象，也就是已经变为垃圾的对象。但是我们需要判断哪些对象可回收哪些对象不可以。下面我们介绍两种判断方法，即引用计数法和可达性分析法。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法的大致执行过程为：首先，给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。<br>主流的Java虚拟机里面不会选用引用技术算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p>比如下图，虚拟机栈中objectA和objectB分别持有对堆中对象实例的引用，而堆中两个对象相互也有引用，此时堆中的两个对象实例的引用计算器值都为2。objectA和objectB不再持有对象实例的引用时，堆中的对象实例可以被视为垃圾，但是此时堆中的两个对象实例的引用计算器值却都为1，因此其很难解决对象之间相互循环引用的问题。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690767.png" alt><br>下面是相关的验证代码，运行参数设置为-verbose:gc -XX:+PrintGCDetails，这两个参数用于打印垃圾回收日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 起到占用内存的作用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objectA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objectB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objectA.instance = objectB;</span><br><span class="line">        objectB.instance = objectA;</span><br><span class="line"></span><br><span class="line">        objectA = <span class="keyword">null</span>;</span><br><span class="line">        objectB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现新生代被回收了，从22476K变为616K，也说明堆中的对象是有被回收的，也说明主流的Java虚拟机里面不会选用引用技术算法来管理内存。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690769.png" alt></p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690888.png" alt><br>算法基本思路：通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 可作为 GC Roots 的对象包含以下几种：</p><ul><li>虚拟机栈中引用的对象</li><li>本地方法栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用4种。</p><p><strong>（一）强引用</strong></p><p>   被强引用关联的对象<strong>不会被垃圾收集器回收</strong>，我们可以使用 new 一个新对象的方式来创建强引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p><strong>（二）软引用</strong></p><p>​    软引用是用来描述一些还有用但并非必需的对象。被软引用关联的对象，只有<strong>在内存不够的情况下才会被回收</strong>，使用 java.lang.ref.SoftReference 类来创建软引用，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 使对象只被软引用关联</span></span><br></pre></td></tr></table></figure><p><strong>（三）弱引用</strong></p><p> 若引用也是用来描述非必需对象的，但是他的强度比软引用更弱一些，被弱引用关联的对象一定会<strong>被垃圾收集器回收</strong>，也就是说它只能存活到下一次垃圾收集，可以使用 WeakReference 类来实现弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">WeakReference&lt;Object&gt; wf = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><strong>（四）虚引用</strong></p><p>​    虚引用又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。可以使用 PhantomReference 来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">PhantomReference&lt;Object&gt; pf = <span class="keyword">new</span> PhantomReference&lt;&gt;(obj);</span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>使在可达性分析算法中不可达的对象，也并非是要宣判“死亡”的，它们暂时都处于“缓刑”阶段，要真正宣告一个对象“死亡”，首先要经历<strong>两次标记过程</strong>：</p><ol><li>对象在进行可达性分析后发现没有与 GC Roots相连接的引用链，那它将会被第一次标记并进行一次筛选的条件是此对象是否有必要执行finalize方法。</li><li>当对象没有覆盖finaliza() 方法，或者finaliza() 方法已经被虚拟机调用过，虚拟机则会回收这个对象。否则执行finalize方法，此过程可能会将宣判“死亡”的对象“救活”。</li></ol><p><strong>对象复活</strong></p><p>如果实例对象被判定为有必要执行finaliza() 方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发此方法，但并不承诺会等待它运行结束。</p><p>因为如果一个对象在finaliza() 方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p><p><code>finaliza()</code> 方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行第二次小规模的标记。</p><p>如果对象想在<code>finaliza()</code> 方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，基本上它就被回收了。</p><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">【一次对象自我拯救的演示】</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> * 1.对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes, i am still alive :)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize mehtod executed!"</span>);</span><br><span class="line">        <span class="comment">//重新关联引用</span></span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//gc时会调用finalize方法</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 同样会再gc时调用finalize方法，但是finalize执行过一次了</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"no, i am dead :("</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><pre><code>finalize method executed!yes, i am still alive :)no, i am dead :(</code></pre><p>由以上结果可知，SAVE_HOOK 对象的<code>finalize()</code> 方法确实被GC收集器触发过，并且在收集前成功逃脱了。</p><p>另一个值得注意的地方，代码中有两段一模一样的代码段，执行结果却是一次逃脱成功，一次失败。</p><p><strong>这是因为任何一个对象的<code>finalize()</code> 方法都只会被系统调用一次，如果对象面临下一次回收，它的<code>finalize()</code> 方法不会再被执行，因此第二次逃脱行动失败。</strong></p><p><strong>执行过程：</strong></p><p><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690893.png" alt></p><p><strong>有关finaliza()方法的建议:</strong></p><ul><li><p>需要特别说的是，<code>finalize()</code> 方法，不建议开发人员使用这种方法拯救对象。</p></li><li><p>应当尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。</p></li><li><p>它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。</p></li><li><p>有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对此方法用途的一种自我安慰。</p></li><li><p><code>finalize()</code> 能做的工作，使用try-finally 或者其它方法都更合适和及时，所以<strong>作者建议大家可以忘掉此方法存在。</strong></p></li></ul><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><ul><li><p>废弃常量的回收：回收废弃常量与回收Java堆中的对象非常类似。以常量池中字符串常量的回收为例。例如一个字符串“abc”已经进入常量池，但是无任何String对象引用常量池的此常量，也无其它引用此字符串常量，“abc”常量会被系统清理出常量池。</p></li><li><p>无用类的回收：常量池中的其他类（接口）、方法、字段的符号引用也是如此。</p><p>判定一个类是否是“无用类”的3个条件：</p></li></ul><ul><li>该类的所有实例已被回收，也就是Java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法通过反射访问该类的方法。</li></ul><h2 id="三、垃圾收集算法"><a href="#三、垃圾收集算法" class="headerlink" title="三、垃圾收集算法"></a>三、垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>参看下图，标记-清除算法将存活的对象进行标记，然后清理掉未被标记的对象。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690890.jpg" alt><br>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>如下图所示，标记-整理算法让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，该算法主要用于老年代。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690891.jpg" alt></p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。参见下图。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690891.jpg" alt><br>复制算法主要不足是只使用了内存的一半，代价较高。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和较小的 From Survivor 和  To Survivor空间，参见下图。每次使用 Eden 空间和一块 From Survivor。在回收时，将 Eden 和 From Survivor 中还存活着的对象一次性复制到To Survivor 空间上，最后清理 Eden 和使用过的From Survivor。HotSpot 虚拟机的 Eden 和 From Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么To Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。<br><img src="/2019/09/12/2019-9-12-垃圾回收算法/1568301690892.png" alt></p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将 Java 堆分为新生代和老年代。</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清理 或者 标记 - 整理 算法</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配与回收策略</title>
      <link href="/2019/09/12/2019-9-12-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2019/09/12/2019-9-12-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Full-GC-与-Minor-GC"><a href="#一、Full-GC-与-Minor-GC" class="headerlink" title="一、Full GC 与 Minor GC"></a>一、Full GC 与 Minor GC</h3><ul><li><p>Minor GC 表示新生代GC：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生熄灭的特性，所以Minor GC会比较频繁，一般速度也比较快。</p></li><li><p>Full GC(Full GC/Major GC) 表示老年代GC：指发生在老年代的GC，出现了Full GC经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scanvenge收集器的收集策略里就有直接进行Full GC的策略选择过程）。Full GC的速度一般会比Minor GC慢10倍以上。</p></li></ul><p>Java虚拟机的内存分配主要遵循对象优先分配在Eden区，大对象和长期存活的对象分配在老年代、动态对象年龄判定以及空间分配担保策略。下面我们分别介绍这些策略。</p><a id="more"></a><h3 id="二、对象优先在Eden分配"><a href="#二、对象优先在Eden分配" class="headerlink" title="二、对象优先在Eden分配"></a>二、对象优先在Eden分配</h3><p>一般小对象的内存分配过程为先分配给新生代的Eden区，当Eden区不够存放时，则发生一次Minor GC，然后检查survivor区是否够存放一些小对象，能够则进行内存分配，不够则需在Minor GC时将一些对象分配到老年代中。</p><p>新生代的Minor GC 代码测试样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数解释：</span></span><br><span class="line"><span class="comment">     * -verbose:gc -XX:+PrintGCDetails 输出虚拟机中GC的详细信息</span></span><br><span class="line"><span class="comment">     * -Xms20M -Xmx20M 表示限制堆大小为20M, 且不能扩展</span></span><br><span class="line"><span class="comment">     * -Xmn10M 表示新生代占10M</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8 表示Eden区占新生代的80%，其他两个survivor各占10%</span></span><br><span class="line"><span class="comment">     * -XX:+UseSerialGC 表示虚拟机使用Serial收集器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><pre><code>[GC (Allocation Failure) [DefNew: 7292K-&gt;562K(9216K), 0.0252599 secs] 7292K-&gt;6706K(19456K), 0.0844557 secs] [Times: user=0.00 sys=0.01, real=0.09 secs]Heap def new generation   total 9216K, used 4740K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)  from space 1024K,  54% used [0x00000000ff500000, 0x00000000ff58c9c0, 0x00000000ff600000)  to   space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation   total 10240K, used 6144K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)   the space 10240K,  60% used [0x00000000ff600000, 0x00000000ffc00030, 0x00000000ffc00200, 0x0000000100000000) Metaspace       used 2714K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 302K, capacity 386K, committed 512K, reserved 1048576K</code></pre><p>结果分析：</p><p>Eden区的内存大小为8M，allocation1，allocation2，allocation3起初都分配在Eden区，共占6M。allocation4需要占用内存4M，因为Eden区不够存放allocation4且survivor区只有1M也不够存放其余三个对象。故老年代为allocation1，allocation2，allocation3这三个对象进行分配担保，也就是将它们分配到老年代中，然后Eden则存放4M的allocation4。所以最后我们可以发现Eden区大致占了50%的空间，老年代大致占了60%空间。</p><h3 id="三、大对象直接进入老年代"><a href="#三、大对象直接进入老年代" class="headerlink" title="三、大对象直接进入老年代"></a>三、大对象直接进入老年代</h3><p>所谓的大对象是指需要大量连续的内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，我们可以用运行参数-XX:PretenureSizeThreshold来具体指定多大的对象才是大对象。需要注意的是PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。</p><p>下面演示一下测试示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8 -XX:PretenureSizeThreshold=3M -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数解释：</span></span><br><span class="line"><span class="comment">     * -XX:PretenureSizeThreshold=3M 表示大于3M的对象为大对象，会直接存储在老年代中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><pre><code>Heap def new generation   total 9216K, used 1311K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  eden space 8192K,  16% used [0x00000000fec00000, 0x00000000fed47ff8, 0x00000000ff400000)  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation   total 10240K, used 4096K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)   the space 10240K,  40% used [0x00000000ff600000, 0x00000000ffa00010, 0x00000000ffa00200, 0x0000000100000000) Metaspace       used 2716K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 302K, capacity 386K, committed 512K, reserved 1048576K</code></pre><p>结果分析</p><p>运行参数中使用了-XX:PretenureSizeThreshold=3M  表示大于3M的大对象直接存储在老年代中，allocation的大小为4M故直接存储在老年代中，占老年代的40%的空间大小。</p><h3 id="四、长期存活的对象进入老年代"><a href="#四、长期存活的对象进入老年代" class="headerlink" title="四、长期存活的对象进入老年代"></a>四、长期存活的对象进入老年代</h3><p>如果对象在Eden区出生并经历过第一次Minor GC 后仍然存活，并且能被Survivor容纳的话，那么将被移动到Survivor区中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到15岁（默认）时，就将会进入到老年代中。 对象进入老年代的阈值，可以通过参数-XX:MaxTenuringThreshold来设置。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">     * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     * -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数解释：</span></span><br><span class="line"><span class="comment">     * -XX:MaxTenuringThreshold=1 设置对象的最大年龄为1</span></span><br><span class="line"><span class="comment">     * -XX:+PrintTenuringDistribution 打印对象的年龄信息等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        <span class="comment">//allocation1 首先进入Eden区，然后Minor GC后进入Survivor区年龄+1,</span></span><br><span class="line">        <span class="comment">//因为年龄最大为1，所以又从Survivor区进入老年代</span></span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];    <span class="comment">//首先进入Eden区，Minor GC后从Eden区进入老年代</span></span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];    <span class="comment">//Minor GC后进入Eden区</span></span><br><span class="line">        allocation3 = <span class="keyword">null</span>;</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testTenuringThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><pre><code>[GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1)- age   1:     837984 bytes,     837984 total: 5499K-&gt;818K(9216K), 0.0050120 secs] 5499K-&gt;4914K(19456K), 0.0050973 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1): 4914K-&gt;0K(9216K), 0.0015587 secs] 9010K-&gt;4913K(19456K), 0.0015969 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap def new generation   total 9216K, used 4178K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)  eden space 8192K,  51% used [0x00000000fec00000, 0x00000000ff014930, 0x00000000ff400000)  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation   total 10240K, used 4913K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)   the space 10240K,  47% used [0x00000000ff600000, 0x00000000ffacc570, 0x00000000ffacc600, 0x0000000100000000) Metaspace       used 2714K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 302K, capacity 386K, committed 512K, reserved 1048576K</code></pre><p>由上面的结果可以发现，Eden区最终占了约50%的空间，也就是allocation3 对象所占空间的大小。另外也可以发现老年代最终占了47%的空间，这部分的空间主要是allocation1 和allocation2两个对象所占据的空间大小。</p><h3 id="五、动态对象年龄判定"><a href="#五、动态对象年龄判定" class="headerlink" title="五、动态对象年龄判定"></a>五、动态对象年龄判定</h3><p>为了能更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于等于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _10MB = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM参数：-verbose:gc -Xms200M -Xmx200M -Xmn100M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment">     * -XX:+PrintTenuringDistribution -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_10MB / <span class="number">4</span>];   <span class="comment">// allocation1+allocation2大于等于survivo空间一半，且年龄相同</span></span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_10MB / <span class="number">4</span>];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _10MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _10MB];</span><br><span class="line">        allocation4 = <span class="keyword">null</span>;</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _10MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testTenuringThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>代码运行到allocation4的首次创建时由于新生代内存不够分配所以会发生一次Minor GC，此时会将对象allocation1，allocation2存放进Survivor中，将allocation3存放进老年代中。第二次创建allocation4时再次发生一次Minor GC，因为allocation1和allocation2为相同年龄且大小之和大于等于Survivor空间的一半，故将俩放进老年代中。</p><p>下面是运行输出的结果：</p><pre><code>[GC (Allocation Failure) [DefNewDesired survivor size 5242880 bytes, new threshold 1 (max 15)- age   1:    5818736 bytes,    5818736 total: 49356K-&gt;5682K(92160K), 0.0573769 secs] 49356K-&gt;46642K(194560K), 0.0574781 secs] [Times: user=0.00 sys=0.06, real=0.06 secs][GC (Allocation Failure) [DefNewDesired survivor size 5242880 bytes, new threshold 15 (max 15): 46642K-&gt;0K(92160K), 0.0061913 secs] 87602K-&gt;46641K(194560K), 0.0062212 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap def new generation   total 92160K, used 41779K [0x00000000f3800000, 0x00000000f9c00000, 0x00000000f9c00000)  eden space 81920K,  51% used [0x00000000f3800000, 0x00000000f60cce50, 0x00000000f8800000)  from space 10240K,   0% used [0x00000000f8800000, 0x00000000f8800000, 0x00000000f9200000)  to   space 10240K,   0% used [0x00000000f9200000, 0x00000000f9200000, 0x00000000f9c00000) tenured generation   total 102400K, used 46641K [0x00000000f9c00000, 0x0000000100000000, 0x0000000100000000)   the space 102400K,  45% used [0x00000000f9c00000, 0x00000000fc98c580, 0x00000000fc98c600, 0x0000000100000000) Metaspace       used 2717K, capacity 4486K, committed 4864K, reserved 1056768K  class space    used 302K, capacity 386K, committed 512K, reserved 1048576K</code></pre><p>由运行输出结果可以发现，Eden区所占的内存空间大小约占51%，也就是allocation4所占Eden空间大小的比例。老年代所占的空间大小为45%，也就是allocation1，allocation2和allocation3三个对象占总的老年代空间比例的大小。</p><h3 id="六、空间分配担保"><a href="#六、空间分配担保" class="headerlink" title="六、空间分配担保"></a>六、空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，因为进行空间分配担保时会将新生代的所有对象往老年代挪，那么就需要先确定老年代的空间是否足够存储这些对象。如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure参数设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure参数设置不允许冒险，那这时就要改为进行一次Full GC。</p><p>下面解释一下“冒险”是冒了什么风险，前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间。新生代在Minor GC后一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。</p><p>我们可以使用如下运行参数来设置HandlePromotionFailure开关：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:-HandlePromotionFailure // 关闭</span><br><span class="line">-XX:+HandlePromotionFailure // 打开</span><br></pre></td></tr></table></figure><p>其实我们在前面的事例中已经涉及到许多空间分配担保的例子，这里将不再赘述。</p><h3 id="七、Full-GC-的触发条件"><a href="#七、Full-GC-的触发条件" class="headerlink" title="七、Full GC 的触发条件"></a>七、Full GC 的触发条件</h3><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h6 id="1-调用-System-gc"><a href="#1-调用-System-gc" class="headerlink" title="1. 调用 System.gc()"></a>1. 调用 System.gc()</h6><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h6 id="2-老年代空间不足"><a href="#2-老年代空间不足" class="headerlink" title="2. 老年代空间不足"></a>2. 老年代空间不足</h6><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h6 id="3-空间分配担保失败"><a href="#3-空间分配担保失败" class="headerlink" title="3. 空间分配担保失败"></a>3. 空间分配担保失败</h6><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的内容。</p><h6 id="4-JDK-1-7-及以前的永久代空间不足"><a href="#4-JDK-1-7-及以前的永久代空间不足" class="headerlink" title="4. JDK 1.7 及以前的永久代空间不足"></a>4. JDK 1.7 及以前的永久代空间不足</h6><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h6 id="5-Concurrent-Mode-Failure"><a href="#5-Concurrent-Mode-Failure" class="headerlink" title="5. Concurrent Mode Failure"></a>5. Concurrent Mode Failure</h6><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾收集器</title>
      <link href="/2019/09/12/2019-9-12-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/2019/09/12/2019-9-12-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>以下是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519686.png" alt></p><ul><li>单线程与并行（多线程）：单线程指的是垃圾收集器只使用一个线程进行收集，而并行使用多个线程。</li><li>串行与并发：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并发指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。<a id="more"></a><h3 id="一、Serial收集器"><a href="#一、Serial收集器" class="headerlink" title="一、Serial收集器"></a>一、Serial收集器</h3>Serial收集器单线程的新生代收集器，其执行过程如下图所示：<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519545.jpg" alt><br>Serial 翻译为串行，也就是说它以串行的方式执行。它是单线程的垃圾收集器，只会使用一个线程进行垃圾收集工作。</li></ul><p>它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。</p><h3 id="二、ParNew收集器"><a href="#二、ParNew收集器" class="headerlink" title="二、ParNew收集器"></a>二、ParNew收集器</h3><p>ParNew收集器是Serial收集器的多线程版本，是多线程的新生代收集器。其执行流程如下如所示：<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519610.jpg" alt><br>它是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为<strong>除了 Serial 收集器，只有它能与 CMS 收集器配合工作。</strong></p><p>默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。</p><h3 id="三、Parallel-Scavenge-收集器"><a href="#三、Parallel-Scavenge-收集器" class="headerlink" title="三、Parallel Scavenge 收集器"></a>三、Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器是多线程的新生代收集器，其与ParNew收集器的功能大致相同，但其更关注吞吐量。</p><p>其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值，总时间即为执行用户代码的时间与垃圾回收时间之和。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>虚拟机提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX:GCTimeRatio 参数（值为大于 0 且小于 100 的整数）。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的，因为新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>虚拟机还提供了一个参数 -XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为 GC 自适应的调节策略（GC Ergonomics）。</p><h3 id="四、Serial-Old收集器"><a href="#四、Serial-Old收集器" class="headerlink" title="四、Serial Old收集器"></a>四、Serial Old收集器</h3><p>Serial Old收集器是Serial收集器的老年代版本，单线程收集器，可以给 Client 模式下的虚拟机使用。其执行流程如下图所示：<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519640.jpg" alt></p><p>如果用在 Server 模式下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure（后面解释） 时使用。</li></ul><h3 id="五、Parallel-Old收集器"><a href="#五、Parallel-Old收集器" class="headerlink" title="五、Parallel Old收集器"></a>五、Parallel Old收集器</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，多线程的老年代收集器。其运行流程如下图所示：<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519645.jpg" alt><br>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3 id="六、CMS收集器"><a href="#六、CMS收集器" class="headerlink" title="六、CMS收集器"></a>六、CMS收集器</h3><p>CMS（Concurrent Mark Sweep），其中 Mark Sweep 指的是标记 - 清除算法。特点是并发收集、低停顿。</p><p>参考下图，其垃圾收集分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519679.jpg" alt><br>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</li></ul><p>CMS收集器具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将启动后备预案：临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次垃圾回收。</li></ul><h3 id="七、G1收集器"><a href="#七、G1收集器" class="headerlink" title="七、G1收集器"></a>七、G1收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>Java 堆被分为新生代、老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519681.png" alt><br>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录引用的 Region的位置。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>参考下图，如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li><p>初始标记</p></li><li><p>并发标记</p></li><li><p>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。最终标记这阶段需要停顿线程，但是可并行执行。</p></li><li><p>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。<br><img src="/2019/09/12/2019-9-12-垃圾收集器/1568301519684.jpg" alt><br>G1收集器具备如下特点：</p></li><li><p>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</p></li><li><p>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</p></li></ul><h3 id="八、比较"><a href="#八、比较" class="headerlink" title="八、比较"></a>八、比较</h3><table><thead><tr><th align="center">收集器</th><th align="center">单线程/并行</th><th align="center">串行/并发</th><th align="center">新生代/老年代</th><th align="center">收集算法</th><th align="center">目标</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center"><strong>Serial</strong></td><td align="center">单线程</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制</td><td align="center">响应速度优先</td><td align="center">单 CPU 环境下的 Client 模式</td></tr><tr><td align="center"><strong>Serial Old</strong></td><td align="center">单线程</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">响应速度优先</td><td align="center">单 CPU 环境下的 Client 模式、CMS 的后备预案</td></tr><tr><td align="center"><strong>ParNew</strong></td><td align="center">并行</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">响应速度优先</td><td align="center">多 CPU 环境时在 Server 模式下与 CMS 配合</td></tr><tr><td align="center"><strong>Parallel Scavenge</strong></td><td align="center">并行</td><td align="center">串行</td><td align="center">新生代</td><td align="center">复制算法</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互的任务</td></tr><tr><td align="center"><strong>Parallel Old</strong></td><td align="center">并行</td><td align="center">串行</td><td align="center">老年代</td><td align="center">标记-整理</td><td align="center">吞吐量优先</td><td align="center">在后台运算而不需要太多交互的任务</td></tr><tr><td align="center"><strong>CMS</strong></td><td align="center">并行</td><td align="center">并发</td><td align="center">老年代</td><td align="center">标记-清除</td><td align="center">响应速度优先</td><td align="center">集中在互联网站或 B/S 系统服务端上的 Java 应用</td></tr><tr><td align="center"><strong>G1</strong></td><td align="center">并行</td><td align="center">并发</td><td align="center">新生代 + 老年代</td><td align="center">标记-整理 + 复制算法</td><td align="center">响应速度优先</td><td align="center">面向服务端应用，将来替换 CMS</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载机制</title>
      <link href="/2019/09/12/2019-9-12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/09/12/2019-9-12-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>在Class文件中描述的各种信息，最终都需要加载到虚拟机中之后才能运行和使用。虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程就是虚拟机的类加载机制。</p><p>在Java语言里面，类的加载、连接和初始化过程都是在程序运行期间完成的，也就是具有运行期动态加载和动态连接的特点。</p><a id="more"></a><h2 id="一、类的生命周期"><a href="#一、类的生命周期" class="headerlink" title="一、类的生命周期"></a>一、类的生命周期</h2><div align="center"> <img src="/2019/09/12/2019-9-12-类加载机制/1568302011476.png" width> </div><p>参考上图，类的生命周期包括以下 7 个阶段：</p><ul><li><strong>加载（Loading）</strong></li><li><strong>验证（Verification）</strong></li><li><strong>准备（Preparation）</strong></li><li><strong>解析（Resolution）</strong></li><li><strong>初始化（Initialization）</strong></li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><h2 id="二、类加载时机"><a href="#二、类加载时机" class="headerlink" title="二、类加载时机"></a>二、类加载时机</h2><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了<strong>有且只有</strong>下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li><p>遇到 new、getstatic、putstatic、invokestatic 这四条<strong>字节码指令</strong>时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。</p></li><li><p>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；</p></li><li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；</p></li></ul><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括如下：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);  <span class="comment">// value 字段在 SuperClass 中定义</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对<strong>数组类</strong>进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure><h2 id="三、类加载过程"><a href="#三、类加载过程" class="headerlink" title="三、类加载过程"></a>三、类加载过程</h2><p>类加载的全过程包含了加载、验证、准备、解析和初始化这 5 个阶段。</p><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p><p>加载过程完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。</li><li>在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>其中获取类的二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，这种场景最典型的应用是 Applet。</li><li>运行时计算生成，这种场景使用得最多得就是动态代理技术，在 java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。</li><li>从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。</li></ul><p>加载阶段与连接阶段的部分内容（如一部分字节码文件格式的验证动作）是交互进行的，加载阶段尚未完成，连接阶段可能已经开始，当然两个阶段的开始时间仍然保持着固定的先后顺序。</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>验证阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致上会完成下面4个阶段的校验动作：</p><ul><li><p>文件格式验证：验证字节流是否符合 Class 文件格式的规范，如二进制文件内容必须以0xCAFEBABE开头，并且能被当前版本的虚拟机处理。</p></li><li><p>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。</p></li><li><p>字节码验证：通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。</p></li><li><p>符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。通常需要校验下列内容：</p><p>  ■ 符号引用中通过字符串描述的全限定类名是否能够找到对应的类；<br>  ■ 在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段；<br>  ■ 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可以被当前类访问。<br>  ……..</p></li></ul><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p>准备阶段是正式为类变量（即static修饰的变量）分配内存并设置初始值的阶段，使用的是方法区的内存。</p><p>实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）</p><p>整型变量初始值一般为 0 值，例如下面的类变量 value 在准备阶段过后被初始化为 0 而不是 123。因为这时候尚未开始执行任何Java代码，而把value赋值为123是程序被编译的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>如果类变量是常量，那么会按照指定的赋值表达式来进行初始化，而不是赋值为 0。比如下面的常量value在准备阶段就会被初始化为123，而不是0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析阶段主要包括类或接口的解析、字段解析、类方法解析和接口方法解析这四种引用的解析。</p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段才真正开始执行类中的定义的 Java 程序代码。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源，或者可以从另外一个角度来表达：初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。</p><p>&lt;clinit&gt;() 方法具有以下特点：</p><ul><li><p>&lt;clinit&gt;() 方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在<strong>源文件</strong>中出现的顺序决定。需要特别注意的是，静态语句块能访问和赋值定义在它之前的类变量，而定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态语句块能访问和赋值定义在它之前的类变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">1</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------</span></span><br><span class="line">    <span class="comment">// 定义在静态语句块之后的类变量只能赋值，不能访问</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        i = <span class="number">0</span>;                <span class="comment">// 给变量赋值可以正常编译通过</span></span><br><span class="line">        System.out.print(i);  <span class="comment">// 这句编译器会提示“非法向前引用”</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&lt;clinit&gt;() 方法与类的构造函数（或者说实例构造器 &lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 &lt;clinit&gt;() 方法运行之前，父类的 &lt;clinit&gt;() 方法已经执行结束。因此虚拟机中第一个执行 &lt;clinit&gt;() 方法的类肯定为 java.lang.Object。</p></li><li><p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     System.out.println(Sub.B);  <span class="comment">// 输出结果是父类中的静态变量 A 的值，也就是 2。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>&lt;clinit&gt;() 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 &lt;clinit&gt;() 方法。</p></li><li><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p></li><li><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p></li></ul><h2 id="四、类加载器"><a href="#四、类加载器" class="headerlink" title="四、类加载器"></a>四、类加载器</h2><p>虚拟机把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到  Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><h3 id="1-类与类加载器"><a href="#1-类与类加载器" class="headerlink" title="1. 类与类加载器"></a>1. 类与类加载器</h3><p>类加载器只用于实现类的加载动作，对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机的唯一性，每一个类加载器，都拥有一个独立的类名称空间。若要比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</p><p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p><h3 id="2-类加载器分类"><a href="#2-类加载器分类" class="headerlink" title="2. 类加载器分类"></a>2. 类加载器分类</h3><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++ 实现，是虚拟机自身的一部分；</p></li><li><p>所有其他类的加载器，这些类由 Java 实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。</p></li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）这个类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。</p></li><li><p>扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li><li><p>自定义类加载器（User ClassLoader）</p></li></ul><h3 id="3-双亲委派模型"><a href="#3-双亲委派模型" class="headerlink" title="3. 双亲委派模型"></a>3. 双亲委派模型</h3><p>应用程序都是由启动类加载器、扩展类加载器和应用程序类加载器这三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p><p>下图展示的是类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。</p><div align="center"> <img src="/2019/09/12/2019-9-12-类加载机制/1568302011436.png" width="600"> </div><br><h4 id="（一）工作过程"><a href="#（一）工作过程" class="headerlink" title="（一）工作过程"></a>（一）工作过程</h4><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p><h4 id="（二）好处"><a href="#（二）好处" class="headerlink" title="（二）好处"></a>（二）好处</h4><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 的类并放到 ClassPath 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。因此Object类在程序的各种类加载器环境中都是同一个类，而不会出现多个不同的Object类以此无法保证Java类型体系中最基础的行为。</p><h4 id="（三）实现"><a href="#（三）实现" class="headerlink" title="（三）实现"></a>（三）实现</h4><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The parent class loader for delegation</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;<span class="comment">//未加载过</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//调用父类加载器加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//父类加载器为空则默认使用启动类加载器作为父类加载器</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 父类加载器调用失败则调用自己的findClass进行加载</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-自定义类加载器实现"><a href="#4-自定义类加载器实现" class="headerlink" title="4. 自定义类加载器实现"></a>4. 自定义类加载器实现</h3><p>FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载<strong>文件系统</strong>上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rootDir = rootDir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = getClassData(name);</span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 把字节代码转换成 java.lang.Class 类的实例</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取类的字节码数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</span><br><span class="line">        String path = classNameToPath(className);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream ins = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">            <span class="keyword">int</span> bytesNumRead;</span><br><span class="line">            <span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, bytesNumRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件路劲</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rootDir + File.separatorChar</span><br><span class="line">                + className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机工具</title>
      <link href="/2019/09/12/2019-9-12-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/09/12/2019-9-12-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JDK-命令行工具"><a href="#一、JDK-命令行工具" class="headerlink" title="一、JDK 命令行工具"></a>一、JDK 命令行工具</h2><p>Java的bin目录下有很多命令行工具，比如我们熟悉的“java.exe”和“javac.exe”，下面我们将介绍一些用于监视虚拟机和故障处理的工具，主要如下表所示：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277397.png" alt></p><h3 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h3><p>jps工具可以列出正在运行的虚拟机进程，并显示虚拟机执行主类的名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。<br> <a id="more"></a><br> <strong>jps 命令格式：</strong></p><pre><code>jps [options] [hostid]</code></pre><p>其中hostid一般指的是远程的主机id，而jps常用的操作选项具体见下表：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277400.png" alt><br><strong>jps执行样例：</strong><br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277115.png" alt><br>由上图知，其中id为40684的线程为后台启动eclipse的线程，而67372即为工具jps的线程id。</p><h3 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h3><p>jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的<strong>类装载、内存、垃圾收集、JIT编译等运行数据</strong>。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p><p><strong>jstat命令格式为：</strong></p><pre><code>jstat [ option  vmid [interval [s|ms]] [count] ]</code></pre><p>其中vmid表示虚拟机进程id，参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。</p><p>为了知道Java堆的垃圾收集中的不同区的情况，比如不同区的容量，已用空间等，并且需要每1000毫秒查询一次进程的状况，一共查询10次，那命令应当是：</p><pre><code>jstat -gc 40684 1000 10</code></pre><p>选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、垃圾收集、运行期编译状况，具体选项及其作用参考下表：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277403.png" alt><br>要了解更多信息，可以访问<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" target="_blank" rel="noopener">官网</a>了解更多命令的解释以及使用方式。</p><h3 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h3><p>jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。</p><p><strong>jinfo命令格式：</strong></p><pre><code>jinfo [ option ] pid</code></pre><p>其中option所支持的参数主要如下图所示：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277215.png" alt><br><strong>jinfo执行样例：</strong></p><p>比如我们我们想查看虚拟机的各项参数，比如堆空间的最大值，使用的垃圾收集器等，可以执行如下语句，其中40684为线程id：</p><pre><code>jinfo -flags 40684</code></pre><p>其输出结果具体如下图所示：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277294.png" alt><br>另外，也可以判断当前虚拟机是否使用到了指定的垃圾收集器，具体指令和结果如下图所示：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277298.png" alt><br>其中+号表示有使用，-号则相反。</p><p>需要注意的是，jinfo有些操作在windows系统是受限的，比如操作sysprops在windows系统就不能执行。</p><h3 id="jmap：Java内存映像工具"><a href="#jmap：Java内存映像工具" class="headerlink" title="jmap：Java内存映像工具"></a>jmap：Java内存映像工具</h3><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为headump或dump文件），它还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。同jinfo命令一样，jmap有不少功能在Windows操作系统下是受限的。</p><p><strong>jmap命令格式：</strong></p><pre><code>jmap [ option ] vmid</code></pre><p>option 选项的合法值与具体含义具体如下表所示：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277401.png" alt></p><h3 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h3><p>Sun JDK 提供jhat（JVM Head Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中键入<a href="http://localhost:7000" target="_blank" rel="noopener">http://localhost:7000</a> 来查看分析结果，比如下图示例：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277402.png" alt><br>不过我们一般不会使用jhat去分析dump文件，而是选用我们后面将会讲到的更加强大的VisualVM可视化工具。</p><h3 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h3><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。线程出现停顿的时候用jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。</p><p><strong>jstack命令格式：</strong></p><pre><code>jstack [ option ] vmid</code></pre><p>option选项的合法值与具体含义见下表：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277301.png" alt></p><h2 id="二、JDK-可视化工具"><a href="#二、JDK-可视化工具" class="headerlink" title="二、JDK 可视化工具"></a>二、JDK 可视化工具</h2><p>JDK中除了提供大量的命令行工具外，还有两个功能强大的可视化工具：JConsole和VisualVM。下面介绍一下这两个工具。</p><h3 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h3><p>JConsole是一种基于JMX的可视化监视、管理工具。我们可以通过JDK/bin目录下的“jconsole.exe”来启动JConsole，并会显示如下连接页面：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277303.png" alt><br>其中本地进程中显示的是本机运行的所有虚拟机进程列表，我们只需双击选择其中一个进程即可开始监控指定虚拟机线程。</p><p>下面我们执行如下JConsole监视代码，然后观察JConsole中界面的变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JConsoleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JConsoleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//停顿5s，用于人工进行监控连接操作</span></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;JConsoleTest&gt; jList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//稍作停顿，令监视曲线的变化更为明显</span></span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            jList.add(<span class="keyword">new</span> JConsoleTest());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是概览，包括堆内存使用量，线程使用等多种情况：<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277304.png" alt><br>下面两张图显示的是堆内存使用量的变化情况以及老年代的变化情况，当然我们也可以点击下拉列表选择查看其他区域的变化情况。<br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277368.png" alt><br><img src="/2019/09/12/2019-9-12-虚拟机工具/1568302277396.png" alt><br>JConsole除了能够内存监控之外，还可以进行线程监控如查看是否死锁和类监控等，这里就不再展开说明。</p><h3 id="VisualVM：多合一故障处理工具"><a href="#VisualVM：多合一故障处理工具" class="headerlink" title="VisualVM：多合一故障处理工具"></a>VisualVM：多合一故障处理工具</h3><p>VisualVM是到目前为止随JDK发布以来的功能最强大的运行监视可故障处理程序，官方在VisualVM的软件说明中写上了“All-in-One”的描述字样，预示着它除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析，生成和浏览堆转储快照，BTrace动态日志跟踪等功能。可以上其<a href="https://visualvm.github.io/index.html" target="_blank" rel="noopener">官网</a>进行工具的下载安装和使用。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（一）MySQL 索引数理基础</title>
      <link href="/2019/09/12/2019-9-12-%EF%BC%88%E4%B8%80%EF%BC%89MySQL-%E7%B4%A2%E5%BC%95%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/09/12/2019-9-12-%EF%BC%88%E4%B8%80%EF%BC%89MySQL-%E7%B4%A2%E5%BC%95%E6%95%B0%E7%90%86%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>本系列文章摘抄自<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>。</p><p>本系列文章以MySQL数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是，MySQL支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此MySQL数据库支持多种索引类型，如BTree索引，哈希索引，全文索引等等。为了避免混乱，我们将只关注于BTree索引，因为这是平常使用MySQL时主要打交道的索引，至于哈希索引和全文索引暂不讨论。</p><a id="more"></a><h1 id="一、索引的本质"><a href="#一、索引的本质" class="headerlink" title="一、索引的本质"></a>一、索引的本质</h1><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：<strong>索引是数据结构</strong>。</p><p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p><p>看一个例子：</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184905.png"></div><p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p><p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍。</p><h1 id="二、B-Tree和B-Tree"><a href="#二、B-Tree和B-Tree" class="headerlink" title="二、B-Tree和B+Tree"></a>二、B-Tree和B+Tree</h1><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，我们后面会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引。</p><p>下面我们先从数据结构层面来介绍B-Tree和B+Tree索引结构。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>为了描述B-Tree，首先定义一条数据记录（节点）为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p><ul><li><p>d为大于1的一个正整数，称为B-Tree的度。</p></li><li><p>h为一个正整数，称为B-Tree的高度。</p></li><li><p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p></li><li><p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p></li><li><p>所有叶节点具有相同的深度，等于树高h。</p></li><li><p>key和指针互相间隔，节点两端是指针。</p></li><li><p>一个节点中的key从左到右非递减排列。</p></li><li><p>每个指针要么为null，要么指向另外一个节点。</p></li><li><p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。</p></li><li><p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。</p></li><li><p>如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。</p></li></ul><p>图2是一个d=2的B-Tree示意图：</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184908.png"></div><p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到对应的key则返回对应的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点中对应的key或找到null指针，前者查找成功，后者查找失败。</p><p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p><p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p><p>与B-Tree相比，B+Tree有以下不同点：</p><ul><li><p>每个节点的指针上限为2d而不是2d+1。</p></li><li><p>非叶子节点不存储data，只存储key；叶子节点不存储指针。</p></li></ul><p>图3是一个简单的B+Tree示意：</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184909.png"></div><p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和非叶节点一般大小不同。这点与B-Tree不一样，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p><p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p><h2 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h2><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184911.png"></div><p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高<code>区间访问</code>的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p><p>上面对B-Tree和B+Tree进行了一个简单的介绍，下面结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p><h1 id="三、为什么使用B-Tree（B-Tree）"><a href="#三、为什么使用B-Tree（B-Tree）" class="headerlink" title="三、为什么使用B-Tree（B+Tree）"></a>三、为什么使用B-Tree（B+Tree）</h1><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，下面将结合<strong>计算机组成原理</strong>相关知识讨论B-/+Tree作为索引的理论基础。</p><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。</p><p>下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p><h2 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h2><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184912.png"></div><p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p><p>主存的存取过程如下：</p><p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p><p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p><p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p><h2 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h2><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p><p>图6是磁盘的整体结构示意图：</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184960.png"></div><p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p><p>图7是磁盘结构的示意图：</p><div align="center"><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684184994.png"></div><p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p><p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p><h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h2><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百万分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><ul><li><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p></li><li><p>程序运行期间所需要的数据通常比较集中。</p></li></ul><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中（预读），然后异常返回，程序继续运行。</p><h2 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h2><p>到这里终于可以分析B-/+Tree索引的性能了。</p><p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p><code>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</code></p><p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3），所以I/O次数也非常少。</p><p>综上所述，用B-Tree作为索引结构效率是非常高的。</p><p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p><p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：<br><img src="/2019/09/12/2019-9-12-（一）MySQL-索引数理基础/1568684185029.png" alt><br>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p><p>本文从理论角度讨论了与索引相关的数据结构与算法问题，下一篇文章将讨论B+Tree作为MySQL的索引结构的具体实现，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（三）MySQL 索引使用策略及优化</title>
      <link href="/2019/09/12/2019-9-12-%EF%BC%88%E4%B8%89%EF%BC%89MySQL-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2019/09/12/2019-9-12-%EF%BC%88%E4%B8%89%EF%BC%89MySQL-%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>本系列文章摘抄自<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>，基于本文，本人对此进行了一些修改和补充。</p><p>MySQL的优化主要分为<code>结构优化</code>（Scheme optimization）和<code>查询优化</code>（Query optimization）。本文讨论的高性能索引策略主要属于结构优化范畴。本文的内容完全基于前面两篇文章的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p><a id="more"></a><h1 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h1><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p><div align="center"><img src="/2019/09/12/2019-9-12-（三）MySQL-索引使用策略及优化/1568300406537.png"></div><p>MySQL官方文档中关于此数据库的页面为 <a href="https://dev.mysql.com/doc/employee/en/employees-installation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/employee/en/employees-installation.html</a> 。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</p><h1 id="二、最左前缀原理与相关优化"><a href="#二、最左前缀原理与相关优化" class="headerlink" title="二、最左前缀原理与相关优化"></a>二、最左前缀原理与相关优化</h1><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p>这里先说一下<code>联合索引</code>的概念。MySQl 的索引可以引用单个的列，实际上，MySQL中的索引也可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p><p>以employees.titles表为例，下面先查看其上都有哪些索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> employees.titles;</span><br><span class="line">+<span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+</span></span><br><span class="line">| Table  | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | <span class="keyword">Comment</span> | Index_comment | <span class="keyword">Visible</span> |</span><br><span class="line">+<span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+</span></span><br><span class="line">| titles |          <span class="number">0</span> | PRIMARY  |            <span class="number">1</span> | emp_no      | A         |           <span class="number">0</span> |     <span class="literal">NULL</span> |   <span class="literal">NULL</span> |      | BTREE      |         |               | YES     |</span><br><span class="line">| titles |          <span class="number">0</span> | PRIMARY  |            <span class="number">2</span> | title       | A         |           <span class="number">0</span> |     <span class="literal">NULL</span> |   <span class="literal">NULL</span> |      | BTREE      |         |               | YES     |</span><br><span class="line">| titles |          <span class="number">0</span> | PRIMARY  |            <span class="number">3</span> | from_date   | A         |           <span class="number">0</span> |     <span class="literal">NULL</span> |   <span class="literal">NULL</span> |      | BTREE      |         |               | YES     |</span><br><span class="line">+<span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+</span></span><br></pre></td></tr></table></figure><p>从结果中可以看到titles表的主索引为&lt;emp_no, title, from_date&gt;。</p><h2 id="情况一：全列匹配。"><a href="#情况一：全列匹配。" class="headerlink" title="情况一：全列匹配。"></a>情况一：全列匹配。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title=<span class="string">'Senior Engineer'</span> <span class="keyword">AND</span> from_date=<span class="string">'1986-06-26'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | const | PRIMARY       | PRIMARY | 159     | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，所以两者效果是一样的。例如我们将where中的条件顺序颠倒：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date=<span class="string">'1986-06-26'</span> <span class="keyword">AND</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title=<span class="string">'Senior Engineer'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref               | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | const | PRIMARY       | PRIMARY | 159     | const,const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+-------------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><h2 id="情况二：最左前缀匹配。"><a href="#情况二：最左前缀匹配。" class="headerlink" title="情况二：最左前缀匹配。"></a>情况二：最左前缀匹配。</h2><p>当查询条件精确匹配索引的左边<code>连续</code>一个或几个列，如<emp_no>，&lt;emp_no, title&gt;，&lt;emp_no, title, from_date&gt;时，所以索引可以被用到，但是前两个只能用到一部分，后面一个相当于全列匹配即都可以用到，我们可以说符合这些条件即符合最左前缀匹配。</emp_no></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><h2 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> from_date=<span class="string">'1986-06-26'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p>首先我们看下title一共有几种不同的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(title) <span class="keyword">FROM</span> employees.titles;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| title              |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Senior Engineer    |</span><br><span class="line">| Staff              |</span><br><span class="line">| Engineer           |</span><br><span class="line">| Senior Staff       |</span><br><span class="line">| Assistant Engineer |</span><br><span class="line">| Technique Leader   |</span><br><span class="line">| Manager            |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span></span><br><span class="line"><span class="keyword">AND</span> title <span class="keyword">IN</span> (<span class="string">'Senior Engineer'</span>, <span class="string">'Staff'</span>, <span class="string">'Engineer'</span>, <span class="string">'Senior Staff'</span>, <span class="string">'Assistant Engineer'</span>, <span class="string">'Technique Leader'</span>, <span class="string">'Manager'</span>)</span><br><span class="line"><span class="keyword">AND</span> from_date=<span class="string">'1986-06-26'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 159     | NULL |    7 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>这次key_len为159，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较（这里用到了<code>SHOW PROFILES</code>命令，关于该命令的使用可以参考其他文章）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROFILES</span>;</span><br><span class="line">+<span class="comment">----------+------------+-------------------------------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                                         |</span><br><span class="line">+<span class="comment">----------+------------+-------------------------------------------------------------------------------+</span></span><br><span class="line">|       10 | 0.00140475 | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> from_date=<span class="string">'1986-06-26'</span>|</span><br><span class="line">|       <span class="number">11</span> | <span class="number">0.00070325</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title <span class="keyword">IN</span> ...          |</span><br><span class="line">+<span class="comment">----------+------------+-------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>“填坑”后性能提升了一些。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><h2 id="情况四：查询条件没有指定索引第一列。"><a href="#情况四：查询条件没有指定索引第一列。" class="headerlink" title="情况四：查询条件没有指定索引第一列。"></a>情况四：查询条件没有指定索引第一列。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date=<span class="string">'1986-06-26'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   28 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h2 id="情况五：范围查询。"><a href="#情况五：范围查询。" class="headerlink" title="情况五：范围查询。"></a>情况五：范围查询。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no &lt; <span class="string">'10010'</span> <span class="keyword">and</span> title=<span class="string">'Senior Engineer'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   14 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no != <span class="string">'10010'</span> <span class="keyword">and</span> title=<span class="string">'Senior Engineer'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   27 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引，所以索引最多用于一个范围列，因为第一个范围列之后的列索引会失效。</p><p>这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles</span><br><span class="line">    -&gt; <span class="keyword">WHERE</span> emp_no <span class="keyword">BETWEEN</span> <span class="string">'10001'</span> <span class="keyword">AND</span> <span class="string">'10010'</span></span><br><span class="line">    -&gt; <span class="keyword">AND</span> title=<span class="string">'Senior Engineer'</span></span><br><span class="line">    -&gt; <span class="keyword">AND</span> from_date <span class="keyword">BETWEEN</span> <span class="string">'1986-01-01'</span> <span class="keyword">AND</span> <span class="string">'1986-12-31'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 159     | NULL |   15 |     3.57 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><p><code>规律总结</code>：观察情况三、四和五，我们发现这三种情况都是<strong>不符合最左匹配原则</strong>的，情况三是查询条件中间缺少索引列；情况四是缺少了左边的索引列；情况五则是因为在索引列上使用<strong>范围查询</strong>而导致后面的索引列失效。另外，我们可以发现<code>全列匹配</code>也是符合<code>最左匹配原则</code>的。</p><h2 id="情况六：匹配某列的前缀字符串。"><a href="#情况六：匹配某列的前缀字符串。" class="headerlink" title="情况六：匹配某列的前缀字符串。"></a>情况六：匹配某列的前缀字符串。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">'Senior%'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 156     | NULL |    1 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>上述结果发现可以使用到了两个索引，需要注意的是如果通配符%<strong>不出现</strong>在开头，则可以用到索引。比如下面的情况则使用不到索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">'%enior'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |    11.11 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><h2 id="情况七：查询条件中含有函数或表达式。"><a href="#情况七：查询条件中含有函数或表达式。" class="headerlink" title="情况七：查询条件中含有函数或表达式。"></a>情况七：查询条件中含有函数或表达式。</h2><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> <span class="keyword">left</span>(title, <span class="number">6</span>)=<span class="string">'Senior'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>虽然这个查询和情况六中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no - <span class="number">1</span> = <span class="string">'10000'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   28 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h2 id="情况八：字符串不加单引号。"><a href="#情况八：字符串不加单引号。" class="headerlink" title="情况八：字符串不加单引号。"></a>情况八：字符串不加单引号。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title = <span class="number">123</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>titles表中title字段是varchar类型的，上述查询并未用单引号来表示123属于字符串，虽然MySQL在底层会将其转换为varchar类型，但是这样会导致title字段的索引失效。给123加上单引号后，便不会导致索引失效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">AND</span> title = <span class="string">'123'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 156     | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><h2 id="情况九：涉及多索引列并用OR连接。"><a href="#情况九：涉及多索引列并用OR连接。" class="headerlink" title="情况九：涉及多索引列并用OR连接。"></a>情况九：涉及多索引列并用OR连接。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no=<span class="string">'10001'</span> <span class="keyword">OR</span> title=<span class="string">'Senior Engineer'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |   28 |    19.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>可以发现虽然在emp_no列和title列都建了索引，但是都没有用到导致全表扫描。</p><h2 id="情况十：IS-NOT-NULL-无法使用索引。"><a href="#情况十：IS-NOT-NULL-无法使用索引。" class="headerlink" title="情况十：IS (NOT) NULL 无法使用索引。"></a>情况十：IS (NOT) NULL 无法使用索引。</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |   28 |    90.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p><code>规律总结</code>：情况六-情况七的都是导致当前索引失效的实例。</p><h1 id="三、索引选择性与前缀索引"><a href="#三、索引选择性与前缀索引" class="headerlink" title="三、索引选择性与前缀索引"></a>三、索引选择性与前缀索引</h1><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引：</p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓<code>索引选择性</code>（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p><code>Index Selectivity = Cardinality / #T</code></p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(title))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.titles;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| Selectivity |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|      0.0000 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p>有一种与索引选择性有关的索引优化策略叫做<code>前缀索引</code>，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p>从上面的数据库的E-R关系图可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</emp_no></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name=<span class="string">'Eric'</span> <span class="keyword">AND</span> last_name=<span class="string">'Anido'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span></span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span></span><br></pre></td></tr></table></figure><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</first_name></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(first_name))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| Selectivity |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|      0.0042 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">concat</span>(first_name, last_name)))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| Selectivity |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|      0.9313 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p><first_name>显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</first_name></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">concat</span>(first_name, <span class="keyword">left</span>(last_name, <span class="number">3</span>))))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| Selectivity |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|      0.7879 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(<span class="keyword">DISTINCT</span>(<span class="keyword">concat</span>(first_name, <span class="keyword">left</span>(last_name, <span class="number">4</span>))))/<span class="keyword">count</span>(*) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">| Selectivity |</span><br><span class="line">+<span class="comment">-------------+</span></span><br><span class="line">|      0.9007 |</span><br><span class="line">+<span class="comment">-------------+</span></span><br></pre></td></tr></table></figure><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.employees</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`first_name_last_name4`</span> (first_name, last_name(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROFILES</span>;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------+</span></span><br><span class="line">|       87 | 0.11941700 | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name=<span class="string">'Eric'</span> <span class="keyword">AND</span> last_name=<span class="string">'Anido'</span> |</span><br><span class="line">|       <span class="number">90</span> | <span class="number">0.00092400</span> | <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees.employees <span class="keyword">WHERE</span> first_name=<span class="string">'Eric'</span> <span class="keyword">AND</span> last_name=<span class="string">'Anido'</span> |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>性能的提升是显著的，查询速度提高了120多倍。</p><p>前缀索引兼顾索引大小和查询速度，<code>但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</code></p><h1 id="四、InnoDB的主键选择与插入优化"><a href="#四、InnoDB的主键选择与插入优化" class="headerlink" title="四、InnoDB的主键选择与插入优化"></a>四、InnoDB的主键选择与插入优化</h1><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><div align="center"><img src="/2019/09/12/2019-9-12-（三）MySQL-索引使用策略及优化/1568300406533.png"></div><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><div align="center"><img src="/2019/09/12/2019-9-12-（三）MySQL-索引使用策略及优化/1568300406534.png"></div><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（二）MySQL 索引实现</title>
      <link href="/2019/09/12/2019-9-12-%EF%BC%88%E4%BA%8C%EF%BC%89MySQL-%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/12/2019-9-12-%EF%BC%88%E4%BA%8C%EF%BC%89MySQL-%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本系列文章摘抄自<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>。</p><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p><a id="more"></a><h1 id="一、MyISAM索引实现"><a href="#一、MyISAM索引实现" class="headerlink" title="一、MyISAM索引实现"></a>一、MyISAM索引实现</h1><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p><div align="center"><img src="/2019/09/12/2019-9-12-（二）MySQL-索引实现/1568300215502.png"></div><p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，<code>主索引</code>和<code>辅助索引</code>（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p><div align="center"><img src="/2019/09/12/2019-9-12-（二）MySQL-索引实现/1568300215503.png"></div><p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p><p>MyISAM的索引方式也叫做<code>非聚集索引</code>，之所以这么称呼是为了与InnoDB的聚集索引区分。</p><h1 id="二、InnoDB索引实现"><a href="#二、InnoDB索引实现" class="headerlink" title="二、InnoDB索引实现"></a>二、InnoDB索引实现</h1><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p><p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p><div align="center"><img src="/2019/09/12/2019-9-12-（二）MySQL-索引实现/1568300215471.png"></div><p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<code>聚集索引</code>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引，这里以英文字符的ASCII码作为比较准则：</p><div align="center"><img src="/2019/09/12/2019-9-12-（二）MySQL-索引实现/1568300215504.png"></div><p>聚集索引这种实现方式使得主索引的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p><p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p><p>下一篇文章将具体讨论与索引有关的优化策略。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="/2019/09/10/2019-9-10-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/10/2019-9-10-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>有很多算法在结构上是递归的：为了解决一个给定的问题，算法要一次或多次地递归调用其自身来解决相关的问题。这些算法通常采用分治策略：将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。</p><p>分治算法在每一层递归上都有三个步骤：<br><strong>分解（Divide）</strong>：将原问题分解成一系列子问题；<br><strong>解决（Conquer）</strong>：递归地解各子问题。若子问题足够小，则直接求解；<br><strong>合并（Combine）</strong>：将子问题的结果合并成原问题的解。</p><a id="more"></a><p>我们见过分治算法的经典例子，如归并排序和快速排序。以归并排序为例，我们对整个数组进行排序时，会将大的数组递归地分为原数组的一半，然后再递归地解决各个子问题，这里即是递归地完成子数组的排序，最后再将排序的子数组合并成大数组从而完成数组的排序。</p><h4 id="分治算法的运行时间"><a href="#分治算法的运行时间" class="headerlink" title="分治算法的运行时间"></a>分治算法的运行时间</h4><p>下面的定理可以用来确定大部分分治算法的运行时间：</p><p>$$T(N) = a\times{T(\frac{N}{b})} + O(N^d)$$</p><p>1) $\log_b{a} &gt; d$ -&gt; 复杂度为$O(N^{\log_b{a}})$<br>2) $\log_b{a} = d$ -&gt; 复杂度为$O(N^{d} \times{ log{N}})$，log的底数不需明确定义。<br>3) $\log_b{a} &lt; d$ -&gt; 复杂度为$O(N^d)$</p><p>对于归并排序，长度为N的数组分为两次的$T(\frac{N}{2})$时间复杂度的排序和O(N)的归并过程，所以a = b = 2，d = 1，即符合第2点$\log_b{a} = d$，故时间复杂度为$O(N \times{ log{N}})$。因为总的情况下需要长度为N的临时数组空间，故额外空间复杂度为O(N)。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 分治算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher 算法</title>
      <link href="/2019/09/09/2019-9-9-Manacher-%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/09/2019-9-9-Manacher-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>首先我们先来看一个题：给定一个字符串str，返回str中最长回文子串的长度。比如str = “123”，其中的最长回文子串为”1”、”2”、”3”，所以返回1。又比如str = “abc1234321ab”，其中的最长回文子串为”1234321”，所以返回7。</p><p>面对字符串”a131b”，我们寻找字符串中回文子串的最直观的想法也许是在遍历字符串的过程中，以当前字符为中心，向两边“扩”来对比两边的字符是否相等，然后记录回文子串长度。比如当前遍历到的字符为a，只有右边有字符，所以回文子串”a”的长度为1；当遍历到的字符为1时，左右两边的字符分别为’a’和’3’不相等，所以回文子串”1”的长度为1；当遍历到的字符为3时，左右两边的字符都为’1’，记录下长度，然后继续向两边比较，此时‘a’和’b’不相等，所以回文子串”131”的长度为3。。。</p><a id="more"></a><p>但是我们会发现这种方法并不适用于偶数长度的字符串，比如字符串”y1221p”就无法像上面的方法一样求得最大回文子串”1221”的长度为4。</p><p>解决的办法是在字符串的两边和字符之间添加字符，比如添加字符”#”，当然也可以其他任意一种字符，读者可以自行尝试。对于字符串”1221”添加完字符后就变为”#1#2#2#1#”，此时我们上面的寻找最长回文子串长度的方法可以运用于偶数字符串和奇数字符串中，不过<code>添加完字符后的字符串所统计出来的回文子串长度是没添加字符前的字符串的两倍</code>。</p><p>上面的方法的时间复杂度为O(n^2)，下面我们使用Manacher算法来达到O(N)时间复杂度的实现。</p><p>首先我们需要明白三个概念：</p><ul><li><strong>回文半径数组pArr</strong>：回文半径数组就是用于存储回文子串的半径长度的数组。比如字符串”#c#a#b#a#c#”，其回文半径数组就为[1，2，1，2，1，6，1，2，1，2，1]。</li><li><strong>最右回文半径指针pR</strong>：该指针每次都会指向当前或之前回文子串最右边字符的下一个字符。如果当前回文子串的最右字符超出了之前回文子串的pR的范围，即当前回文子串的最右字符比pR所指向的字符更右，那么pR就更新为当前回文子串最右边字符的下一个字符，否则就不变。下面我们以字符串”#a#b#a#”为例，来看一下pR指针的移动过程。观察下图，cur表示遍历到的当前字符。<br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046161.png" alt><br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046162.png" alt><br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046164.png" alt><br>后面的过程中pR不再移动，cur一直往右移动，直到等于字符串长度停下。</li><li><strong>回文子串中心指针index</strong>：回文子串中心指针是随着pR变化的，也就是pR改变时，index也会变化。观察上图，当cur指向第一个字符’#’时，pR发生改变并指向了’a’，此时回文中心指针index指向当前回文子串”#”的中心位置，即cur指向的位置。当cur指向第二个字符’a’时，pR发生改变并指向了字符’b’，此时回文中心指针index指向当前回文子串”#a#”的中心位置，同样也是cur指向的位置，后面的同理。</li></ul><p>在理解了上面的三个概念之后，我们再来看在遍历的过程中当前指针i可能会面临如下两种情况：</p><p><strong>第一种情况</strong>：观察下图，[L…pR-1]是回文子串，index为回文子串的中心指针。此时当前指针i在pR的右边时（包括pR），我们就像普通解法一样，从i位置字符开始向左右两边开始“扩”，即以当前字符为中心寻找其最大的回文子串半径长度。<br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046165.png" alt><br><strong>第二种情况</strong>是i在pR指针左边，如下图所示：<br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046166.png" alt><br>此时可以又可以分为下面三种子情况：</p><p><strong>情况1</strong>：观察下图，i’是i关于index对称的位置，且i’已经有其对应的回文子串半径值pArr[i’]。假如以i’为中心的回文子串（下图左边蓝色区域）包含于大回文子串[L…pR-1]中，那么我们可以直接得出i的回文半径即为i’的回文半径值。<br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046168.png" alt><br>这个很好证明，因为[L..index-1]与[index + 1…pR - 1]关于index对称，那么上图中蓝色与绿色区域的字符串也关于index对称，又因为蓝色区域是回文子串，那么自然绿色区域也是回文子串，他们长度相等，所以回文半径也相等。</p><p><strong>情况2</strong>：观察下图，i’是i关于index对称的位置。假如以i’为中心的回文子串（下图左边蓝色区域）的左边界超过了最大回文子串[L…pR-1]的左边界，那么我们可以直接得出i的回文半径即为i到pR的距离的长度pR - i。<br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046172.png" alt><br>我们同样可以证明这个结论是正确的。观察上图，[L…pR-1]是回文子串，X和Y关于i’对称并相等，Y与X’关于index对称并相等，X与Y’关于index对称并相等，那么就有X=Y=X’≠Y’，所以以i为中心的回文子串的即为上图中的绿色区域，其半径等于i到pR的距离pR - i。</p><p><strong>情况3</strong>：观察下图，i’是i关于index对称的位置。此时以i’为中心的回文子串（下图左边蓝色区域）的左边界刚好与最大回文子串[L…pR-1]的左边界重合，那么此时i为中心的回文半径<code>至少</code>等于i’的回文半径。<br><img src="/2019/09/09/2019-9-9-Manacher-算法/1568040046176.png" alt><br>当然，i为中心的回文半径可能更大，比如上图中，X如果等于Y那么以i为中心的回文半径长度+1。由于无法向上面两种情况一样直接得出以i为中心的回文半径长度，那么需要X和Y位置开始向两边”扩”以寻找更大的回文子串半径长度。</p><p>综合上述分析，其具体代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manacher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法将形如"abccba"的字符串转为形如"#a#b#c#c#b#a#"</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] manacherString(String str) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] charArr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">2</span> * str.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; charArr.length; i++) &#123;</span><br><span class="line">            charArr[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">'#'</span> : chs[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> charArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxLcpsLength</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 获取源字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] charArr = manacherString(str);</span><br><span class="line">        <span class="comment">// 定义一个回文半径长数组pArr</span></span><br><span class="line">        <span class="keyword">int</span>[] pArr = <span class="keyword">new</span> <span class="keyword">int</span>[charArr.length];</span><br><span class="line">        <span class="comment">// 定义最右回文指针，每次都指向当前回文子串的最右字符的下一个字符</span></span><br><span class="line">        <span class="keyword">int</span> pR = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 定义当前回文子串的回文中心节点坐标</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 记录最大回文半径值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 先根据i是否在pR左边来给pArr[i]一个初始值，然后再根据实际情况，</span></span><br><span class="line">            <span class="comment">// 即是否需要从i往外扩来增大pArr[i]的值</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 1. 如果i在pR的右边，那么先给pArr[i]赋值1,即半径大小至少等于自己本身的长度</span></span><br><span class="line"><span class="comment">             * 2. 如果i在pR的左边，那么i关于index的对称点i'的半径值为pArr[2 * index - i]，</span></span><br><span class="line"><span class="comment">             * 2.1 如果i'的左半径超过以index为中心的回文子串的左边界，那么其pArr[i]至少为pArr[2 * index - i]。</span></span><br><span class="line"><span class="comment">             * 2.2 如果i'的左半径没有超过以index为中心的回文子串的左边界，那么其pArr[i]为pR - i。</span></span><br><span class="line"><span class="comment">             * 2.3 如果i'的左半径与以index为中心的回文子串的左边界重合，那么其pArr[i]为pArr[2 * index - i]。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            pArr[i] = i &lt; pR ? Math.min(pArr[<span class="number">2</span> * index - i], pR - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 下面两个循环条件分别表示在从i向两边扩时的最右边界和最左边界</span></span><br><span class="line">            <span class="keyword">while</span> (i + pArr[i] &lt; charArr.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//比较当前左右半径的外面的字符是否相等，相等则半径加1</span></span><br><span class="line">                <span class="keyword">if</span> (charArr[i - pArr[i]] == charArr[i + pArr[i]]) &#123;<span class="comment">//1和2.1会执行</span></span><br><span class="line">                    pArr[i]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//2.2和2.3的情况会执行</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更改最右回文指针，每次都指向当前i为中心回文子串的最右字符的下一个字符</span></span><br><span class="line">            <span class="comment">// 更改当前回文子串的回文中心节点坐标</span></span><br><span class="line">            <span class="keyword">if</span> (i + pArr[i] &gt; pR) &#123;</span><br><span class="line">                pR = i + pArr[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新最大回文子串长度</span></span><br><span class="line">            max = Math.max(max, pArr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(maxLcpsLength(<span class="string">"olocbadebcolo"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> Manacher </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈结构</title>
      <link href="/2019/09/09/2019-9-9-%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/09/2019-9-9-%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个<code>不含有重复值</code>的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。</p><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><blockquote><p>第一行输入一个数字 n，表示数组 arr 的长度。<br>以下一行输出 n个数字，表示数组的值。</p></blockquote><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><blockquote><p>输出n行，每行两个数字 L 和 R，如果不存在，则值为-1，下标从0开始。</p></blockquote><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><blockquote><p>输入<br>7<br>3 4 1 5 6 2 7</p></blockquote><blockquote><p>输出<br>-1 2<br>0 2<br>-1 -1<br>2 5<br>3 5<br>2 -1<br>5 -1</p></blockquote><a id="more"></a><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>要找到数组中每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置，我们需要借助栈来实现，该<code>栈保存数组的下标，且需要保持从栈顶到栈底的下标idx所对应的arr[idx]由大到小</code>。当然，如果我们是要找到数组中每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 大的位置，那么我们就需要保持栈从栈顶到栈底的下标idx所对应的arr[idx]由小到大的特性。</p><p>接下来我们来使用单调栈来求得数组arr[3 4 1 5 6 2 7]中每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置：</p><p>当数组遍历到0号位时，发现栈为空，那么就直接将下标0压入栈中，如下图所示：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170343.png" alt><br>当数组遍历到1号位时，发现arr[1]大于栈顶元素即数组的坐标0所对应的数组元素3，那么直接将下标1压入栈中，如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170345.png" alt><br>接着数组遍历到2号位时，发现arr[2]小于栈顶元素即数组的下标1所对应的数组元素4，那么直接弹出栈顶元素1，<code>那么 1 位置左边和右边离 1 位置最近且值比 arr[1] 小的位置分别为新的栈顶0和当前的i = 2</code>，并记录在结果数组中。<code>若当前位置i其左边和右边不存在比arr[i]最近且比其小元素，那么就默认位置为-1</code>。重复上述过程，直到栈为空或者arr[2]大于栈顶下标所对应的数组元素时直接压入i。该过程的结果如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170346.png" alt><br>当数组从3号位遍历到4号时，会将数组元素5和6所对应的下标压入栈中。如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170363.png" alt><br>当数组遍历到5号位时，发现arr[5]小于栈顶中元素4所对应的数组元素6，那么弹出栈顶元素并记录其左右比arr[5]小且最近的元素的下标。同理，新的栈顶也会被弹出。然后压入元素2的下标5。如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170364.png" alt><br>当数组遍历到6号位时，发现arr[6]大于栈顶元素5所对应的arr[5]，即2，那么直接压入下标6。自此，数组遍历结束，栈和结果数组的状态如下图所示：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170365.png" alt><br>接着，我们循环的弹出栈顶元素idx，并记录arr[idx]的左边和右边最近且比arr[idx]小的元素下标，我们可以发现左边最近且比arr[idx]小的元素的下标为新的栈顶元素（若不存在则为-1），右边最近且比arr[idx]小的元素的下标不存在，即为-1。最后我们得到如下结果数组：<br><img src="/2019/09/09/2019-9-9-单调栈结构/1568038170366.png" alt></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getNearLessNoRepeat(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> leftIdx = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">                res[top][<span class="number">0</span>] = leftIdx;</span><br><span class="line">                res[top][<span class="number">1</span>] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftIdx = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            res[top][<span class="number">0</span>] = leftIdx;</span><br><span class="line">            res[top][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = getNearLessNoRepeat(arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            System.out.println(res[i][<span class="number">0</span>] + <span class="string">" "</span> + res[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈结构（进阶）</title>
      <link href="/2019/09/09/2019-9-9-%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/"/>
      <url>/2019/09/09/2019-9-9-%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一个<code>可能含有重复值</code>的数组 arr，找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置。返回所有位置相应的信息。</p><a id="more"></a><h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h5><p>第一行输入一个数字 n，表示数组 arr 的长度。<br>以下一行输入 n 个数字，表示数组的值</p><h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h5><p>输出n行，每行两个数字 L 和 R，如果不存在，则值为 -1，下标从 0 开始。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h5><blockquote><p>输入<br>7<br>3 4 1 5 6 2 7</p></blockquote><blockquote><p>输出<br>-1 2<br>0 2<br>-1 -1<br>2 5<br>3 5<br>2 -1<br>5 -1</p></blockquote><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>我曾在该篇文章<a href="https://blog.csdn.net/weixin_40374341/article/details/100055210" target="_blank" rel="noopener">单调栈结构</a>介绍过单调栈，但是这种单调栈只适合求<code>不含有重复值</code>的数组 arr 的每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置，而对于<code>可能含有重复值</code>的数组也就无可奈何。</p><p>我们可以改进单调栈的结构，我们仅将单调栈中的Integer元素改为链表的形式，<code>链表即用来存取相等数组元素的下标</code>，而单调栈仍然保持从栈顶到栈底元素idx所对应的arr[idx]由大到小（求最近最小值时）。</p><p>下面我们就一个简单的例子来演示单调栈的使用，比如现在有一数组arr[2,2,4,4,3]。</p><p>当遍历到数组的0号位时，由于栈为空，那么将下标0添加进链表中，然后将链表压入栈中；</p><p>当遍历到数组的1号位时，发现栈不为空，且因为arr[1]等于链表元素0所对应的arr[0]，即都等于2，那么则将下标1添加进栈顶的链表中，如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构（进阶）/1568038681569.png" alt><br>接着数组遍历到2号时，发现arr[2]大于栈顶链表元素0所对应的arr[0]，那么直接将下标2添加进新的链表中，然后将链表压入栈中。另外，当数组遍历到3号位时同当遍历到数组的1号位时的情况一样，如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构（进阶）/1568038681570.png" alt><br>当数组遍历到4号位时，发现arr[4]小于栈顶链表元素2所对应的arr[2]，那么则将栈顶的链表弹出，然后遍历该链表，我们可以知道链表中的每个元素idx所对应的arr[idx]的左边和右边离其最近且小于arr[idx]的元素的下标分别为<code>新的栈顶链表最右的元素（这里是3）</code>和<code>当前遍历到的数组元素的下标（这里是4）</code>。然后重复上述过程，直到arr[4]小于或等于新的栈顶链表元素idx所对应的arr[idx]才停止。</p><p>如果arr[4]等于新的栈顶链表元素idx所对应的arr[idx]时，那么就将arr[4]添加到该栈顶链表中，否则就将arr[4]添加进新的链表，然后再将该链表添加进栈中。由于arr[4]不等于栈顶链表元素2所对应的arr[2]，那么我们将arr[4]添加进新的链表，然后再将该链表添加进栈中。如下图示：<br><img src="/2019/09/09/2019-9-9-单调栈结构（进阶）/1568038681576.png" alt><br>接下来我们开始循环的弹出栈中的链表，然后遍历该链表，我们可以知道链表元素4所对应的arr[4]的左边离其最近且小于arr[4]的元素的下标为新的栈顶链表最右的元素的下标1，右边的则不存在，默认为-1。<br><img src="/2019/09/09/2019-9-9-单调栈结构（进阶）/1568038681602.png" alt><br>我们继续弹出栈顶链表，然后遍历该链表。我们发现无新的栈顶，那么我们说明当前链表元素idx所对应的arr[idx]左边无离其最近且小于arr[idx]的元素，我们默认下标为-1，而右边的也不存在，默认为-1。<br><img src="/2019/09/09/2019-9-9-单调栈结构（进阶）/1568038681625.png" alt></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getNearLessRepeat(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        ArrayDeque&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt; arr[stack.peek().get(<span class="number">0</span>)]) &#123;</span><br><span class="line">                List&lt;Integer&gt; topList = stack.pop();</span><br><span class="line">                <span class="comment">// 不为空时为新的栈顶链表最右的元素</span></span><br><span class="line">                <span class="keyword">int</span> leftLessIdx = stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (Integer n : topList) &#123;</span><br><span class="line">                    res[n][<span class="number">0</span>] = leftLessIdx;</span><br><span class="line">                    res[n][<span class="number">1</span>] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; arr[i] == arr[stack.peek().get(<span class="number">0</span>)]) &#123;</span><br><span class="line">                stack.peek().add(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(i);</span><br><span class="line">                stack.push(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; topList = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> leftLessIdx = stack.isEmpty() ? -<span class="number">1</span> : stack.peek().get(stack.peek().size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Integer n : topList) &#123;</span><br><span class="line">                res[n][<span class="number">0</span>] = leftLessIdx;</span><br><span class="line">                res[n][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] res = getNearLessRepeat(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(res[i][<span class="number">0</span>] + <span class="string">" "</span> + res[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>平衡二叉树之平衡调整图解</title>
      <link href="/2019/09/09/2019-9-9-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4%E5%9B%BE%E8%A7%A3/"/>
      <url>/2019/09/09/2019-9-9-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%B9%B3%E8%A1%A1%E8%B0%83%E6%95%B4%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>先看一个平衡二叉树创建的例子。假设现在表中关键字序列为（13，24，37），具体的平衡二叉树创建过程如下图所示：<br><img src="/2019/09/09/2019-9-9-平衡二叉树之平衡调整图解/1568039870243.png" alt><br>我们可以发现结点37的插入导致二叉树的根结点13的平衡因子变为-2，此时二叉树没有达到平衡状态。其中<strong>离插入结点最近且平衡因子绝对值超过1的祖先结点，以该结点为根的子树称为最小不平衡树， 我们可将重新平衡的范围局限于这颗树或子树。</strong></p><a id="more"></a><p>一般情况下，假设最小不平衡树的根结点为A，则失去平衡后进行调整的规律可归纳为以下四种情况。</p><h3 id="1-LL型"><a href="#1-LL型" class="headerlink" title="1. LL型"></a>1. LL型</h3><p>由于在<strong>A左子树根结点的左子树</strong>上插入结点C，A的平衡因子由1增至2，致使以A为根的子树失去平衡，则需要进行一次<strong>向右的顺时针旋转操作</strong>，如下图所示。<br><img src="/2019/09/09/2019-9-9-平衡二叉树之平衡调整图解/1568601856130.png" alt></p><h3 id="2-RR型"><a href="#2-RR型" class="headerlink" title="2. RR型"></a>2. RR型</h3><p>由于在<strong>A的右子树根结点的右子树</strong>上插入结点C，A的平衡因子由-1变为-2，致使以A为根结点的子树失去平衡，则需进行一次<strong>向左的逆时针旋转操作</strong>，如下图所示。<br><img src="/2019/09/09/2019-9-9-平衡二叉树之平衡调整图解/1568039870244.png" alt></p><h3 id="3-LR型"><a href="#3-LR型" class="headerlink" title="3. LR型"></a>3. LR型</h3><p>由于在<strong>A的左子树根结点的右子树</strong>上插入结点，A的平衡因子由1增至2，致使以A为根结点的子树失去平衡，则需要进行<strong>二次旋转</strong>操作。第一次<strong>对B及其右子树进行逆时针旋转</strong>，C转上去成为B的根，这时变成了LL型，所以第二次进行<strong>LL型的顺时针旋转</strong>即可恢复平衡。如果C原来有左子树，则调整C的左子树为B的右子树，如下图所示。<br><img src="/2019/09/09/2019-9-9-平衡二叉树之平衡调整图解/1568039870245.png" alt></p><h3 id="4-RL型"><a href="#4-RL型" class="headerlink" title="4. RL型"></a>4. RL型</h3><p>由于在<strong>A的右子树根结点的左子树</strong>上插入结点，A的平衡因子由-1变为-2，致使以A为根结点的子树失去平衡，则旋转方法和LR型相对称，也需进行<strong>两次旋转</strong>，<strong>第一次对B及其左子树进行顺时针右旋</strong>，C转上去成为B的根，这时变成了RR型，再<strong>进行RR型的逆时针左旋</strong>，如下图所示。<br><img src="/2019/09/09/2019-9-9-平衡二叉树之平衡调整图解/1568039870247.png" alt><br>综上，LL型与RR型对称，LR型和RL型对称。我们可以由中序遍历（左-&gt;根-&gt;右）所得关键字序列自小到大有序来证明平衡调整的正确；另外，平衡二叉树的深度在插入结点前和插入结点并平衡调整之后是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集的实现</title>
      <link href="/2019/09/09/2019-9-9-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/09/2019-9-9-%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h3><p>并查集由一群集合构成，最开始时所有元素各自单独构成一个集合。比如，有一批元素arr = [a, b, c, d, e]，我们需要将这一批元素初始化成单个元素的集合，即a单独构成一个集合，b单独构成一个集合。其中并查集中的单个集合结构如下所示：<br> <div align="center"><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829388.png"></div></p><p> 当集合中只有一个元素时，这个元素的father为自己，也就是这个集合的<strong>代表节点</strong>。当一个集合有多个节点时，代表节点为集合中某节点的father指向其自己的节点，比如下图的节点a。<br>  <div align="center"><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829396.png"></div></p><p>我们使用哈希表来保存所有并查集所有集合的所有元素的father信息，记为fatherMap。比如，哈希表fatherMap中的某一条记录会为(当前节点，father节点)。也就是key为当前节点，而value为当前节点的father节点。</p><p>另外，我们使用另外一个哈希表rankMap来保存一个集合中的元素个数，即集合的大小rank。且只有一个集合的代表节点的rank信息才有效。rankMap的某条记录为（代表节点，集合节点数）。上图中集合的rank为6，并记录在代表节点a对应的valuer中。</p><a id="more"></a><h3 id="二、查找"><a href="#二、查找" class="headerlink" title="二、查找"></a>二、查找</h3><p>在并查集中，若要查找一个节点属于哪个集合，就是在查这个节点所在集合的代表节点是什么，一个节点通过father信息逐渐找到最上面的节点，其中某个节点的father是自己本身，那么这个节点即为代表节点，也代表整个集合。比如下图中，节点g和节点c所在的集合的代表节点同为节点a，那么这两个节点同为一个集合，否则不是。<br>  <div align="center"><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829396.png"></div></p><p>通过一个节点找到所在集合代表节点的过程叫作findFather过程，findFather最终会返回代表节点，但在查找过程会把整个<strong>查找路径</strong>压缩。比如再进行findFather(g)的过程中，会将查找路径的节点g, e, b的father都设置为a，则集合会变成如下图所示的样子。<br>  <div align="center"><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829397.png"></div><br>经过路径压缩之后，路径上的每个节点下次在找代表节点的时候都只需经过一次移动过程。这也是整个并查集结果设计中最重要的优化。</p><h3 id="三、合并"><a href="#三、合并" class="headerlink" title="三、合并"></a>三、合并</h3><p>接下来介绍集合的合并。首先，两个集合进行合并操作时，参数并不是两个集合，而是并查集中的任意两个节点，记为a和b。所以集合的合并更准确的说法是，根据a找到a所在集合的代表节点是findFather(a)，记为aF，b同理为bF。合并过程如下：</p><ol><li>如果aF == bF，说明a和b本身就在一个集合里，不用合并；</li><li>如果aF != bF，那么从rankMap中获取代表节点aF和bF所处集合的节点数，分别为aFRank和bFRank。如果aFRank &gt; bFRank，那么将节点b所处的集合合并到节点a所处的集合中，其中代表节点bF的father设置为节点aF，并修改aFRank的值为aFRank + bFRank。而bF的rank信息可以删除，因为已经不会再次使用到了。aFRank &lt; bFRank的情况同理，而aFRank == bFRank的情况我们可以假定与aFRank &gt; bFRank的情况一样。<br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829398.png" alt><br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829399.png" alt><h3 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h3>并查集所有代码见如下的UnionFindSet类实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T val;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Element</span><span class="params">(T val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Element&lt;T&gt;, Element&lt;T&gt;&gt; fatherMap;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Element&lt;T&gt;, Integer&gt; rankMap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(List&lt;Element&lt;T&gt;&gt; eles)</span> </span>&#123;</span><br><span class="line">        makeSets(eles);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(List&lt;Element&lt;T&gt;&gt; eles)</span> </span>&#123;</span><br><span class="line">        fatherMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        rankMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//构建单元素并查集合</span></span><br><span class="line">        <span class="keyword">for</span> (Element&lt;T&gt; el : eles) &#123;</span><br><span class="line">            fatherMap.put(el, el);</span><br><span class="line">            rankMap.put(el, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找元素所处集合的代表节点并压缩查找路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Element&lt;T&gt; <span class="title">findFather</span><span class="params">(Element&lt;T&gt; e)</span> </span>&#123;</span><br><span class="line">        Element&lt;T&gt; father = fatherMap.get(e);</span><br><span class="line">        <span class="keyword">if</span> (e != father) &#123;</span><br><span class="line">            father = findFather(father);</span><br><span class="line">        &#125;</span><br><span class="line">        fatherMap.put(e, father);</span><br><span class="line">        <span class="keyword">return</span> father;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并集合</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Element&lt;T&gt; a, Element&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Element&lt;T&gt; aF = findFather(a);</span><br><span class="line">        Element&lt;T&gt; bF = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (aF != bF) &#123;</span><br><span class="line">            <span class="keyword">int</span> aFRank = rankMap.get(aF);</span><br><span class="line">            <span class="keyword">int</span> bFRank = rankMap.get(bF);</span><br><span class="line">            <span class="keyword">if</span> (aFRank &gt;= bFRank) &#123;</span><br><span class="line">                fatherMap.put(bF, aF);</span><br><span class="line">                rankMap.put(aF, aFRank + bFRank);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fatherMap.put(aF, bF);</span><br><span class="line">                rankMap.put(bF, aFRank + bFRank);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Element&lt;T&gt; a, Element&lt;T&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="五、岛问题扩展"><a href="#五、岛问题扩展" class="headerlink" title="五、岛问题扩展"></a>五、岛问题扩展</h3><p>我们先了解一下岛问题。</p><p>一个矩阵中只有0和1两种值， 每个位置都可以和自己的上、 下、 左、 右四个位置相连， 如果有一片1连在一起， 这个部分叫做一个岛。<br>举例：<br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829404.png" alt><br>这个矩阵中有三个岛。</p><p>复杂岛问题的求解可以利用并查集来实现，比如有如下矩阵（实际可以是很大的矩阵）。<br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829405.png" alt><br>由于矩阵过于大，一台机器计算岛数量会过慢。因此假设我们将矩阵分为两个部分，可以将两个子矩阵分由两台机器并发执行计算得出各自的岛数量，得出的总数量为4，然后再计算大矩阵实际的岛数量为2。</p><p>问题是我们如何通过子矩阵计算大矩阵实际的岛数量呢？观察下图，首先，我们在计算左边子矩阵的岛数量时，首先会从a从右然后在往下走，然后将这些节点合并为一个并查集，其中第一个节点1（a所指向的节点，后面我们用a, b, c, d代称代表节点）为代表节点，其他三个到同理。<br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829407.png" alt><br>经过上述过程我们知道岛1元素集合的代表节点为a，岛2元素集合的代表节点为b，岛3元素集合的代表节点为c，岛4元素集合的代表节点为d。下面我们考虑两个子矩阵的边界元素。</p><p>观察下图，现在我们<strong>只考虑子矩阵的边界元素。</strong> 假设现在指针在遍历边界元素时指向如下，发现黑色指针所指向的元素为1，且其右边的蓝色指针指向的元素也是1。那么又发现左边的节点所属集合的代表节点为a，而右边的节点所属集合的代表节点为b，此时将代表节点b所属的集合合并到集合a中，并将上次计算各子矩阵岛数量的总和num减1，即num = 4 - 1 = 3。</p><p>黑色和蓝色指针都向往下移动一位，此时会发现两指针指向的元素所属同一个集合，因此num值不变。<br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829408.png" alt><br>两指针继续往下移动，假设现在某一时刻指针的指向如下图所示：<br><img src="/2019/09/09/2019-9-9-并查集的实现/1568037829475.png" alt><br>我们发现黑色指针指向的元素属于代表节点为c的集合，而蓝色指针指向的元素属于代表节点为a的集合，此时集合不相等，num再次减1变为2，同时在将两集合合并。经过上述步骤最终得出实际的岛数量2。</p><p>在遇到大矩阵时，我们完全可以将大矩阵拆分为多个子矩阵并交由多台机器去计算各自的岛数量，同时利用并查集完成最后实际岛数量的计算。</p><p>本文参考《程序员代码面试指南—IT名企算法与数据结构题目最优解》</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典树的实现</title>
      <link href="/2019/09/09/2019-9-9-%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/09/09/2019-9-9-%E5%AD%97%E5%85%B8%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>字典树又称为前缀树或Trie树，是处理字符串常见的数据结构。假设组成所有单词的字符仅是“a”~“z”，实现字典树结构，并包含以下四个主要功能。</p><ul><li>void insert(String word)：添加word，可重复添加；</li><li>void delete(String word)：删除word，如果word添加过多次，仅删除一个；</li><li>boolean search(String word)：查询word是否在字典树中；</li><li>int prefixNumber(String pre)：返回以字符串pre为前缀的单词数量。</li></ul><p>字典树是一种树形结构，优点是利用字符串的公共前缀来节约存储空间，比如加入“abc”、“abcd”、“adb”、“b”、“bcd”、“efg”、“hik”之后，字典树如下图所示，其中橙色节点表示一个终止节点。</p><div align="center"><img src="/2019/09/09/2019-9-9-字典树的实现/1568022512381.png"></div>字典树的基本性质如下：<ul><li>根节点没有字符路径。除根节点外，每一个节点都被一个字符路径找到；</li><li>从根节点出发到任何一个节点，如果将沿途经过的字符连接起来，一定为某个加入过的字符串的前缀；</li><li>每个节点向下的所有字符串路径上的字符都不同；</li></ul><a id="more"></a><p>在字典树上<strong>搜索</strong>添加过的单词的步骤如下：</p><ol><li>从根节点开始搜索；</li><li>取得要查找单词的第一个字母，并根据该字母选择对应的字符路径向下继续搜索；</li><li>字符路径指向的第二层节点上，根据第二个字母选择对应的字符路径向下继续搜索；</li><li>一直向下搜索，如果单词搜索完后，找到的最后一个节点是一个终止节点。比如上图，搜索单词“abc”时，单词的最后一个字符’c’对应的在字典树中的字符路径a-&gt;b-&gt;c中’c’为终止节点，那么说明字典树中包含该单词；如果找到的最后一个节点不是一个终止节点，比如查找单词“hi”，其中i不是终止节点，那么说明字典树没添加过该单词；如果单词还没搜索完，但是字典树就已经没有后续节点了，也说明字典树没添加过该单词。</li></ol><p>在字典树上添加一个单词的步骤同理，这里不再赘述。下面介绍有关字典树节点的类型，参见如下代码中的TrieNode类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> TrieNode[] map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        path = <span class="number">0</span>;</span><br><span class="line">        end = <span class="number">0</span>;</span><br><span class="line">        map = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];<span class="comment">// 26个字母</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TrieNode类中，path表示有多少个单词共用这个节点，如此我们才能知道某字符串pre为前缀的单词数量。end表示有多少个单词以这个节点结尾，只要end大于0，那么说明存在单词以该节点结尾，亦表示该节点为终止节点。下面介绍本题的Trie树类如何实现。</p><ul><li><strong>insert方法</strong>：首先我们需要将指针指向根节点node，并将插入的单词word分为字符数组。由于当前节点下面可能有26个节点，我们取单词word的第一个字符并减去字符’a’来获取一个下标值，这个下标值指的是单词word的第一个字符应该插入到当前节点node下面的26个节点中的某个节点的位置。如果该位置的节点为空，那么就新建一个节点，代表单词word的第一个字符节点。若不为空，那么就说明该字符已经插入过了，指针指向下一个节点，并将其path加1。当单词的所有字符都遍历后，其最后一个字符所对应的节点的end需加1。具体实现代码如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    node.path++;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        index = words[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.map[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.map[index];</span><br><span class="line">        node.path++;</span><br><span class="line">    &#125;</span><br><span class="line">    node.end++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>search方法</strong>：search方法基本思路与insert方法是相似的。不同的是，当在查找某个单词时，若该单词还没查找完，单词字符序列没有与之对应的字典树中的字符节点序列，也就在查找过程中发现了空节点，那么说明该单词不存在与字典树中。若单词查找完了，但是该单词的最后一个字符所对应的字典树中节点的end的值为0，即该节点不是终止节点，那么也说明该单词不存在与字典树中。具体实现代码如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (word == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        index = words[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        node = node.map[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>delete方法</strong>：首先需要确保要删除的单词是存在字典树中的。然后在删除的过程中，需要将对应的字符路径的每个节点的path值减1，同时判断是否等于0。若某个节点的path等于0，那么直接将当前节点置为空即可，比如下图的情况，节点中的第一个值为path，第二个值为end。当要删除单词“cef”时，发现c的节点的path-1后等于0，那么直接将该节点设置为空即可，不需要再往后遍历。<div align="center"><img src="/2019/09/09/2019-9-9-字典树的实现/1568022512387.png"></div></li></ul><p>另一种情况是要删除单词“a”时，a的节点的path-1后不等于0，但是因为已经遍历到终止节点了，那么需要将end的值减1。具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (search(word)) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        node.path--;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            index = words[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (--node.map[index].path == <span class="number">0</span>) &#123;</span><br><span class="line">                node.map[index] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map[index];</span><br><span class="line">        &#125;<span class="comment">//for</span></span><br><span class="line">        node.end--;</span><br><span class="line">    &#125;<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>prefixNumber方法</strong>：和查找操作同理，不断的在树中查找前缀pre，若该前缀存在，那么返回其最后一个节点的path值，如不存在直接返回0。具体实现代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TrieNode node = root;</span><br><span class="line">    <span class="keyword">char</span>[] pres = pre.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pres.length; i++) &#123;</span><br><span class="line">        index = pres[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.map[index] == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        node = node.map[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个扩展的字典树，支持所有字符，而不仅仅是26个字母，具体实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//字典树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> path;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Character, TrieNode&gt; map;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            path = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        node.path++;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.map.get(words[i]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node.map.put(words[i], <span class="keyword">new</span> TrieNode());</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.map.get(words[i]);</span><br><span class="line">            node.path++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.end++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.map.get(words[i]) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            node = node.map.get(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.end &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word)) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            node.path--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--node.map.get(words[i]).path == <span class="number">0</span>) &#123;</span><br><span class="line">                    node.map.remove(words[i]);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.map.get(words[i]);</span><br><span class="line">            &#125;<span class="comment">//for</span></span><br><span class="line">            node.end--;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prefixNumber</span><span class="params">(String pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">char</span>[] pres = pre.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pres.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.map.get(pres[i]) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            node = node.map.get(pres[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TrieTree trie = <span class="keyword">new</span> TrieTree();</span><br><span class="line">        System.out.println(trie.search(<span class="string">"程龙颖"</span>));<span class="comment">//f</span></span><br><span class="line">        trie.insert(<span class="string">"程龙颖"</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">"程龙颖"</span>));<span class="comment">//t</span></span><br><span class="line">        trie.delete(<span class="string">"程龙颖"</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">"程龙颖"</span>));<span class="comment">//f</span></span><br><span class="line">        trie.insert(<span class="string">"程龙颖"</span>);</span><br><span class="line">        trie.insert(<span class="string">"程龙颖"</span>);</span><br><span class="line">        trie.delete(<span class="string">"程龙颖"</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">"程龙颖"</span>));<span class="comment">//t</span></span><br><span class="line">        trie.delete(<span class="string">"程龙颖"</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">"程龙颖"</span>));<span class="comment">//f</span></span><br><span class="line">        trie.insert(<span class="string">"程龙颖一"</span>);</span><br><span class="line">        trie.insert(<span class="string">"程龙颖二"</span>);</span><br><span class="line">        trie.insert(<span class="string">"程龙颖一三"</span>);</span><br><span class="line">        trie.insert(<span class="string">"程龙颖一四"</span>);</span><br><span class="line">        trie.delete(<span class="string">"程龙颖一"</span>);</span><br><span class="line">        System.out.println(trie.search(<span class="string">"程龙颖一"</span>));<span class="comment">//f</span></span><br><span class="line">        System.out.println(trie.prefixNumber(<span class="string">"程龙颖"</span>));<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文参考《程序员代码面试指南—IT名企算法与数据结构题目最优解》</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 字典树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成窗口最大值数组</title>
      <link href="/2019/09/09/2019-9-9-%E7%94%9F%E6%88%90%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E6%95%B0%E7%BB%84/"/>
      <url>/2019/09/09/2019-9-9-%E7%94%9F%E6%88%90%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置，求每一种窗口状态下的最大值。（如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值）</p><a id="more"></a><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h6><blockquote><p>第一行输入n和w，分别代表数组长度和窗口大小<br>第二行输入n个整数Xi，表示数组中的各个元素</p></blockquote><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><blockquote><p>输出一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值</p></blockquote><h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><p>输入</p><blockquote><p>8 3<br>4 3 5 4 3 3 6 7</p></blockquote><h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><blockquote><p>5 5 5 4 6 7</p></blockquote><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>做这道题需要理解好<a href="https://blog.csdn.net/weixin_40374341/article/details/99712545" target="_blank" rel="noopener">窗口以及窗口内最大值或最小值的更新结构</a>，然后还需注意的点是何时进行减数操作以及何时统计窗口最大值。</p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMaxArray(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> w) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || w &lt; <span class="number">1</span> || arr.length &lt; w)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length - w + <span class="number">1</span>];</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//加数过程</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; arr[i] &gt;= arr[queue.peekLast()]) &#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.offerLast(i);</span><br><span class="line">            <span class="comment">//减数过程</span></span><br><span class="line">            <span class="keyword">if</span> (i - w == queue.peekFirst()) &#123;</span><br><span class="line">                queue.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i - w &gt;= -<span class="number">1</span>) &#123;</span><br><span class="line">                res[idx++] = arr[queue.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> w = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = getMaxArray(arr, w);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : res) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大值减去最小值小于或等于num的子数组的数量</title>
      <link href="/2019/09/09/2019-9-9-%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%8F%E5%8E%BB%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B0%8F%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8Enum%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E9%87%8F/"/>
      <url>/2019/09/09/2019-9-9-%E6%9C%80%E5%A4%A7%E5%80%BC%E5%87%8F%E5%8E%BB%E6%9C%80%E5%B0%8F%E5%80%BC%E5%B0%8F%E4%BA%8E%E6%88%96%E7%AD%89%E4%BA%8Enum%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定数组 arr 和整数 num，共返回有多少个子数组满足如下情况：<br>max(arr[i…j]) - min(arr[i…j]) &lt;= num<br>max(arr[i…j])表示子数组arr[i…j]中的最大值，min[arr[i…j])表示子数组arr[i…j]中的最小值。</p><a id="more"></a><h6 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h6><blockquote><p>第一行输入两个数 n 和 num，其中 n 表示数组 arr 的长度<br>第二行输入n个整数X_i，表示数组arr中的每个元素</p></blockquote><h6 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h6><blockquote><p>输出给定数组中满足条件的子数组个数</p></blockquote><h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><p>输入</p><blockquote><p>5 2<br>1 2 3 4 5</p></blockquote><p>输出</p><blockquote><p>12</p></blockquote><h6 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h6><p>这道题是滑动窗口问题，做好此题需要理解<a href="https://blog.csdn.net/weixin_40374341/article/details/99712545" target="_blank" rel="noopener">窗口以及窗口内最大值或最小值的更新结构</a>，下面就此题进行简单地分析。</p><p>观察题目，我们知道需要求得子数组的最大值和最小值，显然我们可以通过滑动窗口的<code>最大值更新结构和最小值更新结构</code>来获得。</p><p>另外需要两个指针，R指针是滑动窗口的右边界，负责将当前指向的元素加入到更新结构中，而L指针则是滑动窗口的左边界，其指向的元素表示即将要过期，因此在窗口向右滑动之前需要从更新结构中弹出（若该元素存在）。</p><p>下面举个例子。假设num = 2，观察下图，指针L和指针R的状态如下，同时最大值更新结构qmax和最小值更新结构qmin里保存的元素如下，括号内的值为数组对应下标的值。</p><p>我们可以发现此时max(arr[L…R]) - min(arr[L…R]) = 4 - 1 = 3 刚好大于num，所以如果窗口继续扩大，即R指针继续往右移动只可能使得原有的最大值变得更大，因此更不符合max(arr[L…R]) - min(arr[L…R]) &lt;= num的条件。此时我们可以统计出arr[L..R - 1]之间的子数组的数量了，可以发现其值为R - L。</p><p>继续观察下图，我们可以发现如果L指针往右移动，只可能使得原有的最小值变得更大，因此其是满足max(arr[L…R]) - min(arr[L…R]) &lt;= num这个条件的趋势的。所以每次当max(arr[L…R]) - min(arr[L…R]) &gt; num时，就向右移动L指针。</p><p>总的来说，因为一个数组可以分为arr[0]，arr[0..1]，…，arr[0…n - 1]以及arr[1]，arr[1..2]，…， arr[1…n - 1]，arr[2]…这些子数组，上述的过程只是从这些子数组中统计满足max(arr[i…j]) - min(arr[i…j]) &lt;= num的子数组数量。<br><img src="/2019/09/09/2019-9-9-最大值减去最小值小于或等于num的子数组的数量/1568039638498.png" alt></p><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值减最小值小于或等于num的子数组的数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; qmax = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; qmin = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; arr.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (R &lt; arr.length) &#123;</span><br><span class="line">                <span class="comment">// 生成最大值更新结构</span></span><br><span class="line">                <span class="keyword">while</span> (!qmax.isEmpty() &amp;&amp; arr[R] &gt;= arr[qmax.peekLast()]) &#123;</span><br><span class="line">                    qmax.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                qmax.offerLast(R);</span><br><span class="line">                <span class="comment">// 生成最小值更新结构</span></span><br><span class="line">                <span class="keyword">while</span> (!qmin.isEmpty() &amp;&amp; arr[R] &lt;= arr[qmin.peekLast()]) &#123;</span><br><span class="line">                    qmin.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                qmin.offerLast(R);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (arr[qmax.peekFirst()] - arr[qmin.peekFirst()] &gt; num) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                R++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// L所指向的元素将过期，需从更新结构中弹出</span></span><br><span class="line">            <span class="keyword">if</span> (qmax.peekFirst() == L) &#123;</span><br><span class="line">                qmax.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (qmin.peekFirst() == L) &#123;</span><br><span class="line">                qmin.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计子数组数量</span></span><br><span class="line">            res += R - L;</span><br><span class="line">            L++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getNum(arr, num));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>窗口以及窗口内最大值或最小值的更新结构</title>
      <link href="/2019/09/09/2019-9-9-%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E7%AA%97%E5%8F%A3%E5%86%85%E6%9C%80%E5%A4%A7%E5%80%BC%E6%88%96%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%84/"/>
      <url>/2019/09/09/2019-9-9-%E7%AA%97%E5%8F%A3%E4%BB%A5%E5%8F%8A%E7%AA%97%E5%8F%A3%E5%86%85%E6%9C%80%E5%A4%A7%E5%80%BC%E6%88%96%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E6%9B%B4%E6%96%B0%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="窗口概念"><a href="#窗口概念" class="headerlink" title="窗口概念"></a>窗口概念</h3><p>什么是窗口？假设现在有一数组及两个指针L和R，两指针只能在数组上向右移动且不能回退，那么[L…R]这个区域即是一个窗口。</p><h3 id="最大值更新结构"><a href="#最大值更新结构" class="headerlink" title="最大值更新结构"></a>最大值更新结构</h3><p>假设现在有一需求，即在窗口滑动的过程中我们需要求窗口内的最大值。这时我们需求借助最大值的更新结构，即<code>双端队列</code>。该更新结构需要保持其中的元素从大到小（从左到右）排序。</p><a id="more"></a><h4 id="加数过程"><a href="#加数过程" class="headerlink" title="加数过程"></a>加数过程</h4><p>指针R在数组上向右滑动的过程中，滑动窗口的范围会扩大。此时我们需要将指针R所指向的元素加入到双端队列的<code>尾部</code>中去，当然这一加入过程还需要满足双端队列中元素从左到右从大到小的规律。</p><p>假如现在有如下数组，其中R指针从0号位开始往后移动：</p><ol><li>当R指针指向0号元素时，我们将（0，4）加入到双端队列中，其中0表示元素4的坐标；</li><li>当R指针指向1号元素时，此时发现1号元素小于队列尾部的元素4，因此我们将（1，3）加入到双端队列中，此时双端队列中的数组元素满足从左到右从大到小的规律；</li><li>同理，当R指针指向2号元素时，此时发现2号元素小于队列尾部的元素3，因此我们将（2，1）加入到双端队列中；</li><li>当指针R指向3号元素时，此时发现队列中尾部的元素1小于此时的元素2，故将队列尾部的元素弹出，并再次判断队列尾部的元素是否还小于当前的元素2，我们发现3并不小于2，故将（3，2）加入队列中；</li><li>当指针R指向4号元素时，此时发现队列尾部的元素2小于5，故而将2弹出。队列中的元素3和4也同理依次弹出。此时发现队列为空，所以将（4，5）加入到队列中；</li><li>当指针R指向5号元素时，此时发现5号元素小于队列尾部的元素5，因此我们将（5，3）加入到双端队列中；</li><li>当指针R指向6号元素时，此时发现6号元素<code>不小于</code>队列尾部的元素3，因此我们将队列尾部的元素3弹出，并将（6，3）加入到双端队列中。自此，最大值的更新结构的加数过程就结束了。</li></ol><p><img src="/2019/09/09/2019-9-9-窗口以及窗口内最大值或最小值的更新结构/1568038994706.png" alt></p><p>上述的加数过程简单的讲即为，每次都将R指针指向的当前元素轮询的与队列中尾部的元素比较，如果当前元素大于等于队列的尾部的元素那么就将该尾部元素从尾部弹出，弹到尾部元素大于当前元素或队列为空为止。最后再将该当前元素从尾部加入到队列中去。</p><h4 id="减数过程"><a href="#减数过程" class="headerlink" title="减数过程"></a>减数过程</h4><p>指针L在数组上向右滑动的过程中，滑动窗口的范围会缩小。此时我们需要将指针L所指向的元素从双端队列的<code>头部</code>中弹出（如果该元素还存在）。</p><p>假设当前处于上述加数的过程4，此时双端队列的状态如下所示，即此时队列中存在元素（0，4），（1，3）和（3，2）。</p><p><img src="/2019/09/09/2019-9-9-窗口以及窗口内最大值或最小值的更新结构/1568038994709.png" alt></p><p>现在我们来模拟一下最大值的更新结构的减数过程，假设指针L从数组的0号位开始往右移动：</p><ol><li>当L指针指向0号元素时，此时发现双端队列中存在0号元素4，此时我们将0号元素4从队列的头部弹出；</li><li>当L指针指向1号元素时，此时发现双端队列中存在1号元素3，此时我们将1号元素3从队列的头部弹出；</li><li>当L指针指向1号元素时，此时发现双端队列中并不存在2号元素（之前加数过程被弹出了），那么指针L继续向右移动；</li><li>…</li></ol><p>可以发现最大值的更新结构的减数过程很简单，即每次判断L指针指向的当前元素是否在双端队列的头部，若存在则弹出，否则L指针继续向右移动。</p><p><code>注意</code>：上述为了便于讨论，我们假设双端队列中保存的元素是（i，arr[i]）。但是双端队列其实可以只保存元素的下标，因为当要比较元素的大小时，我们完全可以通过下标去或获取下标所对应的元素。</p><h3 id="最小值更新结构"><a href="#最小值更新结构" class="headerlink" title="最小值更新结构"></a>最小值更新结构</h3><p>假如在窗口滑动的过程中我们需要求窗口内的最小值。这时我们需求借助最小值的更新结构，同样也是<code>双端队列</code>。该更新结构需要保持其中的元素从小到大（从左到右）排序。</p><p>由于最小值的更新结构和最大值的更新结构的加数过程与减数过程是相似的，下面我们仅简单的描述其过程。</p><h4 id="加数过程-1"><a href="#加数过程-1" class="headerlink" title="加数过程"></a>加数过程</h4><p>最小值更新结构加数过程简单地讲即为，每次都将R指针指向的当前元素轮询的与队列中尾部的元素比较，如果当前元素小于等于队列的尾部的元素那么就将该尾部元素从尾部弹出，弹到当前元素大于尾部元素或队列为空为止。最后再将该当前元素从尾部加入到队列中去。</p><h4 id="减数过程-1"><a href="#减数过程-1" class="headerlink" title="减数过程"></a>减数过程</h4><p>减数过程很简单，即每次判断L指针指向的当前元素是否在双端队列的头部，若存在则弹出，否则L指针继续向右移动。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小和与逆序对问题</title>
      <link href="/2019/09/08/2019-9-8-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%E4%B8%8E%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/08/2019-9-8-%E5%B0%8F%E5%92%8C%E9%97%AE%E9%A2%98%E4%B8%8E%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="小和问题"><a href="#小和问题" class="headerlink" title="小和问题"></a>小和问题</h3><p>在一个数组中， 每一个数左边比当前数小的数累加起来， 叫做这个数组的小和。 求一个数组的小和。<br>例子：<br>[1,3,4,2,5]<br>1左边比1小的数， 没有；<br>3左边比3小的数， 1；<br>4左边比4小的数， 1、 3；<br>2左边比2小的数， 1；<br>5左边比5小的数， 1、 3、 4、 2；<br>所以小和为1+1+3+1+1+3+4+2=16</p><a id="more"></a><p>小和问题使用的思想即为归并排序，当上述数组在排序和归并处于如下过程时：<br><img src="/2019/09/08/2019-9-8-小和问题与逆序对问题/1567745710108.png" alt><br>因为1小于2，那么1一定小于2即其后的所有元素（因为前后两半数组已排好序）,那么小和中一定有R - j + 1个元素1。当归并排序处于如下过程时，会产生小和：<br><img src="/2019/09/08/2019-9-8-小和问题与逆序对问题/1567745710110.png" alt><br>同理，我们可以得出有R - j + 1个3。</p><p>小和问题的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小和问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeSortCore(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mergeSortCore</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 相比于(L + R) / 2，下面的更快且避免整型溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> mergeSortCore(arr, L, mid) + mergeSortCore(arr, mid + <span class="number">1</span>, R) + merge(arr, L, R, mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// 指向数组help的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = L;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R) &#123;</span><br><span class="line">            res += arr[j] &gt; arr[i] ? arr[i] * (R - j + <span class="number">1</span>) : <span class="number">0</span>;<span class="comment">//计算小和</span></span><br><span class="line">            help[k++] = arr[j] &lt;= arr[i] ? arr[j++] : arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">            help[k++] = arr[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= R)</span><br><span class="line">            help[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; help.length; u++)</span><br><span class="line">            arr[L + u] = help[u];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逆序对问题"><a href="#逆序对问题" class="headerlink" title="逆序对问题"></a>逆序对问题</h3><p>在一个数组中， 左边的数如果比右边的数大， 则两个数构成一个逆序对， 请统计所有逆序对数。<br>逆序对问题其实和小和问题基本上是一样的，只是这里的比较标准是左边的数大于右边的数，而小和问题是左边的数要小于右边的数才能产生小和。<br>逆序对的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆序对问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InversionPair</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> inversionPairCore(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">inversionPairCore</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);<span class="comment">//注意括号</span></span><br><span class="line">        <span class="keyword">int</span> leftPairs = inversionPairCore(arr, L, mid);</span><br><span class="line">        <span class="keyword">int</span> rightPairs = inversionPairCore(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> (leftPairs + rightPairs + merge(arr, L, R, mid));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = L;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pairNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R) &#123;</span><br><span class="line">            pairNum += arr[i] &gt; arr[j] ? mid - i + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            help[k++] = arr[j] &lt; arr[i] ? arr[j++] : arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">            help[k++] = arr[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= R)</span><br><span class="line">            help[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; help.length; u++)</span><br><span class="line">            arr[L + u] = help[u];</span><br><span class="line">        <span class="keyword">return</span> pairNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP 算法</title>
      <link href="/2019/09/06/2019-9-6-KMP-%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/06/2019-9-6-KMP-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们先来看的题目，假如给定两个字符串str和match，长度分别为N和M。实现一个算法，如果字符串str中含有子串match，则返回match在str中的开始位置，不含有则返回-1，要求算法复杂度为O(N)。</p><p>举例如下：<br>str = “acbc”,  match = “bc”,  返回 2。<br>str = “acbc”,  match = “bcc”,  返回 -1。</p><a id="more"></a><h2 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h2><p>最普通的解法是从左到右遍历str的每一个字符，然后看如果以当前字符作为第一个字符出发是否匹配出match。比如str = “aaaaaaaaab”，match = “aaaab”。从str[0] 出发，开始匹配，匹配到str[4] == ‘a’ 时发现和 match[4] == ‘b’不一样，所以匹配失败，说明从str[0]出发是不行的。下一轮则开始从str[1]出发开始匹配，如此反复。普通解法的时间复杂度较高，从每个字符出发时，匹配的代价都可能是O(M)，那么一共有N个字符，所以整体的时间复杂度为O(N * M)。普通解法的时间复杂度这么高，是因为每次遍历到一个字符时，检查工作相当于从无开始，之前的遍历检查不能优化当前的遍历检查。</p><h2 id="KMP-解法"><a href="#KMP-解法" class="headerlink" title="KMP 解法"></a>KMP 解法</h2><h3 id="1-初识-next-数组"><a href="#1-初识-next-数组" class="headerlink" title="1. 初识 next 数组"></a>1. 初识 next 数组</h3><p>首先需要生成match字符串的next数组，这个数组的长度等于match字符串的长度，next[i]的含义是在match[i]之前的字符串match[0..i-1]中，必须以match[i-1]结尾的后缀字符串（不能包含match[0]）与必须以match[0]开头的前缀字符串（不能包含match[i-1]）最大匹配长度。</p><p>下面我们举几个例子，观察下图：<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960621.png" alt><br>我们可以发现match字符串i位置前的字符串”abcgkabc”中的前缀字符串和后缀字符串的最大匹配长度为3，那么此时next[i] == 3。我们可以再考虑下面的例子：<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960623.png" alt><br>从上图中我们可以知道next[i] == 4。需要注意的是前缀和后缀不可重叠，即match[i]之前的字符串match[0..i-1]中，后缀字符串必须以match[i-1]结尾且不能包含match[0]，前缀字符串必须以match[0]开头且不能包含match[i-1]。</p><p>当然，也有两种比较特殊的情形，我们默认next[0] == -1，因为此时match[0]之前并不存在字符串，所以更不存在前缀和后缀问题。另外，我们也将next[1] == 0，此时我们认为match[1]之前的最长匹配前缀和后缀等于0。</p><p>关于如何快速得到next数组的问题，我们后面再详细说明，接下来先看如果有了match的next数组，如何加速进行str和match的匹配过程。</p><h3 id="2-匹配过程"><a href="#2-匹配过程" class="headerlink" title="2. 匹配过程"></a>2. 匹配过程</h3><p>首先观察下图的match字符串，元素Y之前的字符串中具有最长匹配前缀和后缀，其中指针z指向前缀的后面一个元素。<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960625.png" alt><br>然后，下图是str字符串的从i位置开始的某一部分，假设str[i]到元素X的字符（不包含元素X）都已经和match[0]到元素Y的字符（不包含元素Y）匹配成功，其中元素X和元素Y并不匹配。<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960626.png" alt><br>此时我们可以将match向右移动，然后将元素X与match[z]继续向后匹配，如下图：<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960627.png" alt><br>这里需要说明的是为什么不是从str的j号位置与match的0号位置开始向后匹配呢？这是因为此时后缀1与前缀2是相等的，因此只需从元素X与match[z]继续向后匹配即可。</p><p>另一个问题是是否存在从str[i]到str[j]（不包含str[j]）的以某个元素开始的字符串与match匹配呢？答案是不存在，下面我们来进行反证。</p><p>观察下图，我们假设从k位置开始存在某一子串与match向匹配，我们可以发现子串1和子串2相等，因为我们之前已经假设str[i]到元素X之间的字符都已经和match字符串match[0]到元素Y之间的字符匹配成功。另外我们又假设从k位置开始存在某一子串与match向匹配，那么必然符合子串1与子串3相等的情况。此时我们会发现子串2和子串3是match字符串的前缀字符串和后缀字符串，而且比我们原先得出的最长匹配的前缀字符串和后缀字符串更长。所以，从k位置开始存在某一子串与match相匹配的假设不成立。<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960628.png" alt><br>前面有讲到在匹配过程中元素X与元素Y不相等时，此时将match向右移动，然后将元素X与match[z]继续向后匹配，如下图：<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960684.png" alt><br>其实这个match字符串向右移动的过程，我们可以视为指向元素Y的指针y指向了z的位置，仔细发现我们可以知道z的值即为前缀2的长度，亦即next[y]的值。</p><p>假如现在指针y指向了z的位置，那么就从元素X与match[z]开始向后匹配。假如元素X不等于match[z]，那么指针y则重新指向match[0..z-1]之间的最长匹配前缀的后面一个字符。如下图示：<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960685.png" alt><br>其实这个问题只是之前元素X与元素Y不相等时的一个子问题而已，其中当元素X与y指向的元素不相等时，那么指针y就指向next[y]的位置，如此反复。</p><p>然而当指针y指向了match[0]，此时next[0] == -1，指针y将不能继续往前跳了，因为并没有为-1的位置。此时在str字符串中将不再指向元素X，而是指向其后面一个元素，然后继续与match[0]往后匹配。此时我们可以认为从元素str[i]到元素X没有一个以其为起始元素的字符串与match匹配。</p><p>KMP 算法的匹配过程简单的讲就是发现并舍弃字符的过程，当str的元素与match不匹配时，我们就找到了更多需要舍弃的字符，因为这些字符以其为起始字符所构成的字符串并不能与match相匹配。</p><h3 id="3-匹配实现"><a href="#3-匹配实现" class="headerlink" title="3. 匹配实现"></a>3. 匹配实现</h3><p>根据上述匹配过程，我们可以得出如下实现步骤：</p><ol><li>当str中的字符与match中的字符匹配时，那指向str和match的指针都往后移动，且当match走到末尾的时候结束；</li><li>当str中的字符与match中的字符不匹配时，指针match的指针每次都指向next[y]的位置，其中y为当前指针的位置；</li><li>当指向match的指针指向0号位时，即next[0] == -1时，如果依旧不匹配，那么指向str中的指针向后移动。</li></ol><p>具体的实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndexOf</span><span class="params">(String str, String match)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span> || match == <span class="keyword">null</span> || match.length() == <span class="number">0</span> || str.length() &lt; match.length())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] strs = str.toCharArray();</span><br><span class="line">    <span class="keyword">char</span>[] matchs = match.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> si = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNextArray(matchs);<span class="comment">//获取next数组</span></span><br><span class="line">    <span class="keyword">while</span> (si &lt; strs.length &amp;&amp; mi &lt; matchs.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (strs[si] == matchs[mi]) &#123;<span class="comment">//1</span></span><br><span class="line">            si++;</span><br><span class="line">            mi++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next[mi] == -<span class="number">1</span>) &#123;<span class="comment">//3</span></span><br><span class="line">            si++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//2</span></span><br><span class="line">            mi = next[mi];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mi == matchs.length ? si - mi : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-next-数组实现"><a href="#4-next-数组实现" class="headerlink" title="4. next 数组实现"></a>4. next 数组实现</h3><p>最后需要解释如何快速得到match字符串的next数组。我们前面已经说过，match[0] == -1，match[1] == 0。之后对match[i]（i &gt; 1）来说，求解过程如下：</p><p>1.因为是从左到右依次求解next，所以在求解next[i]时，next[0..i-1]的值都已经求出。假设match[i]字符为图9-26中的A字符，match[i-1]为图9-26中的B字符，如下图示。</p><p>通过next[i-1]的值可以知道B字符前的字符串的最长前缀与后缀匹配区域，图9-26中的 l 区域为最长匹配的前缀字符串，k区域为最长匹配的后缀字符串，字符C为l区域之后的字符。然后看字符C与字符B是否相等。<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960687.png" alt><br>2.如果字符C与字符B相等，那么A字符之前的字符串的最长前缀与后缀匹配区域就可以确定，前缀字串为l区域+C字符，后缀子串为k区域+B字符，即next[i] = next[i-1] + 1。</p><p>3.如果字符C与字符B不相等，就看字符C之前的前缀和后缀匹配情况，假设字符C是第cn个字符（match[cn]），那么next[cn]就是字符C之前的最长前缀和后缀匹配长度，如图9-27所示：<br><img src="/2019/09/06/2019-9-6-KMP-算法/1567738960688.png" alt><br>在图9-27中，m区域和n区域分别是字符C之前的字符串的最长匹配的后缀与前缀区域，这是通过next[cn]的值确定的，当然两个区域是相等的，m’区域为k区域最右的区域且长度与m区域一样，因为k区域和l区域是相等的，所以m区域和m’区域也相等，字符D为n区域之后的一个字符，接下来比较字符D是否与字符B相等。<br> 1）如果相等，A字符之前的字符串的最长前缀和后缀匹配区域就可以确定，前缀子串为n区域+D字符，后缀子串为m’区域+B字符，则令next[i] = next[cn] + 1。<br> 2）如果不等，cn继续往前跳到字符D，之后的过程与跳到字符C类似，一直进行这样的跳过程，跳的每一步都会有一个新的字符和B比较（就像C字符和D字符一样），只要有相等的情况，next[i]的值就能确定。</p><p>4.如果向前跳到最左位置（即match[0]的位置），此时next[0] == -1，说明字符A之前的字符串不存在前缀和后缀匹配的情况，则令next[i] == 0。</p><p>求解next数组的具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNextArray(<span class="keyword">char</span>[] ms) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ms.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[ms.length];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; next.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms[cn] == ms[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            next[i++] = ++cn;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cn = next[cn];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文参考《程序员代码面试指南》</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> KMP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2019/09/06/2019-9-6-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2019/09/06/2019-9-6-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="〇、对数器"><a href="#〇、对数器" class="headerlink" title="〇、对数器"></a>〇、对数器</h2><p>对数器的作用是在没有<code>Online Judge</code>的情况下，我们自己实现的测试代码的工具。比如现在我们有一个要测试的方法a，我们需要：</p><ol><li>实现一个<strong>绝对正确</strong>但是复杂度可以不好的方法b</li><li>实现一个随机样本产生器</li><li>实现比对的方法，即用来对比方法a与方法b产生的结果的比对方法</li><li>把方法a和方法b比对很多次来验证方法a是否正确</li><li>如果有一个样本使得比对出错， 打印样本分析是哪个方法出错</li><li>当样本数量很多时比对测试依然正确， 可以确定方法a已经正确<a id="more"></a></li></ol><p>下面是用于测试数据结构为数组的排序算法的对数器代码实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTestUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//随机样本产生器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateRandomArray(<span class="keyword">int</span> maxSize, <span class="keyword">int</span> maxValue) &#123;</span><br><span class="line">        <span class="comment">//生成一个随机长度的数组，长度位于[0 - maxSize]之间</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[(<span class="keyword">int</span>) ((maxSize + <span class="number">1</span>) * Math.random())];</span><br><span class="line">        <span class="comment">//为数组元素赋随机值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="keyword">int</span>) ((maxValue + <span class="number">1</span>) * Math.random()) - (<span class="keyword">int</span>) (maxValue * Math.random());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个时间复杂度可以差但是绝对正确的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">comparator</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] copyArray(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比对方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((arr1 == <span class="keyword">null</span> &amp;&amp; arr2 != <span class="keyword">null</span>) || (arr1 != <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1 == <span class="keyword">null</span> &amp;&amp; arr2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1.length != arr2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] != arr2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于上述对数器的使用，可以参见下面冒泡排序的部分。</p><h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><p>思想：从左到右不断交换相邻<strong>逆序</strong>的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。<br>举例：<br>比如现在有数组[3,5,2,4,1]。开始时有指针j和j+1指向元素3和5，发现3小于5，那么不交换元素位置。指针j加1，此时j和j+1分别指向5和2，因为5大于2，所以交换元素位置。以此类推，当j指向最后第二个元素并交换元素位置之后，数组变为[3,2,4,1,5]，此时元素5已经排好序了。现在j重新指向0号位置，重新进行如上过程。因为最后一个元素5已经排好序了，所以指针j只需走到最后第三个元素即可停止。当第二大元素排好序后，第三次循环同理。</p><p>冒泡排序的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">            <span class="comment">//变量j向右走最远的坐标为 arr.length - 2</span></span><br><span class="line">            <span class="comment">//变量e走到坐标1即可停止</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; e; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                    swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用对数器来验证如上冒泡排序算法的正确性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testTime = <span class="number">500000</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">boolean</span> succeed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span>[] testArr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = SortTestUtil.generateRandomArray(maxSize, maxValue);</span><br><span class="line">        testArr = SortTestUtil.copyArray(arr1);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = SortTestUtil.copyArray(arr1);</span><br><span class="line">        BubbleSort.bubbleSort(arr1);</span><br><span class="line">        SortTestUtil.comparator(arr2);</span><br><span class="line">        <span class="keyword">if</span> (!SortTestUtil.isEqual(arr1, arr2)) &#123;</span><br><span class="line">            succeed = <span class="keyword">false</span>;</span><br><span class="line">            SortTestUtil.printArray(testArr);</span><br><span class="line">            SortTestUtil.printArray(arr1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(succeed ? <span class="string">"Nice!"</span> : <span class="string">"Fucking fucked!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡排序的时间复杂度O(N^2)， 额外空间复杂度O(1)。</p><h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><p>思想：从数组中选择最小元素，将它与数组的第一个元素交换位置。再从数组剩下的元素中选择出最小的元素，将它与数组的第二个元素交换位置。不断进行这样的操作，直到将整个数组排序。<br>举例：<br>现在有一数组[3,5,2,4,1]。开始时有两个指针minIndex和j分别指向3和5，然后j依次往后遍历，并分别与指针minIndex所指向的元素3进行对比，如果j所指向的元素小于minIndex所指向的元素，那么将minIndex设置为j，当j遍历完之后就得到了数组中最小元素的下标minIndex，此时将minIndex与0号元素交换位置，那么0号位置的元素就排好序了。下一次循环开始，minIndex指向1号位置元素，j指向2号位置元素，重复上述过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, i, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序的时间复杂度O(N^2)， 额外空间复杂度O(1)</p><h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><p>思想：每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。<br>举例：<br>现在有一数组[3,5,2,4,1]。开始时指针j指向1号元素5，将1号元素与0号元素进行对比，如果1号元素小于0号元素那么就交换位置。因为5大于3，所以不交换位置。下一次循环j指向2号元素，同样与前一个元素进行对比，因为2小于5所以交换位置，此时数组变为[3,2,5,4,1]。j减1指向1号元素2，同样的与前一个元素进行对比，因为2小于3所以交换元素位置，此时数组变为[2,3,5,4,1]。下一次循环j指向3号元素，然后进行上述过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j-<span class="number">1</span>])</span><br><span class="line">                    swap(arr, j, j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序的时间复杂度O(N^2)， 额外空间复杂度O(1)</p><h2 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h2><p>希尔排序是希尔（Donald Shell） 于 1959 年提出的一种排序算法。 希尔排序也是一种<strong>插入排序</strong>， 它是简单插入排序经过改进之后的一个更高效的版本， 也称为<strong>缩小增量排序</strong>。</p><p>思想：希尔排序是把记录按下标的一定增量分组， 对每组使用直接插入排序算法排序； 随着增量逐渐减少， 每组包含的关键词越来越多， 当增量减至 1 时， 整个文件恰被分成一组， 算法便终止。</p><p>上面的算法思想阐述得可能不是很明了，下面就一个例子来讲解该算法的排序过程：</p><p>观察如下数组，<strong>以下数据元素颜色相同为一组</strong>：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710073.png" alt><br>初始增量gap = length / 2 = 5，意味着整个数组被分为5组：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710076.png" alt><br>对这5组分别进行直接插入排序，结果如下。可以看到，像3，5，6，0这些小元素都被调到前面了。</p><p>然后缩小增量 gap = 5 / 2 = 2，数组被分为2组，如下所示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710077.png" alt><br>对以上2组再分别进行直接插入排序，结果如下。可以看到，此时整个数组的有序程度更近了一步。</p><p>再缩小增量gap = 2 / 2 = 1，此时，整个数组为1组，如下：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710078.png" alt><br>此时，仅仅需要对以上数组进行最后一次直接插入排序，即可完成整个数组的排序：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710079.png" alt></p><p>实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                    swap(arr, j, j - gap);</span><br><span class="line">                    j -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// for</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h2><p>思想：归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。<br>举例：<br>有一数组[3,5,2,4,1]，其归并排序中将数组以递归地方式分成两部分的过程如下图所示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710080.png" alt="递归拆分过程"><br>上图中仅涉及数组的拆分过程，并未涉及数组元素的排序和归并过程。观察上图左下角部分，数组[3,5]被拆分为子数组[3]和子数组[5]，此时我们需要将两个子数组进行排序然后并归并到原数组中的对应位置上(这里是0号和1号元素位置)。排序和归并的过程以下图的排序状态为例：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710081.png" alt><br>假设现在有一个指针i指向前半部分的首个元素位置，j指针指向后半部分的第一个元素位置。比较i和j所指向的元素，并将较小值拷贝到一个临时数组中，较小值所对应的指针往后移动一位，另一个指针不变。比如上图，j所指向的元素2小于i所指向的元素3,那么元素2会拷贝到临时数组中，指针j往后移动，如果元素2后还有一个元素4，那么显然i所指向的元素3会被拷贝到临时数组，i然后向后移动一位。进行上述过程中，i和j会向后移动，当其中一个指针数组越界后，即可结束上述过程。<br>如上图，j指针会先数组越界，那么将i指针及其后的所有元素拷贝进临时数组中。如果i先越界也同理。<br>以上过程即完成了数组元素的排序过程，然后将临时数组中排好序的元素拷贝回原数组中的对应位置中，便完成了归并过程。即在完成了上述步骤后，原数组变为[2,3,5,4,1]。<br>当递归完数组的后半部分[4,1]后，原数组会变为[2,3,5,1,4]。最后进行前后各半部分的排序和归并过程便得出最后的排序数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        mergeSortCore(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortCore</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == R)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 相比于(L + R) / 2，下面的更快且避免整型溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSortCore(arr, L, mid);</span><br><span class="line">        mergeSortCore(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">        merge(arr, L, R, mid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;<span class="comment">// 指向数组help的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = L;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= R)</span><br><span class="line">            help[k++] = arr[j] &lt;= arr[i] ? arr[j++] : arr[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">            help[k++] = arr[i++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= R)</span><br><span class="line">            help[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; help.length; u++)</span><br><span class="line">            arr[L + u] = help[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序的时间复杂度O(N*logN)， 额外空间复杂度O(N)</p><p>【补充】：<br>递归行为和递归行为时间复杂度的估算遵循如下master公式：<br><strong>T(N) = a*T(N/b) + O(N^d)</strong></p><p>1) log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))<br>2) log(b,a) = d -&gt; 复杂度为O(N^d * logN)<br>3) log(b,a) &lt; d -&gt; 复杂度为O(N^d)</p><p>对于归并排序，长度为N的数组分为两次的T(N/2)时间复杂度的排序和O(N)的归并过程，所以a = b = 2，d = 1，即符合第2点log(b,a) = d，故时间复杂度为O(N*logN)。因为总的情况下需要长度为N的临时数组空间，故额外空间复杂度为O(N)。</p><h2 id="六、随机快速排序"><a href="#六、随机快速排序" class="headerlink" title="六、随机快速排序"></a>六、随机快速排序</h2><p>在讲随机快速排序前，有必要了解一下两个问题：</p><h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>给定一个数组arr， 和一个数num， 请把小于等于num的数放在数组的左边， 大于num的数放在数组的右边。要求额外空间复杂度O(1)， 时间复杂度O(N)</p><p>分析：假设现在有一数组[4,5,1,2,9]。我们可以使用指针less指向数组的-1处，然后指针i从0号位往后遍历数组。如果i指向的元素大于num，那么i向右移动一位。如果小于等于num那么将i指向的元素与less + 1位置的元素交换位置，然后less和i向右移动一位。<br>由此less其左边的小于num的区域逐渐向右扩张，从而就把小于等于num的数放在数组的左边， 大于num的数放在数组的右边。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftSmallNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftSmallNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= num)</span><br><span class="line">                swap(arr, ++less, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> less, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[less];</span><br><span class="line">        arr[less] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>荷兰国旗问题：给定一个数组arr， 和一个数num， 请把小于num的数放在数组的左边， 等于num的数放在数组的中间， 大于num的数放在数组的右边。要求额外空间复杂度O(1)， 时间复杂度O(N)</p><p>与问题一类似，假设现在需要将小于2的数放在数组的左边，大于2的数放在数组的右边，等于2的数放在数组中间。<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710111.png" alt><br>初始时有指针less指向-1，more指向arr.length。如果当前指针i所指向的元素大于num，那么与more - 1的元素交换位置，more向左移动一位，i指针不移动并继续判断。如果当前指针i所指向的元素小于num，那么与less + 1的元素交换位置，less向右移动一位，i指针也向右移动一位。如果当前指针i所指向的元素等于num，i指针向右移动一位。当i大于等于more时，即可结束上述过程。</p><p>下面代码，实现了自定义边界L和R，而不再是简单的指向-1和数组的长度arr.length。其能够实现指定范围内的荷兰国旗问题的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetherLandsFlag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回值为数组中等于num的左右边界（包含）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] netherLandsFlag(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = L;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &gt; num)</span><br><span class="line">                swap(arr, cur, --more);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &lt; num)</span><br><span class="line">                swap(arr, cur++, ++less);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more - <span class="number">1</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以用荷兰国旗问题来改进快速排序。由于荷兰国旗问题实现了数组中等于num的元素的上下边界值，然后我们通过上下边界值可以递归地实现数组前半部分和后半部分，最后实现了数组的整体有序。需要注意的是：不同于荷兰国旗问题中num的值是自己给定的，随机快速排序算法中的num值是当前数组的最后一个元素。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>我们看一下随机排序算法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="comment">// 随机将数组L ~ R - 1内的某个元素与R位置的元素交换位置</span></span><br><span class="line">            swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br><span class="line">            <span class="keyword">int</span>[] p = partition(arr, L, R, arr[R]);</span><br><span class="line">            quickSort(arr, L, p[<span class="number">0</span>] - <span class="number">1</span>);<span class="comment">//前半部分</span></span><br><span class="line">            quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, R);<span class="comment">//后半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> less = L - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> more = R;<span class="comment">// more指向R</span></span><br><span class="line">        <span class="keyword">int</span> cur = L;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[cur] &gt; num)</span><br><span class="line">                swap(arr, cur, --more);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[cur] &lt; num)</span><br><span class="line">                swap(arr, cur++, ++less);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, more, R);<span class="comment">//交换元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 随机将数组L ~ R - 1内的某个元素与R位置的元素交换位置</span></span><br><span class="line">swap(arr, L + (<span class="keyword">int</span>) (Math.random() * (R - L + <span class="number">1</span>)), R);</span><br></pre></td></tr></table></figure><p>为什么要<strong>随机</strong>从数组中选取一个元素然后与R位置的元素交换位置，然后将其作为num呢？我们下面来分析一下为什么需要随机的选择。</p><p>假设现在有一个数组[5,4,3,2,1]。如果我们不随机选择，而是每次将最右边的元素（第一次递归时是元素1）作为num，那么我们会发现大于1的元素占了4个，快速排序算法最终会退化为时间复杂度为O（n * n）的算法。如果是随机选择的，那么在期望上随机选择排序的时间复杂度是O(N * logN)。</p><p>随机快速排序的时间复杂度是O(N*logN)， 额外空间复杂度是O(logN)。</p><h2 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h2><p>堆即为完全二叉树。下面我们使用数组来实现大根堆，所谓大根堆就是符合树中的所有子树的根大于其所有子节点的完全二叉树。比如下面即为一个大根堆：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710112.png" alt="大根堆"><br>其物理存储结构为数组，如下所示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710113.png" alt="物理数组结构"><br>我们可以通过如下公式来求得当前节点的左孩子、右孩子和父节点的位置，假设节点的位置为index：</p><ol><li>左孩子：2 * index + 1</li><li>右孩子：2 * index + 2</li><li>父节点：(index - 1) / 2</li></ol><h3 id="heapInsert"><a href="#heapInsert" class="headerlink" title="heapInsert"></a>heapInsert</h3><p>当一个元素加入大根堆时，可以使用heapInsert方法对该元素进行调整，即若该元素大于其父节点的值，那么就往上浮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大值往上浮</span></span><br><span class="line"><span class="comment">//index为该元素在数组中的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>当大根堆中的顶部某元素的值变小了，就比如当元素5变为0时，即：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710114.png" alt><br>为了符合大根堆的特性，我们需调整大根堆，将0往下沉，最后符合如下图示：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710116.png" alt><br>上述过程的代码具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小值往下沉</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// arr[parent]往下沉的过程</span></span><br><span class="line">        <span class="keyword">int</span> left = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 假设left为最大值</span></span><br><span class="line">        <span class="keyword">int</span> largest = left;</span><br><span class="line">        <span class="comment">// left &lt; size说明左孩子存在</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 在右孩子存在的情况下，将左右孩子较大者的下标赋给largest，其中left + 1为右孩子</span></span><br><span class="line">            largest = left + <span class="number">1</span> &lt; size &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">// 左右孩子较大者与父节点比较，将较大者赋给largest</span></span><br><span class="line">            largest = arr[largest] &gt; arr[parent] ? largest : parent;</span><br><span class="line">            <span class="comment">// 如果父节点最大，则说明不再需要进行下沉过程</span></span><br><span class="line">            <span class="keyword">if</span> (largest == parent)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 父节点下沉</span></span><br><span class="line">            swap(arr, parent, largest);</span><br><span class="line">            parent = largest;</span><br><span class="line">            left = (parent &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>理解了上述两个方法后，我们就可以使用如下方法完成堆排序的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> size = arr.length;</span><br><span class="line">    <span class="comment">//构建大根堆，即往大根堆插入数据的过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        heapInsert(arr, i);</span><br><span class="line">    <span class="comment">//从大根堆中删除元素，并达到排序效果</span></span><br><span class="line">    <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 堆顶最大元素移动数组最后位置</span></span><br><span class="line">        swap(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 逻辑上删除堆的最后一个元素</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>, --size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆排序的时间复杂度O(N*logN)， 额外空间复杂度O(1)</p><h2 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h2><p>计数排序属于桶排序的一种，是非基于比较的排序， 与被排序的样本的实际数据状况很有关系， 所以实际中并不经常使用。</p><p>为什么说计数排序与被排序的样本的实际数据状况很有关系呢？先看下面的例子，我们可以实现对以下数组进行排序，另外假设数组中的元素大小需满足[0 ~ length] 。<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710117.png" alt><br>我们可以创建一个长度为length + 1的数组作为桶数组，每个桶用于保存原数组中的某元素出现的次数。其中元素值对应于桶数组中元素的下标。比如上面的数组经过元素个数统计后，其桶数组如下：<br><img src="/2019/09/06/2019-9-6-排序算法/1567745710118.png" alt><br>其表示元素0出现的次数为1，元素1出现的次数为2，其他同理。得到桶数组后，我们可以依靠该数组的信息将数据以有序的方式拷贝回原数组中。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定arr的元素符合0 ~ arr.length</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bucket[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>)</span><br><span class="line">                arr[index++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以规定数组arr中的元素需满足0 到该数组中的最大值max，此时我们就需要创建一个长度为max + 1为的桶数组。当max很大时，我们不得不创建很大的桶数组，这就是我们上面说计数排序与被排序的样本的实际数据状况很有关系的原因。更改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 规定arr的元素符合0 ~ max</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            max = Math.max(arr[i], max);</span><br><span class="line">        <span class="keyword">int</span>[] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            bucket[arr[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j]-- &gt; <span class="number">0</span>)</span><br><span class="line">                arr[index++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计数排序的时间复杂度为O(N)， 额外空间复杂度为O(N)。</p><h3 id="补充问题"><a href="#补充问题" class="headerlink" title="补充问题"></a>补充问题</h3><p>给定一个数组， 求如果排序之后， 相邻两数的最大差值， 要求时间复杂度O(N)， 且要求不能用非基于比较的排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxGap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxGap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = arr.length;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 获取数组中的最大最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            min = Math.min(min, arr[i]);</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max == min)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 创建桶，每个桶包含boolean， min，max三个值</span></span><br><span class="line">        <span class="keyword">boolean</span>[] hasNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] mins = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] maxs = <span class="keyword">new</span> <span class="keyword">int</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取每个桶中的最小和最大值，以及是否同中是否有值</span></span><br><span class="line">        <span class="keyword">int</span> bid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            bid = bucket(arr[i], size, max, min);</span><br><span class="line">            mins[bid] = hasNum[bid] ? Math.min(mins[bid], arr[i]) : arr[i];</span><br><span class="line">            maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], arr[i]) : arr[i];</span><br><span class="line">            hasNum[bid] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取桶之间的最大差值</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lastMax = maxs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasNum[i]) &#123;</span><br><span class="line">                res = Math.max(res, mins[i] - lastMax);</span><br><span class="line">                lastMax = maxs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前num所对应的桶号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bucket</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">long</span> size, <span class="keyword">long</span> max, <span class="keyword">long</span> min)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) ((num - min) * size / (max - min));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵的最小路径和</title>
      <link href="/2019/09/06/2019-9-6-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
      <url>/2019/09/06/2019-9-6-%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>给定一个矩阵matrix，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，返回所有的路径中的最小路径和。</p><p>如果给定的矩阵matrix如下：</p><p><img src="/2019/09/06/2019-9-6-矩阵的最小路径和/1567745854978.png" alt="1567745854978"></p><p>其中路径1，3，1，0，6，1，0是所有路径中路径和最小的，所以返回12。</p><a id="more"></a><h3 id="一、暴力递归"><a href="#一、暴力递归" class="headerlink" title="一、暴力递归"></a>一、暴力递归</h3><p>下面我们使用递归的方法来处理这个问题。假设现在矩阵matrix有点a(i,j)，我们要求得点a(i,j)到矩阵右下角的点b的路径和，需遵循如下规律：</p><ol><li>要求得点a(i,j)到点b的路径和，首先要求得点a的<strong>右边的点</strong>到点b的路径和right，以及点a<strong>下面的点</strong>到点b之间的路径和down。那么最后点a到点b的路径和记为min{right, down} + a(i, j)；</li><li>当点a(i, j)到达最后一行时，它已经不能向下移动而只能向右移动，其路径和为点a加上其右边的点到点b的路径和；</li><li>当点a(i, j)到达最后一列时，它已经不能向右移动而只能向下移动，其路径和为点a加上其下面的点到点b的路径和。</li></ol><p>下面是求矩阵最小路径和的递归代码，具体如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含大量重复计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinPathCore1</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row == rows - <span class="number">1</span> &amp;&amp; col == cols - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row == rows - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> matrix[row][col] + getMinPathCore1(matrix, row, col + <span class="number">1</span>, rows, cols);</span><br><span class="line">    <span class="keyword">if</span> (col == cols - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> matrix[row][col] + getMinPathCore1(matrix, row + <span class="number">1</span>, col, rows, cols);</span><br><span class="line">    <span class="keyword">int</span> right = getMinPathCore1(matrix, row, col + <span class="number">1</span>, rows, cols);</span><br><span class="line">    <span class="keyword">int</span> down = getMinPathCore1(matrix, row + <span class="number">1</span>, col, rows, cols);</span><br><span class="line">    <span class="keyword">return</span> matrix[row][col] + Math.min(right, down);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinPath1</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> getMinPathCore1(matrix, <span class="number">0</span>, <span class="number">0</span>, matrix.length, matrix[<span class="number">0</span>].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析如上递归代码，我们会发现有许多重复的计算，比如下面递归过程中有1 -&gt; 3 -&gt; 1 -&gt; …和1-&gt; 8 - &gt; 1 - &gt; …等多条路径。显然从（1,1）到右下角的路径和被计算了多次。</p><p><img src="/2019/09/06/2019-9-6-矩阵的最小路径和/1568357928027.png" alt="1567745854978"></p><p>为了处理这种效果很差的递归，下面我们介绍经典动态规划方法。</p><h3 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h3><p>动态规划从暴力递归中来，它会将每一个子问题的解记录下来，避免重复计算。对于上面的矩阵matrix，我们创建一个同等大小的矩阵dp，其中dp[i][j]的值表示从左上角（即(0,0)）位置走到(i, j)位置的最小路径和。显然对应于矩阵matrix第一行的元素来说，只能从(0,0)向右走到(0,j)，所以dp矩阵的第一行的元素dp[0][j]即为matrix[0][0…j]的和，dp矩阵的第一列同理。因此以题目的例子来说，dp矩阵的第一行和第一列的值如下：</p><p><img src="/2019/09/06/2019-9-6-矩阵的最小路径和/1567745854981.png" alt="1567745854978"></p><p>除了第一行和第一列的其他位置的元素（i，j），都有上边位置（i - 1，j）和左边位置（i，j - 1）。因为从（0,0）到（i，j）的路径必然经过位置（i - 1, j）或（i，j - 1），所以dp表除了第一行和第一列之外的元素都符合dp[i][j] = min{dp[i - 1][j]，dp[i][j - 1]} + matrix[i][j]。以本题的例子来说，最终生成的dp矩阵如下：</p><p><img src="/2019/09/06/2019-9-6-矩阵的最小路径和/1567745854980.png" alt="1567745854978"></p><p>dp矩阵最右下角的值就是整个问题的答案。具体过程参看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinPath2</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">1</span>] + matrix[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line">        dp[j][<span class="number">0</span>] = dp[j - <span class="number">1</span>][<span class="number">0</span>] + matrix[j][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printMatrix(dp);//for test</span></span><br><span class="line">    <span class="keyword">return</span> dp[rows - <span class="number">1</span>][cols - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
